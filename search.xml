<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ReStart</title>
    <url>/2021/11/04/ReStart/</url>
    <content><![CDATA[<p><img src="/2021/11/04/ReStart/2021-11-04-22-11-58.png"></p>
<h1 id="重新搭建的小窝"><a href="#重新搭建的小窝" class="headerlink" title="重新搭建的小窝"></a>重新搭建的小窝</h1><ul>
<li><code>Dell</code>的硬盘坏掉了，来来回回修了快一个月</li>
<li>什么环境都没得了，幸好笔记还都在</li>
<li>虽然怕麻烦，不过重建一个自己的新窝还是很开心的。</li>
<li>继续记录吧。</li>
</ul>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11_thread_local</title>
    <url>/2022/09/14/c++11_thread_local/</url>
    <content><![CDATA[<ul>
<li>起因：在看Muduo如何获取线程id时，发现有个__thread</li>
</ul>
<h2 id="CurrentThread-get-the-thread-id-of-current-Thread"><a href="#CurrentThread-get-the-thread-id-of-current-Thread" class="headerlink" title="CurrentThread : get the thread id of current Thread"></a>CurrentThread : get the thread id of current Thread</h2><ul>
<li>获取线程系统调用：gettid()，开销较大，为提高效率，尽量少执行gettid，因此，在第一次得到gettid之后就将tid存起来，下次要用的时候直接返回。</li>
<li>currentThread.h  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  user通过调用CurrentThread::tid()来获取当前线程的tid</span></span><br><span class="line"><span class="keyword">namespace</span> CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">thread_local</span> <span class="keyword">int</span> t_cachedTid;        <span class="comment">//  每个线程独立的全局变量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cacheTid</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(__glibc_unlikely(t_cachedTid == <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// if(__builtin_expect(t_cachedTid == 0, 0))       </span></span><br><span class="line">        <span class="comment">//  告诉编译器 t_cacheTid == 0这件事的值 很有可能为0. 帮助编译器进行分支预测</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cacheTid</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t_cachedTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>currentThread.cpp  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> CurrentThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">int</span> t_cachedTid = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cacheTid</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t_cachedTid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  通过Linux系统调用gettid 获取当前线程的tid值</span></span><br><span class="line">                <span class="comment">//  系统调用没提供gettid这个接口 因此需要我们自己通过syscall 进行调用</span></span><br><span class="line">                <span class="comment">//  见Blog csapp-8-异常控制流中的syscall n</span></span><br><span class="line">                <span class="comment">//  syscall + 系统调用编号 即可进行系统调用</span></span><br><span class="line">            t_cachedTid = <span class="keyword">static_cast</span>&lt;<span class="keyword">pid_t</span>&gt;(::<span class="built_in">syscall</span>(SYS_gettid));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="builtin-expected"><a href="#builtin-expected" class="headerlink" title="builtin_expected"></a>builtin_expected</h2><ul>
<li>__builtin_expect() 是 GCC (version &gt;= 2.96）提供给程序员使用的，目的是将“分支转移”的信息提供给编译器，这样编译器可以对代码进行优化，以减少指令跳转带来的性能下降。</li>
<li>__builtin_expect((x),1)表示 x 的值为真的可能性更大；</li>
<li>__builtin_expect((x),0)表示 x 的值为假的可能性更大。</li>
<li>likely,unlikely  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __glibc_unlikely(cond)	__builtin_expect ((cond), 0)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __glibc_likely(cond)	__builtin_expect ((cond), 1)</span></span><br></pre></td></tr></table></figure></li>
<li>所以<ul>
<li>t_cacheTid == 0的可能性很小<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(__glibc_unlikely(t_cachedTid == <span class="number">0</span>))</span><br><span class="line"><span class="comment">// if(__builtin_expect(t_cachedTid == 0, 0))       </span></span><br><span class="line"><span class="comment">//  告诉编译器 t_cacheTid == 0这件事的值 很有可能为0. 帮助编译器进行分支预测</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cacheTid</span>();     <span class="comment">//  获取Tid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="tid"><a href="#tid" class="headerlink" title="tid"></a>tid</h2><ul>
<li>top -Hp pid​​​：查看某个进程的线程信息，​​-H​​​ 显示线程信息，​​-p​​指定pid</li>
<li>pthread_self返回的不是线程真正的独一无二的那个的tid</li>
<li>std::this_thread::get_id() 和 pthread_self相同</li>
<li>gettid返回的是线程真正的独一无二的的tid<br><img src="/2022/09/14/c++11_thread_local/2022-09-15-14-51-49.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gettid = %d (syscall real thread id)\n&quot;</span>,<span class="built_in">gettid</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pthread_self = %ld (POSIX)\n&quot;</span>,<span class="built_in">pthread_self</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c++11::get_id() = &quot;</span>&lt;&lt;std::this_thread::<span class="built_in">get_id</span>()&lt;&lt;std::endl;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code$ ./tid</span><br><span class="line">gettid = <span class="number">31721</span> (syscall real thread id)</span><br><span class="line">pthread_self = <span class="number">140053980942144</span> (POSIX)</span><br><span class="line">c++<span class="number">11</span>::<span class="built_in">get_id</span>() = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p><a href="https://zh.cppreference.com/w/cpp/language/storage_duration">存储类说明符以及链接</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/24253584/when-is-a-thread-local-global-variable-initialized">参考</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/340201634">代码示例</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1915012">参考</a></p>
</li>
<li><p><strong>thread_local</strong>:存储类说明符</p>
<ul>
<li> thread_local 关键词只能搭配在 [命名空间作用域声明的对象]、[在块作用域声明的对象] 及 [静态数据成员]。</li>
<li>它指示对象具有<strong>线程存储期</strong>。<ul>
<li> 对象的存储在线程开始时分配，而在线程结束时解分配。</li>
<li> 每个线程拥有其自身的对象实例。</li>
</ul>
</li>
<li> 如果对**块作用域变量(函数内)**只应用了 <strong>thread_local</strong> 这一个存储类说明符，那么同时也意味着应用了 <strong>static</strong>。（所以如果在一个函数内声明了thread_local 那么就相当于是这个是一个独属于这个线程的static局部变量）</li>
<li> 它能<strong>与 static 或 extern 结合</strong>，以分别<strong>指定内部或外部链接</strong>（但静态数据成员始终拥有外部链接）。</li>
<li>一言以蔽之：属于线程的变量。线程间独立，每个线程在自己的栈上有自己的副本。</li>
<li>应当在声明时初始化，该初始化语句在本 thread 中只会执行一次</li>
</ul>
</li>
<li><p>对<strong>比__thread</strong></p>
<ul>
<li><strong>__thread</strong>：是GCC的关键字，非Unix编程或C语言标准，属于编译器自己实现。__thread只能修饰基础数据类型或者POD类型。<ul>
<li>所谓POD就是C语言中传统的struct类型。即无拷贝、析构函数的结构体。</li>
</ul>
</li>
<li><strong>thread_local</strong>：可以修饰函数内局部对象(自动static)；除标准类型外，还可以修饰C++的对象如vector；还可以修饰类中的成员变量，但只能是static。<ul>
<li>thread_local修饰类内成员变量：static thread_local的变量也需要在类外进行初始化，并且带着thread_local关键字 <code>thread_local int A::count = 0;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><ul>
<li><p>如下，一个<strong>thread_local的全局变量</strong>。</p>
<ul>
<li>属于线程的全局变量。全局可见，但每个线程有自己的副本。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex cout_mutex;    <span class="comment">//  for multiple print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> std::string&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread[&quot;</span> &lt;&lt; thread_name &lt;&lt; <span class="string">&quot;]: x = &quot;</span> &lt;&lt; ++x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">&quot;t1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">&quot;t2&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread[t1]: x = <span class="number">1</span></span><br><span class="line">thread[t1]: x = <span class="number">2</span></span><br><span class="line">thread[t1]: x = <span class="number">3</span></span><br><span class="line">thread[t2]: x = <span class="number">1</span></span><br><span class="line">thread[t2]: x = <span class="number">2</span></span><br><span class="line">thread[t2]: x = <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一个<strong>thread_local的局部变量</strong>：</p>
<ul>
<li><strong>只用thread_local的话相当于static thread_local</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex cout_mutex;    <span class="comment">//方便多线程打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> std::string&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">thread_local</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cout_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread[&quot;</span> &lt;&lt; thread_name &lt;&lt; <span class="string">&quot;]: x = &quot;</span> &lt;&lt; ++x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">&quot;t1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">&quot;t2&quot;</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread[t1]: x = <span class="number">1</span></span><br><span class="line">thread[t1]: x = <span class="number">2</span></span><br><span class="line">thread[t1]: x = <span class="number">3</span></span><br><span class="line">thread[t2]: x = <span class="number">1</span></span><br><span class="line">thread[t2]: x = <span class="number">2</span></span><br><span class="line">thread[t2]: x = <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>thread_local 修饰类成员变量</p>
<ul>
<li>必须是static</li>
</ul>
</li>
<li><p>thread_local 修饰的对象只在其作用域内可见</p>
</li>
</ul>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a><a href="https://stackoverflow.com/questions/10422034/when-to-use-extern-in-c">extern</a></h2><ul>
<li>header.h : extern xx <ul>
<li>存在一个这样的变量xx。他在某一个.c文件中被定义。任何一个include该header.h 都可以看到并使用这个变量xx。</li>
<li>被多个文件include，但只被某个.c定义了一次。</li>
<li>在.c文件编译完成，进入链接阶段，linker会将所有xx的引用 和 一个 xx的定义关联起来。（xx的定义到已经compiled source files中去找）</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Muduo</tag>
      </tags>
  </entry>
  <entry>
    <title>c++_string_view</title>
    <url>/2023/02/15/c++_string_view/</url>
    <content><![CDATA[<p>string_view : {data_pointer , data_len}<br>不拥有数据、只读<br>解决在只需读str时 还会拷贝str造成的开销 ; 提高效率.<br>可用string_view代替const string &amp;作为形参</p>
<p><a href="https://segmentfault.com/a/1190000018387368">基本参考一篇挺好的string_view科普.</a></p>
<span id="more"></span>

<p>总结如下</p>
<h1 id="string-view"><a href="#string-view" class="headerlink" title="string_view"></a>string_view</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li>为什么要有string_view ? 提高性能. 为什么提高性能 ? 有const string &amp;还不够吗 ? <ul>
<li>const string &amp;问题如下.</li>
<li>对于形参为const string&amp;的，此时的情况必然是传递的数据为只读.<ul>
<li><ol>
<li>使用&amp;当然是为了避免拷贝, 可是<strong>对于要传递给const &amp; , 只有当实参类型相同 , 即为string时, 才不会发生拷贝</strong>.</li>
</ol>
</li>
<li><strong>如果实参 字符串字面值(“sss”)、字符数组(char [])、字符串指针(char *) 的传递给 const string&amp; —&gt; 仍要数据拷贝</strong><ul>
<li>实参与string类型不同 , 则需要拷贝生成个string临时对象,然后const string &amp;指向这个临时对象. 见(C++ Primer)</li>
</ul>
</li>
<li><ol start="2">
<li>同时string的substr效率为O(n),耗费性能. </li>
</ol>
<ul>
<li>O(n) : 因为substr会生成新的子串</li>
<li>我们本意很可能并不是要改变原字符串,实际上返回源字符串本身的一部分即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>string_view</strong><ul>
<li><strong>组成 : {data_pointer , data_len}.</strong></li>
<li><strong>string_view本身并不持有数据，只是有个指向数据的指针罢了. 所以注意string_view可能指向一个已经失效的str</strong></li>
<li><strong>只读data，不可修改data</strong></li>
<li><strong>构造</strong>：除默认构造和拷贝构造外,还有<ul>
<li>constexpr string_view(const CharT* s, size_type count); </li>
<li>constexpr string_view(const CharT* s);</li>
<li>string_view foo(string(“abc”))<ul>
<li>a. string(“abc”)转换为string_view对象</li>
<li>b. string_view对象拷贝构造</li>
</ul>
</li>
</ul>
</li>
<li><strong>自定义字面量</strong> : sv做后缀 , 将串中的\0视作字符而非null<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals;</span><br><span class="line"><span class="built_in">std</span>::string_view s1 = <span class="string">&quot;abc\0\0def&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::string_view s2 = <span class="string">&quot;abc\0\0def&quot;</span>sv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1.size() &lt;&lt; <span class="string">&quot; \&quot;&quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2.size() &lt;&lt; <span class="string">&quot; \&quot;&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">s1: <span class="number">3</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">s2: <span class="number">8</span> <span class="string">&quot;abc^@^@def&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><strong>好处</strong><ul>
<li><ol>
<li>我们可以使用<strong>string_view</strong> 代替 const string &amp; 作为<strong>形参</strong>. 效率更高. 无论实参是 “sss” , char[] , 还是 char * , 还是string , 都只需要构造一个string_view , 然后拷贝构造string_view即可. 代价基本仅仅是1 data_pointer + 1 data_len. 远小于拷贝整个string的代价.</li>
</ol>
</li>
<li><ol start="2">
<li>string_view的<strong>substr</strong>函数的时间复杂度是<strong>O(1)</strong>.(移动data_pointer构造string_view即可)</li>
</ol>
</li>
</ul>
</li>
<li><strong>注意</strong><ul>
<li>string_view范围内的字符可能不包含\0</li>
<li>从[const] char*构造string_view对象时间复杂度O(n).(为了遍历获取data_len)</li>
<li>string_view指向的内容的生命周期可能比其本身短</li>
</ul>
</li>
<li><strong>指导</strong> : 约束少，使用自由，难以保证data的生命周期长于string_view. 故我们应将string_view作为<strong>函数形参</strong>，因为如果该参数仅仅在函数体内使用而不传递出去，这样使用是安全的。<ul>
<li>当然string_view作为函数形参 , 整个函数中 绝对不会出现data失效的问题.</li>
<li>不过可以看到 cs144中依然返回了string_view(Buffer.h) ，因为Buffer内部通过shared_ptr保证了data的生命周期 ? </li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>bind、function机制</title>
    <url>/2022/03/18/c++_bind%E3%80%81function%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>bind和function 极常用！！</li>
<li>bind1st：operator()的第一个形参绑定成一个确定的值</li>
<li>bind2nd：operator()的第二个形参绑定成一个确定的值</li>
<li>c++11从boost库引入了bind绑定器和function函数对象机制</li>
<li>lambda表达式：底层依赖函数对象的机制实现</li>
</ul>
<h2 id="bind1st、bind2nd（弃用）。bind更好用"><a href="#bind1st、bind2nd（弃用）。bind更好用" class="headerlink" title="bind1st、bind2nd（弃用）。bind更好用"></a>bind1st、bind2nd（弃用）。bind更好用</h2><ul>
<li>绑定器+二元函数对象 -&gt; 一元函数对象<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span> ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">showContainer</span>(vec);</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// 默认小到大排序</span></span><br><span class="line">	<span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找第一个小于70的数字</span></span><br><span class="line">	<span class="comment">// operator()(const T &amp;val)</span></span><br><span class="line">	<span class="comment">// greater   a &gt; b</span></span><br><span class="line">	<span class="comment">// less      a &lt; b</span></span><br><span class="line">	<span class="comment">// 绑定器 + 二元函数对象 =》 一元函数对象</span></span><br><span class="line">	<span class="comment">// bind1st: + greater bool operator()(70, const _Ty&amp; _Right)</span></span><br><span class="line">	<span class="comment">// bind2nd: + less bool operator()(const _Ty&amp; _Left, 70)</span></span><br><span class="line">	<span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">		<span class="built_in">bind1st</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line">    cout&lt;&lt;*it1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">28</span> <span class="number">21</span> <span class="number">82</span> <span class="number">75</span> <span class="number">89</span> <span class="number">90</span> <span class="number">7</span> <span class="number">4</span> <span class="number">82</span> <span class="number">79</span> <span class="number">57</span> <span class="number">31</span> <span class="number">41</span> <span class="number">91</span> <span class="number">58</span> <span class="number">38</span> <span class="number">74</span> <span class="number">63</span> <span class="number">63</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">9</span> <span class="number">21</span> <span class="number">28</span> <span class="number">31</span> <span class="number">38</span> <span class="number">41</span> <span class="number">57</span> <span class="number">58</span> <span class="number">63</span> <span class="number">63</span> <span class="number">74</span> <span class="number">75</span> <span class="number">79</span> <span class="number">82</span> <span class="number">82</span> <span class="number">89</span> <span class="number">90</span> <span class="number">91</span></span><br><span class="line"><span class="number">74</span></span><br></pre></td></tr></table></figure>


<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>bind1st底层原理<ul>
<li>bind1st -&gt; _bind1st<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by dell on 2022/3/18.</span></span><br><span class="line"><span class="comment">// 手写bind1st、bind2nd、my_find_if</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showContainer</span><span class="params">(Container &amp; con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Container作为一个模板类型参数，当编译器遇到Container::mem这样的代码时，他不会知道mem是一个类型成员还是一个static数据成员，</span></span><br><span class="line">    <span class="comment">//  直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。</span></span><br><span class="line">    <span class="comment">//  默认情况下，C++假定通过作用域运算符::访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显示告诉编译器改名字是一个=类型。我们通过使用typename来实现这一点。</span></span><br><span class="line">    <span class="comment">//  typename：明确指出iterator是一个类型而非static数据成员。</span></span><br><span class="line">    <span class="keyword">typename</span> Container::iterator iter = con.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;iter!=con.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数模板怎么匹配的？？？Iterator和谁匹配？？</span></span><br><span class="line"><span class="comment">//  函数模板可以进行类型推演：根据我们传入的实参，可以把模板类型推演出来</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first,Iterator last,Compare cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( ; first!=last;++first)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(*first))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  重载()，真正的一元函数对象</span></span><br><span class="line"><span class="comment">//  封装，真正做事情的还是那个二元函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">mybind1st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _mybind1st(Compare cmp,<span class="keyword">const</span> T&amp; t):_cmp(cmp),_val(t)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; second)</span>     <span class="comment">//  要传入的参数（非绑定参数）</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _cmp(_val,second);        <span class="comment">//  绑定了第一个参数的二元函数</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _cmp;      <span class="comment">//  二元函数</span></span><br><span class="line">    T _val;              <span class="comment">//  绑定的那个参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数模板：封装了一元对象的产生。</span></span><br><span class="line"><span class="comment">//  就是个中转站。传入函数和要绑定的参数。返回绑定完的一元函数对象。</span></span><br><span class="line"><span class="comment">//  函数模板作用：让用户无需指明类，直接传参数即可。如果直接用_mybind1st的话，则需要自己指明模板参数类型</span></span><br><span class="line"><span class="comment">//  使用函数模板：好处是可以进行类型推演。根据我们传入的实参，可以把模板类型推演出来。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_mybind1st&lt;Compare,T&gt; <span class="title">mybind1st</span><span class="params">(Compare cmp,<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _mybind1st&lt;Compare,T&gt;(cmp,val);      <span class="comment">//  生成一元函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(v);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">showContainer</span>(v);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator iter = <span class="built_in">my_find_if</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(), <span class="built_in">mybind1st</span>(greater&lt;<span class="keyword">int</span>&gt;(),<span class="number">70</span>));</span><br><span class="line">    cout&lt;&lt;*iter&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">58</span> <span class="number">82</span> <span class="number">80</span> <span class="number">86</span> <span class="number">74</span> <span class="number">69</span> <span class="number">79</span> <span class="number">22</span> <span class="number">68</span> <span class="number">60</span></span><br><span class="line"><span class="number">86</span> <span class="number">82</span> <span class="number">80</span> <span class="number">79</span> <span class="number">74</span> <span class="number">69</span> <span class="number">68</span> <span class="number">60</span> <span class="number">58</span> <span class="number">22</span></span><br><span class="line"><span class="number">86</span> <span class="number">82</span> <span class="number">80</span> <span class="number">79</span> <span class="number">74</span> <span class="number">69</span> <span class="number">68</span> <span class="number">60</span> <span class="number">58</span> <span class="number">22</span></span><br><span class="line"><span class="number">69</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><h3 id="用途：建立函数表"><a href="#用途：建立函数表" class="headerlink" title="用途：建立函数表"></a>用途：建立函数表</h3><ul>
<li>把所用的函数、绑定器、函数对象、lambda表达式的类型表达起来，否则绑定器和lambda表达式只能存在于语句之中，在其他语句还要重写绑定器和lambda表达式。</li>
<li>作用：建立函数表。switch不满足开闭原则，我们建立<code>map&lt;int,function&lt;void(void)&gt;&gt;</code>函数表来替代<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doShow</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;查看所有书籍&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBorrow</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;借书&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;还书&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果用函数指针如 void(*)(void)    则second只能接受普通的全局函数。不能接受函数对象（如bind绑定器返回的函数对象；如函数对象类（仿函数）的对象）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt;&gt; actionMap;</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>,doShow));</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,doBack&#125;);</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123;<span class="number">3</span>,doBorrow&#125;);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> choice;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;choice is&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;choice;</span><br><span class="line">        <span class="keyword">if</span>(actionMap.<span class="built_in">find</span>(choice)!=actionMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            actionMap[choice]();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;no choice&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>“渔夫在无法捕鱼时，就会修补他的网，在这段看似停滞不前的日子里，你可以休息但不要什么都不做”</p>
<h3 id="完全特例化和部分特例化"><a href="#完全特例化和部分特例化" class="headerlink" title="完全特例化和部分特例化"></a>完全特例化和部分特例化</h3><ul>
<li><p>必须先有个泛化的，然后才能有部分和全部特例化</p>
</li>
<li><p>泛化、特例化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>     &#123;</span>    &#125;</span><br><span class="line"><span class="comment">//  就相当于 template&lt;typename T&gt; class B&lt;T&gt;&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&lt;</span><span class="built_in">R</span>(A)&gt;   &#123;   &#125;</span><br><span class="line"><span class="comment">//  class A&lt;内容&gt; &lt;&gt;中的内容，就是这个类在实例化时，&lt;&gt;钟要填入的东西的类型！</span></span><br><span class="line"><span class="comment">//  通过我们填入的东西，解析出R、A这两个模板参数分别是什么</span></span><br><span class="line"><span class="comment">//  如 B&lt;int(int)&gt; b(show) 就是 R：int 。A：int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 完全特例化和部分特例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  针对指针提供的部分特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>Ty*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&lt;Ty*&gt;&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对函数指针(有返回值，两个形参变量）提供的部分特例化</span></span><br><span class="line"><span class="comment">//  这三个合起来共同定义了一个类型 R(*)(A1,A2)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="built_in">R</span>(*)(A1,A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&lt;R(*)(A1,A2)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  针对char*提供的完全特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="keyword">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&lt;char*&gt;&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  针对函数提供的部分特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty,<span class="keyword">typename</span> R1,<span class="keyword">typename</span> R2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="built_in">Ty</span>(R1,R2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&lt;Ty(R1,R2)&gt;&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    Vector&lt;<span class="keyword">int</span>*&gt; v2;</span><br><span class="line">    Vector&lt;<span class="keyword">char</span>*&gt; v3;</span><br><span class="line">    Vector&lt;<span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; v4;</span><br><span class="line">    Vector&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; v5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">E:\Code\CLionCode\project02\cmake-build-debug\project02.exe</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>Ty*&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="keyword">char</span>*&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="built_in">R</span>(*)(A1,A2)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="built_in">Ty</span>(R1,R2)&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://www.jianshu.com/p/f6904c7bdd31">typeid坑</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc就是那样的，只输出类型名的第一个字符，要输出完整的名字可以这样：</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;typeinfo&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cxxabi.h&gt; //使用abi</span></span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">abi::__cxa_demangle(typeid(int).name(),0,0,0 )&lt;&lt;endl;</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="模板实参推演"><a href="#模板实参推演" class="headerlink" title="模板实参推演"></a>模板实参推演</h3><ul>
<li>非常非常强大的功能</li>
<li>将一个大类型（一个函数模板参数） 使用多个模板参数 拆分成多个小类型。便于使用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模板的实参推演 =》基本概念很简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  T包含了所有的大的类型，返回值，所有形参的类型都取出来。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(t).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将类型拆开 即将上面的 函数指针类型T 拆成 返回类型R  参数类型A1 A2组成的</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(R(*a)(A1,A2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(R).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(A1).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(A2).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//              返回值     类类型     参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> T,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(R(T::*t)(A1,A2))</span>     <span class="comment">//  T:: 。怎么写，看typeid.name()就知道了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(R).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(A1).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(A2).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(sum);</span><br><span class="line">    <span class="built_in">func2</span>(sum);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">func</span>(&amp;Test::sum);</span><br><span class="line">    <span class="built_in">func3</span>(&amp;Test::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(Test::*)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function">Test</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="function底层原理"><a href="#function底层原理" class="headerlink" title="function底层原理"></a>function底层原理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function 底层原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  得有泛化，才能有部分/全部特例化！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myfunction</span>&#123;</span>&#125;; <span class="comment">//  默认泛化的是:class Myfunction&lt;Ty&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span>... A&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myfunction</span>&lt;</span><span class="built_in">R</span>(A...)&gt;       <span class="comment">//  void(void) ; int(int,int)... 这里就是我们用户在使用这个类时，&lt;&gt;所放的东西</span></span><br><span class="line">        <span class="comment">//  通过class Myfunction&lt;内容&gt; 内容，和实例化时Myfunction&lt;int(int,int)&gt;以及传入的实参，来解析出这个类的模板参数都是什么</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A...);</span><br><span class="line">    <span class="built_in">Myfunction</span>(PFUNC pfunc):_pfunc(pfunc)&#123;&#125;</span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _pfunc(args...);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;show&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Myfunction&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>&gt; <span class="title">f2</span><span class="params">(sum)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Myfunction&lt;<span class="title">void</span><span class="params">(<span class="keyword">void</span>)</span>&gt; <span class="title">f</span><span class="params">(show)</span></span>;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// terminal</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">show</span><br></pre></td></tr></table></figure>


<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="bind例子"><a href="#bind例子" class="headerlink" title="bind例子"></a>bind例子</h3><ul>
<li><strong>bind参数？</strong></li>
<li><code>std::bind(待绑定的函数对象/函数指针/成员函数指针,参数绑定值1,参数绑定值2,...,参数绑定值n);</code></li>
<li>参数一：函数对象/函数指针。（如果是临时对象的话，则不需要取地址）</li>
<li>其余参数：函数列表中的参数</li>
<li>如果有不想绑定的参数，那么需要用<code>placeholder::_x</code> 来占位，不能略过！！</li>
<li><a href="https://www.jianshu.com/p/f191e88dcc80">hh1</a> ；<a href="https://www.cnblogs.com/sixue/p/4013766.html#:~:text=bind%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA,%E7%9A%84%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E3%80%82">hh2</a><blockquote>
<p>bind的第一个参数是待绑定的函数对象或者函数指针,之后跟随多个参数以设定待绑定函数的参数绑定方式。待绑定函数有多少个参数,则bind后便需要多少个参数以一一声明其参数的绑定方法.当参数绑定为某一固定值时,则其对应参数绑定值可以使一个变量或常量.当需要将参数与绑定所生成的函数对象的某个参数相关联时,则需要用到在标准中预定义的几个常量_1、_2、_3等.这些常量声明在std::placeholders命名空间内.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt; f = <span class="built_in">bind</span>(greater&lt;<span class="keyword">int</span>&gt;(),placeholders::_1,<span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>(<span class="number">4</span>)&lt;&lt;endl;       <span class="comment">//  1</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>(<span class="number">1</span>)&lt;&lt;endl;       <span class="comment">//  0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> string &amp;str)</span></span>&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  bind()返回函数对象</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">bind</span>(sum,<span class="number">10</span>,<span class="number">20</span>)()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bind</span>(&amp;Test::sum,<span class="built_in">Test</span>(),<span class="number">10</span>,<span class="number">90</span>)()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  参数占位符</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">bind</span>(sum,placeholders::_1,placeholders::_2)(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如何保留下bind返回的函数对象？（如果不能保留下来，那么就只能一条语句用一次bind，很无语就）</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">void</span>)&gt; f = <span class="built_in">bind</span>(show,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind-和-function-实现简易线程池"><a href="#bind-和-function-实现简易线程池" class="headerlink" title="bind 和 function 实现简易线程池"></a>bind 和 function 实现简易线程池</h3><p><img src="/2022/03/18/c++_bind%E3%80%81function%E6%9C%BA%E5%88%B6/2022-03-19-18-54-00.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Thread 封装了线程函数，并承担了生成新线程的任务（要将函数装入线程来启动）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FUNC = function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;      <span class="comment">//  命名 function返回的函数对象类型为 void(int)</span></span><br><span class="line">    <span class="built_in">Thread</span>(FUNC func,<span class="keyword">int</span> id):_func(func),_id(id)&#123;&#125;;        <span class="comment">//  传入线程函数  注意线程函数必须是个C线程函数。也即不</span></span><br><span class="line">    <span class="function">thread <span class="title">start</span><span class="params">()</span>      <span class="comment">// 返回启动的线程</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(_func,_id)</span></span>;    <span class="comment">//  启动线程</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FUNC _func;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(Thread *t:_pool)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPool</span><span class="params">(<span class="keyword">int</span> sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i)</span><br><span class="line">        &#123;    <span class="comment">//  bind返回函数对象                 bind (函数地址,函数列表参数1 this，函数列表参数2 未知参数、用placeholder占位);</span></span><br><span class="line">                                            <span class="comment">// (类成员函数在编译时，会生成this指针在参数列表首位）</span></span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;ThreadPool::runInThread,<span class="keyword">this</span>,placeholders::_1),i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());  <span class="comment">// start 返回启动的线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _handler[i].<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;runInthread id = &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Thread*&gt; _pool;      <span class="comment">//  容器内的指针所指向的内存 需要我们手动释放</span></span><br><span class="line">    vector&lt;thread&gt; _handler;    <span class="comment">//  存放所有启动的线程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool tp;</span><br><span class="line">    tp.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runInthread id = runInthread id = <span class="number">3</span></span><br><span class="line">runInthread id = <span class="number">6</span></span><br><span class="line">runInthread id = <span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">runInthread id = <span class="number">8</span></span><br><span class="line">runInthread id = <span class="number">4</span></span><br><span class="line">runInthread id = <span class="number">7</span></span><br><span class="line">runInthread id = <span class="number">2</span></span><br><span class="line">runInthread id = <span class="number">9</span></span><br><span class="line">runInthread id = <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h2 id="lambda表达式（很强大）"><a href="#lambda表达式（很强大）" class="headerlink" title="lambda表达式（很强大）"></a>lambda表达式（很强大）</h2><ul>
<li>生成函数对象的新方式</li>
<li><strong>[捕获外部变量](形参列表)-&gt;返回值{操作代码}</strong></li>
<li>如果返回值=void，那么”-&gt;void”可以省略</li>
<li>[捕获外部变量]<ul>
<li> <strong>[]</strong>:表示不捕获任何外部变量</li>
<li> <strong>[=]</strong>:以传值的方式捕获外部的所有变量</li>
<li> <strong>[&amp;]</strong>:以传引用的方式捕获外部的所有变量</li>
<li> <strong>[this]</strong>:捕获外部this指针</li>
<li> <strong>[=,&amp;a]</strong>:以传值的方式捕获外部的所有变量，但以传引用的方式捕获a变量</li>
<li> <strong>[a,b]</strong>:以值传递的方式捕获外部变量a和b</li>
<li> <strong>[a,&amp;b]</strong>:a以传值的方式捕获，b以传引用的方式捕获<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by dell on 2022/3/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数对象升级 -&gt; lambda表达式</span></span><br><span class="line"><span class="comment"> * 函数对象缺点：</span></span><br><span class="line"><span class="comment"> * 使用在泛型算法参数传递，比较/自定义操作，优先级队列，智能指针删除器</span></span><br><span class="line"><span class="comment"> * lambda语法：</span></span><br><span class="line"><span class="comment"> * [捕获外部变量](形参列表)-&gt;返回值&#123;操作代码&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果返回值=void，那么&quot;-&gt;void&quot;可以省略</span></span><br><span class="line"><span class="comment"> * [捕获外部变量]</span></span><br><span class="line"><span class="comment"> * []:表示不捕获任何外部变量</span></span><br><span class="line"><span class="comment"> * [=]:以传值的方式捕获外部的所有变量</span></span><br><span class="line"><span class="comment"> * [&amp;]:以传引用的方式捕获外部的所有变量</span></span><br><span class="line"><span class="comment"> * [this]:捕获外部this指针</span></span><br><span class="line"><span class="comment"> * [=,&amp;a]:以传值的方式捕获外部的所有变量，但以传引用的方式捕获a变量</span></span><br><span class="line"><span class="comment"> * [a,b]:以值传递的方式捕获外部变量a和b</span></span><br><span class="line"><span class="comment"> * [a,&amp;b]:a以传值的方式捕获，b以传引用的方式捕获</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line">class TestLambda</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestLambda</span>()&#123;&#125;</span><br><span class="line">    T <span class="built_in"><span class="keyword">operator</span></span>()(T a,T b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  lambda生成函数对象传入泛型算法！这样就不用再去记忆greater，less。也不用bind绑定器绑定greater/less生成函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),</span><br><span class="line">         [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a)-&gt;<span class="keyword">void</span>&#123;cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  问题解决了：应该怎么判断传入什么lambda参数()? </span></span><br><span class="line">    <span class="comment">//  就和给find_if传递普通的函数对象一样，函数对象所需要的参数 应当就是*迭代器</span></span><br><span class="line">    <span class="comment">//  因为find_if 中遍历会用到 FUNC(*迭代器) FUNC就是我门传入的函数对象</span></span><br><span class="line">    <span class="comment">// 这里lambda的(参数) 应当和find_if要求传入的函数对象的参数相同</span></span><br><span class="line">        <span class="comment">//  这个参数find_if语法上没法限制</span></span><br><span class="line">        <span class="comment">//  不过我们应该传入的参数是 find_if遍历时 遍历到的 &quot; *迭代器 &quot;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator iter = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="keyword">int</span> a)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> a&lt;<span class="number">70</span>;&#125;);</span><br><span class="line">    vec.<span class="built_in">insert</span>(iter,<span class="number">70</span>);</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a)-&gt;<span class="keyword">void</span>&#123;cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    TestLambda&lt;&gt; t;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">t</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  lambda表达式生成函数对象，替代我们写的模板函数对象类（冗余代码）</span></span><br><span class="line">    <span class="keyword">auto</span> t2 = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">t2</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">4</span>,y = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> t3 = [x,y] () <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> t = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = t;</span><br><span class="line"><span class="comment">//        如果没加mutable的话</span></span><br><span class="line"><span class="comment">//        Cannot assign to a variable captured by copy in a non-mutable lambda</span></span><br><span class="line"><span class="comment">//        不能在非可变lambda里修改按值捕获的变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">t3</span>();</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t4 = [&amp;x,&amp;y] () &#123;</span><br><span class="line">        <span class="keyword">int</span> t = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = t;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">t4</span>();</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="function配合lambda使用"><a href="#function配合lambda使用" class="headerlink" title="function配合lambda使用"></a>function配合lambda使用</h3><ul>
<li>应该用什么类型来接收lamdba表达式返回的函数对象？/ 如何跨语句使用lambda表达式<ul>
<li><strong>当然是<code>function</code></strong></li>
</ul>
</li>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、函数表</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; f;</span><br><span class="line">f[<span class="number">0</span>] = [](<span class="keyword">int</span> a ,<span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line">cout&lt;&lt;f[<span class="number">0</span>](<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、删除器</span><br><span class="line"><span class="comment">//  智能指针自定义删除器</span></span><br><span class="line">unique_ptr&lt;FILE*,function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE*)&gt;&gt; <span class="built_in">up1</span>(</span><br><span class="line">        (<span class="built_in">fopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)),</span><br><span class="line">        [](FILE* pf)-&gt;<span class="keyword">void</span>&#123; <span class="built_in">fclose</span>(pf);&#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 容器比较规则</span><br><span class="line"><span class="comment">//  灵活设定规则。并且可以对同一种对象进行不同规则比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="keyword">int</span> a):<span class="built_in">m_a</span>(a)&#123;&#125;</span><br><span class="line"><span class="comment">//    bool operator&lt; (const Data&amp; rd) const   //  如果自定义的话，必须是const函数。因为容器默认调用的比较函数对象的参数列表会用常量引用。而常量引用对象只能调用常量函数</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return m_a&lt;rd.m_a;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  采用function 配合 lambda表达式</span></span><br><span class="line">    <span class="comment">//  更加灵活的定义比较规则。不用在类内内置&lt;号或者&gt;号。</span></span><br><span class="line">    <span class="keyword">using</span> FUNC = function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">const</span> Data&amp; rd1,<span class="keyword">const</span> Data&amp; rd2)&gt;;</span><br><span class="line">    priority_queue&lt;Data,vector&lt;Data&gt;,FUNC&gt; <span class="built_in">q</span>(</span><br><span class="line">            [](<span class="keyword">const</span> Data&amp; rd1,<span class="keyword">const</span> Data&amp; rd2)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rd1.<span class="built_in">getData</span>() &lt; rd2.<span class="built_in">getData</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = vector&lt;_Tp&gt;,</span><br><span class="line">    <span class="keyword">typename</span> _Compare  = less&lt;<span class="keyword">typename</span> _Sequence::value_type&gt; &gt;</span><br><span class="line">class priority_queue&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span>	_Sequence::value_type		value_type;</span><br><span class="line">    <span class="built_in">priority_queue</span>()</span><br><span class="line">	: <span class="built_in">c</span>(), <span class="built_in">comp</span>() &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span></span></span><br><span class="line"><span class="function">    <span class="title">priority_queue</span><span class="params">(<span class="keyword">const</span> _Compare&amp; __x, _Sequence&amp;&amp; __s = _Sequence())</span></span></span><br><span class="line"><span class="function">    : c(std::move(__s)), comp(__x)</span></span><br><span class="line"><span class="function">    &#123;</span> std::<span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//  See queue::c for notes on these names.</span></span><br><span class="line">    _Sequence  c;</span><br><span class="line">    _Compare   comp;        <span class="comment">//  _comp为函数对象 _Compare为函数对象类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  less源码：所以自定义&lt;必须为const函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">_GLIBCXX14_CONSTEXPR</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/33040213">reinterpret_cast</a></p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p><a href="https://www.cnblogs.com/moodlxs/p/10111609.html">C++11 std::ref使用场景</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp_3_程序的机器级表示2</title>
    <url>/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/</url>
    <content><![CDATA[<p>Procedure</p>
<span id="more"></span>


<h2 id="Mechanisms-in-Procedures"><a href="#Mechanisms-in-Procedures" class="headerlink" title="Mechanisms in Procedures"></a>Mechanisms in Procedures</h2><p><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-07-09-13-33.png"></p>
<h1 id="Procedure-过程"><a href="#Procedure-过程" class="headerlink" title="Procedure 过程"></a>Procedure 过程</h1><ul>
<li><p>过程：一种很重要的抽象，提供了一种封装代码的方式，用一组参数和一个返回值实现了某种功能，隐藏了行为的具体实现。</p>
</li>
<li><p>不同语言中，过程形式多样：函数、方法、子例程、处理函数，</p>
</li>
<li><p>假设过程P调用过程Q，Q执行后返回P。这些动作包括以下机制.</p>
</li>
<li><p><strong>传递控制</strong>：<strong>passing control</strong></p>
<ul>
<li>进入过程Q时，程序计数器（PC/%rip）必须被设置为：过程Q代码的起始地址。（过程Q的地址）</li>
<li>从过程Q返回时，程序计数器必须被设置为：P中调用Q这句代码<code>call Q</code>的下一行代码的地址。（P中的）</li>
</ul>
</li>
<li><p><strong>传递数据</strong>：<strong>passing data</strong></p>
<ul>
<li>P必须能向Q提供一个或多个参数<ul>
<li>参数&lt;=6个，通过寄存器传递</li>
<li>参数&gt;6个，通过将P要传递给Q的参数（6个开外的那些）压入过程P的栈帧来传递。</li>
</ul>
</li>
<li>Q必须能向P返回一个值（一般用%rax返回）</li>
</ul>
</li>
<li><p><strong>分配和释放内存</strong>：<strong>memory management</strong></p>
<ul>
<li>Q可能需要为局部变量分配空间，在返回时，又必须释放这些空间。（移动%rsp）</li>
</ul>
</li>
</ul>
<h2 id="Stack-Structure-运行时栈"><a href="#Stack-Structure-运行时栈" class="headerlink" title="Stack Structure 运行时栈"></a>Stack Structure 运行时栈</h2><ul>
<li><strong>重要图</strong><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-12-09-22-55.png"><br>纠正：被保存的reg中的%rsp换成%rbx</li>
<li><strong>栈</strong>由高地址向低地址增长；**%rsp时刻指向栈顶元素**；pushq、popq将数据存入、弹出栈；%rsp减小可以为没指定初始值的数据在栈上分配空间；也可通过增大%rsp释放空间。</li>
<li>x86-64过程需要的存储空间超过寄存器能存放的时，就会在栈上分配空间，分配的空间称为<strong>栈帧</strong>。当前在运行的栈帧总是在栈顶。</li>
<li>P调用Q时，会将Q过程结束后的返回地址（Q返回后，P过程继续执行的地址）压入栈中。我们将这个返回地址视作P栈帧的一部分。（因为这个返回地址说P过程代码的地址，存放的是与P相关的状态）</li>
<li>Q代码会扩展当前栈的边界，分配它的栈帧所需的空间。<ul>
<li>这个空间中，它可以保存寄存器的值、分配局部变量空间、为调用过程设置参数。</li>
</ul>
</li>
<li>大多数栈帧都是定长的，在过程的开始就分配好了。但是也有些过程需要变长的帧<ul>
<li>3.10.5。比如P调用Q过程时，Q需要&gt;6个参数，那么P就需要将多出的参数存入P自己的栈帧中。如果&lt;=6个，那么就只需要用寄存器传参数即可。</li>
</ul>
</li>
<li>实际上，许多函数甚至不需要栈帧<ul>
<li>当所有局部变量都可以保存在寄存器中，且该函数不会调用其他函数。</li>
</ul>
</li>
<li><strong>栈</strong>是所有过程的集合，<strong>栈帧</strong>是一个过程，在栈顶的栈帧是当前正在执行的过程。<ul>
<li>也意味着，代码中的其他(过程)函数，无论有多少，在该时刻都被冻结，任何时刻运行的只有一个函数(过程)(位于栈顶的栈帧)</li>
</ul>
</li>
</ul>
<h2 id="传递控制-Passing-Control"><a href="#传递控制-Passing-Control" class="headerlink" title="传递控制 Passing Control"></a>传递控制 Passing Control</h2><ul>
<li><p>大体来说，就是传递控制，就是适当的<strong>改变PC/%rip</strong>，以控制该执行哪条指令。并在此过程中会用到栈来存储%rip应该变成的地址。</p>
</li>
<li><p>控制从P转移到Q：将PC设置为Q的起始地址即可</p>
</li>
<li><p>控制从Q返回到P：将PC设置为P中call Q的下一条指令的地址。</p>
</li>
<li><p>call Q ：过程调用</p>
<ul>
<li>（pushq A）将地址A压入栈中。紧跟在call指令后面的那条指令的地址。</li>
<li>（%rip = Q_addr）将PC设置为Q的起始地址</li>
</ul>
</li>
<li><p>ret ：从过程调用中返回</p>
<ul>
<li>（popq）从栈中弹出地址A</li>
<li>（%rip=A）把PC设置为A</li>
</ul>
</li>
<li><p>例子1</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">begin of fun mulstore</span><br><span class="line"><span class="number">0x0000000000400540</span> &lt;mulstore&gt;</span><br><span class="line">    <span class="number">400540</span>: <span class="number">53</span>                     push %rbx</span><br><span class="line">    <span class="number">400541</span>: <span class="number">48</span> <span class="number">89</span> d3               mov %rdx,%rbx</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">40054</span>d: c3                     retq</span><br><span class="line">    ...</span><br><span class="line">main</span><br><span class="line">    <span class="number">400563</span>: e8 d8 ff ff ff          callq <span class="number">400540</span>&lt;mulstore&gt;</span><br><span class="line">    <span class="number">400568</span>: <span class="number">48</span> <span class="number">8b</span> <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>          mov <span class="number">0x8</span>(%rsp),%rdx</span><br></pre></td></tr></table></figure>
<p>  <img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-12-09-59-58.png"></p>
</li>
<li><p>练习<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-12-10-07-30.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-12-10-48-50.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-07-42-57.png"></p>
<h2 id="传递数据-Passing-Data"><a href="#传递数据-Passing-Data" class="headerlink" title="传递数据 Passing Data"></a>传递数据 Passing Data</h2></li>
</ul>
<h3 id="Managing-local-data"><a href="#Managing-local-data" class="headerlink" title="Managing local data"></a>Managing local data</h3><ul>
<li>当调用一个过程时，除了把控制传递给他，并在返回时再传递回来时；还可能包括把数据作为参数传递，而从过程返回害有可能包括返回一个值。</li>
<li>过程间的数据大部分通过寄存器传递。<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-08-09-07.png"></li>
<li>如P调用Q，当参数的个数大于6个之后，就需要Q在自己的栈帧中为要传递给q的参数构造参数，称为参数构造区。当构造完成后，即可进行call Q。</li>
<li>例子<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-08-43-22.png"></li>
</ul>
<h3 id="Local-Storage-On-Stack-栈上的局部存储"><a href="#Local-Storage-On-Stack-栈上的局部存储" class="headerlink" title="Local Storage On Stack 栈上的局部存储"></a>Local Storage On Stack 栈上的局部存储</h3><ul>
<li>某些时候，过程的局部数据必须存放在内存中（虚拟内存中的stack）<ul>
<li>寄存器数量不够，无法存储所有本地数据。</li>
<li>对一个局部变量使用取址&amp;，因此必须为他产生一个地址</li>
<li>某些局部变量时数组或结构，因此必须通过数组或结构引用被访问到。</li>
</ul>
</li>
<li>一般来说，过程通过减小%rsp指针在战胜分配空间，分配的结果作为栈帧的一部分，如重要图中的”局部变量区”。</li>
<li>例子</li>
</ul>
<blockquote>
<p><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-10-25-11.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-10-38-23.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-10-49-17.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-10-48-16.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-10-48-58.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-11-02-36.png"></p>
</blockquote>
<ul>
<li>注意事项：<ul>
<li>为调用过程开辟栈帧，是在call Q之后，进入Q之后做得事情，是被调用过程Q自己负责做得。</li>
<li>不仅直接移动%rsp会开辟栈帧，push也会；call 也会移动%rsp，拓展栈帧。</li>
</ul>
</li>
</ul>
<h3 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h3><ul>
<li><p>寄存器组是唯一被所有过程<strong>共享</strong>的资源</p>
</li>
<li><p>为防止覆盖过程执行时覆盖寄存器的问题，按执行保存动作的对象来进行分类</p>
</li>
<li><p><strong>被调用者保存寄存器</strong></p>
<ul>
<li>%rbx、%rbp 、%r12~%r15</li>
<li>当P调用Q时，Q必须保存寄存器的值，保证他们的值在离开Q返回P时与进入Q之前是一样的。</li>
<li>执行过程是保存寄存器的原值是被调用者Q的责任<ul>
<li>过程Q根本不改变他</li>
<li>过程Q把原始值压入栈中（在栈中的这部分称为被保存的寄存器），再改变寄存器。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>调用者保存寄存器</strong></p>
<ul>
<li>其他所有寄存器，除了栈指针%rsp</li>
<li>过程P调用过程Q。Q可以任意修改这些寄存器。在调用Q之前就保存好这些寄存器的数据是P的责任。</li>
</ul>
</li>
<li><p>把P中不想让被调用过程Q覆盖、改变的值存入被调用者保存寄存器，然后再调用Q即可。</p>
</li>
<li><p>举例<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-16-17-02-54.png"></p>
</li>
<li><p>注意：过程中的局部变量先保存在被调用者保存的寄存器中，如果数量不够，那么在存入本过程的栈帧中。</p>
</li>
</ul>
<h2 id="Illustration-Of-Recursion"><a href="#Illustration-Of-Recursion" class="headerlink" title="Illustration Of Recursion"></a>Illustration Of Recursion</h2><ul>
<li>感觉没啥好说的。。</li>
</ul>
<hr>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="Basic-Principle-基本原则"><a href="#Basic-Principle-基本原则" class="headerlink" title="Basic Principle 基本原则"></a>Basic Principle 基本原则</h3><ul>
<li>T A[N]<ul>
<li>该声明有两个效果</li>
<li>首先，在内存中分配一个L*N字节的连续区域。（L是数据类型T的大小）</li>
<li>其次，引入标识符A，可以用A来作为指向数组开头的指针，指针的值就是xa。</li>
<li>x+i*L即为第i个元素的起始地址(i属于[0,N-1])</li>
<li>但是我们定义一个指针的时候，就只有该指针而没有额外分配的空间</li>
</ul>
</li>
<li>指针运算<ul>
<li>E的起始地址在%rdx; i存在%rcx<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-23-10-10-14.png"></li>
<li>看出：关于int的操作是4bytes，用movl；关于指针的操作是8bytes，用leaq。<ul>
<li>地址计算用leaq，数据计算用movb/w/l/q</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Multi-dimensional-nested-嵌套-多维数组-内存连续"><a href="#Multi-dimensional-nested-嵌套-多维数组-内存连续" class="headerlink" title="Multi-dimensional(nested) 嵌套/多维数组  (内存连续)"></a>Multi-dimensional(nested) 嵌套/多维数组  (内存连续)</h3><ul>
<li><p>整个数组内存连续，在一起，可以一次性计算内存要取的地址。因此，取得数组数据只需一次内存访问mem。（就是计算出地址之后进行一次mem）</p>
</li>
<li><p>嵌套数组和多维数组等价。是一个东西。 </p>
</li>
<li><p><code>typedef int row3_t[3]; row3_t A[5]</code>等价于<code>int A[5][3]</code><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-23-10-40-59.png"></p>
</li>
<li><p><code>T D[R][C]</code></p>
<ul>
<li><code>&amp;D[i][j] = xd + L(C*i+j)</code></li>
</ul>
</li>
<li><p>如何取得数组元素。如下</p>
</li>
<li><p>例1：设int A[5][3]。将A[i][j]复制到寄存器%eax中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A in %rdi , i in %rsi , j in %<span class="function">rdi</span></span><br><span class="line"><span class="function"><span class="title">leaq</span> <span class="params">(%rsi,%rsi,<span class="number">2</span>)</span>,%rax   %rax </span>= <span class="number">3</span>*i      # <span class="number">1</span>行有<span class="number">3</span>个元素,计算i行有几个元素</span><br><span class="line">leaq (%rdi,%rax,<span class="number">4</span>),%rax   %rax = %rdi + <span class="number">4</span>*%rax  = xa + <span class="number">4</span>*(<span class="number">3</span>*i)   <span class="number">1</span>个元素<span class="number">4b</span>ytes,<span class="number">4</span>*(<span class="number">3</span>i) i行占多少个bytes     </span><br><span class="line">movl (%rax,%rdx,<span class="number">4</span>),%rax   %rax = %rax + <span class="number">4</span>*%rdx  = xa + <span class="number">4</span>*(<span class="number">3</span>*i) + <span class="number">4</span>*j  加j个元素大小</span><br></pre></td></tr></table></figure></li>
<li><p>例2：设int pgh[5][4]。将pgh[i][j]放入%eax<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-23-10-51-24.png"></p>
</li>
</ul>
<h3 id="Multi-level-多层次数组-内存不连续"><a href="#Multi-level-多层次数组-内存不连续" class="headerlink" title="Multi-level 多层次数组 (内存不连续)"></a>Multi-level 多层次数组 (内存不连续)</h3><ul>
<li>例子<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;; </span><br><span class="line">zip_dig mit = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;; </span><br><span class="line">zip_dig ucb = &#123; <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span> &#125;; </span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCOUNT 3 </span></span><br><span class="line"><span class="keyword">int</span> *univ[UCOUNT] = &#123;mit, cmu, ucb&#125;;</span><br><span class="line">univ一维数组，每个元素是一个指针，占<span class="number">8b</span>ytes。这个指针指向的是一维数组的起始地址。也就是说，这个元素本身的地址并不是数组的起始地址，而是它里面存的值，是数组的起始地址</span><br></pre></td></tr></table></figure></li>
<li>如何取得值。由于内存不连续，不能一次性计算出地址。<ul>
<li>需要先内存访问mem一次（读取指针），读取指针指向的一维数组的起始地址。然后再在这个的地址进行列的偏移计算。</li>
<li>所以获取一个unix[i][j]数据，需要进行两次内存访问。第一次是在计算地址时，第二次是在根据地址获取数据时。<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-23-10-56-33.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-23-11-11-50.png"></li>
</ul>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>nested array：嵌套/多维数组<ul>
<li>内存连续，可一次性计算出元素地址。获取数据只需要一次 mem_read</li>
</ul>
</li>
<li>multi-level array：多层次数组<ul>
<li>内存不连续，不能一次性计算出元素地址，获取元素需要两次mem_read<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-23-11-14-56.png"></li>
</ul>
</li>
</ul>
<h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-23-11-32-42.png"></p>
<p>数组越界<br>1.得到一个随机值<br>2.地址无效，发生段错误</p>
<h2 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct 结构"></a>struct 结构</h2><ul>
<li>将不同类型的对象组合到一起的机制：结构struct；联合union</li>
<li>struct结构的所有组成部分都存放在内存中一段<strong>连续</strong>的区域内。（虽字段内会有内存对齐，但这些字段是连续的）指向结构的指针就是结构第一个字节的地址。</li>
<li>编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-16-35-58.png"></li>
</ul>
<h2 id="union-联合体"><a href="#union-联合体" class="headerlink" title="union 联合体"></a>union 联合体</h2><ul>
<li>联合：一种方式，规避C语言的类型系统，允许以多种类型来引用一个对象。即用<strong>不同字段来引用相同的内存块</strong>。</li>
<li>一个联合的大小 等于 它最大字段的大小</li>
</ul>
<p><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-16-52-27.png"></p>
<h3 id="联合作用："><a href="#联合作用：" class="headerlink" title="联合作用："></a>联合作用：</h3><ul>
<li>一个结构中的两个不同字段的使用是互斥的，那么就将这两个字段声明为联合的一部分，来节省空间。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_s</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> *<span class="title">left</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">node_s</span> *<span class="title">right</span>;</span></span><br><span class="line">  <span class="keyword">double</span> data[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">8</span>+<span class="number">8</span>+<span class="number">16</span> = <span class="number">32b</span>ytes</span><br><span class="line">--&gt;</span><br><span class="line">struct <span class="keyword">node_t</span>&#123;</span><br><span class="line">  <span class="keyword">type_t</span> t;     <span class="comment">//  4bytes</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">letf</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">right</span>;</span></span><br><span class="line">    &#125;internal;</span><br><span class="line">    <span class="keyword">double</span> data[<span class="number">2</span>];</span><br><span class="line">  &#125;info   <span class="comment">//  16 bytes</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span> + [<span class="number">4</span>] + <span class="number">16</span> = <span class="number">24</span></span><br></pre></td></tr></table></figure></li>
<li>联合还可用来<strong>访问不同数据类型的相同位模式</strong>。<ul>
<li>普通的强制数据类型转换：double d = xxx ; unsigned long u = (unsigned long ) d。u是d的整数表示，且从d转化成u的过程按照IEEE754的标准需要进行位级别的改变（请看上一节博客），也就是说u和d的位模式大不相同。</li>
<li>使用union联合<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">double2bits</span><span class="params">(<span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> u;</span><br><span class="line">  &#125; temp;</span><br><span class="line">  temp.d = d;</span><br><span class="line">  <span class="keyword">return</span> temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>以一种数据类型（double）来存储union中的参数，又以另一种形式（unsigned long）访问它。temp.d和temp.u所引用的内存块中的位完全相同。</li>
</ul>
</li>
</ul>
<h2 id="Alignment-数据对齐"><a href="#Alignment-数据对齐" class="headerlink" title="Alignment 数据对齐"></a>Alignment 数据对齐</h2><h3 id="对齐原则"><a href="#对齐原则" class="headerlink" title="对齐原则"></a>对齐原则</h3><ul>
<li>许多计算机系统对<strong>基本数据类型的合法地址</strong>做出了一些限制，要求某种数据类型对象的地址必须是某个<strong>K</strong>(2/4/8)值的倍数。这种<strong>对齐限制</strong>简化了处理器和内存系统之间接口的硬件设计，（注意是基本数据类型，结构体本身不是基本数据类型）</li>
<li><strong>对齐原则</strong>是任何<strong>K字节的基本对象的地址必须是K的倍数</strong><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-18-48-20.png"></li>
<li>确保每种数据类型都是按照指定方式来组织和分配，即每种类型的对象都满足他的对齐限制，就可以保证实施对齐。如<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-19-08-20.png"></li>
</ul>
<h3 id="结构的字段对齐"><a href="#结构的字段对齐" class="headerlink" title="结构的字段对齐"></a>结构的字段对齐</h3><ul>
<li><p>总的来说，结构的对齐要求就是</p>
<ul>
<li><strong>(1)</strong> K大小的对象的起始地址必须是K的倍数</li>
<li><strong>(2)</strong> 为了下个同类型的结构体的起始地址，需要对本结构体的尾部进行填充。（(2)由(1)推出）<ul>
<li>一个结构体的起始地址应当是这个结构体内最大字段的倍数。（因为基本数据类型最大就是8ytes了。其他都是1、2、4。同时存在1、2、4、8时，起始地址是8的倍数才能满足所有类型的对齐要求。（反正我这么觉得）</li>
<li>因此也可以说是，一个结构体的大小，应当是其最大字段的倍数。</li>
</ul>
</li>
</ul>
</li>
<li><p>对于包含结构的代码，编译器可能需要在阶段的分配中插入间隙，以保证满足元素的对齐要求。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> j;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-19-18-30.png"></p>
</li>
<li><p>为了下一个同类型结构体，对尾部进行填充。（默认进行填充）（按理来说似乎应该结构体数组才会起到作用）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-19-26-10.png"></p>
</li>
</ul>
<ul>
<li>练习<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-20-20-45.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-20-19-28.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-20-19-35.png"></li>
<li>重排字段顺序，以最小化浪费的空间：一个有效的方式是按照字段由大到小排列。</li>
</ul>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>强转指针类型：只改变类型不改变值。</li>
<li>函数指针<ul>
<li>函数指针的值是函数机器代码的第一条指令的地址<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> *p)</span></span>;</span><br><span class="line"><span class="comment">//  定义指针</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fp)(<span class="keyword">int</span> ,<span class="keyword">int</span> *);</span><br><span class="line"><span class="comment">//  指针赋值</span></span><br><span class="line">fp = fun;</span><br><span class="line"><span class="comment">//  使用指针调用函数:</span></span><br><span class="line"><span class="built_in">fp</span>(<span class="number">1</span>,&amp;x);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>int *f(int *)<ul>
<li>f是一个函数。接收参数int* 返回 int*</li>
</ul>
</li>
<li>int (*f)(int *)<ul>
<li>f是一个函数指针。指向函数原型为 参数为int* 返回值为int的函数</li>
</ul>
</li>
</ul>
<h2 id="地址范围"><a href="#地址范围" class="headerlink" title="地址范围"></a>地址范围</h2><ul>
<li>程序虚拟地址的大小范围[0,0x00007FFFFFFFFFFF]<ul>
<li>现在64位机器限制使用47位地址。</li>
<li>64位bits 可以表示 2^64个地址 也就是意味着需要有16*10^18个字节。买这么多内存是一笔巨款。（即便是47位也是一笔巨款啊。<code>2^47/2^20/2^8 *150 = 2^19 * 150 = 75 * 10^6 = 75000000 = 7千5百万）（假设256G内存150RMB）</code><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-18-20-16-44.png"></li>
</ul>
</li>
<li>栈大小<ul>
<li>linux常用系统上，栈stack的大小是8MB，意味着如果用指针访问超过栈的8bytes，就会发生段错误seg fault<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/Shared_ln/csapp/bomb$ ulimit -<span class="function">a</span></span><br><span class="line"><span class="function">core file <span class="title">size</span>          <span class="params">(blocks, -c)</span> 0</span></span><br><span class="line"><span class="function">data seg <span class="title">size</span>           <span class="params">(kbytes, -d)</span> unlimited</span></span><br><span class="line"><span class="function">scheduling <span class="title">priority</span>             <span class="params">(-e)</span> 0</span></span><br><span class="line"><span class="function">file <span class="title">size</span>               <span class="params">(blocks, -f)</span> unlimited</span></span><br><span class="line"><span class="function">pending <span class="title">signals</span>                 <span class="params">(-i)</span> 15409</span></span><br><span class="line"><span class="function">max locked <span class="title">memory</span>       <span class="params">(kbytes, -l)</span> 65536</span></span><br><span class="line"><span class="function">max memory <span class="title">size</span>         <span class="params">(kbytes, -m)</span> unlimited</span></span><br><span class="line"><span class="function">open <span class="title">files</span>                      <span class="params">(-n)</span> 1024</span></span><br><span class="line"><span class="function">pipe <span class="title">size</span>            <span class="params">(<span class="number">512</span> bytes, -p)</span> 8</span></span><br><span class="line"><span class="function">POSIX message <span class="title">queues</span>     <span class="params">(bytes, -q)</span> 819200</span></span><br><span class="line"><span class="function">real-time <span class="title">priority</span>              <span class="params">(-r)</span> 0</span></span><br><span class="line"><span class="function">**stack <span class="title">size</span>              <span class="params">(kbytes, -s)</span> 8192**</span></span><br><span class="line"><span class="function">cpu <span class="title">time</span>               <span class="params">(seconds, -t)</span> unlimited</span></span><br><span class="line"><span class="function">max user <span class="title">processes</span>              <span class="params">(-u)</span> 15409</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">memory</span>          <span class="params">(kbytes, -v)</span> unlimited</span></span><br><span class="line"><span class="function">file <span class="title">locks</span>                      <span class="params">(-x)</span> unlimited</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><h3 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h3><ul>
<li><p>在栈中分配某个字符数组来保存字符串，但是字符串的长度超出了分配的空间。可能会导致</p>
<ul>
<li>破坏本栈帧未被使用的栈空间</li>
<li>破坏稍后离开本栈帧返回时的返回地址</li>
<li>破坏调用者的栈帧状态</li>
</ul>
</li>
<li><p>例子<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-21-56-40.png"><br>所谓的改变返回地址，实际上就是通过改变存在栈中的ret_addr来<strong>改变ret时PC的内容</strong>，也就是%rip将要指向的指令地址<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-21-57-03.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-21-59-11.png"></p>
</li>
<li><p>题<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-22-34-09.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-22-32-32.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-22-35-13.png"></p>
</li>
</ul>
<h3 id="插入攻击代码"><a href="#插入攻击代码" class="headerlink" title="插入攻击代码"></a>插入攻击代码</h3><ul>
<li>缓冲区溢出<strong>最致命</strong>的是可能会让程序执行它本不愿意执行的函数。<ul>
<li>通过在输入的字符串中加入<ul>
<li>可执行代码的字节编码，即<strong>攻击代码</strong>。</li>
<li>指向攻击代码指令地址的<strong>指针</strong>，覆盖原本的ret addr。</li>
</ul>
</li>
<li>如P调用Q，Q离开时<ul>
<li>原本%rip应当指向正常设置好的ret_addr（位于.<strong>text</strong>段），然后%rip一步步++去执行下一条指令。</li>
<li>然而，通过上述操作，使得ret_addr被更改为<strong>栈</strong>中的另一块地址，并且，栈中的这另一块地址也放入了编号的攻击代码。那么，%rip就会指向这段攻击代码的起始地址。随着%rip++，这段攻击代码就会被执行。</li>
</ul>
</li>
<li><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-22-49-02.png"><ul>
<li>如图。gets的字符串溢出。字符串包括 exploit code（攻击代码）、pad（空）、（攻击代码地址）。（pad是为了让ret_addr被覆盖）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h2><ul>
<li>随机化、栈保护、限制那部分内存可以存储可执行代码<ul>
<li>是用于最小化程序缓冲区溢出攻击漏洞的三种最常见机制。</li>
<li>不需要程序员做任何特殊的奴鲁，带来的性能代价很小甚至没有。</li>
</ul>
</li>
</ul>
<h3 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h3><ul>
<li><p>为了在系统中插入攻击代码，攻击者既要插入exploit code，又要插入指向exploit code的pointer，这个pointer也是攻击字符串的一部分。其中产生这个pointer，需要知道字符串缓冲区的栈地址。</p>
</li>
<li><p>如果栈地址非常容易预测，且运行同样程序和操作系统的不同机器上，栈的位置都相当固定。因此，攻击者确定了一个常用的服务器所用的栈空间，就可以设计一个许多机器上都能实现的攻击。形成安全单一化现象：许多系统都易受到同一病毒攻击。</p>
</li>
<li><p><strong>栈随机化</strong>：栈的位置在程序每次运行时都有变化。因此，当许多机器运行同样的代码，他们的栈地址是不同的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> local;</span><br><span class="line">    <span class="keyword">int</span> * p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size = %ld\n&quot;</span>,<span class="keyword">sizeof</span>(&amp;local));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>,&amp;local);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;local at %p\n&quot;</span>,fun);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ gcc aslr.c -o asl.out -Wall</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./asl.out </span><br><span class="line">size = <span class="number">8</span></span><br><span class="line">local at <span class="number">0x7ffd1b230218</span></span><br><span class="line">local at <span class="number">0x55a4564ab260</span></span><br><span class="line">local at <span class="number">0x55a454c25018</span></span><br><span class="line">local at <span class="number">0x55a454c25010</span></span><br><span class="line">local at <span class="number">0x55a454a246fa</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./asl.out </span><br><span class="line">size = <span class="number">8</span></span><br><span class="line">local at <span class="number">0x7ffc2e7746b8</span></span><br><span class="line">local at <span class="number">0x55d825bc1260</span></span><br><span class="line">local at <span class="number">0x55d824e70018</span></span><br><span class="line">local at <span class="number">0x55d824e70010</span></span><br><span class="line">local at <span class="number">0x55d824c6f6fa</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./asl.out </span><br><span class="line">size = <span class="number">8</span></span><br><span class="line">local at <span class="number">0x7fffb1830868</span></span><br><span class="line">local at <span class="number">0x55fa6f69c260</span></span><br><span class="line">local at <span class="number">0x55fa6f05d018</span></span><br><span class="line">local at <span class="number">0x55fa6f05d010</span></span><br><span class="line">local at <span class="number">0x55fa6ee5c6fa</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./asl.out </span><br><span class="line">size = <span class="number">8</span></span><br><span class="line">local at <span class="number">0x7ffc45a56418</span></span><br><span class="line">local at <span class="number">0x557de4b6c260</span></span><br><span class="line">local at <span class="number">0x557de2e3c018</span></span><br><span class="line">local at <span class="number">0x557de2e3c010</span></span><br><span class="line">local at <span class="number">0x557de2c3b6fa</span></span><br><span class="line">似乎只有栈在变。。为啥捏。。</span><br><span class="line">&gt;视频：global和fun不变，<span class="built_in">stack</span>上的局部变量的地址每次会改变，害有heap上的地址每次也会改变</span><br></pre></td></tr></table></figure>
<ul>
<li>实现方式：程序开始时，在栈上分配[0,n]bytes之间随即大小的空间。程序不使用这段空间。但他会导致每次执行时后续的栈位置发生变化。<ul>
<li>分配的范围n必须足够大，才能获得足够多的栈地址变化，但又要足够小，不至于浪费程序太多空间。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>地址空间布局随机化</strong>(Address-Space Layout Randomization  — ASLR)</p>
<ul>
<li><blockquote>
<p>每次程序运行时的不同部分：程序代码、库代码、栈、全局变量和堆数据，都被加载到内存不同区域。这意味着不同机器上运行的相同程序，其地址映射不同，以此对抗攻击。 </p>
</blockquote>
</li>
<li>但我运行了以下没变啊。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>空操作雪橇</strong><ul>
<li>在攻击代码前插入一段很长的nop空指令。只有PC++的效果，无其他行为。只要攻击者能猜中这段序列的某个地址，程序就会划过这个序列。</li>
<li>应该是这个意思。至于如何保证pointer放置在原ret_addr位置上，我也不到啊。<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-26-08-12-43.png"></li>
</ul>
</li>
</ul>
<h3 id="栈破坏检测"><a href="#栈破坏检测" class="headerlink" title="栈破坏检测"></a>栈破坏检测</h3><ul>
<li><p><strong>检测栈何时被破坏</strong></p>
<ul>
<li>C无法防止数组越界写，但我们可以在数组越界时，在<strong>造成任何有害结果</strong>前，尝试检测到他。</li>
</ul>
</li>
<li><p><strong>栈保护者</strong>机制</p>
<ul>
<li>在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值（canary），也被称为哨兵值。（攻击者没法轻易获取该值）<ul>
<li>在<strong>恢复寄存器状态和从过程返回之前</strong>，程序会<strong>检查</strong>这个<strong>金丝雀</strong>值是否被该过程的某个操作或者该过程调用的某个过程的某个操作改变。若是，程序异常终止。<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-26-08-53-46.png"><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-26-08-53-39.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>canary原本被存储在只读段 %fs:40（段寻址）。xorq，结果非0代表canary被改变。</p>
</li>
<li><p>栈保护很好的防止了缓冲区溢出攻击破坏存储在程序栈上的状态，性能损失也很小。</p>
</li>
<li><p>GCC只在函数中有局部char类型缓冲区时才插入这样的代码。</p>
</li>
<li><p>栈状态相关的局部变量应比buf更靠近栈顶，这样buf溢出就更不会破坏局部变量的值。所以自顶向底应该是局部变量、canary、buf。</p>
</li>
</ul>
<h3 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h3><ul>
<li><strong>消除攻击者向系统插入可执行代码的能力</strong></li>
<li>方法：限制那些内存区域能够存放可执行代码。<ul>
<li>在典型的程序中，只有保存编译器产生的代码的那部分(text)内存才需要是可执行的，其他部分被限制为只允许读和写。详情见csapp第9章。</li>
<li>硬件支持多种形式的内存保护，可以指明用户程序和os内核所允许的访问形式。</li>
<li>许多系统允许控制三种访问形式：<strong>读</strong>（从内存中读数据）、<strong>写</strong>（写数据到内存）、<strong>执行</strong>（将内存的内容看作机器级代码）。</li>
<li>以前，x86将读和执行合并成1位标志位，这样任何被标记为可读的页也是可执行的。因为栈上的字节可读，因此栈上的字节也是可执行的。</li>
<li>后来，x8664引入No-Excute位，<strong>将读和执行模式分开</strong>，栈上的字节可以被标记为可读可写不可知性，而检查页是否可执行由<strong>硬件</strong>完成，效率上没损失。</li>
</ul>
</li>
</ul>
<h2 id="变长栈帧"><a href="#变长栈帧" class="headerlink" title="变长栈帧"></a><strong>变长栈帧</strong></h2><ul>
<li><p>场景：当函数中存在变长数组时</p>
</li>
<li><p><strong>帧指针 : frame pointer</strong></p>
<ul>
<li>也被称为<strong>基指针 : base pointer</strong></li>
</ul>
</li>
<li><p>为了<strong>管理变长栈帧</strong>，x86-64使用<strong>寄存器%rbp作为帧指针</strong></p>
</li>
<li><p>使用帧指针的栈帧结构<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-26-10-16-34.png"></p>
</li>
<li><p>%rbp作用：在函数的整个执行过程中，%rbp一直指向那个时刻栈的位置，然后用固定长度的局部变量（例如i）<strong>相对于%rbp的偏移量来引用他们</strong>。</p>
<ul>
<li>也就是说，用作一个基坐标，去确定其他变量的地址。</li>
</ul>
</li>
<li><p>非变长栈帧时，用的基坐标是%rsp，其中注意%rsp时刻指向栈顶，因此当栈帧长度无法确定（编译时无法确定，需运行时确定如由用户输入确定时），编译器就无法确定在某一时刻%rsp的位置，也就无法把他当作基坐标去定位其他变量。因此需要引入一个<strong>固定</strong>的地址，因此就需要%rbp作为基指针，保存某一时刻（进入过程时）的栈的位置不变，作为基坐标，去定位本过程中用到的其他变量。</p>
</li>
<li><p>剩下的有时间再整理。该补数罗作业了。。。</p>
</li>
<li><p>csapp 202 + 3.49</p>
</li>
<li><p>较早版本的x86中，每个函数都使用帧指针（%rbp存储），而现在，只有栈帧长度为变长时（编译时无法确定的长度）才使用，如例子中的frame。</p>
</li>
</ul>
<h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><ul>
<li>详情见gdb调试博客<br><code>$&gt;gdb prog</code><br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-25-20-55-29.png"></li>
</ul>
<h1 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h1><ul>
<li>总容易搞混啊md</li>
<li>大端模式：低地址放高位 Sprac</li>
<li>小端模式：低地址放低位。Intel    x86,    ARM    Android    and    IOS    </li>
<li>一个字节内不存在什么大小端。（因为一地址一字节）</li>
<li><strong>大小端模式存在于一个基本类型的对象内，其内部的低地址存储低位数据，高地址存储高位数据。</strong></li>
<li>而不是不存在于一个数组中，那整个数组岂不是倒过来了。如数组c[8]，那么c[0]位于低地址，c[7]位于高地址。</li>
<li>小端x86<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-26-09-49-05.png"></li>
<li>大端<br><img src="/2022/06/07/csapp-3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA2/2022-06-26-09-51-12.png"></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp_6_存储器层次结构2</title>
    <url>/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/</url>
    <content><![CDATA[<p>存储器层次结构<br>高速缓存存储器：直接映射、组相联映射、全相连映射<br>缓存的行替换策略<br>缓存的写问题：写命中/不命中，以及策略<br>存储器山<br>小结</p>
<span id="more"></span>


<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a><strong>层次结构</strong></h2><ul>
<li><strong>重点图</strong><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-07-10-14-10.png"></li>
<li>高速缓存（cache）：小而快的存储设备。使用高速缓存的过程称为缓存。</li>
<li>存储器层次结构<strong>中心思想</strong>：对于每个k，位于第k层的更小更快的存储设备作为位于第k+1层的更大更慢的存储设备的缓存。即，层次结构中的每一层都缓存来自较低一层的数据对象。</li>
<li>数据以<strong>块为传送单元</strong>在第k层和第k+1层之间来回赋值。<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-07-10-23-25.png"><ul>
<li>任何一对相邻层次之间块的大小是一致的固定的，但其他层次对之间块的大小可以与本层次对不同。<ul>
<li>如L0和L1的块大小为1个word；L2和L1、L3和L2、L4和L3是几十bytes；L5和L4之间的块是几百/几千bytes。</li>
<li>距离cpu越远的层次，访问设备时间越长。为了弥补这些时间，块也相应大。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h3><ul>
<li><strong>缓存命中</strong>：如果第k+1层的数据对象d，刚好缓存在第k层中，那么就是缓存命中（程序需要第k+1层的数据对象d时，会现在第k层的一个块中查找d）</li>
</ul>
<h3 id="缓存不命中"><a href="#缓存不命中" class="headerlink" title="缓存不命中"></a>缓存不命中</h3><ul>
<li><p><strong>缓存不命中</strong>：如果第k+1层的数据对象d，没有缓存在第k层中，那么就是缓存不命中。</p>
</li>
<li><p>此时第k层会从第k+1层取出包含d的块，将其存入第k层。此时可能会发生覆盖第k层现存的块。</p>
<ul>
<li>覆盖的过程称为 替换/驱逐 块。被驱逐的块称为牺牲块。<strong>决定哪个块被替换由缓存的替换策略控制</strong>（如LRU，LFU等）</li>
</ul>
</li>
<li><p>缓存不命中种类</p>
<ul>
<li><strong>冷不命中 / 强制不命中</strong><ul>
<li>对于冷缓存，任何数据对象的访问都不命中。（第k层为冷缓存即第k层为空）</li>
<li>冷不命中短暂。暖身之后就不会出现。</li>
</ul>
</li>
<li><strong>冲突不命中</strong><ul>
<li>为了速度更快，硬件会使用更严格的放置策略，但这种放置策略会引起冲突不命中。</li>
<li>有足够的高速缓存空间，却交替的引用映射到同一个组的块。</li>
</ul>
</li>
<li><strong>容量不命中</strong><ul>
<li>程序通常是按照一系列阶段（循环）来运行的，每个极端访问缓存块的某个相对稳定不变的集合。</li>
<li>感觉就是最一般的不命中吧，缓存不够大，不能一次就将工作集放入缓存，若当工作集的大小超过缓存大小时，当需要用到没放入缓存中的工作集数据时，缓存会经历容量不命中。（如访问一个大数组，其块的集合就被称为该阶段的工作集）</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>放置策略</strong>：决定第k+1层取出的块放在第k层哪个组<ul>
<li>Placement    policy: determines    where    b    goes</li>
</ul>
</li>
<li><strong>替换策略</strong>：决定哪个块被驱逐<ul>
<li>Replacement    policy:<br>determines    which    block<br>gets    evicted    (victim)</li>
</ul>
</li>
</ul>
<h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><ul>
<li>管理缓存的逻辑可以是硬件、软件或两者结合<ul>
<li>需要由某种形式的逻辑管理缓存，也即如何将某个对象划分成块，如何传递块，是否命中，并如何放置，替换等处理他们。如</li>
<li>寄存器文件 由 编译器管理</li>
<li>L1 L2 L3 由内置在缓存中的硬件逻辑管理</li>
<li>在有虚拟内存的系统中，DRAM作为存储在磁盘上的数据块的缓存，由os和cpu上的地址翻译硬件共同管理</li>
<li>本地磁盘作为AFS分布式文件系统的缓存，由运行在本地机器的AFS客户端进程管理</li>
</ul>
</li>
<li>缓存常自动运行，无需用户程序采取特殊或显式的行为。<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-07-12-36-34.png"></li>
</ul>
<h1 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h1><ul>
<li>架构图<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-07-12-46-42.png"></li>
</ul>
<h2 id="结构（高速缓存和主存地址）"><a href="#结构（高速缓存和主存地址）" class="headerlink" title="结构（高速缓存和主存地址）"></a>结构（高速缓存和主存地址）</h2><ul>
<li><p>高速缓存和主存地址图<br>  <img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-07-12-51-26.png"><br>  <img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-07-13-12-38.png"></p>
</li>
<li><p>高速缓存是一个高速缓存组的数组（S=2^s个高速缓存组）</p>
<ul>
<li>每个组包含E（E&gt;=1）行</li>
<li>每行包含一个有效位，t位标记为，一个数据块，且数据块大小为Bbytes（B=2^b）</li>
</ul>
</li>
<li><p><strong>高速缓存的结构可以用(S,E,B,m)来描述。高速缓存的大小C = S*E*B，m表示主存地址的位数</strong></p>
</li>
<li><p>高速缓存的结构将m个地址位划分为t位标记位，s位组索引位，b位块偏移。</p>
</li>
<li><p>注意<code>S=2^s,B=2^b</code>,但E!=2^t，因为t位标记位只是作为标记位，通过比较是否相等来标记该行缓存的是否是我所请求的地址的块内容，不时用来指示组中的哪一个行。</p>
</li>
<li><p>当CPU要从主存地址A读一个字时，降低至A发送给高速缓存，如果缓存命中，那么就将该字A发送给CPU。那么<strong>如何判断缓存是否命中</strong>（在缓存找找到请求的字）？如下，利用主存的目的地址</p>
<ul>
<li>地址中<strong>s位组索引</strong>：指明该地址起始的块应该缓存在哪一组。</li>
<li>地址中<strong>t位标记</strong>：定位到正确的组之后，遍历该缓存组的行，将每行的t位标记与该地址的t位标记比较，相同，则表明改行缓存的就是该地址起始的块。</li>
<li>地址中<strong>b位偏移量</strong>：指出请求的字在相应行的数据块中的字节偏移量。</li>
<li>除此外，还有高速缓存行中的有效位：如果该行的有效位为0，则无效。1则有效</li>
</ul>
</li>
<li><p><strong>主存和缓存</strong>之间的数据交换，一般是以<strong>块</strong>为单元，即以Bbytes为单元。</p>
</li>
<li><p><strong>缓存和cpu</strong>之间的数据交换，一般是以字，字节，双字等为单元。</p>
</li>
</ul>
<ul>
<li>根据每个组的高速缓存行数E，高速缓存被分为不同的类。</li>
</ul>
<h2 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h2><ul>
<li><strong>直接映射</strong>高速缓存：E=1，即每个组只有一行。<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-07-48-32.png"></li>
<li>缓存命中：高速缓存很快地抽取字w，返回给cpu</li>
<li>缓存不命中：<ul>
<li>高速缓存向主存（下一层结构）请求包含w的块的一个副本，在这个过程中，cpu必须等待。</li>
<li>当被请求的块从主存中到达时，高速缓存根据组索引位的指示将该块放在它某组中的一个高速缓存行里。<ul>
<li>可能会需要驱逐一个缓存中现存的行<ul>
<li>对于直接映射来说，替换策略很简单，就是用新取出的行替换当前的行。</li>
</ul>
</li>
</ul>
</li>
<li>然后从被存储的块中抽出字w，然后将它返回给cpu。</li>
</ul>
</li>
</ul>
<h3 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h3><ul>
<li>高速缓存判断一个请求是否命中，然后抽取出被请求的字的过程，分为<ul>
<li><ol>
<li>组选择</li>
</ol>
</li>
<li><ol start="2">
<li>行匹配</li>
</ol>
</li>
<li><ol start="3">
<li>字抽取</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="组选择"><a href="#组选择" class="headerlink" title="组选择"></a>组选择</h4><p><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-08-07-29.png"></p>
<ul>
<li>组索引位：s位标记位被解释为无符号整数，是一个到高速缓存数组的索引。</li>
</ul>
<h4 id="行匹配"><a href="#行匹配" class="headerlink" title="行匹配"></a>行匹配</h4><p><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-08-09-53.png"></p>
<ul>
<li>行匹配：选择了组i之后需要进一步确认组中是否有字w的一个副本</li>
<li><strong>缓存命中条件：有效位设置 &amp;&amp; 标记匹配</strong><ul>
<li>有效位设置：缓存行中标记和块中的位是有意义的。</li>
<li>标记匹配：高速缓存行中的标记与w的地址中的标记相同，此时行中包含w的一个副本</li>
</ul>
</li>
</ul>
<h4 id="字选择"><a href="#字选择" class="headerlink" title="字选择"></a>字选择</h4><ul>
<li>一旦缓存命中，我们就知道w就在该行的块中的某个地方，接下来最后一步确定所需的字在块中从哪里开始即可。利用b位的块偏移。<ul>
<li>b位二进制表示偏移的字节数。</li>
</ul>
</li>
</ul>
<h4 id="行替换"><a href="#行替换" class="headerlink" title="行替换"></a>行替换</h4><ul>
<li>用新取出的行替换当前的行。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>(S,E,B,m) = (4,1,2,4)<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-08-55-32.png"></li>
<li>标记位和索引位连起来唯一的标识了主存中的每个块。</li>
<li>映射到同一个高速缓存组的块由标记位唯一的标识。</li>
<li>见csapp_430</li>
</ul>
<h3 id="直接映射的冲突不命中"><a href="#直接映射的冲突不命中" class="headerlink" title="直接映射的冲突不命中"></a>直接映射的冲突不命中</h3><p><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-10-19-50.png"><br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-10-19-35.png"></p>
<ul>
<li><strong>抖动</strong>：高速缓存反复的加载和驱逐相同的高速缓存块的组。 （因为不同块被映射到同一组）<ul>
<li>即便程序有良好的空间局部性，高速缓存空间也够，但由于抖动，程序速度也会下降。</li>
</ul>
</li>
<li>修正抖动问题：在每个数组的结尾放B字节的填充。<ul>
<li>B字节，正好错开一组。<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-10-20-47.png"></li>
</ul>
</li>
</ul>
<ul>
<li>为什么用中间的位作为组索引，而不是用高位<ul>
<li>因为用高位做索引，那么一些连续的内存块就会被映射到相同的高速缓存行。</li>
<li>那么，如果一个程序有良好的空间局部性，顺序扫描数组时，在任意时刻，高速缓存块中只保留一个块大小的数组内容。因为相邻的块都被映射到同一组了。效率低下，</li>
</ul>
</li>
</ul>
<h2 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h2><ul>
<li><strong>E路组相联：一组里面有E行</strong><ul>
<li>一个1&lt;E&lt;C/B的高速缓存（C=E*S*B &amp;&amp; 1&lt;E&lt;C/B –&gt; S &gt; 1）<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-11-43-48.png"></li>
</ul>
</li>
<li><strong>一个组中的任何一行都可以包含任何映射到这个组的内存块</strong></li>
</ul>
<h3 id="组选择-1"><a href="#组选择-1" class="headerlink" title="组选择"></a>组选择</h3><ul>
<li>组索引标识组，同直接映射的组选择。<br>  <img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-11-58-29.png"></li>
</ul>
<h3 id="行选择"><a href="#行选择" class="headerlink" title="行选择"></a>行选择</h3><ul>
<li>比直接映射的组选择复杂。</li>
<li>高速缓存必须搜索一个组中的所有行，若行的标记和主存地址的标记匹配，即命中。<br>  <img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-12-02-03.png"></li>
</ul>
<h3 id="字偏移"><a href="#字偏移" class="headerlink" title="字偏移"></a>字偏移</h3><ul>
<li>还是b位二进制表示偏移的字节数。</li>
</ul>
<h3 id="行替换-1"><a href="#行替换-1" class="headerlink" title="行替换"></a>行替换</h3><ul>
<li>在不命中时，如果定位到的组中有空行，那么直接放入；<strong>如果没有空行，即会发生行替换</strong>。（尽量使得这个牺牲行之后不会很快被cpu引用）</li>
<li>行替换策略<ul>
<li>随机选择要替换的行（简单）</li>
<li>LRU（Least-Recently-Used）：最近最少使用策略<ul>
<li>替换最后一次访问时间最久远的那一行</li>
</ul>
</li>
<li>LFU（Least——Frequently-Used）：最不常使用策略<ul>
<li>替换在过去某个时间窗口引用次数最少的那一行</li>
</ul>
</li>
<li>这些策略需要额外的硬件和事件，但是，存储层次越向下，越远离cpu，一次不命中的开销越大，因此，用更好的替换策略使得不命中最少也变得更加值得了。</li>
</ul>
</li>
</ul>
<h2 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h2><ul>
<li>只有一个组，也即S = 2^0 = 0。也即主存地址中的s组索引部分的位数为0。</li>
<li>比前两种都复杂和昂贵，全相联只适合做小的高速存储，如虚拟内存系统中的翻译备用缓冲器TLB，用于缓存页表项（cy，还没学啊）</li>
</ul>
<h3 id="组选择-2"><a href="#组选择-2" class="headerlink" title="组选择"></a>组选择</h3><ul>
<li>组索引位数为0<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-12-21-54.png"></li>
</ul>
<h3 id="行匹配-1"><a href="#行匹配-1" class="headerlink" title="行匹配"></a>行匹配</h3><h3 id="字偏移-1"><a href="#字偏移-1" class="headerlink" title="字偏移"></a>字偏移</h3><ul>
<li>m = t+b<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-12-24-35.png"></li>
</ul>
<h2 id="读概要"><a href="#读概要" class="headerlink" title="读概要"></a>读概要</h2><ul>
<li>之前探讨的都是读的问题。关于读命中和读不命中。<h3 id="读命中"><a href="#读命中" class="headerlink" title="读命中"></a>读命中</h3></li>
<li>缓存命中则直接将字返回给cpu；<h3 id="读不命中"><a href="#读不命中" class="headerlink" title="读不命中"></a>读不命中</h3></li>
<li>不命中的话<ul>
<li>高速缓存向主存（下一层结构）请求包含w的块的一个副本，在这个过程中，cpu必须等待。</li>
<li>当被请求的块从主存中到达时，高速缓存根据组索引位的指示将该块放在它某组中的一个高速缓存行里。<ul>
<li>可能会需要驱逐一个缓存中现存的行<ul>
<li>对于直接映射来说，替换策略很简单，就是用新取出的行替换当前的行。</li>
</ul>
</li>
</ul>
</li>
<li>然后从被存储的块中抽出字w，然后将它返回给cpu。</li>
</ul>
</li>
</ul>
<h2 id="写"><a href="#写" class="headerlink" title="写"></a>写</h2><h3 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h3><ul>
<li>要写一个已经缓存了的字w</li>
<li><ol>
<li>先在<strong>高速缓存</strong>更新w的副本</li>
</ol>
</li>
<li><ol start="2">
<li>然后更新w在层次结构中紧挨着的<strong>下一层</strong>的副本，有两种方案。write-through 和 write back</li>
</ol>
<ul>
<li><strong>write-through ：直写</strong><ul>
<li>立即将w的高速缓存块写回紧挨着的低一层中</li>
<li>优点：实现简单</li>
<li>缺点：每次写都会引起总线流量</li>
</ul>
</li>
<li><strong>write-back：写回</strong><ul>
<li>尽可能推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写道紧接着的低一层中。</li>
<li>优点：利用局部性，写回策略可以显著减少总线流量</li>
<li>缺点：增加复杂性。高速缓存必须维护一个额外的修改为（dirty-bit），表明这个高速缓存块是否修改过。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h3><ul>
<li>要写一个还没被缓存的块。</li>
<li><strong>write-allocate：写分配</strong><ul>
<li>加载相应的低一层中的块到高速缓存中，然后更新这个告诉缓存块。</li>
<li>优点：利用了空间局部性</li>
<li>缺点：每次不命中都会导致一个块从低一层传送到高速缓存。</li>
<li>写分配策略提问<ul>
<li>为什么写不命中需要将原内存内容先加载入cache，再更新这行cache。为啥不直接根据主存地址在cache里的相应位置写入要写的新内容。之后这个块需要被驱逐时再紧接着的下一层？</li>
<li>因为写分配是一个写不命中时的策略，这是高速缓存中相应的行不是主存相应地址的内容。主存和缓存交换的单元是数据块，缓存和cpu交换的单元是字/字节等。缓存行的数据块除了你写入修改的bytes，还会有其他bytes不是主存相应地址的内容，怎么办？你只写入了几个有效的bytes，那行里的把其他无效bytes呢？岂不是会破坏主存里的内容</li>
<li>所以，写分配应当先讲下一层的该地址的块加载到本层内存中，然后更新这个告诉缓存块。</li>
</ul>
</li>
</ul>
</li>
<li><strong>not-write-allocate 非写分配</strong><ul>
<li>避开高速缓存，直接把这个字写入低一层中。</li>
</ul>
</li>
<li><strong>直接</strong>写高速缓存通常是<strong>非写分配</strong>的。<ul>
<li> <strong>write-through &amp;&amp; not-write-allocate</strong></li>
</ul>
</li>
<li><strong>写回</strong>高速缓存一般是<strong>写分配</strong>的<ul>
<li><strong>write-back &amp;&amp; write-allocate</strong></li>
</ul>
</li>
<li>但是读都是一样的。</li>
</ul>
<ul>
<li>写程序时一般认为os和机器使用写回写分配的高速缓存模型<ul>
<li>由于较长的传送时间，因而采用写回</li>
<li>策略实现的复杂性不再是阻碍</li>
<li>现在所有层次上都能看到写回缓存</li>
<li>与处理读的方式相对称，都利用了局部性</li>
<li>基于这种假设，我们可以在高层次上写程序，而不用去试图优化一个存储器系统</li>
</ul>
</li>
</ul>
<h2 id="真实结构"><a href="#真实结构" class="headerlink" title="真实结构"></a>真实结构</h2><p><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-14-15-32.png"><br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-14-15-41.png"></p>
<ul>
<li>unified-cache：统一的高速缓存：既保存指令又保存数据</li>
<li>i-cache：只保存指令的高速缓存</li>
<li>d-cache：只保存数据的高速缓存<ul>
<li>两个独立的高速缓存的优点</li>
<li>处理器可以同时访问这俩</li>
<li>可以针对不同访问模式优化</li>
<li>确保数据访问不会和指令访问形成冲突不命中（代价：可能会引起容量不命中up）</li>
</ul>
</li>
<li>L3所有核共享；L1、L2每个核私有</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><ul>
<li><p><strong>衡量</strong>性能</p>
<ul>
<li>不命中率（miss rate）：不命中数量 / 引用数量</li>
<li>命中率（hit rate）</li>
<li>命中时间（hit time）：从高速缓存中传送一个字到cpu的时间：<ul>
<li>组选择、行确认、字偏移的时间。</li>
<li>对L1来说，命中时间的数量级为几个时钟周期。</li>
</ul>
</li>
<li>不命中处罚（miss penalty）：由于不命中所需的额外时间<ul>
<li>L1不命中后</li>
<li>从L2得到服务的处罚：10个时钟周期</li>
<li>从L3得到服务的处罚：50个时钟周期</li>
<li>从主存得到服务的处罚：200个时钟周期</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>影响因素</strong></p>
<ul>
<li>高速缓存大小<ul>
<li>较大的高速缓存：<ul>
<li>提高命中率，</li>
<li>但也会增加命中时间。（使大存储器运行更快比较难）</li>
</ul>
</li>
<li>所以L1比L2小，L2比L3小</li>
</ul>
</li>
<li>块大小<ul>
<li>较大的块<ul>
<li>更能利用程序中可能存在的空间局部性，帮助提高命中率</li>
<li>但对于给定的高速缓存大小，块越大意味着高速缓存行数越少（我感觉容易发生抖动，可能会多个块映射到同一行），会降低时间局部性比空间局部性更好的程序的命中率。</li>
<li>对不命中处罚也有不利影响：块越大，传送时间越长，不命中处罚也就越大。</li>
</ul>
</li>
</ul>
</li>
<li>相联度<ul>
<li>每组行数E即相联度。</li>
<li>较大的E<ul>
<li>降低了由于冲突不命中而出现抖动的可能</li>
<li>但是复杂，昂贵，增加命中时间（因为行的复杂性增加了)，增加不命中处罚（因为选择牺牲行的复杂性增加了）。</li>
</ul>
</li>
<li>E的选择是命中时间和不命中处罚的折中。<ul>
<li>L1：E较小（因为不命中处罚只是几个clk）</li>
<li>而较低层则E较大（因为不命中处罚很大）</li>
</ul>
</li>
</ul>
</li>
<li>写策略<ul>
<li>…</li>
<li>越向下，越可能使用写回而不是直写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>组包含行，行包含块<br>  <img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-14-49-40.png"></li>
</ul>
<h1 id="编写高速缓存友好的代码"><a href="#编写高速缓存友好的代码" class="headerlink" title="编写高速缓存友好的代码"></a>编写高速缓存友好的代码</h1><ul>
<li><p>基本方法</p>
<ul>
<li>让最常见的情况运行的快</li>
<li>尽量减小每个循环内部的缓存不命中数量</li>
</ul>
</li>
<li><p>对局部变量的反复吟咏是好的，因为编译器能将他们缓存在Register File中（时间局部性）</p>
</li>
<li><p>步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是讲数据存储为连续的块。</p>
<ul>
<li>步长为k（字）的引用模式：平均每次循环迭代会有<code>min(1,(wordsize*k)/B)</code>次缓存不命中</li>
</ul>
</li>
<li><p>二维数组遍历 行优先 / 列优先。（假设1字4bytes，高速缓存4个字，初始为空）</p>
<ul>
<li>行优先：不命中率1/4<br>  <img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-15-31-37.png"><br>  <img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-15-31-45.png"></li>
<li>列优先。可以自己对着地址和程序看一眼。会出现抖动。<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-15-48-00.png"><br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-15-48-29.png"><ul>
<li>数组地址<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">t s  b</span><br><span class="line"><span class="number">0</span> <span class="number">00</span> <span class="number">0000</span>   <span class="comment">// (0,0)</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">01</span> <span class="number">0000</span>   <span class="comment">// (0,4)</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">10</span> <span class="number">0000</span>   <span class="comment">// (1,0)</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">11</span> <span class="number">0000</span>   <span class="comment">// (1,4)</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">00</span> <span class="number">0000</span>   <span class="comment">// (2,0)</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">01</span> <span class="number">0000</span>   <span class="comment">// (2,4)</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">10</span> <span class="number">0000</span>   <span class="comment">// (3,0)</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">11</span> <span class="number">0000</span>   <span class="comment">// (3,4)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>例题<br>  <img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-16-27-17.png"></p>
</li>
<li><p>关键点：</p>
<ul>
<li>直接映射，直写（写命中），写分配（写不命中）<ul>
<li>写分配：需要将下一层的块加载入高速缓存中，又因为直接映射，因此会发生替换。</li>
<li>直接映射：E=1</li>
</ul>
</li>
<li>块大小B=8bytes，故b=3。</li>
<li>组数S = C / (E*B) = 16/8 = 2 = 2^s 。故s=1</li>
<li>标记位t多少位无所谓，就是个标记。</li>
</ul>
</li>
<li><p>逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dst[<span class="number">0</span>][<span class="number">0</span>] = src[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">dst[<span class="number">1</span>][<span class="number">0</span>] = src[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">dst[<span class="number">0</span>][<span class="number">1</span>] = src[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">dst[<span class="number">1</span>][<span class="number">1</span>] = src[<span class="number">1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">src     </span><br><span class="line">         <span class="number">0</span>         <span class="number">1</span></span><br><span class="line"><span class="number">0</span>     <span class="number">0</span> <span class="number">0</span> <span class="number">000</span>   <span class="number">0</span> <span class="number">0</span> <span class="number">100</span></span><br><span class="line"><span class="number">1</span>     <span class="number">0</span> <span class="number">1</span> <span class="number">000</span>   <span class="number">0</span> <span class="number">1</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">dst</span><br><span class="line">         <span class="number">0</span>          <span class="number">1</span></span><br><span class="line"><span class="number">0</span>     <span class="number">1</span> <span class="number">0</span> <span class="number">000</span>   <span class="number">1</span> <span class="number">0</span> <span class="number">100</span></span><br><span class="line"><span class="number">1</span>     <span class="number">1</span> <span class="number">1</span> <span class="number">000</span>   <span class="number">1</span> <span class="number">1</span> <span class="number">100</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-16-30-08.png"></p>
<h1 id="存储器山"><a href="#存储器山" class="headerlink" title="存储器山"></a>存储器山</h1><p><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-18-20-46.png"></p>
<ul>
<li><p>读吞吐量(read throughput)/读带宽(read handwidth)：一个程序从存储系统中读数据的速率。(n/s ：s秒内读n字节；通常以MB/s为单位)</p>
</li>
<li><p><strong>存储器山：读吞吐量的时间局部性和空间局部性二维函数</strong>。<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-18-06-09.png"></p>
</li>
<li><p>大小是指工作集大小：工作集越小，时间局部性越好。</p>
</li>
<li><p>步长stride：步长越小，空间局部性越好。</p>
</li>
<li><p>橘色：四条山脊对应的工作集完全在L1、L2、L3、主存内的时间局部性区域</p>
</li>
<li><p>粉色：空间局部性好可以补救时间局部性差</p>
</li>
<li><p>固定步长为常数，观察吞吐量与时间局部性（工作集）关系<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-18-10-25.png"></p>
</li>
<li><p>固定工作集大小，观察吞吐量和空间局部性（步长）关系(csapp447.其实没太看懂，这步长的单位到底是啥。)<br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-18-21-51.png"></p>
</li>
<li><p>码农尽可能利用时间局部性和空间局部性，去访问存储器山的左上角。</p>
</li>
</ul>
<h3 id="在程序中利用局部性"><a href="#在程序中利用局部性" class="headerlink" title="在程序中利用局部性"></a>在程序中利用局部性</h3><ul>
<li>正如我们看到的，存储系统被组织成一个存储设备的层次结构，较小、较快的设备靠近顶部，较大、较慢的设备靠近底部。由于采用了这种层次结构，程序访问存储位置的实际速率不是一个数字能描述的。相反，它是一个变化很大的程序局部性的函数（我们称之为存储器山）， 变化可以有几个数量级。有良好局部性的程序从快速的高速缓存存储器中访问它的大部分数据。局部性差的程序从相对慢速的 DRAM 主存中访问它的大部分数据。</li>
<li>理解存储器层次结构本质的程序员能够利用这些知识编写出更有效的程序，无论具体<br>的存储系统结构是怎样的。特别地，我们推荐下列技术</li>
<li>将你的注意力集中在内循环上，大部分计算和内存访问都发生在这里。</li>
<li>通过按照数据对象存储在内存中的顺序、以步长为 1 的来读数据，从而使得你程序中的空间局部性最大。</li>
<li>一旦从存睹器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大。</li>
</ul>
<p><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-18-28-13.png"><br><img src="/2022/07/07/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%842/2022-07-09-18-28-19.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp_6_存储器层次结构</title>
    <url>/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li>各类存储技术 <ul>
<li>RAM：SRAM DRAM</li>
<li>ROM</li>
<li>磁盘</li>
</ul>
</li>
<li>访问主存，访问磁盘流程<span id="more"></span></li>
</ul>
<h1 id="Storage-technologies-存储技术"><a href="#Storage-technologies-存储技术" class="headerlink" title="Storage technologies 存储技术"></a>Storage technologies 存储技术</h1><h2 id="Random-Access-Memory（RAM）随机访问存储器"><a href="#Random-Access-Memory（RAM）随机访问存储器" class="headerlink" title="Random-Access Memory（RAM）随机访问存储器"></a>Random-Access Memory（RAM）随机访问存储器</h2><ul>
<li>Random-Access Memory（RAM）：随机访问存储器<ul>
<li><strong>RAM就是所说的内存</strong></li>
</ul>
</li>
<li>分为SRAM（快）和DRAM（慢）。<br>  <img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-12-34-52.png"></li>
<li><strong>SRAM和DRAM都是易失性存储器</strong>（volatile memories）<ul>
<li>当断电得时候存储的信息就会丢失。</li>
</ul>
</li>
</ul>
<h3 id="SRAM-静态RAM"><a href="#SRAM-静态RAM" class="headerlink" title="SRAM   静态RAM"></a>SRAM   静态RAM</h3><ul>
<li>用作<strong>高速缓存存储器</strong></li>
<li>双稳态特性，只要有点，就会永远地保持它的值。只要有电，SRAM就会保持不变。</li>
<li>对干扰（光、电噪）不敏感</li>
<li>贵（需要晶体管多，密集度低）</li>
</ul>
<h3 id="DRAM-动态RAM"><a href="#DRAM-动态RAM" class="headerlink" title="DRAM   动态RAM"></a>DRAM   动态RAM</h3><ul>
<li>用作<strong>主存</strong></li>
<li>有许多原因会导致DRAM单元漏电，因此内存系统必须周期性的通过读出然后重写，来刷新内存每一位。</li>
<li>对干扰敏感</li>
<li>便宜</li>
</ul>
<h2 id="ROM-：nonvolatile-memory-非易失性存储器"><a href="#ROM-：nonvolatile-memory-非易失性存储器" class="headerlink" title="ROM ：nonvolatile memory 非易失性存储器"></a>ROM ：nonvolatile memory 非易失性存储器</h2><ul>
<li><p><strong>非易失性存储器（nonvolatile memory）</strong>：即使在断电之后，仍然保存着他们的信息。（ROM就是非易失性存储器）</p>
</li>
<li><p><strong>ROM</strong>：由于历史原因，虽然ROM中有的类型既可以读又可以写，但是他们整体上都被称为<strong>只读存储器（Read-Only Memory，ROM）</strong></p>
</li>
<li><p>ROM以他们能被重新编程的<strong>次数</strong>和对他们重新编程所用的<strong>机制</strong>来区分。</p>
<ul>
<li>可编程ROM  (Programmable ROM，PROM)：只能被编程一次</li>
<li>可擦写可编程ROM（Erasable Programmable ROM，EPROM）：能够被擦除和重编程。（1000次）</li>
<li>电子可擦除PROM（Electrically Erasable Programmable ROM：EEPROM）。（100000次）：为大量电子设备提供快速而持久的非易失性存储，如数码相机，手机，笔记本，台式机等。</li>
<li>闪存（flash memory）：基于EEPROM的非易失性存储器。</li>
<li>固态硬盘（Solid State）：基于闪存的磁盘驱动器，提供相对于传统旋转磁盘的一种更快速、更强健和更低能耗的选择。</li>
</ul>
</li>
<li><p><strong>固件 firmware</strong>：存储在ROM设备中的程序。</p>
<ul>
<li>当一个计算机系统通电之后，它会运行存储在ROM中的固件。</li>
<li>一些系统在固件中提供了少量的基本输入输出函数。如PC的BIOS例程。<ul>
<li>BIOS,controllers    for    disks,network cards,graphics accelerators,security subsystems,…</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>有个之前没搞懂的问题，现在懂了<ul>
<li>RAM就是内存。SRAM 高速缓冲 DRAM 主存</li>
<li>ROM不意味着硬盘<ul>
<li>旋转磁盘：不是基于ROM。是靠磁性物质</li>
<li>固态硬盘：基于flash memroy。是ROM</li>
</ul>
</li>
<li>RAM、ROM都算半导体存储器利用逻辑电路读写，磁盘就是磁介质存储加上机械传动读写</li>
</ul>
</li>
</ul>
<h2 id="Disk-磁盘"><a href="#Disk-磁盘" class="headerlink" title="Disk 磁盘"></a>Disk 磁盘</h2><p>略</p>
<h3 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h3><p><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-19-16-29.png"></p>
<ul>
<li>盘片以固定速率旋转</li>
</ul>
<p><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-19-19-34.png"></p>
<ul>
<li>磁盘（disk）由多个盘片（platter）组成。每个盘片有两个表面（surface），表面覆盖着磁性记录材料。</li>
<li>每个表面由多个同心环组成，被称为磁道（track）。</li>
<li>每个磁道由一组扇区（sector）组成。一组中的每个扇区被间隙（gap）分隔开。每个扇区包含数量相等的数据位；间隙不存储数据位。</li>
<li>磁盘：由一或多个盘片组成，封装起来。称为磁盘驱动器(disk driver)，也称为磁盘(disk)，也叫玄幻磁盘(rotating disk)（以区分固态硬盘ssd）</li>
</ul>
<h3 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h3><ul>
<li><p>磁盘容量：一个磁盘可以记录的最大位数</p>
<ul>
<li>记录密度（recording density）：磁道一英寸的段可以放入的位数</li>
<li>磁道密度（track density）：从盘片中心出发半径一英寸的段内可以有的磁道数</li>
<li>面密度（areal density）：记录密度 * 磁道密度的乘积。</li>
</ul>
</li>
<li><p>公式<br>  <img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-19-49-20.png"></p>
</li>
<li><p>单位 K M G T</p>
<ul>
<li>对于DRAM、SRAM容量相关的计量单位：2^10进制，<code>K=2^10,M=2^20,G=2^30</code></li>
<li>对于磁盘和网络这样的IO设备的容量计量单位：10^3进制，<code>K=10^3,M=10^6,G=10^9,T=10^12</code></li>
</ul>
</li>
</ul>
<h3 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h3><ul>
<li>大体有两个操作，一个是传动臂，一个是盘面</li>
<li>寻道：传动臂沿半径轴前后移动，驱动读写头定位任意一个磁道。称为寻道。<ul>
<li>寻道是为了确定目标扇区所在磁道</li>
<li>（即将读写头定位到正确柱面。柱面：所有盘片到主轴中心举例相等的磁道集合，即垂直看重合的磁道称为一个柱面）</li>
</ul>
</li>
<li>盘面：以固定速率旋转。<ul>
<li>盘面旋转是为了让扇区处于读写头下。<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-20-11-39.png"></li>
</ul>
</li>
<li>对磁盘的访问时间<ul>
<li>寻道时间：寻道所花时间</li>
<li>旋转时间：寻道结束后，旋转扇区所花时间</li>
<li>传送时间：当目标山区第一个位位于读写头希望，驱动器就可以开始读或者写该扇区内容了。</li>
</ul>
</li>
</ul>
<h3 id="逻辑磁盘块"><a href="#逻辑磁盘块" class="headerlink" title="逻辑磁盘块"></a>逻辑磁盘块</h3><p><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-20-28-22.png"></p>
<ul>
<li>Disk Controller：磁盘控制器。<ul>
<li>维护逻辑块号码和物理扇区的关系。</li>
<li>控制器上的固件：将逻辑块号翻译成（盘片、磁盘、扇区）三元组</li>
<li>磁盘控制器上的硬件会解释这个三元组，将读写头移动到适当的柱面，等待扇区移动到读写头下，将读写狗感知的位放到控制器上的一个小缓冲区中，然后将他们复制到主存。</li>
</ul>
</li>
</ul>
<h2 id="Solid-State-Disk-SSD-固态硬盘"><a href="#Solid-State-Disk-SSD-固态硬盘" class="headerlink" title="Solid State Disk (SSD) 固态硬盘"></a>Solid State Disk (SSD) 固态硬盘</h2><ul>
<li>solid state disk 基于闪存实现的存储技术。<ul>
<li>由一个或多个闪存芯片和闪存翻译曾组成。</li>
<li>闪存芯片 &lt;—&gt; 旋转磁盘的机械驱动盘</li>
<li>闪存翻译层 &lt;—&gt; 磁盘控制器 </li>
<li>ssd大部分取代旋转磁盘。</li>
</ul>
</li>
</ul>
<h2 id="访问主存"><a href="#访问主存" class="headerlink" title="访问主存"></a>访问主存</h2><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ul>
<li><p>总线（bus）：数据流通过被称为总线的共享电子电路在处理器和DRAM主存之间传递。</p>
<ul>
<li>一组并行的导线，可以携带地址，数据和控制信号。</li>
<li>数据和地址信号是否共享同一组导线，取决于总线的设计。同时，总线通常被不同设备共享。</li>
<li>控制线携带的信号会同步事务，并表示出当前正在被执行的事务的类型。</li>
</ul>
</li>
<li><p>总线事务：每次cpu和主存之间的数据传送都是通过一系列步骤完成的，这些步骤，称为总线事务</p>
<ul>
<li>读事务：数据从主存传送到cpu</li>
<li>写事务：数据从cpu-&gt;主存。</li>
</ul>
</li>
<li><p><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-13-49-41.png"></p>
</li>
<li><p>总共有三个总线</p>
<ul>
<li><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-20-41-07.png"></li>
<li>系统总线</li>
<li>内存总线</li>
<li>IO总线</li>
</ul>
</li>
</ul>
<h3 id="读事务"><a href="#读事务" class="headerlink" title="读事务"></a>读事务</h3><p>没画高速缓存L123</p>
<ul>
<li><code>movq A,%rax</code>：地址A的内容被加载入寄存器<ul>
<li>cpu芯片上被称为<strong>总线接口</strong>的的电路在总线上<strong>发起读事务</strong></li>
<li><strong>1</strong>. cpu将地址A放在系统总线上，IO桥将信号传递到内存总线<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-18-54-08.png"></li>
<li><strong>2</strong>. 主存感受到内存总线上的地址信号，从内存总线上读地址，然后从DRAM中取数据，并将数据写到内存总线；IO桥将内存总线的信号转化成系统总线的信号，然后通过系统总线传递给cpu<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-18-54-26.png"></li>
<li><strong>3</strong>. cpu感觉到系统总线上的数据，从总线上读数据，然后将数据复制到寄存器%eax<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-18-54-41.png"></li>
</ul>
</li>
</ul>
<h3 id="写事务"><a href="#写事务" class="headerlink" title="写事务"></a>写事务</h3><ul>
<li><code>mov %rax,A</code>：寄存器的内容被写入地址A<ul>
<li>cpu芯片发起<strong>写事务</strong></li>
<li><ol>
<li>cpu将地址A放在内存总线上，IO桥将信号传递到内存总线，DRAM主存从内存总线上读地址。DRAM然后等待数据信息到达。<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-19-01-07.png"></li>
</ol>
</li>
<li><ol start="2">
<li>cpu将数据信息放在系统总线上。<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-19-01-29.png"></li>
</ol>
</li>
<li><ol start="3">
<li>主存从总线上读取字，并存储在地址A中。<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-19-01-39.png"></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-21-00-35.png"></p>
<ul>
<li>**内存映射I/O(memory-mapped I/O)**：CPU使用该技术来向IO设备发射命令。<ul>
<li>在使用内存映射io的系统中，地址空间有一块地址是为与io设备通信保留的。每个这样的地址称为一个IO端口。当一个设备连接到总线时，她与一个或多个这样的端口相关联。（或他被映射到一或多个端口）</li>
<li>这不是Linux的mmaped，我第一眼还以为是hhh</li>
</ul>
</li>
</ul>
<h3 id="访问磁盘过程："><a href="#访问磁盘过程：" class="headerlink" title="访问磁盘过程："></a>访问磁盘过程：</h3><ul>
<li><p>CPU 将【命令、逻辑块号、目的内存地址】 写到 【与磁盘相关联的】【内存映射地址】，发起一个【磁盘读】。<img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-21-04-47.png"></p>
</li>
<li><p>磁盘控制器读扇区，并执行到主存的DMA传送<img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-21-08-36.png"></p>
<ul>
<li>cpu发出请求后，在磁盘执行读的时候，通常会执行其他工作。</li>
<li><strong>DMA(direct memory access)传送</strong>：磁盘控制器收到cpu的读命令后，将逻辑块号翻译成一个扇区地址，读取该扇区内容，然后将这些内容传送给主存，无需cpu干涉。也即，设备可以自己执行读或写总线事务而无需cpu参与的过程。</li>
</ul>
</li>
<li><p>当DMA传送完成时，磁盘控制器用中断的方式通知CPU<img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-21-10-14.png"></p>
<ul>
<li>基本思想：中断会发出信号给cpu芯片的引脚，使得cpu暂停当前工作，将控制传递给一个os的例程。这个例程记录下IO已经完成，然后将控制返还给cpu刚刚被中断的地方。</li>
</ul>
</li>
<li><p>例子：假设磁盘控制器映射到IO端口0xa0，随后cpu可能通过执行三个对地址0xa0的存储指令，发起磁盘读。</p>
</li>
<li><p>CPU执行三个对地址0xa0的存储指令，发起磁盘读</p>
<ul>
<li>第一条指令是发送一个命令字，告诉磁盘发起一个读（还可能有其他参数，如是否中断cpu）。</li>
<li>第二条指令指明应该读取的逻辑块号。（磁盘控制器会找到相应物理扇区）。</li>
<li>第三条指令指明应该存储磁盘扇区内容的贮存地址。</li>
</ul>
</li>
</ul>
<h2 id="Trend"><a href="#Trend" class="headerlink" title="Trend"></a>Trend</h2><p><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-06-21-40-45.png"></p>
<ul>
<li>内存和磁盘技术：增加密度（从而降低成本）比降低访问时间容易得多</li>
<li>SRAM的性能滞后于CPU的性能，但SRAM还在保持继续增长。</li>
<li>DRAM和磁盘的性能滞后于CPU的性能（时间），且差距逐渐增大。</li>
<li>现代计算机频繁使用基于SRAM的告诉缓存，试图弥补处理器-内存（cpu-memory）的之间的差距。（原理：程序的局部性属性）</li>
</ul>
<h1 id="Locality-局部性"><a href="#Locality-局部性" class="headerlink" title="Locality 局部性"></a>Locality 局部性</h1><ul>
<li><p>分为<strong>时间局部性</strong>和<strong>空间局部性</strong></p>
</li>
<li><p><strong>时间局部性 (temporal locality)</strong></p>
<ul>
<li>在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。（重复引用<strong>同一</strong>数据项）</li>
</ul>
</li>
<li><p><strong>空间局部性 (spatial locality)</strong></p>
<ul>
<li>在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用<strong>附近</strong>的一个内存位置。（引用邻近于最近使用过的数据项的数据项</li>
</ul>
</li>
<li><p>评价局部性的简单原则</p>
<ul>
<li>data<ul>
<li>时间局部性良好：重新引用相同变量</li>
<li>空间局部性良好：步长为k的引用模式，k越小越好（不在内存中大步长跳来跳去。</li>
</ul>
</li>
<li>instruction<ul>
<li>对于取指令来说，循环有好的时间局部性和空间局部性。</li>
<li>循环体越小，循环迭代次数越多（相同频率下），局部性越好。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="程序例子"><a href="#程序例子" class="headerlink" title="程序例子"></a>程序例子</h2><p><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-07-08-38-24.png"></p>
<h2 id="对程序数据引用的局部性"><a href="#对程序数据引用的局部性" class="headerlink" title="对程序数据引用的局部性"></a>对程序数据引用的局部性</h2><ul>
<li><p>变量sum  </p>
<ul>
<li>时间局部性很好：每次循环被引用一次</li>
<li>不存在空间局部性：sum是标量</li>
</ul>
</li>
<li><p>变量v：</p>
<ul>
<li>时间局部性很差：因为每个向量元素只被访问一次。</li>
<li>空间局部性很好<ul>
<li>步长为1的引用模式<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-07-08-42-13.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>看出时间局部性和空间起码占一样儿。</p>
</li>
<li><p><strong>步长为1的引用模式</strong>（顺序访问一个向量）</p>
<ul>
<li>stride-1 reference pattern / sequential reference pattern</li>
<li>在一个连续向量中，每隔k个元素进行访问，称为步长为k的引用模式（stride-k reference pattern）</li>
<li>k越大，空间局部性越差。</li>
</ul>
</li>
<li><p>…<br><img src="/2022/06/27/csapp-6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2022-07-07-08-50-09.png"></p>
</li>
</ul>
<h2 id="取指令的局部性"><a href="#取指令的局部性" class="headerlink" title="取指令的局部性"></a>取指令的局部性</h2><ul>
<li>cpu需要从内存读出指令，所以我们也能够评价一个程序关于指令的局部性。</li>
<li><strong>空间局部性</strong>：for循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。</li>
<li><strong>时间局部性</strong>：for循环体会被执行多次。（Loop:… goto Loop;）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mystring</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一元操作符重载</span></span><br><span class="line">    <span class="comment">//重载1</span></span><br><span class="line">    <span class="built_in">mystring</span> (mystring &amp;a)&#123;cout&lt;&lt;<span class="string">&quot;wrong!&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">mystring</span> ()&#123;&#125;</span><br><span class="line">    mystring <span class="keyword">operator</span>=(<span class="keyword">const</span> mystring &amp;it)</span><br><span class="line">    &#123;   <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(s,it.s);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;111&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mystring s1;</span><br><span class="line">    s1.s=<span class="string">&quot;111&quot;</span>;</span><br><span class="line">    mystring s2=s1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">因为<span class="string">&quot;111&quot;</span>在rodata段，所以报错。</span><br></pre></td></tr></table></figure>



<p><a href="https://stackoverflow.com/questions/26672661/for-write-back-cache-policy-why-data-should-first-be-read-from-memory-before-w">https://stackoverflow.com/questions/26672661/for-write-back-cache-policy-why-data-should-first-be-read-from-memory-before-w</a></p>
<p><a href="https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#%E5%86%99%E5%9B%9E">https://xiaolincoding.com/os/1_hardware/cpu_mesi.html#%E5%86%99%E5%9B%9E</a></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp-8-异常控制流2</title>
    <url>/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/</url>
    <content><![CDATA[<ul>
<li><p>信号 signal<br>信号编号、事件、默认行为、处理方式（见Linux信号）<br>发送信号方式、接收信号<br>阻塞、接触阻塞信号<br>进程接收信号流程<br>  内核为每个进程维护了pending和blocked</p>
</li>
<li><p>非本地跳转<br>catch – setjmp、throw – longjmp</p>
</li>
</ul>
<span id="more"></span>

<h2 id="Signal-信号"><a href="#Signal-信号" class="headerlink" title="Signal 信号"></a>Signal 信号</h2><ul>
<li>Linux信号：更高层次，软件形式的异常。它允许进程和内核中断其他进程。</li>
<li>定义：一个<strong>信号</strong>就是一条小消息，它通知进程系统中发生了一个某种类型的事件。<ul>
<li>信号由内核（可能是应另一个进程的要求）发送给一个进程。    </li>
<li>信号提供了一种机制，通知用户进程发生了什么类型的异常。</li>
</ul>
</li>
<li><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-11-13-59-40.png"></li>
</ul>
<ul>
<li><strong>fork出的子进程会继承父进程关于signal的dispostion 如处理函数、掩码等</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A  child created via fork(2) inherits a copy of its parent<span class="string">&#x27;s signal dispositions.  During an execve(2), the dispositions of handled signals are reset to the default; the</span></span><br><span class="line"><span class="string">dispositions of ignored signals are left unchanged.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="信号的两个阶段"><a href="#信号的两个阶段" class="headerlink" title="信号的两个阶段"></a>信号的两个阶段</h3><p>以下仅为方便自己理解</p>
<ul>
<li>被处理的信号：<strong>信号被接收</strong></li>
<li>发出但还没被处理的信号：<strong>待处理信号</strong></li>
</ul>
<p>待处理信号集 / 未决信号集：1表示待处理，即内核发送了，但该信号还没被进程接收(处理)。</p>
<p>阻塞/屏蔽信号集：1表示该信号目前不可被prog进程接收(处理)。<br>一般是因为该信号在被进程的处理程序处理，此时，若内核再发送一个该信号SIGINT，则将该信号加入待处理信号集(置1)，待处理信号集不可排队（只是二进制而已）；即有多个该信号发送来，也只能有一个被加入待处理信号集，其余被抛弃。</p>
<h3 id="传送信号的步骤"><a href="#传送信号的步骤" class="headerlink" title="传送信号的步骤"></a>传送信号的步骤</h3><ul>
<li><p>kernal -&gt; process</p>
<h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4></li>
<li><p>如何<strong>递送</strong>信号：</p>
<ul>
<li>内核通过更新目的进程上下文中的某个状态，发送（<strong>递送</strong>）一个信号给目的进程</li>
</ul>
</li>
<li><p>发送信号原因</p>
<ul>
<li>内核检测到一个系统事件，比如除0错误或者子进程错误</li>
<li>一个进程调用了kill函数，显示地要求内核发送一个信号给目的进程，一个进程可以放信号给它自己。</li>
</ul>
</li>
<li><p>一个进程可以发送信号给他自己</p>
</li>
</ul>
<h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><ul>
<li><strong>接收</strong>信号<ul>
<li>当目的进程被内核强迫以某种方式对信号的发送做出反应时，他就接收了信号。</li>
<li>进程对信号的反应<ul>
<li><strong>忽略</strong> Ignore the    signal    (do    nothing)</li>
<li><strong>终止</strong> Terminate    the    process    (with optional    core    dump)</li>
<li><strong>信号处理程序</strong> Catch the    signal    by    executing    a user-level function called signal    handler。<ul>
<li>具体信号处理程序的默认行为都是什么。下文有接收信号有。</li>
<li> Akin    to    a    hardware    exception    handler    being called in    response to    an    asynchronous interrupt<br><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-11-14-32-28.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Signal dispositions</span><br><span class="line">    Each signal has a current disposition, <span class="built_in">which</span> determines how the process behaves when it is delivered the signal.</span><br><span class="line"></span><br><span class="line">    The entries <span class="keyword">in</span> the <span class="string">&quot;Action&quot;</span> column of the tables below specify the default disposition <span class="keyword">for</span> each signal, as follows:</span><br><span class="line"></span><br><span class="line">    Term   Default action is to terminate the process.</span><br><span class="line"></span><br><span class="line">    Ign    Default action is to ignore the signal.</span><br><span class="line"></span><br><span class="line">    Core   Default action is to terminate the process and dump core (see core(5)).</span><br><span class="line"></span><br><span class="line">    Stop   Default action is to stop the process.</span><br><span class="line"></span><br><span class="line">    Cont   Default action is to <span class="built_in">continue</span> the process <span class="keyword">if</span> it is currently stopped.</span><br></pre></td></tr></table></figure>


<h3 id="send-signal-发送信号"><a href="#send-signal-发送信号" class="headerlink" title="send signal 发送信号"></a>send signal 发送信号</h3><h4 id="进程组-amp-会话session"><a href="#进程组-amp-会话session" class="headerlink" title="进程组 &amp; 会话session"></a>进程组 &amp; 会话session</h4><p><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-11-15-38-18.png"></p>
<ul>
<li>作业job：对一条命令求值而创建的进程。</li>
<li>每个进程只属于一个进程组</li>
<li>进程组是一个或者多个进程的集合</li>
<li>会话session 是一个或者多个进程组的集合。</li>
<li>一般情况下 session 和终端是一对一的关系，当我们打开多个终端窗口时，实际上就创建了多个 session。</li>
<li><code>./a.out &amp;</code>。表示将命令放入后台执行。这样该命令对应的进程组即为后台进程组。</li>
<li>shell 中可以存在多个进程组，无论是前台进程组还是后台进程组，它们或多或少存在一定的联系，为了更好地控制这些进程组（或者称为作业），系统引入了会话的概念。</li>
<li><strong>会话（Session）的意义在于将很多的工作集中在一个终端，选取其中一个作为前台来直接接收终端的输入及信号，其他的工作则放在后台执行。</strong></li>
<li><strong>一个会话的几个进程组可被分成一个前台进程组（foreground process group）以及一个或几个后台进程组（background process group）。</strong><ul>
<li>在任意时刻，可能同时存在多个后台进程组，但是不管什么时候都只能有一个前台进程组。</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组则为后台进程组。</li>
</ul>
</li>
</ul>
<h4 id="从键盘发送信号"><a href="#从键盘发送信号" class="headerlink" title="从键盘发送信号"></a>从键盘发送信号</h4><ul>
<li>无论何时键入中断键（常常是DELETE或Ctrl - C）或退出键（常常是Ctrl - \），<strong>内核就会将中断信号或退出信号送至前台进程组的所有进程。</strong><ul>
<li><strong>只有在前台进程组中进程才能在控制终端读取输入</strong>。当用户在终端输入信号生成终端字符（如 ctrl+c、ctrl+z、ctr+\等）时，内核会把对应的信号发送给前台进程组。前台进程组的输出也会显示在控制终端上。</li>
</ul>
</li>
</ul>
<h4 id="用-bin-kill程序发送信号"><a href="#用-bin-kill程序发送信号" class="headerlink" title="用/bin/kill程序发送信号"></a>用/bin/kill程序发送信号</h4><ul>
<li>/bin/kill program    sends    arbitrary    signal    to    a    process or process    group</li>
<li><strong>send a signal to a process</strong> 不是杀掉一个process!</li>
<li>DESCRIPTION<ul>
<li>The  default signal for kill is TERM.  Use -l or -L to list available signals.  </li>
<li><strong>Particularly useful signals include HUP, INT, KILL, STOP, CONT, and 0.</strong>  </li>
<li><strong>Alternate signals may be specified in three ways: -9, -SIGKILL or -KILL</strong>.  </li>
<li>Negative PID values may be used to choose whole process groups<ul>
<li>A PID of -1 is special; it indicates all processes except the kill process itself and init.</li>
</ul>
</li>
</ul>
</li>
<li>Examples    <ul>
<li>/bin/kill –9 24818 ：Send    SIGKILL    to    process    24818    </li>
<li>/bin/kill –9 –24817 ：Send    SIGKILL    to    every    process    in    process    group    24817</li>
</ul>
</li>
</ul>
<h4 id="用kill函数发送信号"><a href="#用kill函数发送信号" class="headerlink" title="用kill函数发送信号"></a>用kill函数发送信号</h4><ul>
<li>pid&gt;0，kill函数发送信号sig给pid</li>
<li>pid=0，kill发送sig给调用进程所在进程组的每个进程</li>
<li>pid&lt;0，kill发送给进程组|pid|中的每个进程。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"><span class="keyword">return</span> val  </span><br><span class="line">  success : <span class="number">0</span></span><br><span class="line">  fail    : <span class="number">-1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="用alarm函数发送信号"><a href="#用alarm函数发送信号" class="headerlink" title="用alarm函数发送信号"></a>用alarm函数发送信号</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"><span class="keyword">return</span> val:</span><br><span class="line">  前一次闹钟剩余的秒数，若以前没有设定闹钟，则为<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>alarm函数：安排内核在secs秒后发送一个SIGALRM信号给调用进程。<ul>
<li>secs=0，则不会调度安排新的alarm</li>
</ul>
</li>
</ul>
<h3 id="接收信号-1"><a href="#接收信号-1" class="headerlink" title="接收信号"></a>接收信号</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>内核把进程p从内核模式切换到用户模式时（例如，从系统调用返回或完成了一次上下文切换），它会检查进程p的**未被阻塞的待处理信号的集合(pending &amp; ~blocked)**。<ul>
<li><strong>若集合为空</strong>：内核将控制传递到p的逻辑控制流的下一条指令（I_next）</li>
<li><strong>若集合非空</strong>：内核选择集合中的某个信号k（通常是最小的k），并强制p接收信号k。进程反应安慰你之后，控制就传递回p的逻辑控制流中的下一条指令（I_next）<ul>
<li><strong>信号对应的默认行为</strong>（信号处理程序默认做什么）<ul>
<li>The    process    terminates</li>
<li>The    process    terminates    and    dumps    core(转储内存)</li>
<li>The    process    stops    until    restarted    by    a    SIGCONT signal</li>
<li>The    process    ignores    the    signal</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>SIGSTOP 和 SIGKILL的默认行为不能更改</li>
</ul>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><ul>
<li><p>signal</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"><span class="keyword">return</span> :</span><br><span class="line">  success ：返回指向前次处理程序的指针</span><br><span class="line">  error：SIG_ERR 且 不设置errno</span><br></pre></td></tr></table></figure>
<ul>
<li>handler = SIG_IGN ，那么忽略signum型信号</li>
<li>handler = SIG_DFL，那么signum的信号行为恢复为默认行为</li>
<li>Otherwise,    handler    is    the    address    of    a    user-level    signal    handler。调用信号处理程序称为捕获信号，执行信号处理程序称为处理信号。<ul>
<li> Called    when    process    receives    signal    of    type    signum</li>
<li> Executing    handler    is    called    “catching”    or    “handling”    the    signal</li>
<li> return时控制传递给被中断的指令：When    the    handler    executes    its    return    statement,    control    passes    back    to    instruction    in    the    control    flow    of    the    process    that    was    interrupted    by receipt    of    the    signal</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-11-20-04-31.png"></p>
</li>
<li><p><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-11-20-09-06.png"><br><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-11-20-09-18.png"></p>
</li>
</ul>
<h4 id="SIGCHLD信号处理"><a href="#SIGCHLD信号处理" class="headerlink" title="SIGCHLD信号处理"></a>SIGCHLD信号处理</h4><p><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-13-52-44.png"><br><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-13-50-02.png"></p>
<ul>
<li>如何利用SIGCHLD 非阻塞 回收子进程 </li>
<li>下面这段代码不见得对</li>
<li>handler里面的waitpid的返回值究竟应该和0比较还是和-1比较，目前来看，我认为 如果！=-1的判断条件的话，那么while会一直轮询下去，很消耗性能，甚至还不如阻塞等待wait(null)。我认为应当是和0比较，如果&gt;0，就轮询,==0或者=-1就不轮询了。<ul>
<li>WNOHANG =-1是error ，=0是集合里剩余的所有进程还没结束</li>
<li>默认（HANG）=-1 &amp;&amp; errno = echild是 所有进程都被回收完毕。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  回收子进程比较好的方案，一定要会！！： 利用信号机制去回收子进程，防止使用execlp而无法回收子线程的情况</span></span><br><span class="line"><span class="comment">//  利用的信号：SIGCHLD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> signo)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">// while((wpid=wait(&amp;status)))</span></span><br><span class="line">    <span class="comment">// while((wpid=waitpid(-1,&amp;status,0)!=-1))</span></span><br><span class="line">    <span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG))!=<span class="number">-1</span>)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(wpid==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d exit with %d\n&quot;</span>,wpid,WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d killed with %d\n&quot;</span>,wpid,WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  设置PCB中的mask屏蔽字屏蔽SIGCHLD</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//  在进行主函数逻辑之前</span></span><br><span class="line">        <span class="comment">//  注册信号处理函数 来 处理捕捉信号</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  准备act</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_handler = <span class="keyword">catch</span>;    </span><br><span class="line">        act.sa_flags = <span class="number">0</span>;  </span><br><span class="line">        sigemptyset(&amp;act.sa_mask); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注册捕捉信号的处理函数  </span></span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解除屏蔽</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  模拟后序逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child id = %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./signal_to_catch_child.out </span><br><span class="line">i am child id = <span class="number">8585</span></span><br><span class="line">i am child id = <span class="number">8586</span></span><br><span class="line">i am child id = <span class="number">8589</span></span><br><span class="line">i am child id = <span class="number">8588</span></span><br><span class="line">i am child id = <span class="number">8587</span></span><br><span class="line">i am child id = <span class="number">8590</span></span><br><span class="line">i am child id = <span class="number">8593</span></span><br><span class="line">i am child id = <span class="number">8591</span></span><br><span class="line">i am child id = <span class="number">8594</span></span><br><span class="line">i am child id = <span class="number">8592</span></span><br><span class="line">child <span class="number">8585</span> <span class="built_in">exit</span> with <span class="number">0</span></span><br><span class="line">child <span class="number">8586</span> <span class="built_in">exit</span> with <span class="number">1</span></span><br><span class="line">child <span class="number">8587</span> <span class="built_in">exit</span> with <span class="number">2</span></span><br><span class="line">child <span class="number">8588</span> <span class="built_in">exit</span> with <span class="number">3</span></span><br><span class="line">child <span class="number">8589</span> <span class="built_in">exit</span> with <span class="number">4</span></span><br><span class="line">child <span class="number">8590</span> <span class="built_in">exit</span> with <span class="number">5</span></span><br><span class="line">child <span class="number">8591</span> <span class="built_in">exit</span> with <span class="number">6</span></span><br><span class="line">child <span class="number">8592</span> <span class="built_in">exit</span> with <span class="number">7</span></span><br><span class="line">child <span class="number">8593</span> <span class="built_in">exit</span> with <span class="number">8</span></span><br><span class="line">child <span class="number">8594</span> <span class="built_in">exit</span> with <span class="number">9</span></span><br><span class="line">^C</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>忽略了SIGCHLD信号之后，子进程不必再手动wait回收获取信息，也没有残余资源。所以，如果不需要子进程的信息的话，应该直接忽略SIGCHLD信号。</li>
<li>如果要忽略SIGCHLD信号，需直接写出signal(SIGCHLD,SIG_IGN)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>)&#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;my child is %d\n&quot;</span>,pid);</span><br><span class="line"></span><br><span class="line">    signal(SIGCHLD,SIG_IGN);    <span class="comment">//  忽略 SIGCHLD</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> child = waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">-1</span> &amp;&amp; errno == ECHILD)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGCHLD is connected with waitpid\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))&#123;                  <span class="comment">//  true  &lt;---&gt;  child process return  /  exit</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status %d\n&quot;</span>,child,WEXITSTATUS(status));    <span class="comment">//  return the exist status of a normally exit process       </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>,child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/csapp_try/process$ ./sigchld_wait </span><br><span class="line">my child is <span class="number">125233</span></span><br><span class="line">SIGCHLD is connected with waitpid</span><br><span class="line"></span><br><span class="line">$ ps ajx</span><br><span class="line"><span class="number">123968</span> <span class="number">124077</span> <span class="number">124077</span> <span class="number">124077</span> pts/<span class="number">9</span>    <span class="number">125232</span> Ss    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> /bin/bash</span><br><span class="line"><span class="number">123754</span> <span class="number">125153</span> <span class="number">123754</span> <span class="number">123754</span> ?            <span class="number">-1</span> S     <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> sleep <span class="number">180</span></span><br><span class="line"><span class="number">124077</span> <span class="number">125232</span> <span class="number">125232</span> <span class="number">124077</span> pts/<span class="number">9</span>    <span class="number">125232</span> S+    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> ./sigchld_wait</span><br><span class="line"><span class="number">125232</span> <span class="number">125233</span> <span class="number">125232</span> <span class="number">124077</span> pts/<span class="number">9</span>    <span class="number">125232</span> S+    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> ./sigchld_wait</span><br><span class="line"><span class="number">116918</span> <span class="number">125255</span> <span class="number">125255</span> <span class="number">116918</span> pts/<span class="number">1</span>    <span class="number">125255</span> R+    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> ps ajx</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/csapp_try/process$ ps ajx</span><br><span class="line">  PPID    PID   PGID    SID TTY       TPGID STAT   UID   TIME COMMAND</span><br><span class="line">    <span class="number">0</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span> ?            <span class="number">-1</span> Ss       <span class="number">0</span>   <span class="number">1</span>:<span class="number">17</span> /sbin/init splash</span><br><span class="line"><span class="number">123754</span> <span class="number">125153</span> <span class="number">123754</span> <span class="number">123754</span> ?            <span class="number">-1</span> S     <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> sleep <span class="number">180</span></span><br><span class="line"><span class="number">124077</span> <span class="number">125232</span> <span class="number">125232</span> <span class="number">124077</span> pts/<span class="number">9</span>    <span class="number">125232</span> S+    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> ./sigchld_wait</span><br><span class="line"><span class="number">116918</span> <span class="number">125267</span> <span class="number">125267</span> <span class="number">116918</span> pts/<span class="number">1</span>    <span class="number">125267</span> R+    <span class="number">1000</span>   <span class="number">0</span>:<span class="number">00</span> ps ajx</span><br></pre></td></tr></table></figure></li>
</ul>
<p>waitpid函数里面是怎么实现的呀？我觉得是先判断有没有已经死去的子进程，没有则阻塞，再等待SIGCHLD信号触发SIGCHLD的信号处理程序，处理信号 获取进程信息？</p>
<h3 id="wait-a-signal-to-be-caught-等待（任意）一个信号"><a href="#wait-a-signal-to-be-caught-等待（任意）一个信号" class="headerlink" title="wait a signal to be caught 等待（任意）一个信号"></a>wait a signal to be caught 等待（任意）一个信号</h3><ul>
<li>Waiting for a signal to be caught<ul>
<li>The following system calls suspend execution of the calling process or thread until a signal is caught (or an unhandled signal terminates the process):</li>
<li><strong>pause</strong>(2)        Suspends execution until any signal is caught.</li>
<li><strong>sigsuspend</strong>(2)   Temporarily changes the signal mask (see below) and suspends execution until one of the unmasked signals is caught.</li>
</ul>
</li>
</ul>
<h3 id="Signal-mask-and-pending-signals"><a href="#Signal-mask-and-pending-signals" class="headerlink" title="Signal mask and pending signals"></a>Signal mask and pending signals</h3><ul>
<li>Signal mask and pending signals<ul>
<li><strong>Blocked阻塞</strong> : A signal may be <strong>blocked</strong>, which means that it will <strong>not be delivered</strong> until it is later unblocked.  <ul>
<li>not be delivered – 没有递送到 — 没被process处理</li>
</ul>
</li>
<li><strong>pending 没处理</strong> : Between the time when it is generated and when it is delivered a  signal is said to be <strong>pending</strong>.</li>
<li>**signal mask ** : Each  thread  in  a process has an independent <strong>signal mask</strong>, which indicates the set of signals that the thread is <strong>currently blocking</strong>.<ul>
<li>signal mask 就是当前的 block set  </li>
<li><strong>sigprocmask</strong> : A thread can manipulate its signal mask using pthread_sigmask(3).  In a traditional single-threaded application, <strong>sigprocmask</strong>(2) can be used to manipulate the signal mask.</li>
<li><strong>fork and signal mask</strong> : A child created via fork(2) <strong>inherits a copy of its parent’s signal mask</strong>; the signal mask is preserved across execve(2).</li>
</ul>
</li>
<li><strong>which to deliver signal</strong> : A signal may be generated (and thus pending) for a process as a whole (e.g., when sent using kill(2)) or for a specific thread (e.g., certain signals,  such  as  SIGSEGV and  SIGFPE,  generated  as  a  consequence  of executing a specific machine-language instruction are thread directed, as are signals targeted at a specific thread using pthread_kill(3)).  A process-directed signal may be delivered to <strong>any one of</strong> the threads that <strong>does not currently have the signal blocked</strong>.  If more than one of the threads has the signal unblocked, then the kernel chooses an arbitrary thread to which to deliver the signal.</li>
<li>A thread can obtain the set of signals that it currently has pending using sigpending(2).  This set will consist of the union of the set of pending process-directed signals and the set of signals pending for the calling thread.</li>
<li><strong>fork and pending set</strong> : A child created via fork(2) initially has an <strong>empty pending signal set</strong>; the pending signal set is preserved across an execve(2).</li>
</ul>
</li>
</ul>
<h3 id="阻塞、解除阻塞-sigprocmask"><a href="#阻塞、解除阻塞-sigprocmask" class="headerlink" title="阻塞、解除阻塞 sigprocmask"></a>阻塞、解除阻塞 sigprocmask</h3><ul>
<li><strong>sigprocmask DESCRIPTION</strong><ul>
<li>sigprocmask()  is  used  to fetch and/or change the <strong>signal mask</strong> of the calling thread.  </li>
<li>The <strong>signal mask</strong> is the set of signals whose delivery is <strong>currently blocked for the caller</strong> (see also signal(7) for more details).</li>
<li>The behavior of the call is dependent on the value of how, as follows.</li>
</ul>
</li>
</ul>
<ul>
<li><p>隐式阻塞：<strong>内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。</strong></p>
<ul>
<li>eg:    A    SIGINT    handler    can’t    be    interrupted    by    another    SIGINT</li>
</ul>
</li>
<li><p>显示阻塞：<strong>sigprocmask</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how,<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,sigset *oldset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;     </span><br><span class="line">  <span class="comment">//  create empty set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">  <span class="comment">//  add every signal number to set </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;</span><br><span class="line">  <span class="comment">//  add signal number to set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;</span><br><span class="line">  <span class="comment">//  delete signal number from set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>int sigprocmask(int how,const sigset_t *set,sigset *oldset);</p>
<ul>
<li>改变当前阻塞的信号集合</li>
<li>how = SIG_BLOCK：blocked = blocked | set</li>
<li>how = SIG_UNBLOCK：blocked = blocked &amp; (~set)</li>
<li>how = SIG_SETMASK：blockded = set</li>
<li>oldset = prev_mask;</li>
</ul>
</li>
<li><p>例子：如何阻塞SIGINT信号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> mask,prev_mask;</span><br><span class="line"></span><br><span class="line">sigemptyset(&amp;mask);       <span class="comment">//  mask = null</span></span><br><span class="line">sigaddset(&amp;mask,SIGINT);  <span class="comment">//  mask = mask | SIGINT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  blocked sigint and save previous blocked set</span></span><br><span class="line">sigprocmask(SIG_BLOCK,&amp;mask,&amp;prev_mask);</span><br><span class="line"><span class="comment">//...  Code region that will not be interrupted by SIGINT</span></span><br><span class="line"><span class="comment">//  **restore previous blocked set , unblocking SIGINT**</span></span><br><span class="line">sigprocmask(SIG_SETMASK,&amp;prev_mask,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Safe-Signal-Handling-信号处理程序注意"><a href="#Safe-Signal-Handling-信号处理程序注意" class="headerlink" title="Safe    Signal    Handling 信号处理程序注意"></a>Safe    Signal    Handling 信号处理程序注意</h3><ul>
<li>棘手<ul>
<li>signal handler 和 main program concurrently 运行，sharing data structures 共享全局变量，可能互相干扰</li>
<li>如何以及何时接收信号</li>
<li>不通过的系统有不同的信号处理语义</li>
</ul>
</li>
</ul>
<h4 id="Guidlines-for-Writing-Safe-Handlers-CSAPP-P534"><a href="#Guidlines-for-Writing-Safe-Handlers-CSAPP-P534" class="headerlink" title="Guidlines for Writing Safe Handlers CSAPP P534"></a>Guidlines for Writing Safe Handlers CSAPP P534</h4><ul>
<li><p><strong>G0:    Keep    your    handlers    as    simple    as    possible</strong>    </p>
<ul>
<li>e.g.,    Set    a    global    flag    and    return    </li>
</ul>
</li>
<li><p><strong>G1:    Call    only    async-signal-safe    functions    in    your    handlers</strong>    </p>
<ul>
<li>printf, sprintf, malloc,    and    exit    are    not    safe!</li>
<li>write is safe    </li>
</ul>
</li>
<li><p><strong>G2:    Save    and    restore    errno    on    entry    and    exit</strong></p>
<ul>
<li>So    that    other    handlers    don’t    overwrite    your    value    of    errno</li>
</ul>
</li>
<li><p><strong>G3:    Protect    accesses    to    shared    data    structures    by temporarily    blocking    all    signals</strong>.        </p>
<ul>
<li>To    prevent    possible    corruption<ul>
<li>从主程序访问一个data structure 需要一系列指令，如果指令序列被访问d的处理程序中断，那么前后d的状态不一致，可能会导致不可预知的结果    </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>G4:</strong>    Declare    global    variables    as    <strong>volatile</strong> </p>
<ul>
<li><strong>To    prevent    compiler    from    storing    them    in    a    register</strong></li>
</ul>
</li>
<li><p><strong>G5:    Declare    global    flags    as    volatile sig_atomic_t</strong></p>
<ul>
<li>flag:    variable    that    is    only    read    or    wriien    not incremented or updated(e.g.    flag    =    1,    not    flag++)    </li>
<li>if we do that then teh system guarantees that reads and writen to that variable will be atmoic</li>
<li>So if Flag    declared    this    way    does    not    need    to    be    protected        like    other    globals</li>
</ul>
</li>
<li><p><strong>不可以用信号来对其他进程中发生的事件计数。</strong></p>
</li>
</ul>
<h4 id="Async-Signal-Safety-异步信号安全"><a href="#Async-Signal-Safety-异步信号安全" class="headerlink" title="Async-Signal-Safety 异步信号安全"></a>Async-Signal-Safety 异步信号安全</h4><ul>
<li>function : <strong>async signal safety 异步信号安全</strong><ul>
<li>printf就不是异步信号安全的，printf获得一个terminal的锁。</li>
<li>如下，main和handler里面都调用print，造成了deadlock<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;  <span class="comment">//  handler INT</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//  lock aquire ? </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hi\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//  terminal lock   </span></span><br><span class="line">    printd(<span class="string">&quot;hello\n&quot;</span>);        <span class="comment">//  被信号打断，进入handler。handler里的printf还想获得锁，但是显然不可。死锁等待。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write是异步信号安全的</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Function    is    async-signal-safe    if    either    reentrant    (e.g.,    all    variables    stored    on    stack    frame,    CS:APP3e    12.7.2)    or    non-interruptible    by    signals.    </li>
<li>Posix    guarantees    117    functions    to    be    async-signal-safe    <ul>
<li>Source:    “man 7 signal”    </li>
<li>Popular    functions    on    the    list:    <ul>
<li>_exit, write, wait, waitpid, sleep, kill </li>
</ul>
</li>
<li>Popular    functions    that    are    not    on    the    list:    <ul>
<li>printf,        sprintf, malloc, exit </li>
<li>Unfortunate    fact:    write    is    the    only    async-signal-safe    output    function</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Portable-Signal-Handling"><a href="#Portable-Signal-Handling" class="headerlink" title="Portable    Signal    Handling"></a>Portable    Signal    Handling</h4><ul>
<li>Ugh!    Different    versions    of    Unix    can    have    different    signal    handling    semantics<ul>
<li>Some    older    systems    restore    action    to    default    after    catching    signal    </li>
<li>Some    interrupted    system    calls    can    return    with    errno    ==    EINTR    (慢速系统调用被中断)</li>
<li>Some    systems    don’t    block    signals    of    the    type    being    handled    </li>
</ul>
</li>
<li> Solution:    sigaction<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="title">handler_t</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="number">151</span> <span class="comment">/* $begin sigaction */</span></span><br><span class="line"><span class="number">152</span> <span class="function"><span class="keyword">handler_t</span> *<span class="title">Signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">handler_t</span> *handler)</span></span></span><br><span class="line"><span class="function">153 </span>&#123;</span><br><span class="line"><span class="number">154</span>     <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line"><span class="number">155</span> </span><br><span class="line"><span class="number">156</span>     action.sa_handler = handler;  <span class="comment">//  指明处理函数  </span></span><br><span class="line"><span class="number">157</span>     sigemptyset(&amp;action.sa_mask); <span class="comment">/* Block sigs of type being handled */</span>  <span class="comment">//  解决有的系统不block正在被处理的信号</span></span><br><span class="line"><span class="number">158</span>     action.sa_flags = SA_RESTART; <span class="comment">/* Restart syscalls if possible */</span>  <span class="comment">//  解决慢速系统调用被中断</span></span><br><span class="line"><span class="number">159</span> </span><br><span class="line"><span class="number">160</span>     <span class="keyword">if</span> (sigaction(signum, &amp;action, &amp;old_action) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">161</span>         unix_error(<span class="string">&quot;Signal error&quot;</span>);</span><br><span class="line"><span class="number">162</span>     <span class="keyword">return</span> (old_action.sa_handler);</span><br><span class="line"><span class="number">163</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Synchronizing-Flow-to-Avoid-Races"><a href="#Synchronizing-Flow-to-Avoid-Races" class="headerlink" title="Synchronizing Flow to Avoid Races"></a>Synchronizing Flow to Avoid Races</h4><ul>
<li><p><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-14-37-43.png"></p>
</li>
<li><p><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-14-38-08.png"></p>
</li>
<li><p><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-14-49-31.png"></p>
</li>
</ul>
<h4 id="Explicitly-Waiting-for-Signals"><a href="#Explicitly-Waiting-for-Signals" class="headerlink" title="Explicitly    Waiting    for    Signals"></a>Explicitly    Waiting    for    Signals</h4><ul>
<li><p>Handlers    for    program    explicitly    waiting    for    SIGCHLD    to    arrive</p>
<ul>
<li><strong>while(!pid)</strong> 通过共享的全局变量global</li>
<li><strong>correct! but wasteful!</strong><br><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-15-11-50.png"><br><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-15-12-03.png"></li>
</ul>
</li>
<li><p>Other    options:</p>
<ul>
<li>RACE！不可这样，可能导致一直卡在pause();    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!pid)</span><br><span class="line">  <span class="comment">//  如果在这里 接收了信号 hanlder处理了signal 改变了pid</span></span><br><span class="line">  <span class="comment">//  但是之后pause不会再被唤醒 因为没信号了。</span></span><br><span class="line">  pause();</span><br></pre></td></tr></table></figure></li>
<li>TOO SLOW！<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!pid)</span><br><span class="line">  sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Solution : sigsuspend</p>
</li>
</ul>
<h4 id="Waiting-for-Signals-with-sigsuspend"><a href="#Waiting-for-Signals-with-sigsuspend" class="headerlink" title="Waiting    for    Signals    with    sigsuspend"></a>Waiting    for    Signals    with    sigsuspend</h4><ul>
<li>sigsuspend：等待任意一个信号到来<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>;</span><br></pre></td></tr></table></figure>
<img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-15-33-49.png"><ul>
<li>DESCRIPTION<ul>
<li>sigsuspend()  temporarily  <strong>replaces</strong>  the  signal  mask  of the calling process with the mask given by mask and then <strong>suspends</strong> the process <strong>until delivery of a signal</strong> whose action is to invoke a signal handler or to terminate a process.</li>
<li>If the signal terminates the process, then sigsuspend() does not return.  If the signal is caught, then sigsuspend() returns after the signal handler  returns,  and  the signal mask is restored to the state before the call to sigsuspend().</li>
<li>It is not possible to block SIGKILL or SIGSTOP; specifying these signals in mask, has no effect on the process’s signal mask.</li>
</ul>
</li>
</ul>
</li>
<li>在不消耗性能的情况下，实现Explicitly    Waiting    for    Signal<br><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-20-15-38-34.png"></li>
</ul>
<h3 id="小结-内核让进程p接收信号流程"><a href="#小结-内核让进程p接收信号流程" class="headerlink" title="小结 内核让进程p接收信号流程"></a>小结 内核让进程p接收信号流程</h3><ul>
<li><p>内核为每个进程p维护两个向量</p>
<ul>
<li>一个是 pending   —-  待处理信号的集合 </li>
<li>另一个是 blocked —-  当前阻塞的信号集合</li>
</ul>
</li>
<li><p>未被阻塞的待处理信号的集合：pending &amp; ~blocked（进程p需要接收的信号）</p>
</li>
<li><p>何时会有内核检查p的pending &amp; ~blocked的契机</p>
<ul>
<li>内核把进程p从内核切换到用户模式</li>
</ul>
</li>
</ul>
<ul>
<li>一个signal发送给进程p时<ul>
<li>p先将该信号加入pending向量中 因为仅仅是向量，所以并不支持排队</li>
<li>然后看该信号是否被blocked（blocked集合中该信号是否置为1<ul>
<li>被blocked，则进程p不进行相应的signal handler。pending中保持该signal为1，直到相应signal handler被调用。<ul>
<li>当该signal不再被blocked时，pending中该signal又为1，故p会接收该signal（触发相应handler）</li>
</ul>
</li>
<li>没被blocked，则进程p触发相应的signal handler。pending中该signal归0，blocked向量中加入该信号，直到相应的signal handler执行完毕，blocked向量中移除该信号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CSAPP-540-546"><a href="#CSAPP-540-546" class="headerlink" title="CSAPP 540-546"></a>CSAPP 540-546</h3><ul>
<li>同步流</li>
<li>显示竞争</li>
</ul>
<h2 id="Nonlocal-jump"><a href="#Nonlocal-jump" class="headerlink" title="Nonlocal    jump"></a>Nonlocal    jump</h2><ul>
<li>非本地跳转<strong>Nonlocal jump</strong><ul>
<li>用户级的异常控制流形式</li>
<li>通过<strong>setjmp,longjmp</strong></li>
<li>不需要经过正常的call-ret返回序列</li>
<li><strong>应用</strong>：<ul>
<li><ol>
<li>从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。可以直接返回到一个普通的错误处理程序，而非费力地解开调用栈，</li>
</ol>
</li>
<li><ol start="2">
<li>使得一个信号处理程序将控制传递到一个指定的代码位置，而非一定返回到被信号中断了的位置</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>C++中的catch  &lt;—&gt;  C中的setjmp</li>
<li>C++中的throw  &lt;—&gt;  C中的longjmp</li>
</ul>
<h3 id="setjmp"><a href="#setjmp" class="headerlink" title="setjmp"></a>setjmp</h3><ul>
<li><strong>int setjmp(jmp_buf env)</strong> <ul>
<li>功能：指明之后的longjmp返回的位置<ul>
<li>在env缓冲区保存当前调用环境：PC、stack pointer、通用目的寄存器。</li>
<li>必须在longjmp之前调用</li>
<li><strong>Called    once,    returns    one    or    more    times</strong></li>
<li>return 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="longjmp"><a href="#longjmp" class="headerlink" title="longjmp"></a>longjmp</h3><ul>
<li><strong>void longjmp(jmp_buf env,int retval)</strong><ul>
<li>功能：<strong>触发一个</strong> 从最近一次初始化env的 <strong>setjmp</strong> <strong>的返回</strong><ul>
<li>从env缓冲区中恢复调用环境，进而触发一个从最近一次初始化env的setjmp调用的返回，然后setjmp返回，并带有非0的返回值retval</li>
<li>在setjmp之后调用。</li>
<li><strong>called once , but never returns</strong></li>
<li>Set    %eax (the    return    value)    to    retval</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>应用2：软中断<br><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-12-18-38-49.png"></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2022/07/27/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%812/2022-08-12-18-43-14.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux上进程的五种状态：</span><br><span class="line"></span><br><span class="line">1.R——Runnable（运行）：正在运行或在运行队列中等待</span><br><span class="line"></span><br><span class="line">2.S——sleeping（中断）：休眠中，受阻，在等待某个条件的形成或接收到信号</span><br><span class="line"></span><br><span class="line">3.D——uninterruptible sleep(不可中断)：收到信号不唤醒和不可运行，进程必须等待直到有中断发生</span><br><span class="line"></span><br><span class="line">4.Z——zombie（僵死）：进程已终止，但进程描述还在，直到父进程调用wait4()系统调用后释放</span><br><span class="line"></span><br><span class="line">5.T——traced or stoppd(停止)：进程收到SiGSTOP,SIGSTP,SIGTOU信号后停止运行</span><br><span class="line"></span><br><span class="line">状态后缀表示：</span><br><span class="line"></span><br><span class="line">&lt;：优先级高的进程</span><br><span class="line"></span><br><span class="line">N：优先级低的进程</span><br><span class="line"></span><br><span class="line">L：有些页被锁进内存</span><br><span class="line"></span><br><span class="line">s：进程的领导者（在它之下有子进程）</span><br><span class="line"></span><br><span class="line">l：ismulti-threaded (using CLONE_THREAD, like NPTL pthreads <span class="keyword">do</span>)</span><br><span class="line"></span><br><span class="line">+：位于后台的进程组</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp-8-异常控制流</title>
    <url>/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/</url>
    <content><![CDATA[<p>Exceptional Control Flow:<br>Exceptions and Processes</p>
<ul>
<li>异常<br>异常控制流类型：从硬件到软件都有，Execption、Context Switching、Signal、NonLocal Jump。<br>异常处理流程、异常四种类型：中断、故障、陷阱、终止</li>
</ul>
<ul>
<li>进程<br>进程 —&gt; 不同进程需上下文切换  —-&gt; 进入内核模式  —-&gt; 依赖于 异常的机制<br>进程调度流程 –&gt; 0123<br>并发概念<br>如何从用户模式到内核模式 –&gt; 通过异常 控制传递给处理程序时，会设置模式位。</li>
</ul>
<ul>
<li>进程控制<br>API：getpid、fork、waitpid、wait、sleep、execve、fork和execve区别<br>SHELL：fork and execve</li>
</ul>
<span id="more"></span>



<h2 id="Exceptional-Control-Flow（ECF）"><a href="#Exceptional-Control-Flow（ECF）" class="headerlink" title="Exceptional Control Flow（ECF）"></a>Exceptional Control Flow（ECF）</h2><ul>
<li><p>Processors do only one thing</p>
<ul>
<li>从给（处理器）processors加电开始，直到断电，CPU只是读取并执行一序列的指令，每次执行一条指令。</li>
</ul>
</li>
<li><p>程序计数器假设一个值的序列：a0,a1,…,an-1。其中，每个ak是某个相应指令Ik的地址。</p>
</li>
<li><p>控制转移（control transfer）：每次从ak到ak+1的过渡称为控制转移。</p>
</li>
<li><p><strong>控制流（control flow）</strong>：这样的控制转移序列叫做处理器的控制流。<br>  <img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-10-38-23.png"></p>
</li>
<li><p>突变：最简单的控制流是一个“平滑”序列，即Ik和Ik+1在内存中相邻。当Ik和Ik+1不相邻时，即为突变。</p>
</li>
<li><p><strong>控制流突变的机制</strong></p>
<ul>
<li>跳转：jumps and branches</li>
<li>调用及返回：call and return</li>
<li>这两种机制是对由程序变量表示的<strong>内部程序状态中的变化</strong>作出反应。即 <strong>react to changes in program state</strong></li>
</ul>
</li>
<li><p>但是这两个机制无法对系统状态的变化作出反应。<strong>difficult to react changes in system state</strong>。</p>
<ul>
<li>这些系统状态不是被内部程序变量捕获的，且也不一定要和程序的执行相关。如</li>
<li>从磁盘或者网络适配器来的数据</li>
<li>除0</li>
<li>键盘的ctrl + c</li>
<li>硬件定时器定期产生信号</li>
</ul>
</li>
<li><p><strong>异常控制流（Exceptional Control Flow，ECF）</strong>：现代系统使控制流发生突变来对上述这类情况（也即<strong>system state</strong>）作出反应，这种突变一般称为异常控制流。</p>
</li>
<li><p>异常控制流存在于计算机系统的各个层次</p>
<ul>
<li><strong>硬件层</strong>（low level mechanisms）<ul>
<li><strong>Exceptions 异常</strong><ul>
<li>Changes in control flow    in    response to    a    system event</li>
<li>通过硬件和os协作实现</li>
</ul>
</li>
</ul>
</li>
<li>以下是Higher level mechanisms</li>
<li><strong>操作系统层</strong><ul>
<li><strong>Process context switch 进程上下文切换</strong><ul>
<li>内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。</li>
<li>通过os和硬件协作实现</li>
</ul>
</li>
</ul>
</li>
<li><strong>应用层</strong><ul>
<li><strong>Signal 信号</strong><ul>
<li>一个进程可以发送信号到另一个进程，而接收者会将控制转移到它的一个信号处理程序。</li>
<li>os实现</li>
</ul>
</li>
<li><strong>Nonlocal jumps</strong>：setjump() and longjump()<ul>
<li>通过setjump() and longjump()回避通常的栈规则。</li>
<li>C runtime library实现</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Exceptions-异常"><a href="#Exceptions-异常" class="headerlink" title="Exceptions 异常"></a>Exceptions 异常</h2><ul>
<li><p>异常：控制流中的突变，用来响应处理器状态中的某些变化。</p>
<ul>
<li>异常控制流的一种形式</li>
<li>由硬件和os实现。</li>
</ul>
</li>
<li><p><strong>异常流程</strong>：</p>
<ul>
<li>任何情况下，当处理器检测到有事件发生时，他就会通过一张跳转表：<strong>异常表</strong>（exceptional table），进行一个间接过程调用（异常），<strong>控制转移到异常处理程序</strong>（exception handler）。当异常处理程序完成后，根据引起异常的事件的类型，将<strong>控制返回</strong>。关于返回，如下<ul>
<li>处理程序将控制返回给当前指令I_curr，即当实现发生时正在执行的指令</li>
<li>return to I_next</li>
<li>处理程序终止被中断的程序</li>
</ul>
</li>
<li>关键词：事件发生、异常表、控制转移、异常处理程序、控制返回。<br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-12-43-20.png"></li>
<li>其中异常中的事件<ul>
<li>可能和当前指令的执行相关：如虚拟内存却也，算术溢出，除0</li>
<li>也可能无关：如系统定时器产生一个信号或者IO请求完成</li>
</ul>
</li>
</ul>
</li>
<li><p>异常exception类似于过程调用call，但也有重要的不同之处。</p>
<ul>
<li><ol>
<li>ret addr</li>
</ol>
<ul>
<li>call：在跳转到目标过程前，会先将返回地址push入栈。</li>
<li>exception：根据异常的类型，处理成序结束后返回到当前指令/下一条指令。</li>
</ul>
</li>
<li><ol start="2">
<li>exception：处理器会把额外的处理器状态压入栈中，处理程序返回时，重新执行被中断的程序需要这些指令。</li>
</ol>
</li>
<li><ol start="4">
<li>exception：<strong>完全运行在内核模式</strong>下，也即它们对所有的系统资源都有完全访问权限</li>
</ol>
</li>
</ul>
</li>
<li><p>一旦硬件触发了异常，剩下的工作就是由异常处理成须在软件中完成.</p>
</li>
<li><p>异常处理完之后如何返回：</p>
<ul>
<li>在处理成须处理完事件之后，它通过执行一条特殊的从中断返回的指令可选地返回到被中断的程序，<ul>
<li>该指令将适当的状态弹回到处理器的控制和数据寄存器中，</li>
<li>如果异常中断的是一个用户程序，就将<strong>状态恢复为用户模式</strong>，</li>
<li>然后将控股之返回给被中断的程序。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Exception-tables"><a href="#Exception-tables" class="headerlink" title="Exception tables"></a>Exception tables</h3><ul>
<li>每种类型的异常都分配了一个唯一的非负整数的异常号。<ul>
<li>一些号码由处理器的设计者分配：除0、缺页、内存访问违例、断点、算数运算溢出</li>
<li>一些由操作系统内核的设计者分配：系统调用以及来自外部IO设备的信号</li>
</ul>
</li>
</ul>
<p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-19-19-39.png"></p>
<ul>
<li>异常表中存储的是异常号k以及相应的code for exception handler k的地址</li>
<li>当每次异常k发生时，会调用异常处理程序k。(处理器通过异常表的表目k 转到相应的处理程序)</li>
<li>如何生成exception handler k的地址<br>  <img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-19-27-40.png"></li>
</ul>
<h3 id="Cateories-Of-Exception"><a href="#Cateories-Of-Exception" class="headerlink" title="Cateories Of Exception"></a>Cateories Of Exception</h3><p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-19-47-45.png"></p>
<ul>
<li><strong>中断（interrupt）、陷阱（trap）、故障（fault）、终止（abort）</strong></li>
<li>异步：中断</li>
<li>同步：陷阱、故障、终止。这类指令称之为故障指令<ul>
<li>由执行一条指令而造成的事件所引发的异常。</li>
</ul>
</li>
</ul>
<h4 id="异常示例"><a href="#异常示例" class="headerlink" title="异常示例"></a>异常示例</h4><ul>
<li><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-22-10-15.png"></li>
<li><strong>除法错误</strong>：除0，Linux shell报告为 <strong>Floating Exception</strong></li>
<li><strong>一般保护故障</strong>：许多原因。通常是因为一个程序引用了一个<strong>未定义</strong>的虚拟内存区域，或者因为程序试图<strong>写只读</strong>的文本段。报告为<strong>Segmentation fault</strong></li>
<li><strong>缺页</strong>：异常处理程序将适当的磁盘上的虚拟内存的一个页面映射到物理内存的一个页面。然后重新执行这条产生故障的指令。</li>
<li><strong>机器检查</strong>：致命硬件错误。机器检查处理程序曾布返回控制给应用程序</li>
</ul>
<h4 id="Asychronous-Exceptions-异步异常"><a href="#Asychronous-Exceptions-异步异常" class="headerlink" title="Asychronous Exceptions 异步异常"></a>Asychronous Exceptions 异步异常</h4><h5 id="Interrupts-中断"><a href="#Interrupts-中断" class="headerlink" title="Interrupts 中断"></a>Interrupts 中断</h5><ul>
<li><strong>中断</strong><ul>
<li><strong>异步</strong>发生（硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的）</li>
<li>是来自<strong>外部IO设备的信号的结果</strong>(Indicated    by    setting    the    processor’s    interrupt    pin)</li>
<li><strong>返回到下一条指令</strong></li>
<li>硬件中断的异常处理程序称为<strong>中断处理程序</strong></li>
</ul>
</li>
<li><strong>中断处理</strong><br>  <img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-21-32-53.png"><ul>
<li>中断处理的结果：程序继续执行，就好像没发生过中断一样。</li>
</ul>
</li>
<li>Examples:    <ul>
<li>Timer    interrupt    <ul>
<li>Every    few    ms,    an    external    timer    chip    triggers    an    interrupt    </li>
<li>Used    by    the    kernel    to    take    back    control    from    user    programs    </li>
</ul>
</li>
<li>I/O    interrupt    from    external    device    <ul>
<li>Hitting    Ctrl-C    at    the    keyboard    </li>
<li>Arrival    of    a    packet    from    a    network    </li>
<li>Arrival    of    data    from    a    disk</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Synchronous-Exceptions-同步异常"><a href="#Synchronous-Exceptions-同步异常" class="headerlink" title="Synchronous Exceptions 同步异常"></a>Synchronous Exceptions 同步异常</h4><h5 id="Trap-陷阱-gt-System-Calls-系统调用"><a href="#Trap-陷阱-gt-System-Calls-系统调用" class="headerlink" title="Trap 陷阱 -&gt; System Calls 系统调用"></a>Trap 陷阱 -&gt; System Calls 系统调用</h5><ul>
<li><p><strong>陷阱</strong></p>
<ul>
<li>是<strong>有意</strong>的异常</li>
<li><strong>返回到下一条指令</strong></li>
<li>Examples：<strong>system calls</strong>，breakpoint traps，special instructions</li>
<li>陷阱最重要的用途：在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用 system call</strong></li>
<li>陷阱的异常处理程序称为陷阱处理程序</li>
</ul>
</li>
<li><p>syscall n：当用户程序想要请求内核的服务n时，可以执行这条指令。</p>
<ul>
<li>陷阱指令：syscall</li>
<li>执行<strong>syscall</strong>会<strong>导致</strong>一个到异常处理程序的<strong>陷阱</strong></li>
<li>这个处理程序解析参数，并调用适当的内核程序。</li>
</ul>
</li>
<li><p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-21-35-06.png"></p>
</li>
<li><p>syscall 是 64位系统 中断 的指令</p>
</li>
<li><p>int0x80 是 32位系统 中断 的指令<br><a href="https://cloud.tencent.com/developer/article/1492374">https://cloud.tencent.com/developer/article/1492374</a><br><a href="https://blog.csdn.net/weixin_43363675/article/details/117944212">https://blog.csdn.net/weixin_43363675/article/details/117944212</a></p>
</li>
</ul>
<h6 id="System-Call-Example"><a href="#System-Call-Example" class="headerlink" title="System Call Example"></a>System Call Example</h6><ul>
<li><p>每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。<br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-21-21-16.png"></p>
</li>
<li><p>系统级函数：C中的syscall可以直接调用任何系统调用，但我们没必要，因为C库提供了包装函数。我们将系统调用及其相关的包装函数，称为系统级函数。<br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-21-27-27.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-27-21-31-00.png"></p>
</li>
<li><p>C中的syscall库函数 #include&lt;sys/syscall&gt;</p>
<ul>
<li>调用系统调用，该系统调用的汇编语言接口具有指定的带指定参数的数字</li>
<li>例如：当调用C库中没有包装函数的系统调用时，使用syscall()非常有用。<ul>
<li>如有一个函数gettid()可以得到线程的真正PID，但glibc并没有实现该函数，只能通过Linux的系统调用syscall来获取</li>
<li>```c++<br>tid = syscall(SYS_gettid);<br>printf(“tid:%d\n”,tid); <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  - syscall()在进行系统调用之前保存CPU寄存器，从系统调用返回时恢复寄存器，如果发生错误，将系统调用返回的任何错误代码存储在errno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### Fault 故障</span><br><span class="line"></span><br><span class="line">- **故障**</span><br><span class="line">  - 不是故意的，由错误情况引起，可能被故障处理程序修正。 </span><br><span class="line">  - **可能返回到当前指令，也有可能终止**。</span><br><span class="line">    - 修正了则返回到当前指令，重新执行。</span><br><span class="line">    - 没修正则返回到内核的abort例程。</span><br><span class="line">![](csapp-8-异常控制流1/2022-07-27-21-50-51.png)</span><br><span class="line"></span><br><span class="line">- 经典例子：**Page Fault 缺页异常**</span><br><span class="line">  - 当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。</span><br><span class="line">  - 缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。</span><br><span class="line">  - 当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。</span><br><span class="line">  - ![](csapp-8-异常控制流1/2022-07-27-22-10-55.png)</span><br><span class="line">- 例子2：一般保护故障![](csapp-8-异常控制流1/2022-07-27-22-11-19.png)</span><br><span class="line"></span><br><span class="line">##### Abort 终止</span><br><span class="line">- 不是故意的，且不可修正的。是致命错误造成的结果，通常是一些硬件错误。</span><br><span class="line">![](csapp-8-异常控制流1/2022-07-27-22-07-40.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Processes 进程</span><br><span class="line"></span><br><span class="line">- 异常是允许os内核提供进程概念的基本构造块。</span><br><span class="line">- 经典定义：**一个执行中程序的实例**。</span><br><span class="line">  - 系统中的每个程序都运行在某个进程的**上下文中（context）**。</span><br><span class="line">  - **上下文**是由程序正确运行所需的**状态**组成的。具体见下文</span><br><span class="line">    &lt;!-- - 存放在内存中的程序的代码和数据</span><br><span class="line">    - 栈</span><br><span class="line">    - 通用目的寄存器的内容</span><br><span class="line">    - 程序计数器</span><br><span class="line">    - 环境变量</span><br><span class="line">    - 打开的文件描述符等 --&gt;</span><br><span class="line">- 如何在shell中运行可执行文件</span><br><span class="line">  - 每次用户通过向shell输入一个可执行目标文件的名字，运行程序时，shell就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行文件。</span><br><span class="line">  - 应用程序也能够创建新进程，并在这个新进程的上下文中运行它们自己的代码或其他应用程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **os如何实现进程的细节**</span><br><span class="line">  - **上学再学**</span><br><span class="line"></span><br><span class="line">- 先关注**进程提供给应用程序的关键抽象**</span><br><span class="line">  - **Logical	control	flow	 一个独立的逻辑控制流**</span><br><span class="line">    - 它提供一个假象，好像我们的程序**独占地使用处理器(CPU)**。</span><br><span class="line">    - 通过内核提供的名为**上下文切换（context switching）**的机制实现</span><br><span class="line">      - 上下文切换：是地址空间和寄存器的变化。</span><br><span class="line">  - **Private address space   一个私有的地址空间**</span><br><span class="line">    - 它提供一个家乡，好像我们的程序**独占地使用内存系统**。（每个运行的程序都有自己的上下文，并且看不到其他运行中程序的上下文）</span><br><span class="line">    - 通过内核提供的名为**虚拟内存（virtual memory）**的机制实现</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-18-22-05.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 单核cpu 多进程</span><br><span class="line">![](csapp-8-异常控制流1/2022-08-06-18-56-44.png)</span><br><span class="line">- 单核cpu并发地执行多进程 -- Single processor executes	multiple	processes	concurrently</span><br><span class="line">  - 多个进程交织在一起  --  Process	execusions interleaved	(multitasking)		</span><br><span class="line">  - 进程地址由虚拟内存机制管理 -- Address	spaces	managed	by	virtual	memory	system	(later in	course)	</span><br><span class="line">  - 没有执行的进程的寄存器值保存在主存里 -- Register	values	for	nonexecuting	processes	saved	in	memory</span><br><span class="line"></span><br><span class="line">- **进程调度流程**</span><br><span class="line">  - **0.** Schedule next process for execution -- 决定重新开始的进程</span><br><span class="line">    - **调度 Schedule**：在进程执行的某些时刻，内核可以决定抢占当前线程，并重新开始一个先前被抢占了的进程，这种决策即为调度。</span><br><span class="line">    - 由内核中的调度器（scheduler）处理</span><br><span class="line">  - **1.** 保存当前进程的上下文</span><br><span class="line">  - **2.** 加载该进程保存的寄存器值到cpu中，并切换到该进程的进程地址。（这就是所谓的 **上下文切换（context switch），恢复某个先前被抢占的进程被保存的上下文**）</span><br><span class="line">  - **3.** 将控制传递给这个新恢复的进程。</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-18-36-35.png)</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-18-41-40.png)</span><br><span class="line">  - 下面又写了一遍，感觉挺重要的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 多核cpu 多进程</span><br><span class="line">![](csapp-8-异常控制流1/2022-08-06-19-07-25.png)</span><br><span class="line">- Multicore	processors	</span><br><span class="line">  - Multiple	CPUs	on	single	chip	</span><br><span class="line">  - Share	main	memory	(and	some	of	the	caches) 共享主存和L3缓存	</span><br><span class="line">  - Each can	execute	a	separate	process	</span><br><span class="line">    - Scheduling	of	processors	onto	cores	done	by	kernel（进程间的切换由cpu调度。切换流程同上）	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Concurrent Process 并发进程</span><br><span class="line">- Each Progess is logical control flow -- 逻辑控制流</span><br><span class="line">- Two Processes run concurrentlay (are concurrent) if their flows overlap in time --- 如果两个进程在时间上是重叠的（宏观），那么就程这两个进程并发的运行</span><br><span class="line">  - **并发流 concurrent flow**：一个逻辑流在时间上与另一个流重叠。</span><br><span class="line">- Otherwise , they are sequential --- 否则，就称他们是连续的</span><br><span class="line">- Examples (running on signle core)</span><br><span class="line">  - （相互）并发：A和B，A和C</span><br><span class="line">  - 连续：B和C</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-19-23-17.png)</span><br><span class="line">  - **关键**：进程轮流使用处理器。每个进程执行它的流的一部分，然后被抢占（preempted）（即暂时挂起，从这里可以看出挂起的时候不占用CPU），然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，他看上去像是在独占的使用处理器。</span><br><span class="line"></span><br><span class="line">- **并发 concurrency**：多个流并发执行的一般现象。</span><br><span class="line">- **多任务 multitasking**：一个进程和其他进程轮流运行</span><br><span class="line">- **时间片 time slice**：一个进程执行它的控制流的一部分的每一时间段。因此，多任务也叫时间分片 time slicing</span><br><span class="line">- **并行流 parallel flow**：两个流并发地运行在不同的处理器核或计算机上。他们并行地运行（running in parallel），且并行地执行（parallel execution）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 私有地址空间</span><br><span class="line">- 上面所说的假象之一：**private address space**</span><br><span class="line">- 进程为每个程序提供他自己的**私有地址空间**。（n位机器的地址空间：0,1,...,(2^n)-1。）</span><br><span class="line">  - 什么叫做地址空间私有：一般，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写，</span><br><span class="line">- 每个私有地址空间相关联的内存的内容不同，但这些私有空间有相同的通用结构。（一般各个这样的地址空间互相不可见，空间中用户代码看不见内核部分的内存）</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-20-06-24.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 用户模式 内核模式</span><br><span class="line"></span><br><span class="line">- **用户模式、内核模式**</span><br><span class="line">  - 为了进程抽象，cpu提供的一种机制，来**限制一个应用可以执行的命令和可访问的地址空间范围**。</span><br><span class="line">- **模式位 mode bit**</span><br><span class="line">  - 控制寄存器中的模式位描述了**进程当前享有的特权**</span><br><span class="line">- **内核模式 / 超级用户模式**</span><br><span class="line">  - 设置了模式位</span><br><span class="line">  - 一个运行在内核模式的进程可以执行指令集中的**任何指令**</span><br><span class="line">  - 并且可以访问系统中的**任何内存位置**。</span><br><span class="line">- **用户模式**</span><br><span class="line">  - 用户模式中的进程不允许执行特权指令，如停止处理器，改变模式为，发起IO操作</span><br><span class="line">  - 不允许用户模式中的进程直接引用地址空间中内核区的代码和数据。（否则会导致致命的保护故障）；用户程序必须通过系统调用接口间接地访问内核代码和数据。</span><br><span class="line">- **用户模式变为内核模式**</span><br><span class="line">  - **唯一方法**</span><br><span class="line">  - **通过异常**：中断、故障、陷阱（系统调用）</span><br><span class="line">    - 异常发生时，控制传递到异常处理程序，</span><br><span class="line">    - **处理器设置模式位，用户模式变为内核模式。**</span><br><span class="line">    - 如前所说，异常处理程序完全运行在内核模式中</span><br><span class="line">    - 返回用户程序时，处理器将内核模式切换为用户莫斯</span><br><span class="line"></span><br><span class="line">- ***上下文切换Context Switching** 需要进入内核模式。也就需要依赖异常机制。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Context Switch 上下文切换 </span><br><span class="line"></span><br><span class="line">#### 上下文 context</span><br><span class="line"></span><br><span class="line">- 上下文切换是为了调度进程，而不是为了进入内核模式。进入内核模式是通过异常机制。</span><br><span class="line">- os内核通过**上下文切换**的机制，来实现multitasking多任务。</span><br><span class="line">- **上下文切换 Context Switch**机制建立在**异常 Exception**之上</span><br><span class="line">  - 上下文是内核重新启动一个被抢占的进程所需的状态，由一些对象的值组成。包括如下</span><br><span class="line">  - 进程上下文采用进程PCB表示。在Linux中，PCB就是task_struct</span><br><span class="line">    - 通用目的寄存器</span><br><span class="line">    - 浮点寄存器</span><br><span class="line">    - 程序计数器</span><br><span class="line">    - 用户栈</span><br><span class="line">    - 状态寄存器：new,ready,running,waiting,terminated.</span><br><span class="line">    - 内核栈</span><br><span class="line">    - 以及各种内核数据结构</span><br><span class="line">      - 描述地址空间的页表</span><br><span class="line">      - 包含当前进程信息的进程表</span><br><span class="line">      - 包含进程已打开文件信息的文件表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 调度、上下文切换</span><br><span class="line"></span><br><span class="line">- **进程调度流程**</span><br><span class="line">  - **0.** Schedule next process for execution -- 决定重新开始的进程</span><br><span class="line">    - **调度 Schedule**：在进程执行的某些时刻，内核可以决定抢占当前线程，并重新开始一个先前被抢占了的进程，这种决策即为调度。</span><br><span class="line">    - 由内核中的调度器（scheduler）处理</span><br><span class="line">  - **1.** 保存当前进程（旧）的上下文</span><br><span class="line">    - 内核将旧进程状态保存进其PCB。</span><br><span class="line">  - **2.** 加载要调度的进程的上下文~~保存的寄存器值~~到cpu中，并切换到该进程的进程地址。（这就是所谓的 **上下文切换（context switch），恢复某个先前被抢占的进程被保存的上下文**）</span><br><span class="line">  - **3.** 将控制传递给这个新恢复的进程。</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-18-36-35.png)</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-18-41-40.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **Processes are managed by a shared chunk of memory-resident OS code called kernal**  ---  进程们是由一块被常驻在主存中的、被称为内核的操作系统代码 来管理的。</span><br><span class="line">  - **Important：the kernal is not a separate process , but rather runs as part of some existing process**.</span><br><span class="line">  - 内核不是一个独立的进程，而是作为于每个进程的一部分。（等待被调用？）</span><br><span class="line">- Control flow passes from one process to another via a context switch</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-21-55-50.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 上下文切换情况</span><br><span class="line"></span><br><span class="line">- 单核多进程还有意义吗？我觉得下面这个情况就能说明有意义。</span><br><span class="line"></span><br><span class="line">- 内核代表用户执行**系统调用时，可能会发生上下文切换**。如果系统调用因为等待某个事件而发生**阻塞**，那么**内核**可以让当前**进程休眠**，**切换到另一个进程**。（所以阻塞了就不会占cpu了，因为内核会执行上下文切换到另一个进程）如下</span><br><span class="line">  - read系统调用：进程A调用read，那么内核可以选择执行上下文切换，运行另一个进程B，而不是等待磁盘数据到达。</span><br><span class="line">  - sleep系统调用：显示地请求让调用进程休眠。</span><br><span class="line">  - 一般来说，即使系统调用没阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。</span><br><span class="line"></span><br><span class="line">- **中断也会引发上下文切换**</span><br><span class="line">  - 比如定时器中断（1ms/10ms），每次定时器中断时，内核就能判定当前进程运行了足够长时间，好切换到下一个进程。</span><br><span class="line"></span><br><span class="line">- **例子**</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-22-36-01.png)</span><br><span class="line">  ![](csapp-8-异常控制流1/2022-08-06-22-39-34.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 上下文切换的时间是**纯粹的开销**，因为在切换时系统并没有做任何有用工作。</span><br><span class="line">  - 典型速度为**几ms**</span><br><span class="line">  - 上下文切换的速度因机器不同而不同，它依赖于内存速度、必须复制的寄存器数量、是否有特殊指令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 内核 躺着的代码？</span><br><span class="line">------</span><br><span class="line">- [Linux 内核的操作系统是不是得一直运行着？ - 高鹏的回答 - 知乎](https://www.zhihu.com/question/23561375/answer/25345790)</span><br><span class="line">- **虽然每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存**。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</span><br><span class="line"></span><br><span class="line">- 内核就是躺着等待别人调用的代码，只有通过异常才可以调用</span><br><span class="line">  - 如何调用：进程通过中断故障陷阱这样的异常 改变模式位 用户模式变为内核模式 然后再请求内核提供的服务（系统调用之类的）。</span><br><span class="line">- **小疑问**</span><br><span class="line">  - 为什么要把内核地址设置在每个进程的高位？</span><br><span class="line">  - 每个虚拟进程地址中的内核区地址我觉得应当都是指向同一块物理内存</span><br><span class="line">    - 这里的东西在虚拟内存那一章应该挺详细。</span><br><span class="line">  - 是为了用户代码可以切换到内核模式调用系统调用，或者说进入异常处理程序。</span><br><span class="line">  - 我认为再说简单一点就是用户代码可以知道内核代码的地址位置，这样就可以找到内核代码。</span><br><span class="line">-------</span><br><span class="line"></span><br><span class="line">## Process Control</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### System	Call	Error	Handling</span><br><span class="line">- unix系统级函数error时，通常返回-1，并且设置全局变量errno。</span><br><span class="line">- You	must	check	the	return	status	of	every	system-level	function</span><br><span class="line">- **包装函数**</span><br><span class="line">```c</span><br><span class="line">void unix_error(char *msg) /* Unix-style error */</span><br><span class="line">&#123;</span><br><span class="line"> fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));</span><br><span class="line"> exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ((pid = fork()) &lt; 0)</span><br><span class="line"> unix_error(&quot;fork error&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pid_t Fork()</span><br><span class="line">&#123;</span><br><span class="line">  pid_t pid;</span><br><span class="line">  if( ( pid=fork() ) &lt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    unix_error(&quot;Fork error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return pid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid = Fork();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="getpid"><a href="#getpid" class="headerlink" title="getpid"></a>getpid</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span>   <span class="comment">//  typedef int pid_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span>      <span class="comment">//  声明getpid、getppid</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">()</span></span>;   <span class="comment">//  返回当前进程id</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">()</span></span>;  <span class="comment">//  返回父进程id</span></span><br></pre></td></tr></table></figure>

<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul>
<li><strong>进程状态</strong></li>
<li>运行 RUNNING<ul>
<li>进程要吗在CPU上执行，要么在等待被执行且最终会被内核调度</li>
</ul>
</li>
<li>停止 Stopped<ul>
<li>进程的执行被挂起（suspended），且不会被执行。</li>
<li>当收到信号 SIGSTOP、SIGTSTP、SIGTIN、SIGTTOU时，进程停止，且保持停止知道受到一个SIGCONT信号，这个时刻，进程再次开始运行。</li>
</ul>
</li>
<li>终止 Terminated<ul>
<li>进程永远地停止了。以下三个原因</li>
<li>收到一个信号，该信号的默认行为是终止进程</li>
<li>从main中return</li>
<li>调用exit函数</li>
</ul>
</li>
</ul>
<h4 id="fork-创建进程-exit销毁进程"><a href="#fork-创建进程-exit销毁进程" class="headerlink" title="fork 创建进程 / exit销毁进程"></a>fork 创建进程 / exit销毁进程</h4><ul>
<li><p><strong>exit</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="comment">//  1. 以status退出状态来终止进程。</span></span><br><span class="line"><span class="comment">//  2. Convention:	normal	return	status	is	0,	nonzero	on	error</span></span><br><span class="line"><span class="comment">//  3. Another	way	to	explicitly	set	the	exit	status	is	to	return	an	integer	value	from	the	main	routine</span></span><br><span class="line"><span class="comment">//  4. exit	is	called	once	but	never	returns.</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>fork</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>Child returns 0</li>
<li>Parent returns Child’s pid</li>
<li>fork:called once , but returns twice</li>
<li>子进程和父进程几乎完全相同。<ul>
<li>Child得到与Parent<strong>相同但独立    (identical but    separate)    <strong>的</strong>用户级虚拟地址空间</strong>副本<ul>
<li>包括代码和数据段、堆、共享库、用户栈</li>
</ul>
</li>
<li>Child获得与父进程打开的文件描述符副本（open    file    descriptors）</li>
<li>Child和Parent的PID不同。</li>
</ul>
</li>
</ul>
</li>
<li><p>进程图，拓扑排序。<br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-08-08-16-50-49.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-08-08-16-50-32.png"></p>
</li>
</ul>
<h3 id="Reaping-Child-Process-回收子进程"><a href="#Reaping-Child-Process-回收子进程" class="headerlink" title="Reaping Child Process 回收子进程"></a>Reaping Child Process 回收子进程</h3><ul>
<li>man wait<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NOTES</span><br><span class="line">      A child that terminates, but has not been waited <span class="keyword">for</span> becomes a <span class="string">&quot;zombie&quot;</span>.  **The kernel maintains a minimal <span class="built_in">set</span> of information about the zombie  process**  (PID,  termination</span><br><span class="line">      status,  resource usage information) **<span class="keyword">in</span> order to allow the parent to later perform a <span class="built_in">wait</span> to obtain information about the child**.  As long as a zombie is not removed from</span><br><span class="line">      the system via a <span class="built_in">wait</span>, it will consume a slot <span class="keyword">in</span> the kernel process table, and <span class="keyword">if</span> this table fills, it will not be possible to create further  processes.   If  a  parent</span><br><span class="line">      process  terminates,  <span class="keyword">then</span>  its  <span class="string">&quot;zombie&quot;</span>  children  (<span class="keyword">if</span>  any)  are adopted by init(1), (or by the nearest <span class="string">&quot;subreaper&quot;</span> process as defined through the use of the prctl(2)</span><br><span class="line">      PR_SET_CHILD_SUBREAPER operation); **init(1) automatically performs a <span class="built_in">wait</span> to remove the zombies**.</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>僵死进程 zombie</strong>：当一个进程由于某种原因终止，<strong>内核</strong>并不是立即把他从系统中清除。相反，进程被保持在一种已终止的状态，直到被它的父进程<strong>回收</strong>。<strong>一个终止了但还未被回收的进程称为僵死进程</strong>。</p>
</li>
<li><p><strong>Reaping 回收</strong></p>
<ul>
<li>当父进程回收已终止的子进程时（通过wait or waitpid）</li>
<li>内核将子进程的退出状态（exit status）传递给父进程，</li>
<li>然后抛弃已终止的进程，（kernel    then    deletes    zombie    child    process）</li>
<li>从此时开始，该进程就不存在了。</li>
</ul>
</li>
<li><p>如果父进程没有回收其子进程？</p>
<ul>
<li>长时间运行的程序（如shell）即使僵死进程并没有运行，也在消耗内存资源。</li>
<li>父进程已终止，子进程没终止：没被回收的子进程称为孤儿进程。内核安排init进程（init process ；pid=1）成为孤儿进程的养父。内核安排init进程去回收这些孤儿进程。</li>
<li>父进程没终止，子进程终止，父进程终止了也没去回收子进程：内核安排init进程去回收这些孤儿进程</li>
<li>因此，长时间不停的父进程需要显示地wait/waitpid回收子进程。</li>
</ul>
</li>
</ul>
<h4 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h4><ul>
<li>DESCRIPTION<ul>
<li>All  of these system calls are used to wait for <strong>state changes</strong> in a child of the calling process, and obtain information about the child whose state has changed.  A state</li>
<li><strong>change is considered to be</strong>: <ul>
<li><strong>the child terminated</strong>; <ul>
<li>In the case of a terminated child, performing a wait allows the system to release the resources associated with the child; if a wait is not performed, then the terminated child remains in a “zombie” state (see NOTES below).</li>
</ul>
</li>
<li><strong>the child was stopped by a signal</strong>; </li>
<li><strong>or the child was resumed by a signal</strong>.  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span>    <span class="comment">//  WNOHANG 一类option</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *statusp, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">// func : 等待调用进程的子进程终止或停止</span></span><br><span class="line"><span class="comment">// return val: 回收到的子进程pid</span></span><br></pre></td></tr></table></figure>
<ul>
<li>阅读功能步骤<ul>
<li><ol>
<li>默认情况下，即 options=0，waitpid挂起当前进程（挂起不占cpu）</li>
</ol>
<ul>
<li>是否挂起（阻塞等待）由options决定</li>
</ul>
</li>
<li><ol start="2">
<li>直到它的等待集合（wait set）的一个子进程终止。</li>
</ol>
<ul>
<li>wait set 由 pid 决定</li>
<li>若wait set集合中的一个进程在刚调用的时刻就已经终止了，那么waitpid就立刻返回</li>
<li>若wait set集合中没有已经停止的，就阻塞等待。</li>
</ul>
</li>
<li><ol start="3">
<li>将返回的子进程的状态信息存入statusp</li>
</ol>
<ul>
<li>statusp = null ? </li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="pid-–-判定等待集合的成员"><a href="#pid-–-判定等待集合的成员" class="headerlink" title="pid – 判定等待集合的成员"></a>pid – 判定等待集合的成员</h5><ul>
<li><strong>pid：判定等待集合的成员</strong></li>
<li>pid&gt;0：一个单独的pid子进程</li>
<li>pid=-1：本进程作为父进程的所有子进程</li>
<li>其他还有，略。</li>
</ul>
<h5 id="options-–-是否挂起"><a href="#options-–-是否挂起" class="headerlink" title="options – 是否挂起"></a>options – 是否挂起</h5><ul>
<li><p><strong>默认行为 0</strong>：</p>
<ul>
<li>挂起调用进程，直到有子进程终止。</li>
<li>return 已终止的子进程。</li>
</ul>
</li>
<li><p><strong>WNOHANG</strong>：</p>
<ul>
<li>等待集合中的任何子进程都还没终止，则立刻return 0。</li>
</ul>
</li>
<li><p><strong>WUNTRACED</strong>：</p>
<ul>
<li>挂起当前进程，直到等待集合中的一个进程变成已终止或者被停止。（比起默认只监听终止，这个还监听了停止（一般是被signal (ztrl+z)SIGTSTP停止，终止一般是 exit，或者被信号如(ctrl+c)SIGINT杀死）</li>
<li>return的pid为导致返回的已终止或被停止子进程的pid。</li>
</ul>
</li>
<li><p><strong>WCONTINUED</strong>：</p>
<ul>
<li>挂起调用进程的执行，<ul>
<li>直到等待集合中一个正在运行的进程终止 或</li>
<li>等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>WNOHANG | WUNTRACED</strong></p>
<ul>
<li>立即返回，如果等待集合中的子进程都没被停止或终止，则return 0</li>
<li>如果有一个停止或终止，则return 该子进程pid。</li>
</ul>
</li>
</ul>
<h5 id="statusp-–-检查已回收子进程的退出状态"><a href="#statusp-–-检查已回收子进程的退出状态" class="headerlink" title="statusp – 检查已回收子进程的退出状态"></a>statusp – 检查已回收子进程的退出状态</h5><ul>
<li>WIFEXITED and WEXITSTATUs<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIFEXITED(status))&#123;                  <span class="comment">//  true  &lt;---&gt;  child process return  /  exit</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status %d\n&quot;</span>,pid,WEXITSTATUS(status));    </span><br><span class="line">    <span class="comment">//  return the exist status of a normally exit process       8位</span></span><br><span class="line">    <span class="comment">// This macro should be employed only if WIFEXITED returned true.</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>,pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>WIFSIGNALED and WTERMSIG<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// returns true if the child process was terminated by a signal.</span></span><br><span class="line"><span class="keyword">if</span>(WIFSIGNALED(status))&#123;    </span><br><span class="line">  <span class="comment">//  returns the number of the signal that caused the child process to terminate.  This macro should be employed only if WIFSIGNALED returned true.</span></span><br><span class="line">  <span class="keyword">int</span> signal = WTERMSIG(status)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>WIFSTOPPED</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// returns  true  if  the  child  process  was stopped by delivery of a signal; this is possible only if the call was done using WUNTRACED or when the child is being traced (see ptrace(2)).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(WIFSTOPPED(status))&#123; </span><br><span class="line">  <span class="keyword">int</span> signal = WSTOPSIG(status);</span><br><span class="line">  <span class="comment">// returns the number of the signal which caused the child to stop.  This macro should be employed only if WIFSTOPPED returned true.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>WIFCONTINUED</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIFCONTINUED(status))&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;continue\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><ul>
<li>RETURN VALUE<ul>
<li>wait(): <ul>
<li>on success, returns the process ID of the terminated child; </li>
<li>on error, -1 is returned.</li>
</ul>
</li>
<li>waitpid(): <ul>
<li>on success, returns the process ID of the child whose state has changed; </li>
<li>if <strong>WNOHANG</strong> was specified and one or more child(ren) specified by pid exist, but  have not yet changed state, then 0 is returned. </li>
<li> On error, -1 is returned.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="错误条件"><a href="#错误条件" class="headerlink" title="错误条件"></a>错误条件</h5><ul>
<li><p>waitpid默认阻塞HANG情况下</p>
<ul>
<li>return -1 &amp;&amp; errno = ECHILD：调用进程没有子进程剩余了，都被回收玩了。</li>
<li>return -1 &amp;&amp; errno = EINTR：waitpid函数被一个信号中断。</li>
</ul>
</li>
<li><p>waitpid(WNOHANG)情况下</p>
<ul>
<li>WNOHANG =-1是error ，=0是集合里剩余的所有进程还没有一个结束的</li>
</ul>
</li>
</ul>
<h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *statusp)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>wait(&amp;status) &lt;===&gt; wait(-1,&amp;status,0);</strong></p>
</li>
<li><p><strong>waitpid 回收子进程 例子</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. fork</span></span><br><span class="line"><span class="comment">// 2. waitpid</span></span><br><span class="line"><span class="comment">// 3. errno</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)    <span class="comment">//  N个子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">exit</span>(i);        <span class="comment">//  exit status</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status,pid;</span><br><span class="line">    <span class="comment">//  当前进程 **挂起** 等待子进程集合中有结束的进程</span></span><br><span class="line">    <span class="comment">//  不会占用cpu。内核会调度到其他不阻塞进程。</span></span><br><span class="line">    <span class="keyword">while</span>( (pid = waitpid(<span class="number">-1</span>,&amp;status,<span class="number">0</span>)) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))&#123;                  <span class="comment">//  true  &lt;---&gt;  child process return  /  exit</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated normally with exit status %d\n&quot;</span>,pid,WEXITSTATUS(status));    <span class="comment">//  return the exist status of a normally exit process       </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d terminated abnormally\n&quot;</span>,pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  检验是否回收完所有子进程</span></span><br><span class="line">    <span class="comment">//  waitpid -- return -1 &amp; errno = ECHILD</span></span><br><span class="line">      <span class="comment">//  只有当 waitpid 的选项是 挂起的时候才可以这样检查errno</span></span><br><span class="line">      <span class="comment">//  如果waitpid的选项是 WNOHANG,那么就不能这样检查,因为不阻塞,返回,会有没结束的子进程. 此时errno应该 = success</span></span><br><span class="line">    <span class="keyword">if</span>(errno == ECHILD)&#123;                </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;all child processes is reaped by parent\n&quot;</span>);   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/csapp_try/process$ ./waitpid1 </span><br><span class="line">child <span class="number">110852</span> terminated normally with <span class="built_in">exit</span> status <span class="number">0</span></span><br><span class="line">child <span class="number">110853</span> terminated normally with <span class="built_in">exit</span> status <span class="number">1</span></span><br><span class="line">child <span class="number">110854</span> terminated normally with <span class="built_in">exit</span> status <span class="number">2</span></span><br><span class="line">child <span class="number">110855</span> terminated normally with <span class="built_in">exit</span> status <span class="number">3</span></span><br><span class="line">child <span class="number">110856</span> terminated normally with <span class="built_in">exit</span> status <span class="number">4</span></span><br><span class="line"><span class="function">all child processes is reaped by parent</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">ERRORS</span></span><br><span class="line"><span class="function">       <span class="title">ECHILD</span> <span class="params">(<span class="keyword">for</span> wait())</span> The calling process does <span class="keyword">not</span> have any unwaited-<span class="keyword">for</span> children.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       <span class="title">ECHILD</span> <span class="params">(<span class="keyword">for</span>  waitpid()  <span class="keyword">or</span> waitid())</span> The process specified by <span class="title">pid</span> <span class="params">(waitpid())</span> <span class="keyword">or</span> idtype <span class="keyword">and</span> <span class="title">id</span> <span class="params">(waitid())</span> does <span class="keyword">not</span> exist <span class="keyword">or</span> is <span class="keyword">not</span> a child of the calling process.  <span class="params">(This</span></span></span><br><span class="line"><span class="params"><span class="function">              can happen <span class="keyword">for</span> one<span class="string">&#x27;s own child if the action for SIGCHLD is set to SIG_IGN.  See also the Linux Notes section about threads.)</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">       EINTR  WNOHANG was not set and an unblocked signal or a SIGCHLD was caught; see signal(7).</span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function"></span></span></span></span><br><span class="line"><span class="string"><span class="params"><span class="function">       EINVAL The options argument was invalid.</span></span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ul>
<li>sleep<ul>
<li>休眠secs秒<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>return value：<ul>
<li>时间已到，返回0</li>
<li>时间未到，返回剩下的要休眠的秒数(sleep信号可能会被信号中断)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>pause</p>
<ul>
<li>让调用进程休眠，直到该进程收到一个信号。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li>return -1</li>
</ul>
</li>
<li><p>snooze函数，同sleep，就是加一条打印</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">snooze</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t_left = sleep(secs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Slept for %d of %d secs\n&quot;</span>,secs-t_left,secs);</span><br><span class="line">    <span class="keyword">return</span> t_left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  信号处理程序（处理SIGNIT）。功能：捕获信号后，将控制返回给snooze函数。（本来对于SIGINT的默认行为是终止进程，现在变成返回控制给用户程序 如P532图8-31）</span></span><br><span class="line"><span class="comment">//  处理SIGINT信号，将控制返回给中断的语句的下一条语句</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prog catch %d\n&quot;</span>,sig);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[],<span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : ./signal_snooze secs\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// signal</span></span><br><span class="line">    signal(SIGINT,sigint_handler);</span><br><span class="line">    snooze(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/csapp_try/process$ ./signal_snooze <span class="number">10</span></span><br><span class="line">^Cprog <span class="keyword">catch</span> <span class="number">2</span></span><br><span class="line">Slept <span class="keyword">for</span> <span class="number">3</span> of <span class="number">10</span> secs</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename,<span class="keyword">const</span> <span class="keyword">char</span> *argv[],<span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>功能：在当前进程的上下文中加载并运行一个新程序</p>
</li>
<li><p><strong>Called    once    and    never    returns</strong>，除非发生错误，会返回。</p>
</li>
<li><p><strong>Loads    and    runs in    the    current    process</strong></p>
<ul>
<li>filename： <ul>
<li>Executable    file    filename，Can    be    object    file    or    script    file</li>
</ul>
</li>
<li>argv：指向一个指针数组<ul>
<li>argv[0] = 可执行文件名</li>
<li>剩余的是参数</li>
</ul>
</li>
<li>envp：指向一个指针数组<ul>
<li>每个指针指向一个环境变量字符串</li>
<li>name = value</li>
</ul>
</li>
</ul>
</li>
<li><p>程序是一堆代码和数据；程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。</p>
</li>
<li><p><strong>fork和execve区别</strong></p>
<ul>
<li><strong>fork新创建了一个进程</strong>，这个新的进程的用户级虚拟地址空间是父进程的复制品，在这个新进程里，运行相同的程序。</li>
<li><strong>execve</strong>在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然具有相同的pid，并继承了调用execve函数时已打开的所有文件描述符。</li>
</ul>
</li>
<li><p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-08-09-15-37-04.png"></p>
</li>
</ul>
<h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><ul>
<li>fork and execve</li>
</ul>
<p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-06-17.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-06-32.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-06-43.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-06-49.png"></p>
<p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-07-05.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-07-08.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-07-12.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-07-15.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-07-19.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-07-24.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-07-27.png"><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-21-07-34.png"><br><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=15&amp;t=2894.1">https://www.bilibili.com/video/BV1iW411d7hd?p=15&amp;t=2894.1</a></p>
<p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-23-07-31.png"><br><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=15&amp;t=3985.4">https://www.bilibili.com/video/BV1iW411d7hd?p=15&amp;t=3985.4</a><br><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-23-08-35.png"></p>
<p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-23-11-47.png"></p>
<p><img src="/2022/07/18/csapp-8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%811/2022-07-18-23-18-47.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache-Lab</title>
    <url>/2022/08/26/csapp-Cache-Lab/</url>
    <content><![CDATA[<p>模拟LRU</p>
<span id="more"></span>

<h1 id="CacheSimulator"><a href="#CacheSimulator" class="headerlink" title="CacheSimulator"></a>CacheSimulator</h1><ul>
<li>pass  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/Shared_ln/csapp/cachelab$ ./test-csim </span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">    3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">    3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">    3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">    3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">    3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">    3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">    3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">    6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">TEST_CSIM_RESULTS=27</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>层次：所模拟的是SRAM作为DRAM的缓存的替换策略。<br>  <img src="/2022/08/26/csapp-Cache-Lab/2022-08-26-12-11-31.png"></li>
<li><strong>Placement    policy</strong>: determines    where    b    goes</li>
<li><strong>Replacement    policy</strong>:    determines    which    block    gets evicted (victim)<br>  <img src="/2022/08/26/csapp-Cache-Lab/2022-08-26-12-14-20.png"></li>
</ul>
<ul>
<li><strong>只是一个cacheSimluator 并不是真正的cache</strong><ul>
<li>A    cache    simulator    is    NOT    a    cache!    </li>
<li>Memory    contents    NOT    stored</li>
<li>Block    offsets    are    NOT    used    –    the    b    bits    in    your    address    don’t matter</li>
<li>Simply    count    hits,    misses,    and    evic-ons    </li>
<li>由于不需要处理数据，那么load store和modify就可简化为同一函数updateCache操作。</li>
</ul>
</li>
</ul>
<ul>
<li>读题时困惑许久<ul>
<li>cacheSimulator中，如果我Load了一个数据，发现在cache中没有，他该从哪里加载进来呢？是我们假设他从下层加载进cache了吗？但实际我们并没有做这个操作？是这样么？<ul>
<li>没错，就是这样。</li>
</ul>
</li>
<li>本实验只是专注于实现一个组中的替换（驱逐）策略：LRU<ul>
<li>至于读时如果不命中如何从下层加载到cache中，这些都不考虑，假设不命中时会自动缓存到cache中。</li>
<li>至于写命中时直写还是写回、写不命中时写分配还是非写分配，这些都不做。只做LRU替换策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://www.cnblogs.com/qingergege/p/5914218.html"><strong>Linux C处理命令行参数</strong></a><ul>
<li><strong>getopt</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>C格式化读取文件</strong><ul>
<li><strong>fscanf</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">fscanf</span>(f,<span class="string">&quot; %c %lx,%d&quot;</span>,&amp;op,&amp;addr,&amp;sz)&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c, %lx %d\n&quot;</span>,op,addr,sz);</span><br><span class="line">    <span class="keyword">switch</span>(op)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:       <span class="comment">//  load data</span></span><br><span class="line">            updateCache(addr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:       <span class="comment">//  modified = load and store    load hit then update cache(write-back) . load not hit and then load into cache and update(write-allocate) </span></span><br><span class="line">            updateCache(addr);   <span class="comment">//  load</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:       <span class="comment">//  store</span></span><br><span class="line">            updateCache(addr);</span><br><span class="line">            <span class="keyword">break</span>;             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/Shared_ln/csapp/cachelab$ ./csim -s <span class="number">4</span> -E <span class="number">1</span> -b <span class="number">4</span> -t traces/yi.trace</span><br><span class="line">L, <span class="number">10</span> <span class="number">1</span></span><br><span class="line">M, <span class="number">20</span> <span class="number">1</span></span><br><span class="line">L, <span class="number">22</span> <span class="number">1</span></span><br><span class="line">S, <span class="number">18</span> <span class="number">1</span></span><br><span class="line">L, <span class="number">110</span> <span class="number">1</span></span><br><span class="line">L, <span class="number">210</span> <span class="number">1</span></span><br><span class="line">M, <span class="number">12</span> <span class="number">1</span></span><br><span class="line">hits:<span class="number">4</span> misses:<span class="number">5</span> evictions:<span class="number">3</span></span><br><span class="line"></span><br><span class="line">yi.trace</span><br><span class="line">L <span class="number">10</span>,<span class="number">1</span></span><br><span class="line">M <span class="number">20</span>,<span class="number">1</span></span><br><span class="line">L <span class="number">22</span>,<span class="number">1</span></span><br><span class="line">S <span class="number">18</span>,<span class="number">1</span></span><br><span class="line">L <span class="number">110</span>,<span class="number">1</span></span><br><span class="line">L <span class="number">210</span>,<span class="number">1</span></span><br><span class="line">M <span class="number">12</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>用unsigned long作为地址 64bits 防止被截断</p>
</li>
<li><p>如何取address低x位被截断</p>
<ul>
<li>通过mask/只通过移位</li>
<li>见datalab如何获取低x位。</li>
</ul>
</li>
<li><p><strong>思路和lc的LRU缓存思路大致相同。</strong></p>
<ul>
<li>本实验大致步骤<ul>
<li>如何从命令中拿到所需的参数 getopt</li>
<li>如何从文件中读入内容      fscanf</li>
<li>如何构造cache结构<ul>
<li>本实验是实现了S组LRU。<ul>
<li>通过数组将index映射到S组中的一组。</li>
<li>每组通过timelist维护数据和访问时间</li>
<li>每组LRU做到了O(1)时间的驱逐evict</li>
<li>但是，没有做到O(1)的取数load，而是O(n)。通过遍历组中的所有节点(cacheLine)</li>
<li>L：load。S：store。M：modify = L + S。由于不处理数据，可以简化为同一函数。</li>
</ul>
</li>
<li>lc通过hash实现了O(1)的取数load，通过timelist实现O(1)的evict。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Part-B-略"><a href="#Part-B-略" class="headerlink" title="Part B(略)"></a>Part B(略)</h2><ul>
<li><p>有些繁琐、感觉没啥意思。</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/142942823">参考</a></p>
</li>
<li><p>32*32</p>
<ul>
<li>C = 1024 Bytes</li>
<li>直接映射 E = 1</li>
<li>B = 32Bytes                      b = 5</li>
<li>S = C / (S*B) = 1024/32 = 32     s = 5</li>
<li>观察A和B的地址可以发现，A和B中相同坐标的元素 会映射到cache中的同一个cache line</li>
<li>一行cache line可以存储8个int。A的一行可以映射到4行不冲突的cacheline。A的8行可以映射到所有cacheline而不冲突。cache可以存储8行1*32的int行。</li>
<li>A/B[0,0]会和A/B[8,0]冲突</li>
<li>数组的行和cache的映射关系如下图<br><img src="/2022/08/26/csapp-Cache-Lab/2022-08-28-00-14-22.png"></li>
<li>为什么划分为8*8？因为要求不超过12个临时变量。4*4没有利用好cacheline.16*16冒出cacheline(cachlien一行只能8个int)</li>
<li>对角线元素相同，没必要交换，且A和B会映射到同一cacheline</li>
<li>不一次读完一行：在读某一行时，初始会有一个读miss；写对角线元素时，会有一个写miss；且会将正在读的A的该行替换出cache。而A的该行还没读完，还需要接着读，因此需要再替换进cache。造成抖动</li>
<li>一次读完一行：在读某一行时，初始会有一个读miss，且一次性全部读完，在写对角线元素时，会有一个写miss，会将读的A行替换出cache。但不会造成抖动，因为A的改行已经读完。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  不一次读</span></span><br><span class="line">    <span class="keyword">int</span> i, j, m, n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)</span><br><span class="line">                    <span class="keyword">for</span> (m = i; m &lt; i + <span class="number">8</span>; ++m)</span><br><span class="line">                            <span class="keyword">for</span> (n = j; n &lt; j + <span class="number">8</span>; ++n)</span><br><span class="line">                            &#123;</span><br><span class="line">                                    B[n][m] = A[m][n];</span><br><span class="line">                            &#125;</span><br><span class="line"><span class="comment">//  一次读</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i+=<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j+=<span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;i+<span class="number">8</span>;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> t0 = A[k][j];</span><br><span class="line">                <span class="keyword">int</span> t1 = A[k][j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> t2 = A[k][j+<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">int</span> t3 = A[k][j+<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">int</span> t4 = A[k][j+<span class="number">4</span>];</span><br><span class="line">                <span class="keyword">int</span> t5 = A[k][j+<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">int</span> t6 = A[k][j+<span class="number">6</span>];</span><br><span class="line">                <span class="keyword">int</span> t7 = A[k][j+<span class="number">7</span>];</span><br><span class="line">  </span><br><span class="line">                B[j][k] = t0;</span><br><span class="line">                B[j+<span class="number">1</span>][k] = t1;</span><br><span class="line">                B[j+<span class="number">2</span>][k] = t2;</span><br><span class="line">                B[j+<span class="number">3</span>][k] = t3;</span><br><span class="line">                B[j+<span class="number">4</span>][k] = t4;</span><br><span class="line">                B[j+<span class="number">5</span>][k] = t5;</span><br><span class="line">                B[j+<span class="number">6</span>][k] = t6;</span><br><span class="line">                B[j+<span class="number">7</span>][k] = t7;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不一次读（a的小矩阵每行多一次读miss）</span></span><br><span class="line">shc@shc-virtual-machine:~/桌面/cachelab$ ./test-trans -M 32 -N 32</span><br><span class="line"></span><br><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1710, misses:343, evictions:311</span><br><span class="line"></span><br><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151</span><br><span class="line"></span><br><span class="line">Summary <span class="keyword">for</span> official submission (func 0): correctness=1 misses=343</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:343</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次读</span></span><br><span class="line"></span><br><span class="line">shc@shc-virtual-machine:~/桌面/cachelab$ ./test-trans -M 32 -N 32</span><br><span class="line"></span><br><span class="line">Function 0 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 0 (Transpose submission): hits:1766, misses:287, evictions:255</span><br><span class="line"></span><br><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151</span><br><span class="line"></span><br><span class="line">Summary <span class="keyword">for</span> official submission (func 0): correctness=1 misses=287</span><br><span class="line"></span><br><span class="line">TEST_TRANS_RESULTS=1:287</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp-9-虚拟内存</title>
    <url>/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>虚拟内存<br>  对主存的抽象，支持处理器通过虚拟寻址的方式来引用主存<br>三个功能</p>
<ol>
<li>缓存磁盘上的虚拟地址空间的内容</li>
<li>简化内存管理、链接、加载等</li>
<li>简化内存保护（通过PTE加保护位）</li>
</ol>
<p>内存映射<br>  将虚拟内存片和disk上的文件片关联起来，来初始化虚拟内存片<br>  mmap</p>
<p>动态内存分配  显示分配器、隐式分配器。<br>  malloc</p>
<span id="more"></span>

<h1 id="Virtual-Memory-Concepts"><a href="#Virtual-Memory-Concepts" class="headerlink" title="Virtual Memory Concepts"></a>Virtual Memory Concepts</h1><h2 id="Why-VM"><a href="#Why-VM" class="headerlink" title="Why VM?"></a>Why VM?</h2><ul>
<li>Uses    main    memory    efficiently    <ul>
<li>Use    DRAM    as    a    cache    for    parts    of    a    virtual    address    space    </li>
<li>DRAM主存作为虚拟地址空间的一部分的缓存？虚拟地址空间还有一部分是啥？就是磁盘本身上的地址？</li>
</ul>
</li>
<li>Simplifies    memory    management    <ul>
<li>Each    process    gets    the    same    uniform    linear    address    space    </li>
</ul>
</li>
<li>Isolates    address    spaces    <ul>
<li>One    process    can’t    interfere    with    another’s    memory</li>
<li>User program cannot    access    privileged    kernel    information    and    code</li>
</ul>
</li>
</ul>
<h2 id="Address-Space"><a href="#Address-Space" class="headerlink" title="Address Space"></a>Address Space</h2><h3 id="Physical-Addressing-物理寻址"><a href="#Physical-Addressing-物理寻址" class="headerlink" title="Physical Addressing 物理寻址"></a>Physical Addressing 物理寻址</h3><p><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-15-47-37.png"></p>
<ul>
<li><strong>Physical Address (PA) 物理地址</strong>：计算机的主存被组织成一个由M个连续的字节大小的单元组成的数组，每字节都有唯一的物理地址。</li>
<li><strong>Physical Addressing 物理寻址</strong>：<ul>
<li>CPU访问内存的一种方式</li>
<li>示例：读取物理地址4处开始的4字节字。<ul>
<li>CPU执行加载指令，生成一个有效物理地址，通过内存总线，把它传递给主存；</li>
<li>主存取出从物理地址处开始的4字节，并将它返回给CPU，CPU会将它存放在一个Reg中。</li>
</ul>
</li>
</ul>
</li>
<li>早期的PC、嵌入式微控制器等使用Physical Addressing</li>
</ul>
<h3 id="Virtual-Addressing-虚拟寻址"><a href="#Virtual-Addressing-虚拟寻址" class="headerlink" title="Virtual    Addressing 虚拟寻址"></a>Virtual    Addressing 虚拟寻址</h3><p><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-15-57-35.png"></p>
<ul>
<li><strong>Virtual Address (VA) 虚拟地址</strong></li>
<li><strong>Virtual Addressing 虚拟寻址</strong><ul>
<li>CPU通过生成一个虚拟地址（VA）来访问主存，然后进行地址翻译：生成的这个虚拟地址先通过<strong>MMU（Memory Management Unit）</strong>转换成物理地址</li>
<li><strong>MMU：利用存放在dram中的page table来动态翻译虚拟地址，该表的内容由os管理。</strong></li>
<li><strong>MMU是硬件实现的，而非os的一部分</strong></li>
<li><strong>MMU本身不保存page table，而是通过到dram中去查询</strong></li>
</ul>
</li>
</ul>
<h3 id="Address-Space-1"><a href="#Address-Space-1" class="headerlink" title="Address Space"></a>Address Space</h3><ul>
<li><p><strong>Linear address space 线性地址空间</strong></p>
<ul>
<li>空间中的地址为连续的非负整数 {0,1,2,3…}</li>
</ul>
</li>
<li><p><strong>Virtual address space 虚拟地址空间</strong></p>
<ul>
<li>在一个带虚拟内存的系统中，CPU从一个由N=2^n个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间Virtual address space</li>
<li>现代系统通常支持32位、64位虚拟地址空间</li>
<li>{0,1,2,3…,N-1}</li>
</ul>
</li>
<li><p><strong>Physical address space 物理地址空间</strong></p>
<ul>
<li>对应于系统中物理内存的M个字节，M不一定是2的幂</li>
<li>{0,1,2,…,M-1}</li>
</ul>
</li>
<li><p>地址空间的概念，区分了数据对象（字节）和他们的属性（地址）。</p>
</li>
<li><p><strong>虚拟内存基本思想</strong>：允许每个数据对象（字节）有多个独立的地址，其中每个地址都选自一个不同的地址空间。</p>
</li>
<li><p>主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
</li>
</ul>
<h2 id="VM-as-a-Tool-for-Caching"><a href="#VM-as-a-Tool-for-Caching" class="headerlink" title="VM as a Tool    for    Caching"></a>VM as a Tool    for    Caching</h2><p>众所周知 计算机系统中 上层是下层的缓存<br>那么 主存是如何作为 磁盘的缓存的呢？<br>要通过VM系统这个机制 来使得 主存作为磁盘的缓存<br>下面介绍VM系统<br>VM系统<br>虚拟内存 是 给磁盘上的一块字节序列组织起来 给他们每人一个地址 ，这个地址就是虚拟地址，所有虚拟地址在一起就叫虚拟地址空间，DRAM主存可从虚拟内存空间VM SPACE 里 取出东西 缓存到主存DRAM中</p>
<ul>
<li><p><strong>virtual memory is an    array of N contiguous bytes stored on    disk</strong> — 虚拟内存被组织为一个由<strong>存放在磁盘</strong>上的N个连续的字节大小的单元组成的数组</p>
<ul>
<li>虚拟内存中的（也即磁盘的这块空间）每个字节都有一个<strong>唯一的虚拟地址</strong>，作为数组的<strong>索引</strong></li>
</ul>
</li>
<li><p><strong>The    contents of    the    array    on    disk    are    cached    in    physical memory    (DRAM    cache)</strong>  —  磁盘上数组的内容<strong>被缓存在主存</strong>中    </p>
<ul>
<li><p>These cache    blocks    are    called    pages    (size is P = 2^p bytes)  </p>
</li>
<li><p>磁盘上的数据被分割成块，作为磁盘和主存之间的传输单元（如第6章所述）。<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-18-00-34.png"></p>
</li>
<li><p>**虚拟页 Virtual Page (VP)**：VM系统将虚拟内存分割为虚拟页的大小固定的块。每个虚拟页大小为 P = 2^p 字节。也即，将磁盘的一块空间，分为一个个虚拟页，(每个字节,每个虚拟页有相应的虚拟地址。)</p>
</li>
<li><p><strong>物理页 Physical Page (PP) / 页帧 page frame</strong>：物理内存被分割为物理页，大小也为P字节。</p>
</li>
</ul>
</li>
<li><p>虚拟页面被分为三个不相交的子集</p>
<ul>
<li><strong>未分配的</strong>：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和他们关联，因此也就不占用任何磁盘空间</li>
<li><strong>缓存的</strong>：当前已经缓存在物理内存（主存）中的已分配页</li>
<li><strong>未缓存的</strong>：未缓存在物理内存（主存）中的已分配页</li>
</ul>
</li>
</ul>
<h3 id="DRAM-Cache-Organization-DRAM作为缓存的组织结构"><a href="#DRAM-Cache-Organization-DRAM作为缓存的组织结构" class="headerlink" title="DRAM Cache Organization DRAM作为缓存的组织结构"></a>DRAM Cache Organization DRAM作为缓存的组织结构</h3><ul>
<li><p>DRAM作为缓存的不命中比SRAM缓存不命中的代价昂贵很多</p>
<ul>
<li>DRAM    is    about    10x    slower    than    SRAM</li>
<li>Disk    is    about    10,000x    slower    than    DRAM    </li>
</ul>
</li>
<li><p>因此</p>
<ul>
<li>虚拟页往往很大:    typically 4    KB,sometimes 2 MB</li>
<li>全相联<ul>
<li>Any    VP    can    be    placed    in    any    PP</li>
<li>Requires a “large”    mapping    function    –    different from cache memories    </li>
<li>复杂精密的替换算法</li>
<li>Write-back    rather    than    write-through</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Enabling-Data-Structure-Page-Table-页表"><a href="#Enabling-Data-Structure-Page-Table-页表" class="headerlink" title="Enabling Data Structure: Page Table 页表"></a>Enabling Data Structure: Page Table 页表</h3><ul>
<li><p>VM系统需要判断 一个虚拟页VP是否缓存在DRAM中的某个地方</p>
<ul>
<li>如果是（命中），系统则必须要确定这个虚拟页VP存放在那个物理页PP中</li>
<li>如果不是（未命中），系统必须判断这个虚拟页VP存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，然后将虚拟页VP从磁盘复制到DRAM中，替换这个牺牲页。</li>
</ul>
</li>
<li><p>os软件 + MMU中的地址翻译硬件 + 存放在物理内存中叫做<strong>页表</strong>的数据结构 实现该功能</p>
</li>
<li><p><strong>Page table 页表</strong></p>
<ul>
<li>Array of Page Table Entry（页表条目）</li>
<li><strong>maps virtual    pages to physical pages</strong>.    </li>
<li>virtual address space 虚拟地址空间 中的每个 VP虚拟页 在 Page Table页表 中一个固定偏移量处都有一个PTE。</li>
<li><strong>PTE的valid bit = 0</strong><ul>
<li>NULL 表示这个虚拟页还未被分配</li>
<li>不是NULL ，则指向该虚拟页在磁盘的起始位置</li>
</ul>
</li>
<li><strong>PTE的valid bit = 1</strong><ul>
<li>地址为DRAM中相应的物理页的起始位置</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-20-50-52.png"></p>
<ul>
<li>valid bit = 1 : VP1、VP2、VP4、VP7被缓存在DRAM中</li>
<li>valid bit = 0 : <ul>
<li>非null : 已经被分配，但还没被缓存。VP3、VP6</li>
<li>null : 没被分配。VP0、VP5</li>
</ul>
</li>
<li>PTE数量 = 虚拟地址空间大小 / 虚拟页大小 （因为一个VP相应的要有一个PTE）</li>
</ul>
</li>
</ul>
<h3 id="Page-Hit-页命中"><a href="#Page-Hit-页命中" class="headerlink" title="Page Hit 页命中"></a>Page Hit 页命中</h3><ul>
<li><p>示例：CPU要读取包含在VP2中的虚拟内存的一个字（已知VP2被缓存在DRAM中）</p>
<ul>
<li>VM页命中。对VP2中一个字的引用就会命中<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-21-58-51.png"></li>
</ul>
</li>
<li><p><strong>虚拟地址VA —–MMU地址翻译硬件—-&gt; 定位PTE</strong> –在内存中读取PTE–&gt; </p>
<ul>
<li>—-&gt; valid bit = 1 —-&gt; VP2已经缓存在DRAM中  —&gt;</li>
<li>—-&gt; 使用PTE中的DRAM（物理内存）地址（该地址指向PP1中缓存页的起始位置（在DRAM中的地址）） —–&gt; 构造出这个字在DRAM中的物理地址</li>
</ul>
</li>
<li><p>MMU如何工作具体看下面</p>
</li>
</ul>
<h3 id="Page-Fault-缺页"><a href="#Page-Fault-缺页" class="headerlink" title="Page Fault 缺页"></a>Page Fault 缺页</h3><ul>
<li><strong>缺页 page fault</strong>：VM系统中，DRAM缓存不命中称为缺页<ul>
<li>reference    to    VM    word    that    is    not    in    physical    memory    (DRAM    cache    miss)</li>
</ul>
</li>
<li>示例：CPU引用VP3中的一个字（已知VP3并未缓存在DRAM中）<ul>
<li>VP3不命中（缺页），对VP3中的字的引用也就不命中，触发Page Fault</li>
</ul>
</li>
<li>虚拟地址VA —MMU的地址翻译硬件—-&gt; 定位PTE —在主存中读取PTE—&gt;<ul>
<li>valid bit = 0 —-&gt; VP3没被缓存  &amp;&amp; !=null —-&gt; 指向虚拟页VP3在磁盘的起始位置</li>
<li>—&gt; <strong>触发缺页异常 cause Page Fault</strong><br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-22-37-30.png"></li>
<li>—&gt; <strong>kernel call Page Fault handler</strong><ul>
<li><strong>在DRAM中选择一个PP存放的的VP作为牺牲页</strong><br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-22-50-13.png"></li>
<li><strong>kernel 将VP3从磁盘copy到DRAM，并更新PTE3，随后返回。</strong><br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-22-50-27.png"></li>
</ul>
</li>
<li>Page Fault Handler return to I_cur ， 造成Page Fault的指令<strong>重新执行</strong>，此时<strong>Page Hit</strong>，该指令将正常的从内存读取字，而不会再产生Page Fault。<ul>
<li>该指令将VA重新发送给硬件，但是VP3已经缓存在DRAM中，故Page Hit。<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-22-52-37.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>VM系统使用了和SRAM缓存不同的术语</p>
<ul>
<li>VM中 <strong>块</strong> 被称为 <strong>页</strong></li>
<li>VM中 磁盘和内存之间传送页的行为称为<strong>交换（swapping）</strong>或者<strong>页面调度（paging）</strong></li>
<li>页从磁盘<strong>换入</strong>（或者<strong>页面调入</strong>）DRAM和从DRAM<strong>换出</strong>（或者<strong>页面调出</strong>）磁盘</li>
<li><strong>demand paging 按需页面调度</strong>：waiting until the miss to copy the page from disk to DRAM </li>
</ul>
</li>
<li><p>MMU如何工作具体看下面</p>
</li>
</ul>
<h3 id="Allocating-Pages-分配页面"><a href="#Allocating-Pages-分配页面" class="headerlink" title="Allocating Pages 分配页面"></a>Allocating Pages 分配页面</h3><ul>
<li>当os分配了一个新的虚拟内存页，对页表有何影响？<ul>
<li>只影响了PTE和disk，并不改变DRAM的PP    </li>
<li>如下调用malloc的结果，<ul>
<li>Allocating    a    new    page    (VP    5)    of    virtual    memory.</li>
<li>在磁盘上创建空间</li>
<li>更新PTE5，指向这个新创建的页面。</li>
<li><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-15-23-08-37.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Locality-局部性-makes-VM-work"><a href="#Locality-局部性-makes-VM-work" class="headerlink" title="Locality 局部性 makes VM work"></a>Locality 局部性 makes VM work</h3><ul>
<li>Virtual    memory    seems    terribly    inefficient,    but    it    works    because    of    locality</li>
<li>尽管整个运行过程中程序引用的不同页面总数可能超出DRAM总的大小，但是Locality保证了任意时刻，程序趋向于在一个较小的活动页面（active page）几何上工作，这个集合称为<strong>工作集（working set）</strong>或者<strong>常驻集合（resident set）</strong><ul>
<li>Programs    with    bigger    temporal    locality    will    have    smaller    working    sets</li>
</ul>
</li>
<li>If    (working    set    size    &lt;    main    memory    size)<ul>
<li>Good    performance    for    one    process    aier    compulsory    misses</li>
<li>在初始开销，也就是将工作集页面调度到内存中之后，接下来对这个working set的引用将集中命中，而不会产生额外磁盘IO</li>
</ul>
</li>
<li>If    (    SUM(working    set    sizes)    &gt;    main    memory    size    )<ul>
<li><strong>Thrashing 抖动:</strong> Performance    meltdown where    pages    are    swapped    (copied)    in    and    out    continuously</li>
</ul>
</li>
</ul>
<h2 id="VM-as-a-Tool-for-Memory-Management-虚拟内存作为内存管理的工具"><a href="#VM-as-a-Tool-for-Memory-Management-虚拟内存作为内存管理的工具" class="headerlink" title="VM    as a Tool    for    Memory    Management    虚拟内存作为内存管理的工具"></a>VM    as a Tool    for    Memory    Management    虚拟内存作为内存管理的工具</h2><h3 id="Page-Table-–-Virtual-Address-Space"><a href="#Page-Table-–-Virtual-Address-Space" class="headerlink" title="Page Table – Virtual Address Space"></a>Page Table – Virtual Address Space</h3><ul>
<li>如何为每个进程维护一个虚拟地址空间？<ul>
<li>os为每个进程提供了一个独立的页表page table，<strong>页表page table维护了虚拟地址空间virtual address space</strong>。</li>
<li>每个进程的虚拟地址空间实际上就是kernel的page table。（虚拟地址 -翻译-&gt; 相应PTE –&gt; 相应DRAM / 触发page fault ）</li>
<li>如下图 progess i的page table将i的虚拟地址空间里的VP1（逻辑上的，不存在的一个VP）映射到DRAM中的PP2，VP2-&gt;PP7 ; progess j 的page table 将 VP1 -&gt; PP7 , VP2-&gt;PP10。<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-13-44-28.png"></li>
</ul>
</li>
</ul>
<h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><ul>
<li><strong>简化链接</strong></li>
<li><strong>简化加载</strong><br>程序员可以认为每个进程有一个非常相似的虚拟地址空间<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-14-00-18.png"></li>
<li><strong>简化共享</strong> <ul>
<li>如何让多个进程<strong>共享</strong>代码、数据？<ul>
<li>让不同进程的page table的PTE指向同一个PP（共享库的实现方式）</li>
<li><strong>每个进程都必须调用相同的kernel代码</strong>，每个C程序都会调用C标准库，通过上述方式，可以使得多个进程共享这部分代码的副本，<strong>而不是在每个进程中都包括单独的kernel和C库的副本，</strong></li>
</ul>
</li>
<li>mmap</li>
</ul>
</li>
<li><strong>简化内存分配</strong><ul>
<li>K个连续的虚拟内存页面，可以映射到DRAM中任意位置的k个物理页面。（可以随机分散在DRAM中）</li>
</ul>
</li>
</ul>
<h3 id="虚拟内存-虚拟地址空间"><a href="#虚拟内存-虚拟地址空间" class="headerlink" title="虚拟内存 != 虚拟地址空间"></a>虚拟内存 != 虚拟地址空间</h3><ul>
<li><strong>虚拟地址空间 和 虚拟内存不是一回事！ 反正我这么认为</strong></li>
<li><strong>虚拟地址空间：cpu(通过地址总线32位能力)寻址虚拟出来的一个范围</strong>。</li>
<li><strong>而虚拟内存：实实在在的硬盘的空间。所以，虚拟内存分割成的的虚拟页也都是实实在在的磁盘空间。</strong>，而虚拟地址空间划分的虚拟页，是想象出来的，逻辑上的，(实际上不存在这个VP表，而是一个页表，)这个虚拟页要去指向一个DRAM中的PP，DRAM中的PP，保存的是从磁盘缓存来的实际虚拟内存的VP页。</li>
<li>cpu认为他有4G内存空间是因为CPU的地址总线有32位，最大的寻址能力就为4G</li>
<li>而DRAM实际上没这么大，所以它想出办法，将硬盘的一部分拿过来，当作主存，骗cpu；并给这块骗人的地方，起名字叫 虚拟内存。（如何用虚拟内存骗人的？DRAM是虚拟内存的缓存，如果DRAM中有cpu要引用的页，那么直接从DRAM里拿，如果没有，那么根据替换算法，选择DRAM中的牺牲页，将要引用的磁盘里的虚拟页替换进来。</li>
</ul>
<h2 id="VM-as-a-tool-for-memory-protection-虚拟内存作为内存保护的工具"><a href="#VM-as-a-tool-for-memory-protection-虚拟内存作为内存保护的工具" class="headerlink" title="VM as    a    tool for    memory    protection 虚拟内存作为内存保护的工具"></a>VM as    a    tool for    memory    protection 虚拟内存作为内存保护的工具</h2><ul>
<li><p>os需要有手段来控制对内存系统的访问，如</p>
<ul>
<li>不允许用户进程修改rodata段</li>
<li><strong>不允许它读或修改任何kernel中的代码和数据结构</strong></li>
<li>不允许它读或者写其他progess的私有内存</li>
<li>不允许他修改任何与其他进程共享的虚拟页面（指向同一PP的VP），除非所有的共享者都显式地允许他这么做。</li>
</ul>
</li>
<li><p>CPU每生成一个VP,MMU都会读一个PTE，因此在PTE上加permission bits<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-14-18-17.png"></p>
</li>
<li><p><strong>segmentation fault</strong></p>
<ul>
<li>如果有指令违反了这些条件，就会触发异常：<strong>一般保护故障</strong></li>
<li>Linux shell一般报告为 段错误(segmentation fault)</li>
</ul>
</li>
</ul>
<h2 id="VM-Effect-Summary"><a href="#VM-Effect-Summary" class="headerlink" title="VM Effect Summary"></a>VM Effect Summary</h2><h3 id="Programmer’s-view-of-virtual-memory"><a href="#Programmer’s-view-of-virtual-memory" class="headerlink" title="Programmer’s    view    of    virtual    memory"></a>Programmer’s    view    of    virtual    memory</h3><ul>
<li>Each    process    has    its    own    private    linear    address    space</li>
<li>Cannot    be    corrupted    by    other    processes</li>
</ul>
<h3 id="System-view-of-virtual-memory"><a href="#System-view-of-virtual-memory" class="headerlink" title="System    view    of    virtual    memory"></a>System    view    of    virtual    memory</h3><ul>
<li>Uses    memory    efficiently    by    caching    virtual    memory    pages    （from disk to DRAM）<ul>
<li> Efficient    only    because    of    locality</li>
</ul>
</li>
<li>Simplifies    memory    management    and    programming</li>
<li> Simplifies    protection    by    providing    a    convenient    interpositioning    point<br>to    check    permissions</li>
</ul>
<h2 id="VM地址翻译-Address-translation"><a href="#VM地址翻译-Address-translation" class="headerlink" title="VM地址翻译 Address    translation"></a>VM地址翻译 Address    translation</h2><ul>
<li>MMU地址翻译大体分为两步<ul>
<li>将VA翻译为PA（涉及TLB）</li>
<li>将PA送至缓存</li>
</ul>
</li>
</ul>
<h3 id="概念-amp-公式"><a href="#概念-amp-公式" class="headerlink" title="概念 &amp; 公式"></a>概念 &amp; 公式</h3><ul>
<li><strong>Virtual    Address    Space     VAS 虚拟地址空间</strong> <ul>
<li>V    =    {0,    1,    …,    N–1}    </li>
</ul>
</li>
<li><strong>Physical Address    Space    PAS 物理地址空间</strong><ul>
<li>P    =    {0,    1,    …,    M–1}</li>
</ul>
</li>
<li><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-16-14-46.png"></li>
<li><strong>地址翻译</strong>：一个N元素的VAS中的元素 和一个 M元素的PAS中元素之间的映射 </li>
<li><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-16-21-19.png"><ul>
<li>For    virtual    address    a:    <ul>
<li>MAP(a)        =        a’        if    data    at    virtual    address    a    is    at    physical    address    a’ in    P    </li>
<li>MAP(a)        =    ∅ if    data    at    virtual    address    a    is    not    in    physical    memory    <ul>
<li>Either    invalid    or    stored    on    disk    </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MMU工作-amp-Page-Table细节"><a href="#MMU工作-amp-Page-Table细节" class="headerlink" title="MMU工作 &amp; Page Table细节"></a>MMU工作 &amp; Page Table细节</h3><ul>
<li><p>Virtual address 如何定位到 PTE &amp;&amp; Page Table里的PTE如何对应到相应物理地址？</p>
<ul>
<li>通过MMU。</li>
</ul>
</li>
<li><p>MMU是个硬件，其中没有page table，page table是存储在dram中的！</p>
</li>
<li><p><strong>MMU功能</strong>：</p>
<ul>
<li><strong>根据VA计算PTEA ：PTEA = register + VPN</strong>，CPU —VA—&gt; MMU —PTEA—&gt; DRAM</li>
<li><strong>根据PTE计算PA ：PA = PPN + PPO</strong>，MMU &lt;–PTE– DRAM , MMU –PA–&gt; DRAM</li>
<li><strong>TLB ：PTE缓存，根据VA快速获取PTE</strong>。<ul>
<li>根据VA(VPN)查看是否缓存了VA对应的PTE，如果是，那么直接返回缓存的PTE，不必到dram中的pagetbale查询。不是，则去查询pagetable</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-16-49-34.png"></p>
<ul>
<li><strong>n位的virtual address</strong>：<ul>
<li><strong>p位VPO</strong> 虚拟页面偏移（virtual page offset）+ 一个 <strong>n-p位的VPN</strong> 虚拟页号（virtual page number）<ul>
<li><strong>VPN</strong>就是讲缓存的时候讲的<strong>tag标记</strong></li>
<li><strong>VPO</strong>就是讲缓存的时候讲的<strong>offset块偏移</strong></li>
<li>没有组索引，是因为因为代价很大，采用了全相联。</li>
</ul>
</li>
</ul>
</li>
<li><strong>m位的physical address</strong><ul>
<li><strong>PPN</strong>（physical page number）物理页号 + <strong>PPO</strong>（physical page offset）物理页偏移量 </li>
</ul>
</li>
<li><strong>MMU —-VPN和PTBR—-&gt;计算出PTEA —&gt; 确定PTE —-&gt; 取出PPN —–&gt; +VA里的VPO —-&gt; 得到相应物理地址</strong>（因为VP和PP都是P字节的，所以PPO=VPO）</li>
</ul>
</li>
</ul>
<p>PTEA : VPN虚拟页号 + PTBR页表基地址</p>
<h3 id="Page-Hit-页命中-1"><a href="#Page-Hit-页命中-1" class="headerlink" title="Page Hit 页命中"></a>Page Hit 页命中</h3><ul>
<li>完全由硬件处理<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-17-29-27.png"></li>
<li><ol>
<li>cpu生成virtual address，并把它传送给MMU</li>
</ol>
</li>
<li><ol start="2">
<li>MMU生成PTE Address，并向高速缓存SRAM/主存DRAM请求得到它</li>
</ol>
</li>
<li><ol start="3">
<li>高速缓存/主存向MMU返回PTE</li>
</ol>
</li>
<li><ol start="4">
<li>MMU构造physical address，并将其传送给高速缓存SRAM/主存DRAM</li>
</ol>
</li>
<li><ol start="5">
<li>高速缓存SRAM/主存DRAM讲所请求的data返回给cpu<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- 1. cpu ---VA---&gt; MMU</span><br><span class="line">- 2. MMU ---PTEA---&gt; SRAM/DRAM</span><br><span class="line">- 3. MMU &lt;---PTE--- SRAM/DRAM</span><br><span class="line">- 4. MMU ---PA----&gt; SRAM/DRAM</span><br><span class="line">- 5. CPU &lt;---data---  SRAM/DRAM</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="Page-Fault-缺页-1"><a href="#Page-Fault-缺页-1" class="headerlink" title="Page Fault 缺页"></a>Page Fault 缺页</h3><ul>
<li><p>由硬件和os kernel协作完成<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-17-34-19.png"></p>
</li>
<li><ol>
<li>cpu —VA—&gt; MMU</li>
</ol>
</li>
<li><ol start="2">
<li>MMU —PTEA—&gt; SRAM/DRAM</li>
</ol>
</li>
<li><ol start="3">
<li>MMU &lt;—PTE— SRAM/DRAM</li>
</ol>
</li>
<li><ol start="4">
<li>PTE的有效位为0，因此MMU触发了一次page fault exception，传递cpu中的控制到kernel中的page fault handler</li>
</ol>
</li>
<li><ol start="5">
<li>page fault handler选出了dram中的牺牲页，如果该victim has been modified，则把它换出到磁盘disk</li>
</ol>
</li>
<li><ol start="6">
<li>page fault handler 调入新的页面到DRAM（将DRAM中的VP拷贝到DRAM中的PP），并更新page table中的PTE</li>
</ol>
</li>
<li><ol start="7">
<li>return to I_cur，再次执行导致page fault的指令。cpu将VA重新发送给MMU，因为VP已经被缓存在DRAM中，故命中。重复Page Hit行为</li>
</ol>
</li>
<li><p>VA的VPN，VPO；PA的PPN，PPO计算</p>
<ul>
<li>2^VPO = size of P / 2^PPO = sizeof P</li>
<li><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-16-17-56-52.png"></li>
</ul>
</li>
</ul>
<h3 id="高速缓存-VM"><a href="#高速缓存-VM" class="headerlink" title="高速缓存 + VM"></a>高速缓存 + VM</h3><p><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-17-09-12-52.png"></p>
<h3 id="翻译后备缓冲器-TLB（为了更快得到PTE，进而更快得到PA）"><a href="#翻译后备缓冲器-TLB（为了更快得到PTE，进而更快得到PA）" class="headerlink" title="翻译后备缓冲器 TLB（为了更快得到PTE，进而更快得到PA）"></a>翻译后备缓冲器 TLB（为了更快得到PTE，进而更快得到PA）</h3><ul>
<li><p><strong>Translation Lookaside Buffer TLB</strong>：MMU中包括的一个关于PTE的小缓存</p>
<ul>
<li>CPU生成VA之后要查询PTE<ul>
<li>从DRAM中查询：几十—几百时钟周期</li>
<li>从SRAM中查询：几个时钟周期</li>
</ul>
</li>
<li>优化：增加这个TLB</li>
</ul>
</li>
<li><p>MMU中的通过VA中的VPN来寻找缓存在TLB中的相应PTE</p>
<ul>
<li>划分成t位<strong>组索引TLBI</strong>，和剩余的位作为<strong>行标记TLBT</strong>（如果TLB有T=2^t个组，那么TLB索引(TLBI)则由VPN的低t位组成）<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-17-09-25-56.png"></li>
</ul>
</li>
</ul>
<h4 id="TLB-HIT-TLB命中"><a href="#TLB-HIT-TLB命中" class="headerlink" title="TLB HIT   TLB命中"></a><strong>TLB HIT   TLB命中</strong></h4><p><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-17-09-47-20.png"></p>
<ul>
<li>因为所有地址翻译步骤均由硬件完成，因此快。(减少了一次访存SRAM/DRAM)</li>
<li><ol>
<li>CPU —产生VA—&gt; MMU</li>
</ol>
</li>
<li><ol start="2">
<li>MMU —- VPN —-&gt; TLB     </li>
</ol>
</li>
<li><ol start="3">
<li>TLB —- PTE —-&gt; MMU</li>
</ol>
</li>
<li><ol start="4">
<li>MMU —- PA —-&gt; SRAM/DRAM (MMU根据PTE翻译出PA)</li>
</ol>
</li>
<li><ol start="5">
<li>SRAM/DRAM — data —&gt; CPU </li>
</ol>
</li>
</ul>
<h4 id="TLB-MISS-TLB不命中"><a href="#TLB-MISS-TLB不命中" class="headerlink" title="TLB MISS  TLB不命中"></a><strong>TLB MISS  TLB不命中</strong></h4><p><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-17-09-47-28.png"></p>
<ul>
<li><ol>
<li>CPU —产生VA—&gt; MMU</li>
</ol>
</li>
<li><ol start="2">
<li>MMU —- VPN —-&gt; TLB</li>
</ol>
</li>
<li><ol start="3">
<li>MMU —- PTEA —-&gt; SRAM/DRAM    (MMU根据VA翻译出PTEA)</li>
</ol>
<ul>
<li>TLB没命中，MMU就会利用VA中的VPN和PTBR寄存器中的page table基地址，计算出PTE的地址（PTEA）</li>
</ul>
</li>
<li><ol start="4">
<li>SRAM/DRAM —- PTE —-&gt; TLB &amp;&amp; MMU</li>
</ol>
</li>
<li><ol start="5">
<li>MMU —- PA —–&gt; SRAM/DRAM     (MMU根据PTE翻译出PA)</li>
</ol>
</li>
<li><ol start="6">
<li>SRAM/DRAM —- data —&gt; CPU</li>
</ol>
</li>
</ul>
<h3 id="Multi-Level-Page-Tables-多级页表"><a href="#Multi-Level-Page-Tables-多级页表" class="headerlink" title="Multi-Level    Page    Tables     多级页表"></a>Multi-Level    Page    Tables     多级页表</h3><ul>
<li>Suppose:<ul>
<li> 4KB    (212)    page    size,    48-bit    address    space,    8-byte    PTE</li>
<li>Problem:    <ul>
<li> Would    need    a    512    GB    page    table 常驻内存!</li>
<li> 2^48    *    2^-12     *    2^3    =    2^39    bytes</li>
</ul>
</li>
</ul>
</li>
<li>Solution：<strong>Multi-level Page Tables 多级页表</strong></li>
</ul>
<h4 id="2-level-page-table-二级页表"><a href="#2-level-page-table-二级页表" class="headerlink" title="2-level    page    table 二级页表"></a>2-level    page    table 二级页表</h4><ul>
<li><p>例子：32bit，4bytes per table，VM4GB<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-17-19-32-55.png"></p>
</li>
<li><p><strong>一级页表 level 1 page table</strong></p>
<ul>
<li>每个PTE指向一个level2的page table页表</li>
<li>常驻内存 （memory resident）</li>
<li>例子中每个level1的PTE最终map到一个4MB的虚拟内存VM</li>
</ul>
</li>
<li><p><strong>二级页表 level 2 page table</strong></p>
<ul>
<li>每个PTE指向一个4KB的VP虚拟内存页面</li>
<li>在需要时创建、页面调入或调出</li>
<li>例子中每个level2 page table最终map到一个4MB的虚拟内存VM</li>
</ul>
</li>
<li><p><strong>如何节约内存？</strong></p>
<ul>
<li>如果一级页表中的一个PTE为空，那么相应的二级页表则不会存在。<ul>
<li>这是一种巨大的潜在节约，因为对于一个典型的程序，4GB的虚拟地址空间的大部分都是未分配的</li>
</ul>
</li>
<li>只有一级页表才需要总是在主存中（memory resident）；虚拟内存系统可以在需要时创建、页面调入或调出二级页表。减少主存压力<ul>
<li>只有最常用的二级页表才需要缓存在主存中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="K-level-Page-Table-k级页表"><a href="#K-level-Page-Table-k级页表" class="headerlink" title="K-level Page Table k级页表"></a>K-level Page Table k级页表</h4><ul>
<li><p>k级页表层次结构的地址翻译</p>
</li>
<li><p><strong>page table register 中存储的是page table的PA物理地址</strong>。因为第一个page table是在dram中的。使用物理地址，我们可以直接找到在dram中找到page table。如果是虚拟地址的话，则会出现递归查询。（因为那样就要先把VA翻译成PA，而这个过程就是我们正在执行的过程。出现递归查询了。）<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-17-20-02-12.png"></p>
</li>
<li><p>第k级页表中的每个PTE </p>
<ul>
<li>要么包含某个物理页面的PPN，<strong>这个PPN是一个DRAM的页面基地址（physical page 的 base addr），这个页面，cached了一个虚拟内存里的VM的内容。</strong></li>
<li>要么包含一个磁盘块地址</li>
<li>NULL？</li>
</ul>
</li>
<li><p>为了构造物理地址PA = PPN+PPO</p>
<ul>
<li>MMU必须访问k个PTE来确定PPN</li>
<li>PPO = VPO</li>
</ul>
</li>
<li><p>访问k个PTE，看起来很慢，实际上通过TLB将不同层次的table缓存起来，并不比单级页表慢很多。</p>
</li>
</ul>
<h3 id="Address-translation-例子"><a href="#Address-translation-例子" class="headerlink" title="Address translation 例子"></a>Address translation 例子</h3><ul>
<li><p>CPU —&gt; VA —VPN(TLBT,TLBI)—&gt; TLB</p>
<ul>
<li>TLB命中<ul>
<li>获取PTE —-&gt; PNN —(+VPO)–&gt; PA(CT,CI,CO) —-&gt; 防蚊SRAM<ul>
<li>SRAM Hit ,return data to cpu</li>
<li>SRAM Miss , 根据PA访问DRAM , return data to cpu</li>
</ul>
</li>
</ul>
</li>
<li>TLB不命中<ul>
<li>访问SRAM/DRAM的Page Table中的PTE<ul>
<li>PTE valid bit = 1，取出PPN <ul>
<li>—(+VPO)–&gt; 组成PA(CT,CI,CO) —-&gt; 访问SRAM<ul>
<li>SRAM Hit ,return data to cpu</li>
<li>SRAM Miss , 根据PA访问DRAM , return data to cpu</li>
</ul>
</li>
</ul>
</li>
<li>PTE valid bit = 0，缺页 Page Fault<ul>
<li>kernal调入合适的页面（复制磁盘的VP到DRAM得PP，更新PTE）</li>
<li>重新运行造成page fault的指令<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-18-16-48-10.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>例子<br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-18-10-34-53.png"><br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-18-10-43-48.png"><br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-18-10-50-33.png"><br><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-18-10-55-51.png"></p>
</li>
<li><p>cpu执行一条读地址0x03d4处的字节的加载指令时</p>
<ul>
<li><strong>VA</strong><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-18-11-00-22.png"></li>
<li>MMU —VPN 0x0f(TLBT=0x03,TLBI=0x03)—&gt; TLB HIT,PPN = 0x0D</li>
<li>PA = PPN 0x0D + VPO 0x14 = 0x354 </li>
<li><strong>PA</strong><img src="/2022/07/25/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2022-08-18-11-14-33.png"></li>
<li>访问SRAM，CI=0x05,CT=0x0d,CO=0x0. SRAM HIT。return 0x36 to CPU</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-Lab</title>
    <url>/2022/08/19/csapp-Shell-Lab/</url>
    <content><![CDATA[<p>实现简易Shell</p>
<span id="more"></span>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li><p><a href="https://www.cnblogs.com/qingergege/p/5914218.html">getopt</a></p>
</li>
<li><p>shell执行一系列的读/求值步骤，然后终止</p>
<ul>
<li><ol>
<li>读步骤       读取来自用户的一个命令行     fgets</li>
</ol>
</li>
<li><ol start="2">
<li> 求值步骤     解析命令行，并代表用户运行   eval</li>
</ol>
<ul>
<li>2.1     前台 or 后台                                     parseline</li>
<li>2.2     whether shell内置命令 or executable可执行文件     builtin_command </li>
<li>2.3     not builtin_command  — execve / builtin_command — execute immediately</li>
</ul>
</li>
</ul>
</li>
<li><p>tsh原理流程图（不严谨画的，但意思是那个意思）<br><img src="/2022/08/19/csapp-Shell-Lab/2022-08-23-19-37-48.png"><br><img src="/2022/08/19/csapp-Shell-Lab/2022-08-23-20-48-23.png"></p>
</li>
</ul>
<h2 id="几个值得注意的地方。"><a href="#几个值得注意的地方。" class="headerlink" title="几个值得注意的地方。"></a>几个值得注意的地方。</h2><ul>
<li>由tsh fork出的子进程所在的进程组所执行的job 通过job list : jobs 管理。每个job结构体记录job的pid(进程组组长的，也即该job的），jid，state，cmdline。</li>
</ul>
<ul>
<li><p>tsh的前台进程组就是占据了tsh输入的进程组</p>
</li>
<li><p><strong>waitfg做的事情就是占据终端。</strong></p>
<ul>
<li><strong>通过busy loop实现，一直spin自旋。</strong></li>
<li><strong>直到检测到前台进程组组长改变。</strong></li>
</ul>
</li>
<li><p>脚本运行bug：解释器错误: 没有那个文件或目录</p>
<ul>
<li>windows下，每一行的结尾是\n\r，而在linux下文件的结尾是\n，那么你在windows下编辑过的文件在linux下打开看的时候每一行的结尾就会多出来一个字符\r,用cat -A yourfile时你可以看到这个\r字符被显示为^M，这时候只需要删除这个字符就可以了。</li>
<li>ssh连接linux<ul>
<li>但是还是编辑在windows下的vscode下</li>
<li><strong>记得去掉trace(不然参数传递的个数会与预期不符）和sdriver.pl中多余的回车符号 \r(ASCII13)</strong></li>
</ul>
</li>
<li><strong><code>sed -i &#39;s/\r$//&#39; yourfile</code></strong></li>
</ul>
</li>
<li><p>限制比较字符个数也可通过n<a href="https://stackoom.com/question/1eBSS">strncmp</a></p>
</li>
</ul>
<h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><ul>
<li><p>main(parent)</p>
<ul>
<li>对于终端键入的SIGINT以及SIGTSTP信号，tsh的<strong>main</strong>(parent)负责对其进行<strong>forward</strong>转发，转发给<strong>foreground</strong>（通过sigint_handler和sigtstp_handler）</li>
<li>对于CHILD死亡后产生的SIGCHLD信号，tsh的main(parent)负责wait、回收。（通过sigchld_handler）</li>
</ul>
</li>
<li><p>child</p>
<ul>
<li>根据以下 <strong>child会继承parent的handler，但是由于execve</strong>，因此，不必手动恢复默认，child对SIGINT，SIGTSTP，SIGCHLD的信号都是默认的或由child execve的prog自己决定。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  没必要手动恢复</span></span><br><span class="line">Signal(SIGINT, SIG_DFL);  <span class="comment">//  change to default (so child progess would terminated instead of forwarding the signal)</span></span><br><span class="line">Signal(SIGTSTP, SIG_DFL); <span class="comment">//  change to default (so child progess would stopped instead of forwarding the signal) </span></span><br></pre></td></tr></table></figure></li>
<li>A  child created via <strong>fork</strong>(2) <strong>inherits</strong> a copy of its parent’s signal <strong>dispositions</strong>.  </li>
<li>During an <strong>execve</strong>(2), the dispositions of handled signals are reset to the <strong>default</strong>; the dispositions of ignored signals are left unchanged.</li>
</ul>
</li>
<li><p>Why parent should forward SIGINT and SIGTSTP ？ </p>
<ul>
<li>信号机制中 信号由前台进程组的所有信号接收</li>
<li>fork出的子进程，默认和其父进程同属一个进程组，而我们的tsh是运行在Linux shell的foreground中，因此tsh以及其fork出的child都是Linux shell的foreground</li>
<li>所以，如果键入一个信号，将发送给我们tsh fork出的所有子进程，并且也包括tsh的main</li>
<li>所以我们的tsh fork出的每个子进程，在execve之前，都要独立成一个进程组(setpgid(0,0))</li>
<li>这样保证Linux shell的前台进程组只有我们的tsh</li>
<li>当键入信号时，shell可以将信号正确转发给应当接收信号的进程组</li>
<li>This ensures that there will be only one process, your shell, in the foreground process group. When you type ctrl-c, the shell should catch the resulting SIGINT and then forward it to the appropriate foreground job (or more precisely, the process group that contains the foreground) </li>
</ul>
</li>
</ul>
<ul>
<li>return value of waitpid <ul>
<li>on success, returns the process ID of the child whose state has changed; </li>
<li>if WNOHANG was specified and one or more child(ren) specified by pid exist, but  have not yet changed state, then 0 is returned.  </li>
<li>On error, -1 is returned.</li>
</ul>
</li>
</ul>
<ul>
<li><p>waitpid(-1, &amp;status, 0)</p>
<ul>
<li>block等待parent的所有child死亡。</li>
<li>return -1 &amp;&amp; errno = echild 代表子进程已经全部回收。</li>
</ul>
</li>
<li><p>waitpid(-1, &amp;status, WNOHANG)</p>
<ul>
<li>不block等待parent的child死亡</li>
<li>return 0 if progess of set is not terminated(change state)</li>
</ul>
</li>
<li><p>waitpid(-1, &amp;status, WNOHANG | WUNTRACED)</p>
<ul>
<li>不block等待set中的progess terminated or stopped</li>
<li>WUNTRACED 与默认不同。默认等待terminated发出的SIGCHLD，WUNTRACED等待STOPPED发出的SIGCHLD</li>
<li>== 0 剩余的子进程都没terminate/stop</li>
<li>== -1 error</li>
</ul>
</li>
</ul>
<ul>
<li><strong>好难找</strong>：这条只能在之前的waitpid是block的时候用！（检验是否还有剩余的子进程（正在运行的、停止的、僵尸的都算剩余的(exits)）。因为如果是WNOHANG，此时出while后，set中仍然有unwaited-for child，打印errno是success，不是ECHILD<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ECHILD : The calling process does <span class="keyword">not</span> have any unwaited-<span class="keyword">for</span> children.</span><br><span class="line"><span class="keyword">if</span>(errno! = ECHILD)&#123;</span><br><span class="line">  unix_error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>关于SIGCHLD信号应当由waitfg还是sigchld_handler来wait ANSWER FROM HINT</strong><ul>
<li>One of the tricky parts of the assignment is deciding on the allocation of work between the waitfg and sigchld handler functions. We recommend the following approach:<br>– In waitfg, use a busy loop around the sleep function.<br>– In sigchld handler, use exactly one call to waitpid</li>
<li>While other solutions are possible, such as calling waitpid in both waitfg and sigchld handler, these can be very confusing. It is simpler to do all reaping in the handler.（qs，之前没看hint，直接写，大多数情况SIGCHLD是被sigchld handler接收了）</li>
</ul>
</li>
</ul>
<ul>
<li><p>父进程死了，子进程在之前被停止，那么子进程不会死。如下，子进程被stopped，tsh死了之后，子进程仍然是stopped</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    2  53179      0      0 ?            -1 I        0   0:00 [kworker/u256:2-]</span><br><span class="line">    1  53235  53234  40687 ?            -1 R     1000   1:38 ./tsh -p</span><br><span class="line">**53235  53239  53239  40687 ?            -1 T     1000   0:00 ./myspin 5**</span><br><span class="line">  4522  53604   4522   4522 ?            -1 S     1000   0:00 sleep 180</span><br></pre></td></tr></table></figure></li>
<li><p>在操作全局的data structure :jobs时，建议<del>上锁</del>，block所有信号，以防止信号打断触发的handler里面对jobs进行modify。</p>
<ul>
<li>在tsh中，和 main 为并发关系，且可以操作jobs的，就是main注册handler。他们均有可能操作jobs structure ，因此要先将所有信号阻塞 防止打断 ，再操作jobs。</li>
</ul>
</li>
</ul>
<ul>
<li><p>关于main的addjob和child 的 data race</p>
<ul>
<li>不能假设addjob在child的excve之前<ul>
<li>如果child先exit，那么就会deletejob一个没记录的job，又会addjob一个不存在的job。</li>
</ul>
</li>
<li>所以应当先为parent block掉SIGCHLD（子进程不block）</li>
<li>当addjob之后，parent再unblock掉SIGCHLD</li>
</ul>
</li>
<li><p>Linux Shell bg和fg的原理是通过SIGCONT信号</p>
<ul>
<li>用bg或fg命令会发SIGCONT, 也可以用kill -SIGCONT PID</li>
<li>fg比起bg就是多了一个占据输入（调用waitfg）（用spin锁 busy loop）</li>
</ul>
</li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ul>
<li>举几个trace<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/Shared_ln/csapp/shlab$ ./sdriver.pl -t trace03.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace03.txt - Run a foreground job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; quit</span><br><span class="line">shc@shc-virtual-machine:~/Shared_ln/csapp/shlab$ ./sdriver.pl -t trace04.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace04.txt - Run a background job.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 1 &amp;</span><br><span class="line">[1] (66506) ./myspin 1 &amp;</span><br><span class="line">shc@shc-virtual-machine:~/Shared_ln/csapp/shlab$ ./sdriver.pl -t trace05.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace05.txt - Process jobs builtin command.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./myspin 2 &amp;</span><br><span class="line">[1] (66540) ./myspin 2 &amp;</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[2] (66542) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (66540) Running ./myspin 2 &amp;</span><br><span class="line">[2] (66542) Running ./myspin 3 &amp;</span><br><span class="line">shc@shc-virtual-machine:~/Shared_ln/csapp/shlab$ ./sdriver.pl -t trace15.txt -s ./tsh -a <span class="string">&quot;-p&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># trace15.txt - Putting it all together</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">tsh&gt; ./bogus</span><br><span class="line">./bogus: Command not found</span><br><span class="line">tsh&gt; ./myspin 10</span><br><span class="line">Job [0] (0) killed by signal 2</span><br><span class="line">tsh&gt; ./myspin 3 &amp;</span><br><span class="line">[1] (66596) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; ./myspin 4 &amp;</span><br><span class="line">[2] (66598) ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (66596) Running ./myspin 3 &amp;</span><br><span class="line">[2] (66598) Running ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">Job [1] (66596) stopped by signal 20</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (66596) Stopped ./myspin 3 &amp;</span><br><span class="line">[2] (66598) Running ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %3</span><br><span class="line">%3: No such job</span><br><span class="line">tsh&gt; <span class="built_in">bg</span> %1</span><br><span class="line">[1] (66596) ./myspin 3 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">jobs</span></span><br><span class="line">[1] (66596) Running ./myspin 3 &amp;</span><br><span class="line">[2] (66598) Running ./myspin 4 &amp;</span><br><span class="line">tsh&gt; <span class="built_in">fg</span> %1</span><br><span class="line">tsh&gt; quit</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>datalab</title>
    <url>/2022/06/06/csapp-Data-Lab/</url>
    <content><![CDATA[<p>位运算 tips</p>
<span id="more"></span>

<h2 id="注意事项及技巧"><a href="#注意事项及技巧" class="headerlink" title="注意事项及技巧"></a>注意事项及技巧</h2><ul>
<li><p>A^B = AB’ + A’B</p>
</li>
<li><p>注意符号扩展！！！</p>
</li>
<li><p>注意有符号数右移时的符号位扩展</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;          <span class="comment">// 1111111...1111</span></span><br><span class="line">cout&lt;&lt;(x&gt;&gt;<span class="number">31</span>)&lt;&lt;endl;    <span class="comment">// 1111111...1111 </span></span><br><span class="line"><span class="comment">// 发生符号位扩展，因为x为有符号数，且符号位为1。故右移时用1填充</span></span><br><span class="line">cout&lt;&lt;((x&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>)&lt;&lt;endl;    <span class="comment">// 00000000...0001</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>两个int立即数异或出的结果立即数，也会进行符号扩展。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x = <span class="number">-2</span>;</span><br><span class="line"><span class="comment">//    int y = -5;</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bitX = x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> bitY = y&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    cout&lt;&lt;bitX&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;bitY&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;(<span class="keyword">unsigned</span>) bitX &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(<span class="keyword">unsigned</span> )bitY&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;=====&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">int</span> check1 = (x&gt;&gt;<span class="number">31</span>) ^ (y&gt;&gt;<span class="number">31</span>); <span class="comment">//  有符号数 异或出1，会进行符号扩展。在赋值给check1之前，就扩展为111111...1111。check1于是为-1：1111..111111</span></span><br><span class="line">    cout&lt;&lt;check1&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt;(<span class="keyword">unsigned</span> )check1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> check2 = bitX ^ bitY;</span><br><span class="line">    cout&lt;&lt;check2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(<span class="keyword">unsigned</span> )check2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    y=<span class="number">-5</span>：</span><br><span class="line">    <span class="number">-2</span> <span class="number">-5</span></span><br><span class="line">    <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line">    <span class="number">4294967295</span> <span class="number">4294967295</span></span><br><span class="line">    =====</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    y=<span class="number">5</span>：</span><br><span class="line">    <span class="number">-2</span> <span class="number">5</span></span><br><span class="line">    <span class="number">-1</span> <span class="number">0</span></span><br><span class="line">    <span class="number">4294967295</span> <span class="number">0</span></span><br><span class="line">    =====</span><br><span class="line">    <span class="number">-1</span> <span class="number">4294967295</span></span><br><span class="line">    <span class="number">-1</span> <span class="number">4294967295</span></span><br></pre></td></tr></table></figure></li>
<li><p>获得符号位的正确操作</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x_sign = x&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;     <span class="comment">//  获取x最高符号位，并将其放到0位</span></span><br><span class="line"><span class="keyword">int</span> y_sign = y&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>;     <span class="comment">//  获取y最高符号位，并将其放到0位</span></span><br><span class="line"><span class="keyword">int</span> sign_xor = x_sign ^ y_sign; <span class="comment">//  x和y符号位是否相同 相同为0，不同为1。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>如何获取一个 m位二进制数（称为待分解数）的低x位</strong><ul>
<li>先定义一个 m位 unsigned 全f 掩码</li>
<li>然后利用unsigned特性(右移左侧补0)右移(m-x)位，然后得到x位全f掩码(高m-x位均为0)</li>
<li>将待分解数与x位全f掩码相&amp;，</li>
<li>得到待分解数的低x位。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mask = <span class="number">0xffffffffffffffff</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> xxxMask = mask &gt;&gt; (m-x);           <span class="comment">//  由于mask为unsigned 故左侧补0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> xxx = xxx &amp; numberToDo;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mask = %lx\txxxMask=%lx\txxx=%ld\n&quot;</span>,mask,xxxMask,xxx);</span><br></pre></td></tr></table></figure></li>
<li>或者也可以通过先左移(m-x)，再右移(m-x)。也是要利用unsigned无符号扩展。</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/06/csapp-Data-Lab/2022-06-09-11-49-53.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp-9-虚拟内存2-Linux内存系统</title>
    <url>/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Linux 内存系统<br>memory map 内存映射</p>
<span id="more"></span>

<h2 id="Linux-内存系统"><a href="#Linux-内存系统" class="headerlink" title="Linux 内存系统"></a><strong>Linux 内存系统</strong></h2><h3 id="Linux-地址翻译"><a href="#Linux-地址翻译" class="headerlink" title="Linux 地址翻译"></a><strong>Linux 地址翻译</strong></h3><ul>
<li><p><strong>结构</strong><br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-18-16-41-13.png"><br>L1-d-TBL 和 L1-i-TLB 这些SRAM中缓存的PTE，是为了防止TLB中找不到相应PTE</p>
</li>
<li><p><strong>地址翻译过程</strong> 注意到是四级页表层次结构<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-18-16-48-10.png"></p>
<ul>
<li><strong>加速技巧</strong></li>
</ul>
</li>
<li><p><strong>由图易知：x64 是 48位虚拟地址 ，52位物理地址</strong></p>
</li>
</ul>
<ul>
<li><p><strong>PTE格式</strong></p>
<ul>
<li>level 1-3<ul>
<li>每个PTE引用一个4KB的子页表（下一级的page table）</li>
<li><strong>组成：page table physical base addr（下一级页表的基地址） + permission bits</strong><br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-18-16-58-14.png"></li>
</ul>
</li>
<li>level 4<ul>
<li>每个PTE引用一个4KB的虚拟内存（实际上存的是DRAM的物理地址）</li>
<li><strong>组成：page physical base addr + permission bits</strong></li>
<li><strong>所存的 page physical base address 就是 PPN</strong><ul>
<li><strong>这个PPN是一个DRAM的页面基地址（physical page 的 base addr），这个页面，cached了一个虚拟内存（位于disk）里的VM的内容。</strong></li>
<li><strong>所以称</strong>，每个PTE引用了一个4KB的虚拟内存。（是指其指向的DRAM的地址的内容是cached的磁盘虚拟内存上的内容）<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-18-17-11-29.png"></li>
</ul>
</li>
</ul>
</li>
<li>PTE的三个权限位<ul>
<li>R/W：页的内容只读/读写</li>
<li>U/S：是否可以用户模式访问（保护kernal的代码和数据不被用户程序访问）</li>
<li>XD：禁止从本页取指令（通过限制只能执行只读代码段，防御缓冲区溢出攻击）</li>
</ul>
</li>
<li>A：引用位（reference bit），用于实现页面替换算法</li>
<li>D：修改位/脏位(dirty bit)</li>
</ul>
</li>
<li><p>MMU如何通过四级页表将VA翻译成PA<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-18-17-47-01.png"></p>
</li>
</ul>
<h3 id="Linux-虚拟内存系统"><a href="#Linux-虚拟内存系统" class="headerlink" title="Linux 虚拟内存系统"></a><strong>Linux 虚拟内存系统</strong></h3><h4 id="Virtual-Address-Space-虚拟地址空间"><a href="#Virtual-Address-Space-虚拟地址空间" class="headerlink" title="Virtual    Address    Space 虚拟地址空间"></a>Virtual    Address    Space 虚拟地址空间</h4><ul>
<li><p><strong>Virtual    Address    Space    of    a    Linux    Process</strong> 一个Linux进程的虚拟地址空间（我觉得不应当叫虚拟内存，你看英文就不这么叫。或者应该叫进程的虚拟内存也不错。）</p>
</li>
<li><p><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-19-08-09-01.png"></p>
<ul>
<li>每个进程共享内核代码和数据结构（Kernel    code    and    data），所以内核虚拟地址空间的这个区域被map映射到所有进程共享的物理页面PP</li>
<li>内核虚拟地址空间的其他区域包含每个进程都不相同的数据，<ul>
<li>page table页表，kernal stack内核在上下文执行代码时使用的栈，task and mm structs 记录虚拟地址空间当前组织的各种数据结构。</li>
</ul>
</li>
</ul>
</li>
<li><p>32位和64位的地址空间<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-10-28-09-24-32.png"></p>
</li>
</ul>
<h4 id="Linux-Organizes-VM-as-Collection-of-“Areas”"><a href="#Linux-Organizes-VM-as-Collection-of-“Areas”" class="headerlink" title="Linux    Organizes    VM    as    Collection    of    “Areas”"></a>Linux    Organizes    VM    as    Collection    of    “Areas”</h4><ul>
<li><strong>Linux 以 区域（也叫做段） 的形式 来管理 虚拟内存（已分配的虚拟地址空间），并把虚拟内存（已分配的虚拟地址空间）作为 区域 的集合</strong><ul>
<li>一个<strong>区域（area）</strong>就是<strong>已经存在着的（已分配的）</strong>（（我认为）但是不一定已经要加载入DRAM中的）的<strong>虚拟内存的连续片</strong>（chunk），这些页以某种方式相关联。</li>
<li>如,.text段,.data段,.bss段,堆,共享库段,以及用户栈都是不同的area区域。</li>
<li><strong>每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。</strong></li>
<li>area的概念很重要，因为它允许虚拟地址空间有间隙。内核不用记录那些<strong>不存在的虚拟页</strong>，而这样的页也<strong>不占用内存、磁盘或者内核本身的任何额外资源</strong>。</li>
</ul>
</li>
</ul>
<ul>
<li><p>kernel通过<strong>task_struct中的mm_struct</strong>来组织进程的虚拟内存。<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-19-08-08-51.png"></p>
<ul>
<li><strong>task_struct</strong>：kernal为os的每个progess维护一个单独的任务结构，其中元素包含内核运行该进程所需的所有信息<ul>
<li>一直说的PCB、PCB。<strong>所谓的PCB，就是这个task_struct</strong></li>
</ul>
</li>
<li><strong>mm_struct</strong>：描述当前虚拟内存状态</li>
<li><strong>pgd</strong>：level 1 page table地址</li>
<li><strong>vm_area_struct 区域结构</strong><ul>
<li>vm_strart：区域的起始处</li>
<li>vm_end：区域的结束处</li>
<li>vm_prot：区域内所有页的读写权限</li>
<li>vm_flags：这个区域内的页面，是与其他进程共享还是私有</li>
<li>vm_next：指向链表中下一个区域的结构</li>
</ul>
</li>
<li>当内核运行某进程时，就将其pgd放在CR3。</li>
</ul>
</li>
<li><p><strong>以上这些所谓的组织虚拟内存，这些都是软件上的，逻辑上的，都是虚拟的，都是Virtual Address Space中的，并没有涉及到MMU将VA翻译成PA的过程，还没走到那里。</strong></p>
</li>
<li><p>vm_area_struct的区域创建了，就代表这那部分虚拟地址空间（虚拟内存）应该有东西，但是实际上那部分东西究竟有没有载入dram，并不知道。</p>
<ul>
<li>如果没有，那么会触发page fault中断，将disk上的相应内容cache入dram</li>
<li>如果有，那么就引用就行了。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>ps:mm_struct的具体成员<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-09-01-20-38-16.png"><br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-09-01-20-38-31.png"></li>
</ul>
<ul>
<li>所谓的一直说的进程控制块<strong>PCB Progess Control Block</strong>,<strong>在Linux下的实现就是task_struct结构体</strong></li>
</ul>
<hr>
<h4 id="Linux-Page-Fault-Handling-Linux缺页异常处理"><a href="#Linux-Page-Fault-Handling-Linux缺页异常处理" class="headerlink" title="Linux Page    Fault    Handling   Linux缺页异常处理"></a>Linux Page    Fault    Handling   Linux缺页异常处理</h4><ul>
<li><p>缺页分三类</p>
<ul>
<li><strong>Segmentation fault 段错误</strong> : 访问一个不存在的页面</li>
<li><strong>Protection    exception 保护异常</strong> : 违反许可，写一个只读的页面</li>
<li><strong>Normal    page    fault    正常缺页</strong> : 可以访问该虚拟页面，但是虚拟页面所映射的虚拟内存，还没有加载到DRAM中，需要加载进来。    </li>
</ul>
</li>
<li><p>MMU翻译某个虚拟地址A时，触发了缺页异常。于是控制转移到kernel的page fault handler。之后</p>
</li>
<li><p><strong>1. 虚拟地址A是合法的吗？</strong></p>
<ul>
<li><strong>也即，A在某个vm_area_struct定义的区域内吗？</strong></li>
<li>handler遍历链表，搜索所有start和end。若不合法（也即不在），那么触发一个<strong>Segmentation fault段错误</strong>。</li>
<li>这种情况就是连malloc还没malloc，连虚拟页面都没有.</li>
</ul>
</li>
<li><p><strong>2. 试图进行的内存访问是否合法？</strong></p>
<ul>
<li><strong>也即，进程是否有读、写或者执行这个区域内页面的权限。</strong></li>
<li>如 用户模式的进程试图从内核虚拟内存中读取字造成的缺页；又如，对只读页面进行写操作的存储指令造成的缺页。</li>
<li>那么，触发一个 <strong>Protection    exception 保护异常</strong></li>
</ul>
</li>
<li><p><strong>3. 此时，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的</strong></p>
<ul>
<li>那么，选择一个牺牲页，如果修改过，就交换出去，换入新的页面并更新页表。handler返回时，cpu重新执行引起缺页的指令。该指令再次将A发送到MMU。这次MMU能正常的翻译而不缺页。</li>
</ul>
</li>
</ul>
<h2 id="Memory-mapping-内存映射"><a href="#Memory-mapping-内存映射" class="headerlink" title="Memory mapping 内存映射"></a>Memory mapping 内存映射</h2><ul>
<li><strong>Memory mapping</strong> : VM    areas    initialized    by    associating    them    with    disk objects.Linux将虚拟内存区域与一个磁盘上的对象关联起来,以初始化这个虚拟内存区域的内容.这个过程,被称作内存映射.</li>
</ul>
<h3 id="映射对象"><a href="#映射对象" class="headerlink" title="映射对象"></a>映射对象</h3><ul>
<li>虚拟内存区域可以映射到的两种类型的对象 <ul>
<li><strong>Regular    file on    disk    Linux文件系统中的普通文件</strong><ul>
<li>一个区域可以映射到一个普通磁盘文件的连续部分(e.g.,    an    executable    object    file) </li>
<li>Initial    page    bytes    come    from    a    section    of    a    file(文件区被分为页大小的片,每一片包含一个虚拟页面的初始内容)</li>
<li><strong>因为按需页面调度,所以这些虚拟页面没有实际交换进入DRAM,直到CPU第一次引用到页面(即发射一个虚拟地址,落在地址空间这个页面的范围之内).如果区域比文件区要大,那么就用0填充这个区域的余下部分.</strong></li>
</ul>
</li>
<li><strong>Anonymous    file    (e.g.,    nothing) 匿名文件</strong><ul>
<li>匿名文件由内核创建,包含的全是二进制0</li>
<li>当cpu引用匿名文件时,调度页面时,用二进制0覆盖victim,并更新页表    ,标记为常驻内存<ul>
<li>页面调度时,disk和dram没有任何数据传送.</li>
</ul>
</li>
<li>Once    the    page    is    wriken    to    (dirtied),    it    is    like    any    other    page</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Swap-File-交换文件"><a href="#Swap-File-交换文件" class="headerlink" title="Swap File 交换文件"></a>Swap File 交换文件</h3><ul>
<li><strong>Dirty    pages    are    copied    back and    forth    between    memory    and    a    special    swap    file.</strong><ul>
<li>dirty page : 一个被初始化过的虚拟页面</li>
<li>swap file 交换文件 也叫做 swap space 交换空间 或者 swap area 交换区域 </li>
<li>任何时刻,swap file 限制着当前运行得进程能够分配的虚拟页面的总数</li>
</ul>
</li>
<li><strong>我认为 我感觉 这个swap file 就是磁盘上的那片虚拟内存吧</strong></li>
</ul>
<h3 id="Sharing-Revisited-Shared-Objects-共享对象"><a href="#Sharing-Revisited-Shared-Objects-共享对象" class="headerlink" title="Sharing    Revisited:    Shared    Objects 共享对象"></a>Sharing    Revisited:    Shared    Objects 共享对象</h3><ul>
<li><p><strong>COW实现?</strong></p>
</li>
<li><p>共享对象 应该就是 <strong>共享库(shared library)的</strong>实现原理吧</p>
</li>
<li><p><strong>内存映射</strong>提供了一种清晰的机制,用来控制多个进程如何<strong>共享对象</strong>.</p>
</li>
<li><p>一个对象可以被映射到虚拟内存的一个区域,要么作为共享对象,要么作为私有对象.</p>
<ul>
<li>作为<strong>共享对象</strong> : 一个进程对这个区域的任何写操作 , 也会反映到这个共享对象映射到的其他进程 . 并且,也会反映在磁盘上的原始对象上.<ul>
<li>一个映射到共享对象的虚拟内存区域称为共享区域</li>
</ul>
</li>
<li>作为<strong>私有对象</strong> : 对四有对象映射到的区域作出的改变,对其他进程是不可见的,也不会反映在磁盘上的对象中 . <ul>
<li>一个映射到私有对象的虚拟内存区域称为私有区域<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-19-11-27-15.png"></li>
</ul>
</li>
<li>即使对象被映射到了多个共享区域,物理内存也只需要存放共享对象的一个副本.</li>
</ul>
</li>
<li><p><strong>COW 写时复制 copy on write</strong>:延迟私有对象中的副本直到最后可能的时刻,充分利用DRAM</p>
<ul>
<li>映射private object的进程,其相应私有区域的<strong>PTE</strong>标记为<strong>read only</strong></li>
<li>且,其相应的<strong>area</strong>区域结构被标记为<strong>私有的写时复制</strong><br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-19-14-07-51.png"></li>
<li>Instruction    writing    to    private    page    triggers    , 触发异常</li>
<li>handler会在DRAM种创建这个私有对象的页面的一个新副本,更新页表条目指向这个新的副本,然后恢复这个页面的可写权限.</li>
<li>控制返回到触发异常的指令,重新执行.<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-19-14-09-52.png"></li>
</ul>
</li>
</ul>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul>
<li><p><strong>fork实现? 共享了什么? 什么不共享?</strong></p>
</li>
<li><p>VM虚拟内存    and    memory    mapping内存映射    explain    how    fork    provides    private    address    space    for    each    process.</p>
</li>
<li><p>fork被当前progess调用时</p>
<ul>
<li>To    create    virtual    address    for    new    new    process    <ul>
<li>Create    exact    copies    of    current    mm_struct,    vm_area_struct区域结构,    and    page    tables页表</li>
<li>Flag    each    page    in    both    processes    as    read-only     — 每个页面的都标记位为只读(因为要实现COW)</li>
<li>Flag    each    vm_area_struct in    both    processes    as    private    COW    — 两个进程中的每个区域结构都标记位私有的写时复制</li>
</ul>
</li>
<li>On    return,    each    process    has    exact    copy    of    virtual    memory    (和刚调用fork时存在的虚拟内存相同的副本)</li>
<li>Subsequent    writes    create    new    pages    using    COW    mechanism<ul>
<li>因此,也就为每个进程保持了私有地址空间的抽象概念</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><blockquote>
<p><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-19-14-31-10.png"><br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-19-14-39-36.png"><br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-09-21-20-43-20.png"></p>
</blockquote>
<ul>
<li><p><strong>加载器如何工作？</strong></p>
</li>
<li><p><code>execve(&quot;a.out&quot;,NULL,NULL)</code> 在当前进程中加载并运行包含在可执行文件a.out中的程序。将executable file a加载进内存。步骤如下<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-09-21-20-49-19.png"></p>
</li>
<li><p><strong>删除已经存在的用户区域；</strong></p>
</li>
<li><p><strong>映射私有区域；</strong></p>
</li>
<li><p><strong>映射共享区域；</strong></p>
</li>
<li><p><strong>设置PC</strong></p>
</li>
<li><p>main开始执行时的用户栈结构<br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-09-21-21-01-14.png"></p>
</li>
</ul>
<h3 id="User-Level-Memory-Mapping-mmap-用户级内存映射"><a href="#User-Level-Memory-Mapping-mmap-用户级内存映射" class="headerlink" title="User-Level    Memory    Mapping     : mmap 用户级内存映射"></a>User-Level    Memory    Mapping     : mmap 用户级内存映射</h3><ul>
<li><p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html">补充</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">TO_READ</a></p>
</li>
<li><p><a href="https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%8B%B7%E8%B4%9D">read mmap</a></p>
</li>
<li><p>read: disk —data—&gt; kernal —data—&gt; user </p>
</li>
<li><p>mmap:disk —data—&gt; kernal —映射到user的虚拟地址空间</p>
</li>
<li><p><strong>mmap不必从内核缓冲区拷贝到用户缓冲区,减少了一次数据拷贝,但是上下文切换次数没减少.(os的内核和用户空间不需要进行任何数据拷贝)</strong></p>
</li>
<li><p><strong>mmap</strong>要求创建一个新的虚拟内存区域,最好是从start开始的一个区域,并将fd指定的对象的一个连续的片(chunk)映射到这个新的区域.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start,<span class="keyword">size_t</span> length,<span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd,<span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>Map    len    bytes    startng    at    offset    offset of    the    file    specified    by    file    description    fd,    preferably    at    address    start    </p>
</li>
<li><p>start : NULL</p>
</li>
<li><p>length : 连续的对象片的大小字节</p>
</li>
<li><p>offset : 从文件开始处偏移量为offset字节的地方开始</p>
</li>
<li><p>prot : 新映射的虚拟内存区域的访问权限位</p>
<ul>
<li>PROT_EXEC : 这个区域内的页面可以由被CPU执行的指令组成</li>
<li>PROT_READ : 这个区域内的页面可读</li>
<li>PROT_WRITE : 这个区域内的页面可写 </li>
<li>PROT_NONE : 这个区域内的页面不能被访问</li>
</ul>
</li>
<li><p>flag : 被映射对象类型的位</p>
<ul>
<li> MAP_ANON : 被映射对象是一个匿名对象</li>
<li> MAP_PRIVATE : 被映射对象是一个私有的,写时复制的对象</li>
<li> MAP_SHARED : 共享对象</li>
</ul>
</li>
<li><p>return: Return    a    pointer    to    start    of    mapped    area    (may    not    be    start)</p>
</li>
</ul>
<p><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-19-15-20-07.png"></p>
<ul>
<li><p><strong>munmap</strong> : 删除虚拟内存的区域</p>
<ul>
<li>删除从虚拟地址start开始,由接下来len字节组成的区域area</li>
<li>也即,<strong>删掉了这个vm_area_struct结构</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *start,<span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line">success : <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">error : <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>我认为：malloc在分配内存的时候，就是创建了几块虚拟页面组成的区域vm_area_struct，并且改变虚拟页面相应PTE，使其指向磁盘上的相应字节。还并没有建设从va到dram中pa的映射，也没有把dram中的physical memory分配给该进程 / 该进程的的user pgtbl 也不知道需要从va到pa建立映射 </p>
</li>
</ul>
<ul>
<li>我认为：mmap在映射内存时，就是将虚拟地址空间里的页面和磁盘上的文件的字节关联了起来，之后在第一次引用这些虚拟内存页面时，发现dram中并没有缓存disk上的这些字节，因此再将disk中的字节换入dram中，改变PTE使其指向dram中的相应physical page</li>
<li>如何将虚拟内存页面和磁盘上的文件的字节关联起来？<ul>
<li>创建了几块虚拟页面组成的区vm_area_struct，并改变了pagetabel上virtual page相应的PTE，使其指向磁盘上相应的文件。</li>
</ul>
</li>
</ul>
<p><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-09-12-13-06-03.png"></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-23-12-47-03.png"></p>
<p>一开始只是建立了映射，进程逻辑上的虚拟地址空间里的虚拟页  映射到了 磁盘上的字节（虚拟内存）<br>（也可称之为进程1的虚拟内存映射到了磁盘上），然后，由于按需页面调度，在第一次引用这个虚拟页的时候，磁盘上的字节会被cached到DRAM中，之后，这个虚拟页的VA所对应的PTE的PA，就是DRAM保存相应内容的PP地址。之后就这么通过VA直接找PA存的内容就行。</p>
<p>虚拟内存系统 页面调入调出作用<br>就是 告诉cpu每个进程 你在你所想象的虚拟地址空间里拿什么地址的内容都行 我都有<br>实际上 有大部分地址的内容都没有在内存中，还在磁盘里躺着<br>但是，当引用到了这部分内容时，VM系统会将磁盘里的相应内容，调度入DRAM<br>再将这部分内容返回给cpu（由于局部性，不会不断地换入换出，还挺高效）</p>
<p>这样，从cpu/用户的角度来看，我想要什么地址的内容，就能拿到什么地址的内容<br>尽管，我所引用的地址，是虚拟的，但我不在乎，我甚至不用知道。<br>因为VM系统（MMU地址翻译）会将我所发射的VA转化成PA，并为我取得相应内容。<br>至于从哪里取得，disk还是dram，用户/cpu不在乎。我能拿到data就可以。</p>
<p><a href="https://www.bilibili.com/video/BV1tN4y1V71B?spm_id_from=333.1007.top_right_bar_window_dynamic.content.click&amp;vd_source=7cf747b91a297d9a0c8581a26188dd95&amp;t=2.6">https://www.bilibili.com/video/BV1tN4y1V71B?spm_id_from=333.1007.top_right_bar_window_dynamic.content.click&amp;vd_source=7cf747b91a297d9a0c8581a26188dd95&amp;t=2.6</a></p>
<p>虚拟内存是一块字节序列？字节存储在磁盘上？<br>    对 是在磁盘上</p>
<p>虚拟内存三大元件：<br>    物理内存（DRAM）<br>    页表    （DRAM）<br>    虚拟内存（磁盘）<br>所谓虚拟内存无非就是一种缓存机制嘛。通过页表 检查我们所需的虚拟内存的相应页面所对应的磁盘内容，是否已经被缓存入物理内存中。</p>
<p>虚拟地址空间可以说就是页表吧</p>
<p><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=18&t=4237.5">mmap</a></p>
<p>【潜水】grey 20:24:02<br>百度面试就让写多线程</p>
<p>【潜水】grey 20:24:04<br>打印</p>
<p>【潜水】grey 20:24:08<br>都忘光了</p>
<p>【潜水】grey 20:24:24<br>还问问完cpp11 thread 再问pthread </p>
<p><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-05-20-32-35.png"></p>
<p><strong><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-05-20-41-52.png"></strong></p>
<p><strong><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-05-20-42-21.png"></strong></p>
<p>》 TODO<br><a href="https://www.bilibili.com/video/BV1iW411d7hd?p=17&amp;vd_source=7cf747b91a297d9a0c8581a26188dd95&amp;t=1962.6">https://www.bilibili.com/video/BV1iW411d7hd?p=17&amp;vd_source=7cf747b91a297d9a0c8581a26188dd95&amp;t=1962.6</a><br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-16-10-06-37.png"><br><img src="/2022/09/01/csapp-9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%982-Linux%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F/2022-08-16-10-18-54.png"></p>
<p>……..:<br>感觉就是 听感觉没啥，一个新系统让你实际 一脸懵， 我就感觉细节还是很重要的，像之前看的一个时间轮实现定时器和堆实现定时器 ，为什么时间轮可以在海量并发下实现定时 而堆排序却不行</p>
<p>……..:<br>看到明白了 时间轮时间复杂度数据量增加也是O（1）级别    堆而言的时间复杂度O（logn）  数据量越多 并发越差  此时设计在优化   </p>
<p>不到叫啥名:<br>请问下xdm 6824需要学什么前置的课程吗</p>
<p>……..:<br>还有就是那个 跳表结构为什么支持高并发  但是我一直不明白 他是如何控制锁粒度去实现的</p>
<h2 id="MORE"><a href="#MORE" class="headerlink" title="MORE"></a>MORE</h2><ul>
<li>task_struct结构体<ul>
<li>linux-5.6.18\include\linux\sched.h<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
<span id="more"></span>

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP_3_程序的机器级表示</title>
    <url>/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<p>Basic x86-64常识以及基本指令<br>Control 条件码相关、循环、跳转表</p>
<span id="more"></span>
<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><h3 id="指令集架构：ISA"><a href="#指令集架构：ISA" class="headerlink" title="指令集架构：ISA"></a>指令集架构：ISA</h3><ul>
<li>architecture（计算机的体系结构，架构）<ul>
<li>also ISA：instruction set architecture 指令集架构</li>
<li>当我们谈论指令和指令集，这是编译器的目标，为你提供一系列指令，告诉机器确切第做了什么</li>
<li>事实证明，关于指令如何实现，硬件的实现者已经想好了。有的速度快，需要很多硬件；有的速度慢，但需要很少的硬件。</li>
<li>所以，人们创建了instruction set architecture 指令集架构这一抽象概念<ul>
<li>编译器的目标是他</li>
<li>如何最好的实现他是硬件研究者需要负责的</li>
</ul>
</li>
<li>处理器实际执行指令是并发执行的，但可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。</li>
</ul>
</li>
</ul>
<h3 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h3><ul>
<li>机器级变成使用多个内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。</li>
<li>程序用虚拟地址寻址，操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存的物理地址</li>
</ul>
<p>text c program —Complier—-&gt; text 汇编asm program —–Assembler—–&gt; binary 文本表示的指令转化成了实际的字节object program ——linker—–&gt; binary executable program</p>
<h2 id="x86-64常识"><a href="#x86-64常识" class="headerlink" title="x86-64常识"></a>x86-64常识</h2><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><ul>
<li><p>汇编中</p>
<ul>
<li>%开头 代表寄存器的实际名称</li>
<li>句点.开头，表示他们事实上不是实际指令，而是直到汇编器和链接器工作的伪指令。<ul>
<li>一些信息提供给调试器，使它能够定位程序的各个部分</li>
<li>一些信息提供给链接器，告诉他这是一个全局定义的函数</li>
<li>还有很多其他信息，在一开始的时候不需要考虑他们太多，因此先删掉 </li>
</ul>
</li>
</ul>
</li>
<li><p>例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/csapp_try$ ll</span><br><span class="line">总用量 36</span><br><span class="line">drwxrwxr-x  2 shc shc 4096 5月  31 20:36 ./</span><br><span class="line">drwxr-xr-x 20 shc shc 4096 5月  31 19:43 ../</span><br><span class="line">-rw-rw-r--  1 shc shc  194 5月  31 20:36 main.c</span><br><span class="line">-rw-rw-r--  1 shc shc  102 5月  31 19:46 mstore.c</span><br><span class="line">-rw-rw-r--  1 shc shc 1400 5月  31 20:01 mstore.o</span><br><span class="line">-rw-rw-r--  1 shc shc  393 5月  31 19:46 mstore.s</span><br><span class="line">-rwxrwxr-x  1 shc shc 8456 5月  31 20:36 prog*</span><br></pre></td></tr></table></figure></li>
<li><p><strong>gcc -Og -S mstore.c</strong></p>
<ul>
<li>O : Optimize 优化</li>
<li>mstore.c-&gt;mstore.s：c语言编译器产生汇编代码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/csapp_try$ cat mstore.s</span><br><span class="line">  .file	<span class="string">&quot;mstore.c&quot;</span></span><br><span class="line">  .text</span><br><span class="line">  .globl	multstore</span><br><span class="line">  .type	multstore, @function</span><br><span class="line">multstore:</span><br><span class="line">.LFB0:</span><br><span class="line">  .cfi_startproc</span><br><span class="line">  pushq	%rbx</span><br><span class="line">  .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">  .cfi_offset <span class="number">3</span>, <span class="number">-16</span></span><br><span class="line">  movq	%rdx, %rbx</span><br><span class="line">  call	mult2@PLT</span><br><span class="line">  movq	%rax, (%rbx)</span><br><span class="line">  popq	%rbx</span><br><span class="line">  .cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">  ret</span><br><span class="line">  .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">  .size	multstore, .-multstore</span><br><span class="line">  .ident	<span class="string">&quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span></span><br><span class="line">  .section	.note.GNU-stack,<span class="string">&quot;&quot;</span>,@progbits</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>gcc -Og -c mstore.c</strong></p>
<ul>
<li>mstore.c-&gt;mstore.o。gcc编译并汇编，生成目标代码文件（机器代码文件）。二进制格式，无法vim直接查看</li>
<li><strong>gdb查看.o文件</strong><ul>
<li><strong>disassemble 函数名</strong>：查看函数二进制代码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/csapp_try$ gdb mstore.o</span><br><span class="line">...</span><br><span class="line">For help, type <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from mstore.o...(no debugging symbols found)...done.</span><br><span class="line">(gdb) disassemble multstore</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function multstore:</span><br><span class="line">  <span class="number">0x0000000000000000</span> &lt;+<span class="number">0</span>&gt;:	push   %rbx</span><br><span class="line">  <span class="number">0x0000000000000001</span> &lt;+<span class="number">1</span>&gt;:	mov    %rdx,%rbx</span><br><span class="line">  <span class="number">0x0000000000000004</span> &lt;+<span class="number">4</span>&gt;:	callq  <span class="number">0x9</span> &lt;multstore+<span class="number">9</span>&gt;</span><br><span class="line">  <span class="number">0x0000000000000009</span> &lt;+<span class="number">9</span>&gt;:	mov    %rax,(%rbx)</span><br><span class="line">  <span class="number">0x000000000000000c</span> &lt;+<span class="number">12</span>&gt;:	pop    %rbx</span><br><span class="line">  <span class="number">0x000000000000000d</span> &lt;+<span class="number">13</span>&gt;:	retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>反汇编器：objdump</strong></p>
<ul>
<li><strong>objdump -d mstore.o</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/csapp_try$ objdump -d mstore.o</span><br><span class="line"></span><br><span class="line">mstore.o：     文件格式 elf64-x86<span class="number">-64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> &lt;multstore&gt;:</span><br><span class="line">  <span class="number">0</span>:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  <span class="number">1</span>:	<span class="number">48</span> <span class="number">89</span> d3             	mov    %rdx,%rbx</span><br><span class="line">  <span class="number">4</span>:	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">9</span> &lt;multstore+<span class="number">0x9</span>&gt;</span><br><span class="line">  <span class="number">9</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">03</span>             	mov    %rax,(%rbx)</span><br><span class="line">  c:	<span class="number">5b</span>                   	pop    %rbx</span><br><span class="line">  d:	c3                   	retq   </span><br></pre></td></tr></table></figure></li>
<li><strong>机器代码.o及其反汇编表示的特性</strong><ul>
<li>x86-64的指令长度为1~15字节</li>
<li>设计指令格式方式：从某个给定位置开始，可以唯一的将字节解码成机器指令。</li>
<li>反汇编程序无法访问源代码，甚至无法访问汇编代码，他只是通过实际代码文件中的字节辨别出来的。</li>
<li>反汇编器使用的指令命名规则与gcc生成的汇编代码使用的有细微差别。反汇编器可能省略指令结尾的后缀q（大小指示符）　　　　　</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>gcc -Og -o prog main.c store.c</strong><ul>
<li>链接：对一组目标代码文件运行链接器。</li>
<li>prog 比.o大，因为还包含了启动和终止程序的代码。</li>
<li><strong>objdump -d prog。可执行文件也可以进行反汇编。</strong><ul>
<li><strong>与机器代码文件mstore.o反汇编的代码几乎完全一样。但也有不同点</strong>：<ul>
<li><strong>重定位</strong>：链接器将这段代码地址移到了一段不同的地址范围中。</li>
<li>链接器填上了mult2的地址：<strong>链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。</strong></li>
<li>多行nop。（为了让下一个函数的地址是16的倍数？）存储性能高。　<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">0000000000000739</span> &lt;mult2&gt;:</span><br><span class="line"><span class="number">739</span>:	<span class="number">48</span> <span class="number">89</span> f8             	mov    %rdi,%rax</span><br><span class="line"><span class="number">73</span>c:	<span class="number">48</span> <span class="number">0f</span> af c6          	imul   %rsi,%rax</span><br><span class="line"><span class="number">740</span>:	c3                   	retq   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000741</span> &lt;multstore&gt;:</span><br><span class="line"><span class="number">741</span>:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line"><span class="number">742</span>:	<span class="number">48</span> <span class="number">89</span> d3             	mov    %rdx,%rbx</span><br><span class="line"><span class="number">745</span>:	e8 ef ff ff ff       	callq  <span class="number">739</span> &lt;mult2&gt;</span><br><span class="line"><span class="number">74</span>a:	<span class="number">48</span> <span class="number">89</span> <span class="number">03</span>             	mov    %rax,(%rbx)</span><br><span class="line"><span class="number">74</span>d:	<span class="number">5b</span>                   	pop    %rbx</span><br><span class="line"><span class="number">74</span>e:	c3                   	retq   </span><br><span class="line"><span class="number">74f</span>:	<span class="number">90</span>                   	nop</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="寄存器-Register"><a href="#寄存器-Register" class="headerlink" title="寄存器(Register)"></a>寄存器(Register)</h3><ul>
<li><strong>整数寄存器x86-64 Integer Register</strong><ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-21-43-35.png"></li>
<li>有的用来存储地址/整数数据；有的记录某些重要的程序状态；有的用来保存临时数据（参数、局部变量、函数返回值）</li>
<li><strong>%rsp</strong>比较特殊，我们不能随意改变，因为这里面存的是栈指针，指向当前栈顶（stack top）</li>
<li>1word = 2bytes。quad word：4字、8bytes、64位；long word：2字、4Bytes、32bit；word：1字、2Bytes、16bit；Bytes：1字节、8bit</li>
</ul>
</li>
<li><strong>程序计数器</strong>：通常写作PC，x86-64中用%rip表示（instruction pointer）。给出将要执行的下一条指令再内存中的地址。不是我们可以正常访问的寄存器（但也有一些技巧可以获得），它只是告诉我们程序执行到了哪里。</li>
<li><strong>条件码寄存器</strong>：保存最近执行的算术或者逻辑指令的状态信息。（用于实现if等条件控制语句）</li>
<li>一组向量寄存器可以存放1或多个整数或浮点数值</li>
<li>%rax和%eax和%ax的关系<ul>
<li>%rax是64位寄存器</li>
<li>%eax是32位寄存器</li>
<li>%ax是16位寄存器</li>
<li>操作%eax就是操作%rax的低32位；同理%ax<h3 id="操作数-Operand"><a href="#操作数-Operand" class="headerlink" title="操作数(Operand)"></a>操作数(Operand)</h3></li>
</ul>
</li>
<li>立即数（immediate）<ul>
<li>Example：$0400,$-533</li>
<li>Like C constant ,but prefixed with $</li>
<li>encoded with 1,2 or 4 bytes</li>
</ul>
</li>
<li>寄存器（register）：上图十六个整形寄存器之一<ul>
<li>example：%rax，%r13</li>
<li>but % rsp reserved for special use</li>
<li>Others have special uses for particular instructions</li>
<li>用ra表示任意寄存器a；R[ra]、Reg[ra]表示它存的值</li>
</ul>
</li>
<li>内存（memory）:x consecutive bytes of memory at address given by register<ul>
<li>example：(%rax)</li>
<li>various other “address mode”</li>
<li>Mb[Addr]：表示对存储在内存中开始的b个字节值得引用，通常省略b。或者mem[addr]。（因此mem[reg[addr]] 就是用寄存器存储的值作为地址进行寻址）</li>
</ul>
</li>
</ul>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ul>
<li><blockquote>
<p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-15-44-54.png"></p>
</blockquote>
</li>
<li>mov后缀 <ul>
<li>movb：传送字节</li>
<li>movw：传送字</li>
<li>mobl：传送双字（long word 32位被称为长字）</li>
<li>movq：传送四字</li>
<li>1字 = 2bytes。1byte=8bit</li>
</ul>
</li>
</ul>
<h3 id="内存地址编码方式"><a href="#内存地址编码方式" class="headerlink" title="内存地址编码方式"></a>内存地址编码方式</h3><ul>
<li><blockquote>
<p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-11-45-13.png"></p>
</blockquote>
</li>
<li>Simple Memory addressing modes。<ul>
<li>normal：(R)  —- mem[reg[R]]<ul>
<li>寄存器R中存的就是内存地址</li>
<li>movq (%rcx),%rax ：%rax = *(%rcx)</li>
</ul>
</li>
<li>displacement：D(R) —- mem[reg[R]+D]<ul>
<li>R中存储内存基地址，向高偏移D个Bytes，得到目标地址</li>
<li>movq 8(%rbp),%rdx ：%rdx = *(%rbp+8)</li>
</ul>
</li>
</ul>
</li>
<li>Complete Memory Addressing Modes<ul>
<li>most genernal form ： D(Rb,Ri,S) —- mem[reg[Rb] + S*reg[Ri] + D]<ul>
<li> 数组引用常见形式</li>
<li>D：偏移量。1 / 2 / 4 Bytes</li>
<li>Rb：该寄存器存储目标内存基地址   </li>
<li>Ri：下标寄存器</li>
<li>Scale：比例。1 / 2 / 4 / 8 Bytes。数组元素的数据类型大小。</li>
</ul>
</li>
<li>special cases<ul>
<li>(Rb,Ri) —- mem[reg[Rb]+reg[Ri]]。</li>
<li>D(Rb,Ri) —- mem[reg[Rb]+Reg[Ri]+D]</li>
<li>(Rb,Ri,S) —- mem[reg[Rb]+S*reg[Ri]]</li>
</ul>
</li>
</ul>
</li>
<li>附：<ul>
<li>用ra表示任意寄存器a；R[ra]、Reg[ra]表示它存的值</li>
<li>Mb[Addr] 表示对存储在内存中开始的b个字节值得引用。通常省略b</li>
<li>基址寄存器rb和变址寄存器ri必须都是64位寄存器。（因为64位系统）</li>
</ul>
</li>
</ul>
<h3 id="指令类"><a href="#指令类" class="headerlink" title="指令类"></a>指令类</h3><ul>
<li>在这些指令中，有很多负责和生成1、2、4、8字节值。当这些指令以寄存器为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样。对此有如下规则<ul>
<li>生成1byte和2bytes的指令会保持剩下的高位字节不变。</li>
<li>生成4bytes的指令会把高位4个bytes置为0。</li>
</ul>
</li>
</ul>
<h4 id="ATT与Intel区别"><a href="#ATT与Intel区别" class="headerlink" title="ATT与Intel区别"></a>ATT与Intel区别</h4><ul>
<li>ATT与Intel格式区别（终于解决了我之前看学c++时看反汇编的迷惑）<ul>
<li>ATT：用于gcc、objdump</li>
<li>Intel：用于微软、Intel</li>
<li>Intel代码省略指示大小的后缀q。（ATT：pushq；Intel：push）</li>
<li>Intel代码省略寄存器名字前面的%。（ATT：%eax；Intel：eax）</li>
<li>二者用不同方式描述内存位置<ul>
<li>ATT：(%rbx) 使用%rbx寄存中的内容作为addr去寻址</li>
<li>Intel：QWORD PTR [rbx]</li>
</ul>
</li>
<li>多操作数时，顺序相反。</li>
</ul>
</li>
</ul>
<h4 id="MOV类：数据传送指令"><a href="#MOV类：数据传送指令" class="headerlink" title="MOV类：数据传送指令"></a>MOV类：数据传送指令</h4><ul>
<li>mov的src和dst<ul>
<li><a href="https://stackoverflow.com/questions/2397528/">https://stackoverflow.com/questions/2397528/</a></li>
<li>mov dest, src称为 Intel syntax 。 (例如mov eax, 123)</li>
<li>mov src, dest称为 AT&amp;T syntax 。 (例如mov $123, %eax)</li>
<li>包括GNU汇编器在内的UNIX汇编器使用AT＆T语法，所有其他x86汇编器都使用Intel语法</li>
<li>mov指令的两个操作数src和dst必须同样大小（没使用movz类和movs类时）</li>
<li><blockquote>
<p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-05-24-19-50-55.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>机器不允许直接将数据从一个内存位置复制到另一个内存位置。需要使用两个指令。<ul>
<li>先将内存的值移到寄存器中</li>
<li>再将寄存器中的值移到内存中</li>
</ul>
</li>
<li>understanding swap<ul>
<li><blockquote>
<p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-05-30-09-07-35.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="MOVS类-MOVZ类"><a href="#MOVS类-MOVZ类" class="headerlink" title="MOVS类 MOVZ类"></a>MOVS类 MOVZ类</h4><ul>
<li>MOVZ类：把目的中剩余的字节填充为0</li>
<li>MOVS类：把目的中剩余的字节通过符号扩展填充</li>
<li>MOVS和MOVZ都是以寄存器或内存地址作为src，寄存器作为dest</li>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-21-28-33.png"></li>
<li>例子<ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-21-32-37.png"></li>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-21-32-48.png"></li>
</ul>
</li>
</ul>
<ul>
<li>三连错。。啧啧</li>
<li>练习题3.2<br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-14-31-20.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> movl, 因为%eax为<span class="number">2</span>字<span class="number">4b</span>ytes32位寄存器</span><br><span class="line"><span class="number">2.</span> movw, 因为%dx为<span class="number">1</span>字<span class="number">16</span>位寄存器</span><br><span class="line"><span class="number">3.</span> movb, 因为%bl为<span class="number">1b</span>yte寄存器</span><br><span class="line"><span class="number">4.</span> movb, 因为%dl为<span class="number">1b</span>yte寄存器</span><br><span class="line"><span class="number">5.</span> movq, 因为%rax为<span class="number">4</span>字<span class="number">64</span>位寄存器</span><br><span class="line"><span class="number">6.</span> movw, 因为%dx为<span class="number">1</span>字<span class="number">16</span>位寄存器</span><br><span class="line">从题中可以看出一个重要特性，x86<span class="number">-64</span> 中的内存引用总是用四字长寄存器给出，例如 %rax，哪怕操作数只是一个字节、一个字或是一个双字</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>练习题3.3<br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-13-58-45.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> x86<span class="number">-64</span>中的内存引用总是用<span class="number">4</span>字长<span class="number">64</span>位寄存器给出，如%rax。所以改为movb $<span class="number">0xF</span>,(%rbx)</span><br><span class="line"><span class="number">2.</span> %rax是<span class="number">64</span>位寄存器，应当用movq %rax ,(%rsp)</span><br><span class="line"><span class="number">3.</span> <span class="built_in">movw</span> (%rax),<span class="number">4</span>(%rsp)。mov的src和dst不能同时都是地址</span><br><span class="line"><span class="number">4.</span> 没有寄存器叫%sl</span><br><span class="line"><span class="number">5.</span> immediate不能作为dst</span><br><span class="line"><span class="number">6.</span> <span class="number">64</span>位%eax和<span class="number">32</span>位%rdx大小不一致。改为movl %eax,%edx；或者movq %rax,%rdx</span><br><span class="line"><span class="number">7.</span> %si是<span class="number">2</span>字<span class="number">16b</span>ytes寄存器，应当改为 movl %si,<span class="number">8</span>(%rbp) 或者 movb %sil,<span class="number">8</span>(%rbp)</span><br></pre></td></tr></table></figure></li>
<li>练习题3.4<br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-21-45-18.png"><br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-01-20-47-55.png"><ul>
<li>注意点<ul>
<li>movz、movs指令以寄存器或内存地址作为源，以寄存器作为目的</li>
<li>发生的是有符号扩展还是无符号扩展，也即使用的是movs类还是movz类，是看源操作数是什么，也就是由将发生符号扩展(类型转换)的数本身是什么类型决定的，而不是看目的数是什么类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="lea：加载有效地址"><a href="#lea：加载有效地址" class="headerlink" title="lea：加载有效地址"></a>lea：加载有效地址</h4><p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-02-17-42-37.png"></p>
<ul>
<li>lea指令：load effective address。将src表达的地址值赋值给Dst<ul>
<li>leaq Src Dst（AT&amp;T syntax）<ul>
<li>src is address mode expression andset dest to address denoted by expression</li>
<li>第一个操作数src看上去是一个内存引用，但实际上根本没有引用内存。该lea指令不是从指定的内存地址读取数据，而是将这个(地址表达式)作为结果写入dest寄存器。</li>
</ul>
</li>
<li>作用：<ul>
<li>计算地址 p = &amp;x[i]</li>
<li>计算数值 x + k*y</li>
</ul>
</li>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x*<span class="number">12</span>;    </span><br><span class="line">  <span class="comment">// convert to asm by complier</span></span><br><span class="line">  <span class="built_in">leaq</span> (%rdi,%rdi,<span class="number">2</span>),%rax  ：reg[%rax] = reg[%rdi]+reg[%rdi]*<span class="number">2</span> = <span class="number">3</span> * %rdi</span><br><span class="line">  salq $<span class="number">2</span> , %rax             ：%rax &lt;&lt; <span class="number">2</span> = %rax * <span class="number">4</span> = <span class="number">12</span> &amp; %rdi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">arith</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">long</span> t1 = x+y;    t1 ：</span><br><span class="line">  <span class="keyword">long</span> t2 = z+t1;   t2 ：</span><br><span class="line">  <span class="keyword">long</span> t3 = x+<span class="number">4</span>;    </span><br><span class="line">  <span class="keyword">long</span> t4 = y*<span class="number">48</span>;</span><br><span class="line">  <span class="keyword">long</span> t5 = t3+t4;</span><br><span class="line">  <span class="keyword">long</span> rval = t2*t5;</span><br><span class="line">  <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arith：</span><br><span class="line">  <span class="built_in">leaq</span> (%rdi,%rsi),%rax     ---&gt; %rax = %rdi+%rsi   <span class="comment">//  t1</span></span><br><span class="line">  addq %rdx,%rax            ---&gt; %rax += %rdx       <span class="comment">//  t2</span></span><br><span class="line">  <span class="built_in">leaq</span> (%rsi,%rsi,<span class="number">2</span>),%rdx   ---&gt; %rdx = <span class="number">2</span>*rsi + %rsi = <span class="number">3</span>*%rsi   </span><br><span class="line">  salq $<span class="number">4</span> , %rdx            ---&gt; %rdx &lt;&lt;= <span class="number">4</span>         <span class="comment">//  t4</span></span><br><span class="line">  leaq <span class="number">4</span>(%rdi,%rdx),%rcx    ---&gt; %rcx = %rdx + %rdi + <span class="number">4</span> <span class="comment">//  t5   t3 = %rdi + 4</span></span><br><span class="line">  imulq %rdx,%rax           ---&gt; %rax = %rax * %rcx <span class="comment">// rval</span></span><br><span class="line">  ret       </span><br><span class="line"></span><br><span class="line">%rdi x</span><br><span class="line">%rsi y</span><br><span class="line">%rax t1 t2 val</span><br><span class="line">%rdx t4</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="push、pop：压入、弹出栈数据"><a href="#push、pop：压入、弹出栈数据" class="headerlink" title="push、pop：压入、弹出栈数据"></a>push、pop：压入、弹出栈数据</h4><ul>
<li>栈底：高地址。栈顶：低地址。栈由高地址向低地址增长。栈底在上，就是栈顶向下方向增长；栈底在下，就是栈顶向上增长。</li>
<li>栈指针：%rsp。栈顶元素的地址是栈中元素最低的。<ul>
<li>%rsp中的指针指向的内存空间有内容，该指针指向的是栈顶地址最低的归本栈帧（有内容）的内存单元</li>
</ul>
</li>
<li>pushq：pushq %rbp<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">subq $<span class="number">8</span>,%rsp</span><br><span class="line">movq %rbp,(%rsp)</span><br></pre></td></tr></table></figure></li>
<li>popq：popq %rax<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">movq</span> (%rsp),%rax</span><br><span class="line">addq $<span class="number">8</span>,%rsp</span><br></pre></td></tr></table></figure>
<img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-02-17-29-03.png"></li>
</ul>
<h4 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h4><ul>
<li>左移不分算数、逻辑；右移分算数、逻辑<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">salq src dst  dst = dst &lt;&lt; src  </span><br><span class="line">shlq src dst  dst = dst &lt;&lt; src  <span class="comment">//  和上一行相同，两者作用一样 都是向左移动。右边填0；只有右移操作需要区分有符号数无符号数。</span></span><br><span class="line">sarq src dst  dst = dst &gt;&gt; src  <span class="comment">// 算数右移</span></span><br><span class="line">shrq src dst  dst = dst &gt;&gt; src  <span class="comment">// 逻辑右移</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-02-17-43-55.png"></p>
<ul>
<li><p>addq,subq,imulq,salq，sarq,shrq,xorq,andq,orq等，都是src在前，dest在后。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">addq src dst  dst = dst + src</span><br><span class="line">subq src dst  dst = dst - src</span><br><span class="line">imulq src dst dst = dst * src</span><br><span class="line">xorq src dst  dst = dst ^ src</span><br><span class="line">andq src dst  dst = dst &amp; src</span><br><span class="line">orq  src dst  dst = dst | src  </span><br></pre></td></tr></table></figure></li>
<li><p>xorq %rdx,%rdx作用</p>
<ul>
<li>将%rdx置0；等价于movq $0,%rdx</li>
<li>xorq版本只用3个Bytes。movq版本需要7个Bytes</li>
<li>其他将%rdx置0的方法都依赖于该属性:任何更新寄存器低4Bytes的的操作，都会将高位Bytes置为0。因此，可以使用 xorl %edx,%edx（2Bytes） ；或者 movl $0,%edx（5Bytes）</li>
</ul>
</li>
<li><p>乘法：(i)mulq</p>
<ul>
<li>imulq src,dst ：dst = src*dst</li>
<li>imulq S：R[%rax] = R[%rax]*S</li>
<li>存储128位乘积时需要两次mov。<ul>
<li>movq %rax,(%rdi)</li>
<li>movq %rdx,8(%rdi)</li>
</ul>
</li>
</ul>
</li>
<li><p>除法：(i)divq</p>
<ul>
<li>被除数：%rdx AND %rax</li>
<li>余数：%rdx</li>
<li>商：%rax</li>
</ul>
</li>
<li><p>例子<br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-02-18-01-14.png"><br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-02-18-04-22.png"></p>
<ul>
<li>cqto：隐含读出%rax的符号位，并复制到%rdx的所有位</li>
<li>无符号除法（divq）时，不用cqto，而是一般先将%rdx设置为0，其他我认为都一样。</li>
</ul>
</li>
<li><p>涉及到内存（存储器）才有大小端问题，寄存器里没有大小端呀，顶多叫高位字节 低位字节</p>
</li>
</ul>
<h1 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h1><h2 id="information-about-currently-executing-program"><a href="#information-about-currently-executing-program" class="headerlink" title="information about currently executing program"></a>information about currently executing program</h2><ul>
<li>temproary data（临时量）：<ul>
<li>%rax…</li>
</ul>
</li>
<li>location of runtime stack：<ul>
<li>%rsp(栈指针)：指向当前栈顶</li>
</ul>
</li>
<li>location of current code control point<ul>
<li>%rip（当前程序运行到哪里）：给出将要执行的下一条指令再内存中的地址。不是我们可以正常访问的寄存器（但也有一些技巧可以获得），它只是告诉我们程序执行到了哪里。</li>
</ul>
</li>
<li><strong>条件码 Single bit register</strong><ul>
<li><strong>CF</strong>：进位标志。最近的操作使得最高位发生进位。可用来检查<strong>无符号溢出</strong><ul>
<li>据群友讨论 CF = （最高位是否向更高发生进位） ^ （加法0 减法1）。（计算规则为采用补码，也即减法时需要先将-x变为+(-x)补）</li>
<li>csapp里只说了最高位发生进位，说得应当是减法时，仍用-x，而不使用-x的补码形式来相加。</li>
</ul>
</li>
<li><strong>ZF</strong>：零表示。最近的操作结果为0</li>
<li><strong>SF</strong>：符号标志。最近的操作得到的结果为负数</li>
<li><strong>OF</strong>：溢出标志。最近的操作导致<strong>补码溢出</strong>–正溢出或负溢出<h2 id="Condition-Codes"><a href="#Condition-Codes" class="headerlink" title="Condition Codes"></a>Condition Codes</h2><h3 id="Set-Condition-Code"><a href="#Set-Condition-Code" class="headerlink" title="Set Condition Code"></a>Set Condition Code</h3><h4 id="Implicitly-Setting：addq、subq一类…"><a href="#Implicitly-Setting：addq、subq一类…" class="headerlink" title="Implicitly Setting：addq、subq一类…"></a>Implicitly Setting：addq、subq一类…</h4></li>
</ul>
</li>
<li>他们在算数过程中是如何被设置的？如 addq Src,Dest &lt;-&gt; t=a+b。他们的设置可以被认为是算数运算的副作用。<ul>
<li>CF：(unsigned) t&lt;(unsigned) a</li>
<li>ZF：t=-0</li>
<li>SF：t&lt;0（signed）</li>
<li>OF：a&gt;0&amp;&amp;b&gt;0&amp;&amp;t&lt;0 || a&lt;0&amp;&amp;b&lt;0&amp;&amp;t&gt;=0</li>
</ul>
</li>
<li>lea指令不会设置这些标志位，</li>
</ul>
<h4 id="Explicitly-Setting-Compare"><a href="#Explicitly-Setting-Compare" class="headerlink" title="Explicitly Setting: Compare"></a>Explicitly Setting: Compare</h4><p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-04-16-27-09.png"></p>
<ul>
<li>cmpq b,a（cmpq Src2,Src1）<ul>
<li>like computing a-b without setting destination</li>
</ul>
</li>
<li>CF：最高位进位。（当src为unsigned时，该寄存器有意义）</li>
<li>ZF：if a==b</li>
<li>SF：if(a-b)&lt;0 (as signed)</li>
<li>OF：(a&gt;0&amp;&amp;b&lt;0&amp;&amp;(a-b)&lt;0) || (a&lt;0&amp;&amp;b&gt;0&amp;&amp;(a-b)&gt;0)</li>
</ul>
<h4 id="Explicitly-Setting-Test"><a href="#Explicitly-Setting-Test" class="headerlink" title="Explicitly Setting: Test"></a>Explicitly Setting: Test</h4><ul>
<li>testq b,a（testq Src2，Src1）<ul>
<li>like computing a&amp;b without setting destination</li>
</ul>
</li>
<li>sets condition codes based on value of a&amp;b（根据a&amp;b的结果设置条件码）</li>
<li>useful to have one of operands be a mask（适用于有一个操作数是掩码的时候）</li>
<li>ZF set when a&amp;b==0</li>
<li>SF set when a&amp;b&lt;0</li>
<li>典型用法：testq %rax,%rax ：测试%rax是&gt;0 &lt;0 还是=0。<ul>
<li>该指令时有 CF=0，OF=0。</li>
<li>%rax=0时，也即%rax&amp;%rax==0时，才有ZF=1；否则ZF=0。</li>
<li>%rax&gt;0时，%rax&amp;%rax&gt;0，有SF=0；%rax&lt;0时，%rax&amp;%rax&lt;0，有SF=1.</li>
</ul>
</li>
</ul>
<h3 id="Condition-Code-使用"><a href="#Condition-Code-使用" class="headerlink" title="Condition Code 使用"></a>Condition Code 使用</h3><ul>
<li><p>根据条件码组合，将一个字节设置为0或者1</p>
</li>
<li><p>可以<strong>条件跳转</strong>到程序的某个其他部分</p>
</li>
<li><p>可以<strong>条件传送数据</strong></p>
<h4 id="SetX指令"><a href="#SetX指令" class="headerlink" title="SetX指令"></a>SetX指令</h4></li>
<li><p>set后面跟的后缀符号指的是所考虑的条件码的组合，而非什么操作数大小。当setX相对应的条件码组合为1时，将所操作的寄存器低位byte赋值为1。</p>
</li>
<li><p>根据条件码设置某一寄存器的最低字节，寄存器的其他高位bytes不变。</p>
</li>
<li><p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-04-16-32-31.png"><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-05-31-13-25-41.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cmpq b,a    <span class="comment">//  Compare a:b  t = a - b</span></span><br><span class="line">setX %al</span><br><span class="line">movzbl %al,%eax</span><br></pre></td></tr></table></figure></li>
<li><p>有符号数比较的set指令</p>
<ul>
<li>sete : ZF <ul>
<li>a=b时，t=a-b=0</li>
</ul>
</li>
<li>setl : SF^OF<ul>
<li>OF=0（未发生signed溢出）<ul>
<li>SF=1：t=a-b&lt;0 —&gt; a&lt;b</li>
<li>SF=0：t=a-b&gt;=0 —&gt; a&gt;=b</li>
</ul>
</li>
<li>OF=1（发生signed溢出）<ul>
<li>SF=1：t=a-b&lt;0 —&gt; a&gt;0,b&lt;0 发生上溢</li>
<li>SF=0：t=a-b&gt;0 —&gt; a&lt;0,b&gt;0 发生下溢（下溢最夸张也就到1,到不了0：Tmin-Tmax）。有a&lt;b</li>
</ul>
</li>
<li>也即SF^OF代表刚刚的算术结果是个负数</li>
</ul>
</li>
<li>所以有符号的其他比较基于SF^OF和ZF的组合  </li>
<li>setge : ~(SF^OF)</li>
<li>setg : ~(SF^OF)&amp;(~ZF)</li>
<li>setle : (DF^OF)|ZF</li>
</ul>
</li>
<li><p>无符号数比较的set指令</p>
<ul>
<li>sete : ZF<ul>
<li>a=b时,t=a-b=0</li>
</ul>
</li>
<li>setb : CF<ul>
<li>CF：进位标志。CF = （最高位是否向更高发生进位） ^ （加法0 减法1）。（计算规则为采用补码，也即减法时需要先将-x变为+(-x)补）</li>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">au = <span class="number">101</span> = <span class="number">5</span></span><br><span class="line">bu = <span class="number">111</span> = <span class="number">7</span>   -bu -&gt; 补码 = ~bu+<span class="number">1</span> = <span class="number">001</span></span><br><span class="line">au - bu = </span><br><span class="line">  <span class="number">101</span></span><br><span class="line">- <span class="number">111</span></span><br><span class="line">-------</span><br><span class="line">  <span class="number">101</span></span><br><span class="line">+ <span class="number">001</span></span><br><span class="line">-------</span><br><span class="line">  <span class="number">110</span>     = 补码意义下的<span class="number">-2</span>，无符号数意义下的<span class="number">6</span></span><br><span class="line">  由上述知: CF = <span class="number">0</span>^<span class="number">1</span> = <span class="number">1</span></span><br><span class="line">  判断发生溢出，符合预期</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>所以无符号数的set比较基于CF和ZF的组合</li>
<li>seta: ~CF &amp; ~ZF</li>
<li>setbe: CF|ZF</li>
<li>setae: ~CF</li>
<li>setb: CF</li>
</ul>
</li>
<li><p>复习au-bu：计算机中的无符号数减法如何进行 </p>
<ul>
<li>也是按照有符号数补码的计算规则进行（计算机内部就都是补码运算，只不过整数的补码等于其本身，详情间补码原码反码运算博客）</li>
<li>计算出(-bu)的补码，在与au相加，也即 au + (-bu)补。其中(-bu)补 = ~(bu)原+1。（又对于无符号数bu原=b真值）</li>
<li>但是-bu的类型还是无符号数！！！不是有符号数。他只是在按照规则进行位级操作而已，对位的意义如何解释是由-bu的类型决定的，而-bu还是无符号数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;-x&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(x).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(-x).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4294967295</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>练习题</p>
</li>
<li><p>cmpl testl setl 的l所指的东西不一样。前两者指的是操作数的大小。setl的l指的是要进行less比较。</p>
</li>
</ul>
<h4 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h4><p>请见p145-146</p>
<h5 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h5><p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-04-18-19-36.png"></p>
<ul>
<li>jmp：无条件跳转<ul>
<li>直接跳转：jmp *%rax。以%rax的值作为跳转目标</li>
<li>间接跳转：jmp *(%rax)。以%rax的值寻址，从内存中读出跳转目标</li>
</ul>
</li>
<li>条件跳转：根据条件码的组合跳转<ul>
<li>只能直接跳转</li>
</ul>
</li>
<li>跳转指令中，执行PC相对寻址时，程序计数器的值是jX跳转指令<strong>后面</strong>的那条指令的地址，而不是jX本身的地址<ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-04-18-43-20.png"></li>
<li>```bash<br>test %rax,%rax<br>jg .L3<br>jg作用：当%rax&gt;0时，跳转到.L3<br>jg：<del>(SF^OF)&amp;</del>ZF<br>SF^OF：由test%rax,%rax知一定未溢出。故SF^OF代表运算结果为负数<br>ZF：test计算结果为0<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 练习题</span><br><span class="line">  - ![](csapp_3_程序的机器级表示/2022-06-04-18-58-22.png)</span><br><span class="line"></span><br><span class="line">##### 条件控制实现条件分支</span><br><span class="line">- C的if-else</span><br><span class="line">  ```c++</span><br><span class="line">  if(test-expr)</span><br><span class="line">    then-statement</span><br><span class="line">  else </span><br><span class="line">    else-statement</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>汇编形式<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">  <span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">  then-statement</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">  elses-statement</span><br><span class="line">done;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h4><ul>
<li><p>抄书 加深下印象。解决了计组里的疑惑。</p>
</li>
<li><p>处理器通过<strong>流水线</strong>获得高性能，这种方法通过重叠连续指令的步骤来获得高性能。为此，就要实现能确定要执行的指令的顺序，这样才能保证流水线中充满待执行的指令。当机器遇到条件跳转（分支）时，只有当分支条件求值完成后，才能决定分支往哪里走。处理器采用非常精密的<strong>分支预测逻辑</strong>来猜测每条跳转指令是否会执行。只要他的猜测还比较可靠（现代微处理器设计试图达到90%以上的成功率），指令流水线就会充满指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作。然后再开始用从正确位置处起始的指令去填充流水线。正如我们看到的，这样一个错误预测会招致很严重的惩罚，浪费大约15~30个时钟周期，导致程序性能严重下降。</p>
</li>
<li><p>惩罚</p>
<ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-04-19-56-49.png"></li>
</ul>
</li>
<li><p>惩罚分析</p>
<ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-04-19-58-08.png"></li>
<li>A. Tavg = (1-p)*Tok + p*(Tok+Tmp) = Tok + p<em>Tmp<br>   可预测时：p=0；Tok = 16<br>   随机时：31 = Tok + p</em>Tmp = 16 + 0.5*Tmp；Tmp = 30。</li>
<li>B. Trun = Tok + Tmp = 46</li>
</ul>
</li>
</ul>
<h4 id="条件传送指令"><a href="#条件传送指令" class="headerlink" title="条件传送指令"></a>条件传送指令</h4><ul>
<li>一定情况下，基于条件数据传送的代码会比基于条件控制转移的代码性能要好。<h5 id="用条件传送实现条件分支"><a href="#用条件传送实现条件分支" class="headerlink" title="用条件传送实现条件分支"></a>用条件传送实现条件分支</h5></li>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-04-20-17-53.png"></li>
<li>与setX和jX一样，取决于条件码的组合。</li>
<li>与条件跳转不同，处理器无需预测测试结果就可执行条件传送，处理器只是读源值，检查条件码，然后要么更新目的寄存器，要么保持不变。</li>
<li>对比<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v = test-expr ? then-expr:<span class="keyword">else</span>-expr</span><br><span class="line"></span><br><span class="line">条件控制转移</span><br><span class="line">  <span class="keyword">if</span>(!test_expr)</span><br><span class="line">      <span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">  v = then-expr</span><br><span class="line">  <span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">  v = <span class="keyword">else</span>-expr</span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">条件传送代码</span><br><span class="line">v = then-expr</span><br><span class="line">ve = <span class="keyword">else</span>-expr</span><br><span class="line">t = test-expr</span><br><span class="line"><span class="keyword">if</span>(!t) v= ve  <span class="comment">//  该条语句用条件传送实现，只有当测试条件t不满足时，才mov</span></span><br></pre></td></tr></table></figure></li>
<li>当对then-expr和else-expr求值会产生错误条件或者副作用时，不能采用条件传送。</li>
<li>使用条件传送也不总是会提高代码效率。如果then-expr或者else-expr需要大量计算，那么相对应的条件不满足时，所对应工作就白费了。编译器必须考虑浪费的计算和由于分支预测错误所造成的性能处罚之间的相对性能。说实话，编译器并不具有足够信息来做出可靠决定；例如，他们不知道分支会多好的遵循可预测的模式。我们对gcc的实验表明，只有当两个表达式都很容易计算时，例如分支表达式分别都只是条加法指令，他才会使用条件传送。根据我们的经验，即使许多分支预测错误的开销会超过复杂的计算，gcc还是会使用条件控制转移。</li>
<li>总的来说，条件数据传送提供了一种条件控制转移来实现条件操作的替代策略，他们只能用于受限情况，但还是很常见的，且与现代处理器运行方式更契合。</li>
<li>练习<ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-49-45.png"></li>
<li>有符号数除法和无符号除法都是用补码除法的规则，只不过无符号数一定&gt;=0，所以不会有bias的情况。<h3 id="Loop-P149"><a href="#Loop-P149" class="headerlink" title="Loop P149"></a>Loop P149</h3></li>
</ul>
</li>
<li>do-while<blockquote>
<p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-37-12.png"><br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-37-21.png"><br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-37-44.png"></p>
</blockquote>
</li>
<li>while<blockquote>
<p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-51-14.png"><br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-51-42.png"><br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-51-56.png"></p>
</blockquote>
</li>
<li>for<blockquote>
<p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-52-33.png"><br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-12-52-48.png"></p>
</blockquote>
</li>
</ul>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ul>
<li>使用跳转表是一种非常有效的实现多重分支的方式</li>
<li>switch语句：根据一个整数（无符号数）的索引值进行分支跳转。</li>
<li><strong>跳转表</strong><ul>
<li>一个数组，其中的每一个元素都是一个代码段的起始地址</li>
<li>根据提供的索引值i会从跳转表中确定目标代码段地址，执行一个跳转。</li>
<li>优点：执行switch语句的时间与case的数量无关。</li>
<li>GCC会根据case的数量和值的情况来决定如何翻译switch语句。case数量多且值跨度小时，翻译为跳转表方式。</li>
</ul>
</li>
<li>switch语句例子<ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-13-16-08.png"></li>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-13-25-28.png"></li>
<li><strong>跳转表</strong><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-06-13-34-23.png"></li>
<li>跳转表的地址数组索引应当尽量从0开始，所以翻译成汇编时会有相应的偏置值相加减。quad 表示这里需要个8bytes的值。</li>
<li>课堂例子<img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-05-31-16-38-11.png"></li>
</ul>
</li>
</ul>
<ul>
<li>练习题<br><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-06-07-07-45-29.png"></li>
</ul>
<h3 id="Control-小结"><a href="#Control-小结" class="headerlink" title="Control 小结"></a>Control 小结</h3><p><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-05-31-17-04-24.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-EventLoop</title>
    <url>/2022/10/11/muduo-EventLoop/</url>
    <content><![CDATA[<p>EventLoop 类图 及成员 : Channel , Poller , EventLoop<br>muduo事件通知机制 : eventfd</p>
<span id="more"></span>

<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><ul>
<li><p>工作流程大致如下<br><img src="/2022/10/11/muduo-EventLoop/2022-10-17-20-03-57.png"></p>
</li>
<li><p>EventLoop : </p>
<ul>
<li>Reactor(mainReactor和subReactor)的核心！！！</li>
</ul>
</li>
<li><p>主要包含</p>
<ul>
<li>Channel </li>
<li>Poller  – epoll的抽象     </li>
</ul>
</li>
</ul>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ul>
<li><p>实际使用中可分为三种channel : acceptChannel(listengingfd) , connfdChannel,(connfd) wakeupChannel(wakeupFd)</p>
</li>
<li><p>Channel 封装</p>
<ul>
<li>管理的fd</li>
<li>挂在epoll tree上的fd的事件 如fd的EPOLLIN、EPOLLOUT</li>
<li>poller实际监听到的事件</li>
<li>EventHandler </li>
</ul>
</li>
<li><p><strong>重要成员如下</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EventLoop *loop_; <span class="comment">//  EventLoop channel归属于哪个EventLoop 为了获取poller</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> fd_;    <span class="comment">//  fd</span></span><br><span class="line"><span class="keyword">int</span> events_;      <span class="comment">//  fd感兴趣的事件的集合（注册在epoll tree上要被监听的事件的集合）</span></span><br><span class="line"><span class="keyword">int</span> revents_;     <span class="comment">//  poller 实际监听到的事件</span></span><br><span class="line">std::weak_ptr&lt;<span class="keyword">void</span>&gt; tie_;   <span class="comment">//  防止channel调用回调时 TcpConnection被销毁。</span></span><br><span class="line">ReadEventCallback readCallback_; <span class="comment">//  读回调</span></span><br><span class="line">EventCallback writeCallback_;    <span class="comment">//  写回调</span></span><br><span class="line">EventCallback closeCallback_;    <span class="comment">//  连接关闭回调</span></span><br><span class="line">EventCallback errorCallback_;    <span class="comment">//  error回调</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>重要方法如下</strong></p>
</li>
<li><p><strong>update</strong>：将fd及evens_注册在epoll Tree上</p>
<ul>
<li>Channel enable/disable -&gt; update -&gt; EventLoop -&gt; Poller -&gt; epoll_ctl<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;updateChannel(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//  Eventloop -&gt; Poller -&gt; epoll_ctl 更新fd注册在事件表上的event</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>handleEvent</strong>：根据revents，调用相应callback</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEvent</span><span class="params">(<span class="keyword">const</span> Timestamp&amp; receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">            handlerEventWithGuard(receiveTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  根据poller通知的channel发生的具体事件，由channel负责调用具体的回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::handlerEventWithGuard</span><span class="params">(<span class="keyword">const</span> Timestamp&amp; receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 大致如下</span></span><br><span class="line">    <span class="comment">//  对端关闭</span></span><br><span class="line">    <span class="keyword">if</span>(!(revents_ &amp; EPOLLIN) &amp;&amp; (revents_ &amp; EPOLLHUP)) </span><br><span class="line">            closeCallback_();</span><br><span class="line">    <span class="comment">//  普通的读事件</span></span><br><span class="line">    <span class="keyword">if</span>(revents_ &amp; (EPOLLIN | EPOLLPRI))</span><br><span class="line">            readCallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>setXXXCalllback</strong></p>
</li>
<li><p><strong>enable/disable Reading/Writing</strong>…</p>
<ul>
<li>注册到poller上 / 从poller上移除</li>
</ul>
</li>
</ul>
<h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><ul>
<li><p>Poller：封装 event-based核心的IO复用(epoll_开头的相关)函数 的模块。</p>
</li>
<li><p>epoll为例子</p>
</li>
<li><p><strong>重要成员</strong></p>
<ul>
<li><strong>epollfd_</strong> : epfd</li>
<li><strong>events_</strong> : 存储发生事件的集合。传递给epoll</li>
<li><strong>ownerLoop_</strong> : 所属eventLoop</li>
<li><strong>channels&lt;fd,Channel*&gt;</strong> : 记录注册在poller上的fd以及channel。用于将监听的channel 和 记录的channel 进行检验。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>重要方法</strong></p>
</li>
<li><p><strong>poll</strong>：</p>
<ul>
<li>epoll_wait</li>
<li>并将fillActiveChannels，将发生的事件传递给ownerLoop_</li>
<li>适时扩容events_<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  核心代码如下</span></span><br><span class="line"><span class="function">Timestamp <span class="title">EpollPoller::poll</span><span class="params">(<span class="keyword">int</span> timeoutMs,ChannelList *activeChannels)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  epoll_wait  </span></span><br><span class="line">        <span class="comment">//  epoll_event[] 传入传出参数 用来存内核得到事件的集合，</span></span><br><span class="line">        <span class="comment">//  maxevents     epoll总共需要监听多少个events</span></span><br><span class="line">    <span class="keyword">int</span> numEvents = <span class="built_in">epoll_wait</span>(epollfd_ , events_.<span class="built_in">begin</span>().<span class="built_in">base</span>() , <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(events_.<span class="built_in">size</span>()) , timeoutMs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fillActiveChannels</span>(numEvents,activeChannels);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Timestamp::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>removeChannel/updateChannel : 将事件注册/更改/移除</p>
</li>
</ul>
<h2 id="EventLoop-核心逻辑"><a href="#EventLoop-核心逻辑" class="headerlink" title="EventLoop 核心逻辑"></a>EventLoop 核心逻辑</h2><ul>
<li><p><strong>EventLoop 是 Reactor的核心</strong>，是event-based模型的核心。</p>
<ul>
<li><strong>作用：循环 监听事件，获取活跃事件，并且根据发生events，来handleEvent</strong></li>
<li>EventLoop 通过调用 Poller 和 Channel 并协作。</li>
<li>Poller: 监听并获取发生事件 上传给EventLoop(activeChannelList)</li>
<li>Channel: 封装fd以及相应event以及相应callback。EventLoop根据Poller上传的channel 来调用handleEvent 处理事件。</li>
</ul>
</li>
<li><p><strong>EventLoop 最重要的函数！！: loop</strong> : 核心逻辑如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loop -&gt; epoll_wait -&gt; handleEvent(IO线程监听到的event) -&gt; doPendingFunctor()(其他worker线程加入的event cb)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  保证是eventloop所属的thread使用该eventloop的loop方法</span></span><br><span class="line">    assertInLoopThread();</span><br><span class="line">    <span class="keyword">while</span>(!quit_)</span><br><span class="line">    &#123;</span><br><span class="line">        activeChannels_.clear();</span><br><span class="line">        <span class="comment">//  监听两类fd</span></span><br><span class="line">            <span class="comment">//  一种是 listenfd / connfd</span></span><br><span class="line">            <span class="comment">//  一种是 **wakeupfd**</span></span><br><span class="line">        pollReturnTime_ = poller_-&gt;poll(kPollerTimeMs,&amp;activeChannels_);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  对于mainReactor的IO loop , 负责监听listenfd , handler : 接收新来的连接 并将新来的连接派发给subReactor(其他thread的eventloop)</span></span><br><span class="line">        <span class="comment">//  对于subReactor的IO loop  , 负责监听connfd   , handler : 处理 已连接socket上发生的事件.可以在subreactor的ioloop中处理 也可将任务打包提交给线程池处理</span></span><br><span class="line">        <span class="keyword">for</span>(Channel *channel:activeChannels_)</span><br><span class="line">        &#123;</span><br><span class="line">            channel-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  执行添加给本eventLoop的回调操作(可能是本thread或其他thread)</span></span><br><span class="line">        doPendingFunctors(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="One-loop-per-thread"><a href="#One-loop-per-thread" class="headerlink" title="One loop per thread"></a>One loop per thread</h1><ul>
<li>one loop per thread : 为了充分利用多核cpu.每一个核的cpu上跑一个Loop的Thread。</li>
</ul>
<h1 id="事件通知机制"><a href="#事件通知机制" class="headerlink" title="事件通知机制"></a>事件通知机制</h1><h2 id="eventfd"><a href="#eventfd" class="headerlink" title="eventfd"></a>eventfd</h2><ul>
<li><p>eventfd : 可用于唤醒等待中的epoll_wait,select等. 以此来作为一种线程间的事件通知机制</p>
<ul>
<li>thread A处于epoll_wait. 且eventfd注册在上面.</li>
<li>thread B写eventfd, 唤醒thread A的epoll_wait. 让thread A向下执行,处理事务.</li>
</ul>
</li>
<li><p>函数如下</p>
<ul>
<li>int eventfd(unsigned int initval, int flags);</li>
<li>eventfd()创建了一个 eventfd object , 其中拥有着一个64bit的整形计数器. 该计数器中的值为user传入的initval</li>
<li>read ： 成功读取返回一个8byte的整数。read（2）如果提供的缓冲区的大小小于8个字节返回错误EINVAL</li>
<li>write将缓冲区写入的8字节整形值加到内核计数器上。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunc</span><span class="params">(<span class="keyword">int</span> eventFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> buf = <span class="number">999</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = write(eventFd,&amp;buf,<span class="keyword">sizeof</span> buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="keyword">sizeof</span> buf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;write &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; bytes instead of 8&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eventFd = eventfd(<span class="number">0</span>,EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;eventFd : &quot;</span>&lt;&lt;eventFd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">        event.data.fd = eventFd;</span><br><span class="line">        event.events = EPOLLIN;</span><br><span class="line">        epoll_ctl(epfd,EPOLL_CTL_ADD,eventFd,&amp;event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(threadFunc,eventFd)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> numEvents = epoll_wait(epfd,events,<span class="number">5</span>,<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span>(numEvents == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;timeout&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        assert(numEvents == <span class="number">1</span>);</span><br><span class="line">        assert(events[<span class="number">0</span>].data.fd == eventFd);</span><br><span class="line">        <span class="keyword">uint64_t</span> buf = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> n = read(eventFd,&amp;buf,<span class="keyword">sizeof</span> buf);</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="keyword">sizeof</span> buf)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;read &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; bytes instead of 8&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;read &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; bytes &quot;</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    t.join();</span><br><span class="line">    close(eventFd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;finished&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>$ ./eventFd </span><br><span class="line">eventFd : <span class="number">3</span></span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">read <span class="number">8</span> bytes <span class="number">999</span></span><br><span class="line">finished</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="wakeupFd"><a href="#wakeupFd" class="headerlink" title="wakeupFd"></a>wakeupFd</h2><h3 id="eventfd封装"><a href="#eventfd封装" class="headerlink" title="eventfd封装"></a>eventfd封装</h3><ul>
<li><p>int wakeupFd_;  主要作用：当mainLoop获取一个新用户的channel，通过轮询算法选择一个subLoop 通过wakeupFd唤醒subLoop处理channel</p>
</li>
<li><p>wakeup : EventLoop提供给外界唤醒其epoll_wait的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  用来唤醒loop所在的(所属于的)线程(IO线程)。向wakeupFd_写一个数据。</span></span><br><span class="line"><span class="comment">//  wakeupChannel就发生读事件 当前loop线程就会被唤醒。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;wakeup&quot;</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = write(wakeupFd_,&amp;one,<span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(n != <span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">&quot;EventLoop:wake() writes %lu bytes instead of 8\n&quot;</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Eventloop处理eventFd的读事件. 防止LT下busyloop. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::handleWakeUpFd</span><span class="params">(<span class="keyword">const</span> Timestamp&amp; )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;handle wakeupFd\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = read(wakeupFd_,&amp;one,<span class="keyword">sizeof</span> one);</span><br><span class="line">    <span class="keyword">if</span>(n!=<span class="keyword">sizeof</span> one)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_ERROR(<span class="string">&quot;EventLoop::handleRead() reads %ld bytes instead of 8\n&quot;</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分发连接"><a href="#分发连接" class="headerlink" title="分发连接"></a>分发连接</h3><ul>
<li><p>问题:<strong>mainReactor如何分发连接</strong> ? 当mainReactor上的Acceptor建立新的连接时，如何将该连接(TCPConnection(connfd))的读写事件注册给subReactor的eventloop中的poller? 让subReactor负责该connfd的所有读写的监听以及回调.</p>
<ul>
<li>这也就是所谓的<strong>muduo的事件通知机制</strong>.</li>
<li>通过<strong>eventfd(wakeupFd_).统一事件源</strong></li>
</ul>
</li>
<li><p><strong>事件分发机制概述:每个eventloop都有一个eventfd,其注册在自己loop的epoll上. 外界在想唤醒eventloop,让他处理事件的时候,就向eventloop放入处理事件的callback,然后通过wakeup()向eventFd写8bytes,将eventloope从poll_wait唤醒，处理放入的callback</strong>.</p>
</li>
<li><p>那么回到问题.mainReactor如何分发连接 ?</p>
<ul>
<li>连接建立后,mainReactor上的acceptor调用TcpServer::newConnection,为connfd指定eventloop(subloop),(TCPConnection)设置读写回调. 然后调用subloop的runInLoop-&gt;queueInLoop-&gt;<strong>wakeup()</strong>, subloop从epoll_wait中离开，执行connectionEstablished.<ul>
<li><strong>queueInLoop会将TcpConnection::connectionEstablished交给该eventloop. 该callback就是将connfd注册到该loop的poller</strong></li>
</ul>
</li>
<li>到此，分发完成.</li>
<li>之后该eventloop负责该connfd的所有读写事件.</li>
</ul>
</li>
</ul>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><ul>
<li>mainReactor(main thread)分发连接代码<ul>
<li>mainReactor的Acceptor<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有一个新的客户端的连接，eventloop 会调用acceptor的handleConnection handleConnection会执行这个回调操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> connfd, <span class="keyword">const</span> InetAddress &amp;peerAddr, <span class="keyword">const</span> InetAddress &amp;localAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_DEBUG(<span class="string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,</span><br><span class="line">            name_.c_str(), connName.c_str(), peerAddr.toIpPort().c_str());</span><br><span class="line">    <span class="comment">//  mainReactor的Acceptor为connfd指定eventloop    </span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;getNextLoop();</span><br><span class="line">    <span class="function">TcpConnection <span class="title">conn</span><span class="params">(ioLoop,connfd)</span></span></span><br><span class="line"><span class="function">    conn-&gt;<span class="title">setUserCallback</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="comment">//  调用eventloop的runInLoop -&gt; queueInLoop 分发连接</span></span><br><span class="line">    ioLoop-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::connectionEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>mainReactor调用subReactor的eventloop的runInLoop <ul>
<li>将connectionEstablished放入eventloop(pendingFunctor)</li>
<li>wakeup唤醒eventloop<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  把cb放入队列 (wakeupfd唤醒loop所在线程 执行cb)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="keyword">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pendingFunctors_.emplace_back(cb);</span><br><span class="line">    <span class="keyword">if</span>(!isInLoopThread())          </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  main thread 通过loop对象wakeup方法 唤醒卡在epoll wait的eventloop</span></span><br><span class="line">        wakeup();                                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>subReactor的Eventloop被唤醒。在doPendingFunctor中通过TcpConnection::connectionEstablished真正实现分发连接. 将该connfd的读写事件注册到本channel所属TCPConnection的loop的poller上(每个loop都有一个poller channel只要知道自己是哪个loop就能找到对应的poller.)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectionEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  注册! connfd 到 loop&#x27;s poller!</span></span><br><span class="line">    channel_-&gt;enableReading();           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p><strong>一言以bi之：</strong></p>
<ul>
<li><strong>mainReactor在建立新连接后，通过写eventFd唤醒subReactor. subReactor将connfd注册在其epoll上，之后负责监听处理connfd所有的读写事件.</strong></li>
</ul>
</li>
<li><p>所谓<strong>统一事件源</strong>:</p>
</li>
<li><p>subReactor要处理的事件只有监听connfd的读写，并不负责建立新连接. 试想（我猜的）如果没有eventfd. 那么 mainReactor接收新连接后要实现分:就只能通过信号通知subReactor，亦或者是放入一个任务队列 ,subReactor定期从中拿取新连接. 都过于复杂或者性能低. </p>
</li>
<li><p>而有了eventFd,mainReactor可以向其中写来唤醒subReactor. 从subReactor的角度来看也是将事件 : 监听新connfd 转化成了一个 eventfd的读事件. 也是通过epoll监听. 和其他正常connfd的读写一样. </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP_2_信息的表示和处理</title>
    <url>/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/</url>
    <content><![CDATA[<p>无符号数、有符号数（补码）<br>浮点型、IEEE</p>
<span id="more"></span>

<h1 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h1><h2 id="补码和无符号数"><a href="#补码和无符号数" class="headerlink" title="补码和无符号数"></a>补码和无符号数</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li>补码和无符号数关系<ul>
<li>无符号数和有符号数并列。</li>
<li>有符号数 的一种表示形式是 补码</li>
</ul>
</li>
<li>转化(位数为[w-1,0])<ul>
<li>补码 -&gt; 无符号<ul>
<li><code>T2U(x) = x + 2^w   (x&lt;0)</code></li>
<li><code>T2U(x) = x         (x&gt;=0)</code></li>
</ul>
</li>
<li>无符号 -&gt; 补码<ul>
<li><code>U2T(u) = u (u&lt;=TMax)</code></li>
<li><code>U2T(u) = u-2^w (u&gt;TMax)</code></li>
</ul>
</li>
</ul>
</li>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-18-09-28-30.png"></li>
<li>补码表示范围<ul>
<li>前提：总共有n位。位数分别是[n-1,0]。也即从0开始，最高位是n-1</li>
<li><code>[-2^(n-1),2^(n-1)-1];</code>（下例中就是<code>[-2^7 , 2^7-1];</code>）</li>
</ul>
</li>
<li>无符号数表示范围<ul>
<li>前提：总共有n位。位数分别是[n-1,0]。也即从0开始，最高位是n-1</li>
<li><code>[0,2^n-1]</code>（下例中就是<code>[0 , 2^8-1];</code>）</li>
</ul>
</li>
<li><strong>首位的符号位可以看作是一个带正/负号的数值位。</strong><ul>
<li>当首位符号位为0时，该补码形式所表示的真值就是[6,0]位的和 + 首位0；首位符号位为1时，该补码形式所表示的真值就是就是 首位-2^7 + [6,0]位的数值位之和。</li>
<li>补码与原码转化。原码 = ~补码+1。不用记，无所谓。求真值用上面的方法就好。</li>
</ul>
</li>
<li>例子：总共8位。[7,0]<ul>
<li>有符号数 补码形式。<code>[-2^7 , 2^7-1];</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>     <span class="comment">//  2^7 - 1 = 127</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>     </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>     <span class="comment">//  0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>     <span class="comment">//  -2^7 + 2^6 + 2^5 + ... + 2^0 = -1;</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>     <span class="comment">//  -2^7 + 1 = -127（该二进制数据对应的真值）</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>     <span class="comment">//  -2^7 = -128（该二进制数据对应的真值）</span></span><br></pre></td></tr></table></figure></li>
<li>无符号数。[0,255]<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>     <span class="comment">//  2^8-1=255</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>     <span class="comment">//  254</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>     <span class="comment">//  2^0 = 1;</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>     <span class="comment">//  0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>从min到max是个循环</strong></li>
<li>例子<ul>
<li>无符号  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 …<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span>   <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li>补码  0 1 2 3 -4 -3 -2 -1 0 1 2 3…<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">-2</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">-3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span>   <span class="number">-4</span></span><br></pre></td></tr></table></figure></li>
<li>有符号数（补码）的溢出：是由正变负，由负变正</li>
<li>无符号数的溢出：由正变0，由0变正。（无符号数的溢出就是取模）</li>
</ul>
</li>
</ul>
<ul>
<li>左移 导致溢出。举例有符号补码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;  <span class="comment">//  有符号数 补码形式表示</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">33</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;(x&lt;&lt;i)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">31</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;(((x&lt;&lt;i)&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./test.out</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">00000000000000000000000000000001</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">00000000000000000000000000000010</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">00000000000000000000000000000100</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">00000000000000000000000000001000</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">00000000000000000000000000010000</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">00000000000000000000000000100000</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">00000000000000000000000001000000</span></span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">00000000000000000000000010000000</span></span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">00000000000000000000000100000000</span></span><br><span class="line"><span class="number">512</span></span><br><span class="line"><span class="number">00000000000000000000001000000000</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">00000000000000000000010000000000</span></span><br><span class="line"><span class="number">2048</span></span><br><span class="line"><span class="number">00000000000000000000100000000000</span></span><br><span class="line"><span class="number">4096</span></span><br><span class="line"><span class="number">00000000000000000001000000000000</span></span><br><span class="line"><span class="number">8192</span></span><br><span class="line"><span class="number">00000000000000000010000000000000</span></span><br><span class="line"><span class="number">16384</span></span><br><span class="line"><span class="number">00000000000000000100000000000000</span></span><br><span class="line"><span class="number">32768</span></span><br><span class="line"><span class="number">00000000000000001000000000000000</span></span><br><span class="line"><span class="number">65536</span></span><br><span class="line"><span class="number">00000000000000010000000000000000</span></span><br><span class="line"><span class="number">131072</span></span><br><span class="line"><span class="number">00000000000000100000000000000000</span></span><br><span class="line"><span class="number">262144</span></span><br><span class="line"><span class="number">00000000000001000000000000000000</span></span><br><span class="line"><span class="number">524288</span></span><br><span class="line"><span class="number">00000000000010000000000000000000</span></span><br><span class="line"><span class="number">1048576</span></span><br><span class="line"><span class="number">00000000000100000000000000000000</span></span><br><span class="line"><span class="number">2097152</span></span><br><span class="line"><span class="number">00000000001000000000000000000000</span></span><br><span class="line"><span class="number">4194304</span></span><br><span class="line"><span class="number">00000000010000000000000000000000</span></span><br><span class="line"><span class="number">8388608</span></span><br><span class="line"><span class="number">00000000100000000000000000000000</span></span><br><span class="line"><span class="number">16777216</span></span><br><span class="line"><span class="number">00000001000000000000000000000000</span></span><br><span class="line"><span class="number">335544321</span></span><br><span class="line"><span class="number">00000010000000000000000000000000</span></span><br><span class="line"><span class="number">67108864</span></span><br><span class="line"><span class="number">00000100000000000000000000000000</span></span><br><span class="line"><span class="number">134217728</span></span><br><span class="line"><span class="number">00001000000000000000000000000000</span></span><br><span class="line"><span class="number">268435456</span></span><br><span class="line"><span class="number">00010000000000000000000000000000</span></span><br><span class="line"><span class="number">536870912</span></span><br><span class="line"><span class="number">00100000000000000000000000000000</span></span><br><span class="line"><span class="number">1073741824</span></span><br><span class="line"><span class="number">01000000000000000000000000000000</span></span><br><span class="line"><span class="number">-2147483648</span></span><br><span class="line"><span class="number">10000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">如果x是<span class="keyword">unsigned</span> <span class="keyword">int</span>的话 那么就是</span><br><span class="line"><span class="number">2147483648</span></span><br><span class="line"><span class="number">10000000000000000000000000000000</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h3><ul>
<li>有符号数与无符号数发生比较/运算时，<strong>有符号数会先被转化为无符号数</strong><ul>
<li>signed(two’s complement) -&gt; unsigned</li>
</ul>
</li>
<li>例子 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELTA sizeof(char)</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  死循环</span></span><br><span class="line">i-<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) 得到一个<span class="keyword">unsigned</span></span><br><span class="line"><span class="comment">// 因为sizeof 返回 size_t ，是unsigned</span></span><br><span class="line"><span class="keyword">for</span>(i=CNT;i-DELTA&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>例子。错把无符号数当作有符号数。递减得到INT_MAX<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  死循环。不会终止。</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">unsigned</span> i = <span class="number">4</span> ; i&gt;=<span class="number">0</span> ; --i )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00000000000000000000000000000100</span>  <span class="number">4</span></span><br><span class="line">...</span><br><span class="line"><span class="number">00000000000000000000000000000001</span>  <span class="number">1</span></span><br><span class="line"><span class="number">00000000000000000000000000000000</span>  <span class="number">0</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span>  <span class="keyword">signed</span> : <span class="number">-1</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">32</span><span class="number">-1</span></span><br><span class="line"><span class="number">11111111111111111111111111111110</span>  <span class="keyword">signed</span> : <span class="number">-2</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">32</span><span class="number">-2</span></span><br><span class="line">...</span><br><span class="line"><span class="number">10000000000000000000000000000000</span>  <span class="keyword">signed</span> : <span class="number">-2</span>^<span class="number">31</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">32</span></span><br><span class="line"><span class="number">01111111111111111111111111111111</span>  <span class="keyword">signed</span> : <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span></span><br><span class="line"><span class="number">01111111111111111111111111111110</span>  <span class="keyword">signed</span> : <span class="number">2</span>^<span class="number">31</span><span class="number">-2</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">31</span><span class="number">-2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>printf并没用使用变量的任何类型信息，只是根据%d %u %x这样的指示符来按照指示将变量底下的字节以相应形式输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  32位</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>;                   <span class="number">11111.</span>.<span class="number">.1111</span></span><br><span class="line"><span class="keyword">unsigned</span> u = <span class="number">2147483648</span>;      <span class="number">10000.</span>.<span class="number">.0000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%u=%d\n&quot;</span>,x,x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;u=%u=%d\n&quot;</span>,u,u);</span><br><span class="line"></span><br><span class="line">x = <span class="number">4294967295</span> = <span class="number">-1</span>;</span><br><span class="line">u = <span class="number">2147836848</span> = <span class="number">-2147836848</span></span><br></pre></td></tr></table></figure></li>
<li><p>有符号数转无符号数对于标准的算数运算并无多大差异，但对于&lt;&gt;比较运算开输送，就会导致非直观的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式                              类型             结果</span></span><br><span class="line"><span class="number">-2147483647</span><span class="number">-1</span> == <span class="number">2147836848U</span>         <span class="keyword">unsigned</span>            <span class="number">1</span></span><br><span class="line"><span class="number">-2147483647</span><span class="number">-1U</span> &lt; <span class="number">2147836847</span>          <span class="keyword">unsigned</span>            <span class="number">0</span>      </span><br><span class="line"><span class="comment">// 1000...0000 U &lt; 0111...1111  </span></span><br><span class="line"><span class="number">-2147483647</span><span class="number">-1U</span> &lt; <span class="number">-2147483647</span>         <span class="keyword">unsigned</span>            <span class="number">1</span></span><br><span class="line"><span class="comment">// 1000...0000 U &lt; 1000...0001       </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h3><ul>
<li><p><strong>符号的扩展发生了什么</strong>（符号扩展在由小类型到大类型时发生）</p>
</li>
<li><p>有符号数：补码的符号扩展。</p>
<ul>
<li><strong>复制符号位</strong>：向高位拿了一个新位用作符号位，<strong>新符号位的权重是原符号位的2倍，把这个原先的符号位用作正的数值位</strong>。</li>
<li>这样并不改变这些数值位的总和；也即并不改变数（真值）的大小</li>
<li>将各个权值位相加，可得补码对应的真值。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   : <span class="number">-8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">-2</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   : <span class="number">-16</span> + <span class="number">8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">-2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>无符号数：0扩展</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   : <span class="number">8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">14</span></span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   : <span class="number">8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">14</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h3><ul>
<li>截断会导致数变化很大。例如补码被截断就有可能一正一负，无符号数被截断就是取模。</li>
<li>无符号数。直接模<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1011</span>  <span class="comment">//  8+2+1=11</span></span><br><span class="line"><span class="number">011</span>   <span class="comment">//  3 = 11%8</span></span><br></pre></td></tr></table></figure></li>
<li>有符号数。补码形式。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">11011</span>   <span class="comment">//  -16+8+2+1=-5</span></span><br><span class="line">-&gt;</span><br><span class="line"><span class="number">1011</span>   <span class="comment">//  -8+2+1=5</span></span><br><span class="line">没变。是因为从<span class="number">1011</span>到<span class="number">11011</span>可以看作是符号位拓展。</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="number">10011</span>   <span class="comment">//  -16+2+1=-13</span></span><br><span class="line">-&gt;</span><br><span class="line"><span class="number">0011</span>   <span class="comment">//  2+1=3</span></span><br><span class="line"><span class="number">3</span> != <span class="number">-13</span>%<span class="number">16</span></span><br></pre></td></tr></table></figure></li>
<li>无论溢出的那个下一个高位有什么，我们都假装看不到并舍弃。只拿低位的[n-1,0]位当作我获得的结果，编译器对这个过程也不会有任何warning</li>
</ul>
<h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><ul>
<li><p>补码右移：算数移位。copy符号位</p>
</li>
<li><p>补码左移：直接移，低位补0</p>
</li>
<li><p>无符号数右移：逻辑右移。高位补0</p>
</li>
<li><p>无符号数左移：逻辑左移。低位补0</p>
</li>
<li><p>总共w位，如果右移k位，且k&gt;=w位，那么结果是:</p>
<ul>
<li>大多数机器中都是这样做：实际位移量是 k mod w。</li>
<li>C标准中规避了说明这种情况下如何做，因此这种行为对C程序来说没有保证。</li>
</ul>
</li>
<li><p>习题</p>
<ul>
<li>六进制中从8到F的最高有效位为1，记住这一点就会发现十六进制表示二进制更方便<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">unsigned</span> word)</span></span>&#123;</span><br><span class="line">              <span class="comment">//  逻辑左移 低位补0</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)( (word&lt;&lt;<span class="number">24</span>) &gt;&gt; <span class="number">24</span> );</span><br><span class="line">                        <span class="comment">//  逻辑右移 高位补0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">unsigned</span> word)</span></span>&#123;</span><br><span class="line">              <span class="comment">//  算数左移 低位补0</span></span><br><span class="line">  <span class="keyword">return</span> ( (<span class="keyword">int</span>)word&lt;&lt;<span class="number">24</span> ) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                        <span class="comment">//  算数右移 高位补x[w-1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">w                   <span class="title">fun1</span><span class="params">(w)</span>                 <span class="title">fun2</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">0x00000076        0x00000076              0x00000076    </span></span><br><span class="line"><span class="function">0x87654321        0x00000021              0x00000021</span></span><br><span class="line"><span class="function">0x000000c9        0x000000c9              0xffffffc9</span></span><br><span class="line"><span class="function">0xEDCBA987        0x00000087              0xffffff87</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 左移24/4=6个十六进制位：只留下最低两位十六进制位</span></span></span><br><span class="line"><span class="function"><span class="comment">// 右移24/4=6个十六进制位：逻辑移位补0，算数移位补x[w-1]</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="对一个数取负"><a href="#对一个数取负" class="headerlink" title="对一个数取负"></a>对一个数取负</h3><ul>
<li><p><strong>对补码的所有位（包括符号位）取反 ，再 + 1</strong></p>
</li>
<li><p><strong>[-x]补 = ~[x]补 + 1</strong></p>
</li>
<li><p>例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x     <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>    <span class="number">-8</span>+<span class="number">2</span>=<span class="number">-6</span></span><br><span class="line">~x    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   </span><br><span class="line">~x+<span class="number">1</span>  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>    <span class="number">2</span>+<span class="number">4</span>=<span class="number">6</span>     </span><br></pre></td></tr></table></figure></li>
<li><p>很巧啊，类似，从补码转到原码/从原码转到补码。都是取反+1，不过原码&lt;-&gt;补码不涉及符号位。</p>
</li>
<li><p><strong>原码补码转化公式：[x]补 =  ~[x]原+1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x     <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">-2</span>  这是原码  </span><br><span class="line">~x    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">~x+<span class="number">1</span>  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">-8</span>+<span class="number">4</span>+<span class="number">2</span>=<span class="number">-2</span>   这是x原码对应的补码</span><br></pre></td></tr></table></figure></li>
<li><p>所以啊，为什么说 在程序中求 -x 就是在求 ~x+1?</p>
<ul>
<li>因为补码及其相反数的转化公式为：**[-x]补 = ~[x]补 + 1**</li>
<li>可不是因为原码补码的转化公式是：[x]补 =  ~[x]原+1。大一做算法题的时候还误以为是这个原因。</li>
</ul>
</li>
</ul>
<h3 id="特别的-TMin的相反数是什么？"><a href="#特别的-TMin的相反数是什么？" class="headerlink" title="特别的 TMin的相反数是什么？"></a>特别的 TMin的相反数是什么？</h3><ul>
<li>T Min的相反数还是 T Min</li>
<li>应用公式：[-x]补 = ~[x]补 + 1</li>
<li>假设n=4<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>   : T MAX</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   : T MIN</span><br><span class="line"></span><br><span class="line">~ T MIN</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">+<span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   = -TMIN</span><br></pre></td></tr></table></figure></li>
<li>所以<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1.</span></span><br><span class="line">x &gt; y 不一定有 -x &lt; -y</span><br><span class="line">当y=T MIN时 y和-y都是最小的</span><br><span class="line"></span><br><span class="line"><span class="comment">//  2.</span></span><br><span class="line">x &gt;=<span class="number">0</span>  =&gt;   -x&lt;=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  3.</span></span><br><span class="line">x&lt;=<span class="number">0</span>  !=&gt;   -x&gt;=<span class="number">0</span></span><br><span class="line">当x=T min时，x=-x=Tmin</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如何编写unsigned"><a href="#如何编写unsigned" class="headerlink" title="如何编写unsigned"></a>如何编写unsigned</h3><ul>
<li>该用unsigned吗？<ul>
<li>Java等语言抹去了unsigned，只保留了补码。<ul>
<li>但Java中&gt;&gt;是算数右移，&gt;&gt;&gt;是逻辑右移</li>
</ul>
</li>
</ul>
</li>
<li>C标准并没有明确规定有符号溢出会发生什么。我们知识假设是按照补码。但严格意义上我们不能假设C标准以外的东西</li>
<li>提出<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> i=...;  <span class="comment">//size_t : unsigned value of word size</span></span><br><span class="line"><span class="keyword">for</span>(i=cnt<span class="number">-2</span>;i&lt;cnt;--i)</span><br><span class="line">&#123;</span><br><span class="line">  a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最终：自己谨慎点吧</li>
</ul>
<h3 id="所以unsigned这么不好用，什么时候用？"><a href="#所以unsigned这么不好用，什么时候用？" class="headerlink" title="所以unsigned这么不好用，什么时候用？"></a>所以unsigned这么不好用，什么时候用？</h3><ul>
<li>加密算法（需要取模）</li>
<li>仅仅把字看作位的集合，而没有任何数学意义。</li>
</ul>
<h3 id="无符号数加法"><a href="#无符号数加法" class="headerlink" title="无符号数加法"></a>无符号数加法</h3><ul>
<li><p>阿贝尔群</p>
</li>
<li><p>无符号加法公式</p>
<ul>
<li>x + w位的无符号数y (写作uwy) <ul>
<li> = x + y  (x+y &lt; 2^w)</li>
<li> = x + y - 2^w  (2^w &lt;= x+y &lt; 2^w+1)</li>
</ul>
</li>
</ul>
</li>
<li><p>整数加法和无符号数加法关系。当x+y &gt; 2^w - 1时，和溢出<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-20-09-42-42.png"></p>
</li>
</ul>
<h3 id="有符号数（补码）加法"><a href="#有符号数（补码）加法" class="headerlink" title="有符号数（补码）加法"></a>有符号数（补码）加法</h3><ul>
<li>阿贝尔群</li>
<li>补码加法公式<ul>
<li>x + w位的补码y（写作twy）<ul>
<li>x + y - 2^w     （2^(w-1) &lt;= x + y）</li>
<li>x + y             （ -2^(w-1) &lt;= x + y &lt; 2^(w-1)）</li>
<li>x + y + 2^w     （ x + y &lt; -2^(w-1)）</li>
</ul>
</li>
</ul>
</li>
<li>整数加法和无符号数加法之间的关系。x + y &lt; 2^(w-1) 时,负溢出 ； x + y &gt; 2^(w-1)-1时,正溢出<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-20-19-46-45.png"></li>
</ul>
<h3 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h3><ul>
<li>两个w位的无符号数相乘，结果应当用2w位保存，但是c语言中无符号乘法被定义成产生w位的值，也就是说会截断低位的w位。</li>
<li>将一个无符号数截断为w位 ，等价于计算该值模2^w</li>
<li>-&gt;得到公式： x * uwy = (x*y) mod (2^w)</li>
</ul>
<h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><ul>
<li>两个w位的有符号数相乘，结果应当用2w位保存，但是c语言中有符号乘法被定义成产生w位的值，也就是说会截断低位的w位。</li>
<li>将一个无符号数截断为w位，相当于 先计算该值模2^w , 再把无符号数转换为补码。</li>
<li>-&gt;得到公式：x * twy = U2T ( (x*y) mod (2^w) )</li>
</ul>
<ul>
<li>补码乘法和无符号乘法的位级表示是一样的（位级等价性）</li>
</ul>
<h3 id="无符号除法"><a href="#无符号除法" class="headerlink" title="无符号除法"></a>无符号除法</h3><ul>
<li>除以2的幂<br>C语言中 无符号数x和k<br>则 x&gt;&gt;k = [x/(2^k)]向下取整</li>
</ul>
<h3 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h3><ul>
<li><p>除以2的幂<br>C语言中 有符号数x和无符号数k<br>对于我们编写的x/2^k，则C底层实际实现的是<br>( x&lt;0 ? x+(1&lt;&lt;k)-1 : x ) &gt;&gt; k<br>x&lt;0时，需要加上偏置值，这样无论x&gt;0还是x&lt;0，其结果都向0舍入</p>
</li>
<li><p>乘法指令（3个周期）比移位指令（1个周期）花的时间周期多</p>
</li>
<li><p>现代计算机除法仍然很慢 30个周期</p>
</li>
</ul>
<h2 id="字长"><a href="#字长" class="headerlink" title="字长"></a><strong>字长</strong></h2><h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><ul>
<li><p>64位机器，寻址是2^64。 这是逻辑上的。实际上最大是2^48-1。可也正常人没钱买这么大内存。</p>
<ul>
<li><a href="https://www.zhihu.com/question/28638698">64位指针 实际上起作用的就只有48位</a></li>
<li><a href="https://www.zhihu.com/question/28638698/answer/41603886">为什么64位机指针只用48个位？</a></li>
<li><a href="https://www.zhihu.com/question/28638698/answer/143997353">48</a></li>
</ul>
</li>
<li><p>运行程序时，程序认为他有这么大内存，实际上没有。操作系统只允许他访问能够访问的区域。</p>
</li>
<li><p>机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存</strong>。</p>
</li>
<li><p>内存的每一个字节都由唯一的数字来标识，称为它的地址。</p>
</li>
<li><p>所有可能地址的集合就称为<strong>虚拟地址空间</strong>。</p>
<ul>
<li>顾名思义，虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。</li>
</ul>
</li>
<li><p>程序对象：程序数据、指令、控制信息。</p>
<ul>
<li>编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的程序对象，即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。</li>
<li>每个程序对象可以简单的视为一个字节快，而程序本身就是一个字节序列</li>
</ul>
</li>
<li><p>字节顺序：</p>
<ul>
<li>几乎在所有的机器上，多字节对象被存储为连续的字节序列；<strong>对象地址</strong>为所使用字节的<strong>最小地址</strong>。<blockquote>
<p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-11-20-42-03.png"></p>
</blockquote>
</li>
<li>大端机器较少，x86机器都是小端，arm处理器既可处理大端也可处理小端，但一般都是小端。</li>
<li>基本上只有互联网是唯一一个有大端序的地方。当向网络发送数据包时，会以大端序接收<blockquote>
<p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-11-21-01-15.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>按字节，将信息以16进制打印</strong>（这不是我昨天刚写过类似的吗哈哈哈）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start,<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\t0x%.2x\n&quot;</span>,start+i,start[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">show_bytes</span>((byte_pointer)&amp;a,<span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./a.out </span><br><span class="line"><span class="number">0x7ffc93b80294</span>  <span class="number">0x09</span></span><br><span class="line"><span class="number">0x7ffc93b80295</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7ffc93b80296</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7ffc93b80297</span>  <span class="number">0x00</span></span><br></pre></td></tr></table></figure></li>
<li><p>单位转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">KB MB GB TB</span><br><span class="line">K、M、G、T是数字大小的进制，单位(<span class="number">1</span>)</span><br><span class="line">B是物理意义上的单位，指Bytes</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>^<span class="number">10</span> = <span class="number">1024</span> ==<span class="number">10</span>^<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>KB = <span class="number">1024B</span> = <span class="number">2</span>^<span class="number">10</span> Bytes;</span><br><span class="line"><span class="number">1</span>MB = <span class="number">1024</span>KB = <span class="number">1024</span>*<span class="number">1024</span>KB = <span class="number">2</span>^<span class="number">20</span> Bytes</span><br><span class="line"><span class="number">1</span>GB = <span class="number">1024</span>MB = <span class="number">2</span>^<span class="number">30</span> Bytes = <span class="number">10</span>^<span class="number">9</span> Bytes</span><br><span class="line"><span class="number">1</span>TB = <span class="number">1024</span>GB</span><br><span class="line"><span class="number">1</span>PB = <span class="number">1024</span>TB = <span class="number">1125899906842624</span> Bytes</span><br><span class="line"><span class="number">1</span>EB = <span class="number">1024</span>PB = <span class="number">1152921504606846976</span> Bytes</span><br><span class="line"><span class="number">1</span>MM = <span class="number">2</span>^<span class="number">20</span> * <span class="number">2</span>^<span class="number">20</span> = <span class="number">2</span>^<span class="number">40</span> Bytes = <span class="number">10</span>^<span class="number">12</span> Bytes</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>^<span class="number">47</span> 估算：</span><br><span class="line"><span class="number">2</span>^<span class="number">40</span> * <span class="number">2</span>^<span class="number">7</span> = <span class="number">128</span> * <span class="number">10</span>^<span class="number">12</span> Bytes = <span class="number">128</span> MM Bytes = <span class="number">128</span>*<span class="number">10</span>^<span class="number">3</span> G Bytes</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="什么是字长"><a href="#什么是字长" class="headerlink" title="什么是字长"></a><strong>什么是字长</strong></h3><ul>
<li><p>每台计算机都有一个字长，<strong>指明指针数据的标称大小</strong>。因为虚拟地址是以这样的一个字来编码的，所有字长决定的最重要的系统参数就是<strong>虚拟地址空间的最大大小</strong>。也就是说，对于一个字长为w位的机器而言，虚拟地址的范围是[0,2^w-1]。程序最多访问2 ^w 个字节。（一个地址背后是1Bytes、8bits的存储空间）</p>
</li>
<li><p>大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。</p>
<ul>
<li>生成32位程序，该程序可以在32位/64位机器上运行<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc -m32 prog.c</span><br></pre></td></tr></table></figure></li>
<li>生成64位程序，只能在64位机器上运行<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc -m64 prog.c</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>困扰我好久了！这些话解决了大半。</p>
</li>
<li><p>Whatever the largest number is that or the range that sort of signifies how big a pointer is in this language , Or hardware wise the largest sort of chunkof hardware for which.<br>无论最大数是多少，或者指针表的范围是多少，或者硬件的一个chunk块是多大<br>There’s a standard support for storing it for arithmetic operations and so forth<br>有一个标准确定如何存储值和进行算数运算等<br>So when we say it’s a 64-bit machine<br>所以当我们说他是64位机器时<br>What we mean is that it regular and routinely manipulate 64-bit and operations<br>意思是他惯常处理64位值和算数运算<br>And also it has a pointer or the values of addresses are 64-bit<br>并且他的指针和地址的值是64位<br>Even if for right now only 47 of those bits are usable , it’s still considered a 64-bit machine<br>即便只有47位是有效的，我们也认为他是64位机器</p>
</li>
<li><p>我们的机器有个奇怪的特性，当我们用gcc作为编译器时，我们可以指定是32位还是64位编译，并且32位和64位会生成两种不同类型的代码。但就目前而言，重点是硬件本身并不一定决定字长的大小，it’s a combination of the hardware and the complier that determines，是由硬件和编译器一起决定的。</p>
<ul>
<li>And that code can be run on the point is a 64-bit machine，and can insert of a backward compatibiltiy a style also excutes 32-bit code</li>
</ul>
</li>
<li><p>And we also saw one of the other feature is<br>并且我们可以看到另一个特性<br>Even though it’s a 64-bit word size machine ,  the data type int without any other qualifiers<br>即使它是个64位机器：对于数据类型int来说，如果没有任何其他的修饰符<br>it is jusy 32-bit<br>它就是32位的<br>so the sort of this mixture of how big things are<br>所以这种数据类型大小的定义是混合的</p>
</li>
<li><p>So when people just say word or word size ，<br>所以当人们说字或者字长时<br>let’s must say give a precise definition that’s not a very meaningful term<br>我们必须说。从精确的定义来说，这不是个有意义的术语/措辞<br>And we’ll sort of throw  it around when we mean sort of generic chunk of bits<br>我们说他的时候一般是泛指一个比特块，<br>without trying to assume that it has a particular number of bits to it<br>而不去假设他具有特定数量的bit</p>
</li>
</ul>
<ul>
<li>64bit的标准int仍然是32位，64位与32位相比，主要特征是<strong>64bit的指针是64位的</strong>，或者说是8字节的。<ul>
<li><blockquote>
<p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-11-20-45-53.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul>
<li><blockquote>
<p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-11-21-44-55.png"></p>
</blockquote>
</li>
<li><p>p75 <strong>经典</strong></p>
<ul>
<li>记住 <strong>无符号数 和 补码的位级表示相同！！哪怕经过加减乘除计算之后，也仍是这样。</strong>（位级别相同的两组补码和无符号数，各自经历相同的加减乘除计算之后，<strong>得到的结果的位级表示仍然相同</strong>）</li>
<li>记住 -Tmin = Tmin</li>
<li>记住第a位的数 在 左(右)移b位后，会移动到a+(-)b位上。（数的位数范围[w-1,0]）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已知</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">foo</span>();</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> ux = x;</span><br><span class="line"><span class="keyword">unsigned</span> uy = y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(x&gt;<span class="number">0</span>) || (x<span class="number">-1</span>&lt;<span class="number">0</span>)      </span><br><span class="line"><span class="comment">//  FALSE</span></span><br><span class="line">x = Tmin = <span class="number">-2147483648</span> </span><br><span class="line">则 x&lt;<span class="number">0</span> , x<span class="number">-1</span>&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(x&amp;<span class="number">7</span>)!=<span class="number">7</span> || (x&lt;&lt;<span class="number">29</span> &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//  TRUE</span></span><br><span class="line"><span class="comment">//  x&amp;7 != 7 ok</span></span><br><span class="line"><span class="comment">//  x&amp;7 == 7 则 x = aaaa...0111</span></span><br><span class="line"><span class="comment">//  则 x&lt;&lt;29 = 111000...0001</span></span><br><span class="line"></span><br><span class="line">(x*x) &gt;= <span class="number">0</span></span><br><span class="line"><span class="comment">//  FALSE</span></span><br><span class="line">x = <span class="number">0xffff</span></span><br><span class="line"><span class="number">0xffff</span> * <span class="number">0xffff</span>  = <span class="number">-131071</span></span><br><span class="line"></span><br><span class="line">x&lt;<span class="number">0</span> || -x&lt;=<span class="number">0</span></span><br><span class="line"><span class="comment">//  TRUE</span></span><br><span class="line">x = Tmin = <span class="number">-2147483648</span></span><br><span class="line">-x = Tmin &lt;=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x&gt;<span class="number">0</span> || -x&gt;=<span class="number">0</span></span><br><span class="line"><span class="comment">// FALSE</span></span><br><span class="line">x = Tmin = <span class="number">-2147483648</span></span><br><span class="line">-x = Tmin &lt;=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">x+y == uy + ux</span><br><span class="line"><span class="comment">//  TRUE</span></span><br><span class="line">补码和无符号数的位级行为相同</span><br><span class="line">也就是说 x + y 与 ux + uy 的位级表示相同</span><br><span class="line">且 在 == 比较时 会将补码转化成无符号数</span><br><span class="line">故 x + y == ux + uy</span><br><span class="line"></span><br><span class="line">x*(~y) + uy*ux == -x</span><br><span class="line"><span class="comment">// TRUE</span></span><br><span class="line">~y = -y<span class="number">-1</span>;</span><br><span class="line">x*(-y<span class="number">-1</span>) + uy*ux = -xy -x + uy * ux = -x</span><br><span class="line">补码和无符号数的位级行为相同</span><br><span class="line">也就是说 uy*ux 与 -xy的位级表示相同 。（也许完整的乘积的位级表示可能不同，但是按照C语言标准，截断之后的乘积的位级表示是相同的）（C标准规定截断位w位）</span><br><span class="line">因此 -xy可以和uy*ux相抵消</span><br><span class="line">故 剩下-x</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如何计算0xf8</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0xf8</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1000</span></span><br><span class="line">高四位的<span class="number">1</span>是符号位扩展出来的，所以：<span class="number">-1</span> +<span class="number">1</span> +<span class="number">1</span> +<span class="number">1</span> &lt;-&gt; 最低为符号位的<span class="number">-1</span></span><br><span class="line"><span class="number">-2</span>^<span class="number">4</span> + <span class="number">8</span> = <span class="number">-8</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><ul>
<li>csapp p59</li>
<li>习题<ul>
<li>当length = 0时，会访问非法内存。<ul>
<li>length = 0，length - 1 = -1 -&gt; UMAX。</li>
<li>i先转化成unsigned，然后从0增至UMAX</li>
</ul>
</li>
<li>改正：<ul>
<li>length 类型改为 int。（即便length想要&gt;INT_MAX也没关系，想想就知道了）</li>
<li>i &lt;= length - 1 ——&gt; i &lt; length<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sum_eles</span><span class="params">(<span class="keyword">float</span> a[],<span class="keyword">unsigned</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;=length<span class="number">-1</span> ; ++i)</span><br><span class="line">    result += a[i];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><h2 id="普通的二进制小数"><a href="#普通的二进制小数" class="headerlink" title="普通的二进制小数"></a>普通的二进制小数</h2><p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-06-19-08-06-03.png"><br>基于此，后来出现了IEEE浮点数表示标准</p>
<h2 id="IEEE浮点数表示（比唐书说得清楚些）"><a href="#IEEE浮点数表示（比唐书说得清楚些）" class="headerlink" title="IEEE浮点数表示（比唐书说得清楚些）"></a>IEEE浮点数表示（比唐书说得清楚些）</h2><h3 id="基本规则说明"><a href="#基本规则说明" class="headerlink" title="基本规则说明"></a>基本规则说明</h3><ul>
<li>IEEE浮点标准用 V = (-1)^s * M * 2^E来表示一个数。<ul>
<li>符号（sign）：1负0正</li>
<li>尾数（significand）：M为一二进制小数。范围是 <code>1~2-无穷小 (2^(-n))</code> 或者<code> 0~1 - 无穷小 (2^(-n))</code></li>
<li>阶码（exponent）：E的作用是对浮点数加权</li>
</ul>
</li>
<li>将浮点数的位表示为三个字段，分别对这三个值进行编码：<ul>
<li>一个单独的符号位s 直接编码符号s</li>
<li>k位的阶码字段 <code>exp=ek-1...e1e0</code> 编码阶码E</li>
<li>n位的小数字段<code>frac=fn-1...f1f0</code>编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于0。frac每一位的权值为<code>2^-1,2^-2....</code></li>
</ul>
</li>
<li>图示<ul>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-12-34-53.png"></li>
<li>阶码的值决定了一个浮点数是否是规格化的<img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-12-35-18.png"></li>
</ul>
</li>
</ul>
<h3 id="是否规格化（三种情况）"><a href="#是否规格化（三种情况）" class="headerlink" title="是否规格化（三种情况）"></a>是否规格化（三种情况）</h3><ul>
<li>V = (-1)^s * M * 2^E</li>
<li><strong>规格化</strong>的值：exp的位模式 既不全为0，也不全为1。<ul>
<li>E = e-Bias。其中e是无符号数，就是上图中的exp:(ek-1..e1e0)。偏置值Bias=2^(k-1) - 1。（这时候也就是所谓的，用移码方式表示阶码E）<ul>
<li>因此，指数的取值范围：单精度 [-126,127] ；双精度 [-1022,+1023]</li>
</ul>
</li>
<li>M = 1+f。称为隐含的以1开头的表示。<ul>
<li>其中f属于[0,1)，f的二进制表示为<code>0.fn-1...f1f0</code>（即小数点在最高位有效位的左边）。因此M可以看为二进制：<code>1.fn-1...f1f0</code>。（可以通过调整E，使得M属于[1,2)。通过M=1+f，使得f不必显示写出那个1。这样，就获得了一个额外的精度位）</li>
</ul>
</li>
</ul>
</li>
<li><strong>非规格化</strong>的值：exp的位模式全部为0<ul>
<li>E = 1-Bias</li>
<li>M = f。即小数字段的值，不包含隐含的开头的1。也即f的值的小数点左侧实际上为0。</li>
<li>非规格化数用途<ul>
<li>提供了一种表示数值0的方法<ul>
<li>+0.0：位模式全部为0。s = 0，exp = 0，frac = 0.</li>
<li>-0.0：s=1，exp=0，frac=0.</li>
</ul>
</li>
<li>还可用于表示那些非常接近0.0的数</li>
</ul>
</li>
</ul>
</li>
<li><strong>特殊值</strong>：exp的位模式全部为1.<ul>
<li>s=0，frac=0，表示正无穷</li>
<li>s=1，frac=0，表示负无穷</li>
<li>frac!=0时，其结果表示为 NaN （Not a number）。可用作表示未初始化的数值，或计算结果不能是实数或者无穷。</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><p>假设6位浮点格式（3位阶码2位尾数）。可表示的数不是均匀分布的，越靠近远点越稠密<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-13-09-51.png"></p>
</li>
<li><p>8位浮点格式的非负值示例<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-12-25-43.png"></p>
</li>
<li><p>最靠近0：非规格化数。</p>
<ul>
<li>E = 1-7 = -6 。权 = 2^E = 1/64</li>
<li><code>f = 0，1/8，...，7/8</code></li>
<li>所以V [0,1/64 * 7/8]。（非连续）</li>
<li>最小为0</li>
</ul>
</li>
<li><p>规格化数</p>
<ul>
<li>最小规格化数：<ul>
<li>E = 1-7 = -6</li>
<li><code>frac = 0,1/8...7/8 -&gt; M = 1+f = 1...15/8</code></li>
<li>所以V [8/512 , 15/512]</li>
<li>最小为8/512。</li>
</ul>
</li>
<li>逐渐增大</li>
<li>最大规格化数<ul>
<li>E = 7 </li>
<li><code>frac = 0,1/8...7/8 -&gt; M = 1+f = 1...15/8</code></li>
<li>所以，最大规格化值 V = 15/8*2^7 = 240</li>
</ul>
</li>
</ul>
</li>
<li><p>无穷大</p>
<ul>
<li>超过最大规格化数，溢出到正无穷</li>
</ul>
</li>
<li><p>k位阶码，n位小数的一般规律</p>
<ul>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-15-09-28.png"></li>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-15-39-17.png"></li>
</ul>
</li>
</ul>
<ul>
<li>整数(int)转化成浮点数(float)表示形式（会改变整数的位）<ul>
<li>(unsigned)short、(unsigned)int和(unsigned)long之间转化也会改变位，但是只是进行符号位的(无符号扩展)有符号扩展<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="number">12345</span></span><br><span class="line"><span class="keyword">int</span>的二进制：<span class="number">11000000111001</span></span><br><span class="line"><span class="number">12345</span> = (<span class="number">1.1000000111001</span>)<span class="number">2</span> * <span class="number">2</span>^<span class="number">13</span></span><br><span class="line">为了用IEEE单精度形式编码，</span><br><span class="line">构造小数字段：应该丢弃开头的<span class="number">1</span>（作为隐含的<span class="number">1</span>），并在末尾+<span class="number">10</span>个<span class="number">0</span>，来构造小数字段：<span class="number">10000001110010000000000</span></span><br><span class="line">构造阶码字段：<span class="number">13</span> + bias（<span class="number">2</span>^(<span class="number">8</span><span class="number">-1</span>)<span class="number">-1</span> = <span class="number">127</span>） = <span class="number">140</span>。二进制表示为 <span class="number">10001100</span></span><br><span class="line">再加上符号位<span class="number">0</span></span><br><span class="line">得到二进制的浮点数表示<span class="number">12345.0</span>(<span class="keyword">float</span>)</span><br><span class="line">s   exp       frac</span><br><span class="line"><span class="number">0</span> <span class="number">10001100</span> <span class="number">10000001110010000000000</span></span><br></pre></td></tr></table></figure></li>
<li>convert integer to float图</li>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-06-19-08-20-25.png"></li>
<li>可以看出 float只有frac的[22,0]位可以用来表示int的数值,因此当int过大时int-&gt;float会发生精度损失<ul>
<li>int:[31,0],去掉符号位不算 [30:0],去掉最高位的1不算(因为M = 1+f 1被隐含)就是[29:0],因此如果int的值过大,转为float时会发生精度损失</li>
<li>int/float转double就一定不会发生精度损失了，因为double的frac是[51:0],能把整个(int)/(float的frac)都涵盖进去</li>
<li>float/double转int可能会发生溢出。（溢出是看阶码exp，精度损失是看小数位frac）</li>
</ul>
</li>
</ul>
</li>
<li>位级比较<ul>
<li>12345整形（0x00003039）：</li>
<li>12345.0单精度浮点数：（0x4640E400）：</li>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-15-49-44.png"></li>
</ul>
</li>
</ul>
<h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h2><ul>
<li>向上舍入</li>
<li>向下舍入</li>
<li>向0舍入</li>
<li><strong>向偶数舍入</strong><ul>
<li>向偶数舍入原则有2个</li>
<li>当要舍入到的位的 之后的位 不等于中间值（半值）时，向最靠近的数舍入。也即&lt;半值就向下舍入，大于半值就向上舍入</li>
<li>当要舍入到的位的 之后的位 等于中间值（半值）时，向偶数舍入<ul>
<li>如果要舍入到的位，现在是偶数，那么向下舍入，直接舍去后面的位，原先要舍入到的位的数就是舍入的结果。</li>
<li>如果要舍入到的位，现在是奇数，那么向上舍入。</li>
</ul>
</li>
<li>例子：舍入到小数点后一位<ul>
<li>10.010(2) -&gt; 10.0 <ul>
<li>因为 小数点右边一位的0之后的10 = 0.25 = 0.5/2 ，也即等于半值，所以向偶数舍入，又因小数点后一位为偶数0，所以结果为10.0</li>
</ul>
</li>
<li>10.011(2) -&gt; 10.1<ul>
<li>因为 0之后的11 = 0.375 &gt; 0.5/2 ，也即&gt;半值，所以向上舍入，故10.1</li>
</ul>
</li>
<li>10.110(2) -&gt; 11.0<ul>
<li>因为 小数点右边一位的1之后的10 = 0.25 = 0.5/2 ，也即等于半值，所以向偶数舍入，又因小数点后一位为偶数1，所以(+1向上舍入)结果为11.0</li>
</ul>
</li>
<li>11.001(2) -&gt; 11.0<ul>
<li>因为 0之后的01 = 0.125 &lt; 0.5/2 ，也即&lt;半值，所以向下舍入，故10.0<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>不是阿贝尔群<ul>
<li>具备交换律 但 不具备 结合律</li>
</ul>
</li>
<li>赶作业去了</li>
</ul>
<ul>
<li><a href="https://zh.m.wikipedia.org/zh-hans/%E9%98%BF%E8%B4%9D%E5%B0%94%E7%BE%A4">阿贝尔群</a>（近世代数里讲过）<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-23-09-14-31.png"></li>
</ul>
<ul>
<li>例子<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-06-19-08-52-59.png"></li>
</ul>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-23-09-11-15.png"></p>
<h1 id="摘要（csapp）"><a href="#摘要（csapp）" class="headerlink" title="摘要（csapp）"></a>摘要（csapp）</h1><p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-23-09-17-51.png"><br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-23-09-17-58.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>CSAPP</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-Multi-Reactors</title>
    <url>/2022/10/18/muduo-Multi-Reactors/</url>
    <content><![CDATA[<p>muduo类图</p>
<span id="more"></span>

<h1 id="TcpServer-multi-single-Reactor"><a href="#TcpServer-multi-single-Reactor" class="headerlink" title="TcpServer - multi/single-Reactor"></a>TcpServer - multi/single-Reactor</h1><ul>
<li><p>全图<br><img src="/2022/10/18/muduo-Multi-Reactors/2022-10-19-08-57-52.png"></p>
</li>
<li><p>大图</p>
</li>
<li><p>建立新连接+分发新连接<br><img src="/2022/10/18/muduo-Multi-Reactors/2022-10-19-09-06-57.png"></p>
</li>
<li><p>已连接读写<br><img src="/2022/10/18/muduo-Multi-Reactors/2022-10-19-09-00-19.png"></p>
</li>
<li><p>销毁连接<br><img src="/2022/10/18/muduo-Multi-Reactors/2022-10-19-09-00-54.png"></p>
</li>
</ul>
<h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><ul>
<li><p><strong>Acceptor</strong>：封装了listening fd 以及 连接event 以及 处理连接事件的callback ： handleConnection</p>
</li>
<li><p><strong>重要成员</strong></p>
<ul>
<li>acceptSocket_：listening fd</li>
<li>acceptChannel_：listening fd 以及 监听事件 以及 回调</li>
<li>EventLoop *loop：listening fd 所属的eventLoop。一般是main thread 的 eventLoop.</li>
<li>newConnectionCallback_: TcpServer构造函数中将 TcpServer::newConnection 绑定给acceptor。故acceptor接收连接之后 分发client的channel给ioloop。</li>
</ul>
</li>
<li><p><strong>重要函数</strong></p>
</li>
<li><p><strong>handleConnection</strong></p>
<ul>
<li>当poller epoll wait 监听到连接事件时 会调用该回调<ul>
<li><ol>
<li>handleConnection : accept连接 得到新connfd</li>
</ol>
</li>
<li><ol start="2">
<li>newConnectionCallback(TcpServer绑定的) : 本mainReactor选择一个subReactor 将连接派发。</li>
</ol>
</li>
</ul>
</li>
<li>核心逻辑如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Acceptor :: handleConnection(Timestamp)</span><br><span class="line">&#123;</span><br><span class="line">    InetAddress peerAddr;</span><br><span class="line">    <span class="keyword">int</span> connfd = acceptSocket_.accept(&amp;peerAddr);               <span class="comment">//  accpet</span></span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(InetAddress::getSockName(connfd))</span></span>;    <span class="comment">// 获取本机信息</span></span><br><span class="line">    newConnectionCallback_(connfd,peerAddr,localAddr);          <span class="comment">//  轮询subloop 唤醒 分发当前新client的channel</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>listen</strong></p>
<ul>
<li>socket开启listen队列，poller监听连接事件，等待connect。</li>
</ul>
</li>
</ul>
<h2 id="TcpConnection"><a href="#TcpConnection" class="headerlink" title="TcpConnection"></a>TcpConnection</h2><ul>
<li><p>与acceptor平级</p>
<ul>
<li><strong>acceptor</strong> : <strong>负责listening fd 的accept。</strong><ul>
<li><strong>mainloop中的 封装listenfd、相关事件及回调.(监听、接受连接、分发连接给subLoop)</strong></li>
</ul>
</li>
<li><strong>tcpconntcion</strong> : <strong>负责一个connfd的通信</strong><ul>
<li><strong>subloop中的 封装已连接connfd、相关事件及回调.(读消息事件、发送消息事件、连接关闭事件、错误事件等)</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>功能!!!</strong></p>
<ul>
<li><strong>1. encapsulate fd into channel</strong></li>
<li><strong>2. register callback into channel</strong> and keep callback</li>
<li><strong>3. bind ownerLoop and channel(fd)</strong> : channel enabling -&gt; reigster on the poller. 即所谓的派发连接给subloop，就是将指定subloop的poller监听、处理channel(fd)的event。</li>
<li><strong>4. keep channel(fd)</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>重要成员</strong><ul>
<li><strong>socket_</strong> :  connfd</li>
<li><strong>connectionEstablished:</strong> 连接建立完成后调用<ul>
<li><strong>将connfd的读事件注册在poller上</strong><ul>
<li>channel_-&gt;enableReading()</li>
</ul>
</li>
<li><strong>调用user set connectionCallback</strong></li>
<li>connectionEstablished在TcpServer::newConnection中被调用</li>
</ul>
</li>
<li><strong>connectionDestroyed ：</strong> 销毁连接<ul>
<li>会调用到user set connectionCallback</li>
<li>销毁连接时会通过调用TcpServer::removeConnection来销毁连接<ul>
<li>removeConnection -&gt; removeConnectionInLoop -&gt; connectionDestroyed</li>
</ul>
</li>
</ul>
</li>
<li><strong>channel_</strong> : connfd的事件(感兴趣和实际发生)以及回调(读、写、关闭连接等)。<ul>
<li>这个Channel的<strong>callback</strong>是在TcpConnection对象构造函数中注册的。<ul>
<li>这些<strong>callback最终都会在loop的handleEvent中被调用</strong></li>
<li><strong>TcpConnection::handleRead / handleClose / handleError / handleWrite</strong><ul>
<li>handleRead中会调用user set的messageCallback_</li>
<li>同理 handleWrite 有 user set 的 writeCompleteCallback_ </li>
<li>handleCose 有 closeCallback_</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>**loop_**：本TcpConnection所属的subloop</li>
<li>inputBuffer_：user态的接收缓冲区。</li>
<li>outputBuffer_：user态的发送缓冲区。</li>
<li>state_：当前TCP连接的状态（Connected、Connecting、Disconnecting、Disconnected）</li>
<li><strong>connetionCallback_、messageCallback_、writeCompleteCallback_</strong><ul>
<li><strong>交给用户自定义</strong>。（这也是用户唯数不多的自由）</li>
</ul>
</li>
<li>closeCallback_ ： <ul>
<li>muduo TcpServer自己定义的（不交给用户）</li>
</ul>
</li>
<li>用户如何自定义？<ul>
<li>TcpServer给了用户这样的接口。如setConnectionCallback。之后TcpServer再传给TcpConnection</li>
</ul>
</li>
</ul>
</li>
<li><strong>重要函数</strong><ul>
<li><strong>handleRead()</strong><ul>
<li>处理读事件，将内容存入inputBuffer</li>
<li>然后再调用user set的messageCallback_</li>
<li>核心代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  注册给channel 这个函数最终会被ioloop调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  将fd中可读的数据 读到inputBuffer中</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n = inputBuffer_.readFd(channel_-&gt;fd(),&amp;savedErrno);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">        messageCallback_(shared_from_this(),&amp;inputBuffer_,receiveTime);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        handleClose();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        handleError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>handleWrite()</strong><ul>
<li>负责处理epoll上注册的Tcp连接的可写事件（即写数据给fd）。视情况与outputBuffer交互。</li>
<li>写完之后 调用 writeCompleteCallback_<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  outputBuffer中的bytes 写入 fd</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  写完 停止Poller监听</span></span><br><span class="line">    <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">        <span class="keyword">if</span>(writeCompleteCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  没写完 继续监听 稍后处理</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;I&#x27;m going to write more data&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  如何做到一个事件的处理不长时间占用控制权？措施之一如下</span></span><br><span class="line">    <span class="comment">//  如果一次没写完的话，不会阻塞在这里等待缓冲区空闲然后继续写</span></span><br><span class="line">    <span class="comment">//  而是将控制交还给eventloop。因为写事件还在epoll tree上监听，并且未写的数据存在outputBuffer中</span></span><br><span class="line">    <span class="comment">//  等待下一次循环poller监听到写事件 触发write即可</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>handleClose()</strong><ul>
<li>负责处理Tcp连接关闭的事件。</li>
<li>大概的处理逻辑就是<ul>
<li>将本TCP Connection的fd 的 channel_从poller中移除。</li>
<li>connectionCallback_ (user set)</li>
<li>closeCallback_。(muduo set)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  poller -&gt;  channel::closeCallback -&gt; TcpConnection::handleClose -&gt; TcpServer::removeConnection -&gt; TcpConnection::connectionDestoyed</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  改变状态</span></span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    <span class="comment">//  从poller上拿下来</span></span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">connPtr</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    <span class="comment">//  user设置的</span></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(connPtr);       <span class="comment">//  连接断开和连接的回调</span></span><br><span class="line">    <span class="comment">//  muduo set TcpServer::removeConnection -&gt; TcpConnection::connectionDestroyed</span></span><br><span class="line">    <span class="built_in">closeCallback_</span>(connPtr);            <span class="comment">//  关闭连接的回调  TcpServer::removeConnection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><strong>send</strong><ul>
<li>send -&gt; sendInLoop -&gt;注册handleWrite<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sendInLoop(buf.c_str(),buf.size());</span><br><span class="line">    <span class="keyword">or</span> loop_-&gt;runInLoop(<span class="built_in">std</span>::bind(</span><br><span class="line">        &amp;TcpConnection::sendInLoop,</span><br><span class="line">        <span class="keyword">this</span>,</span><br><span class="line">        buf.c_str(),</span><br><span class="line">        buf.size()</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>sendInLoop : 与outputBuffer和Poller交互，执行发送</li>
</ul>
<h1 id="TcpServer"><a href="#TcpServer" class="headerlink" title="TcpServer"></a>TcpServer</h1><p><strong>Acceptor ,EventLoopThreadPool ,TcpConnection</strong></p>
<h2 id="重要成员："><a href="#重要成员：" class="headerlink" title="重要成员："></a>重要成员：</h2><ul>
<li>unique_ptr&lt;Acceptor.&gt; <strong>acceptor_</strong><ul>
<li>TcpServer::newConnection 绑定给acceptor</li>
<li>acceptor接收新连接之后 将该连接分发给threadPool中的subloop(subReactor)</li>
</ul>
</li>
<li>shared_ptr&lt;EventLoopThreadPool.&gt; <strong>threadPool_</strong><ul>
<li>subReactors pool</li>
</ul>
</li>
</ul>
<h2 id="重要函数"><a href="#重要函数" class="headerlink" title="重要函数"></a>重要函数</h2><ul>
<li><p><strong>newConnection</strong> ：accept新连接之后， 会调用acceptor的handleConnection，handleConnection会执行newConnection。</p>
<ul>
<li>将新连接派发给subloop，即将新建立连接的connfd的监听和处理都交给一个ioloop<ul>
<li><strong>如何做到派发？</strong></li>
<li><strong>通过new TcpConnection</strong>。TcpConnection会负责将subloop和connfd的channel绑定在一起。即将channel注册在subloop的poller上(在TcpConnection::connectionEstablished中执行)。</li>
</ul>
</li>
<li><strong>如何唤醒</strong> 派发到的(subloop)subReactor,使其处理新连接的connectionEstablished ?<ul>
<li><strong>wakeupFd</strong></li>
<li>subloop此时应当阻塞在poller wait上。main thread 通过向其监听的wakeupFd写入data，使其从poller wait中离开。</li>
</ul>
</li>
</ul>
</li>
<li><p>removeConnection：注册在TcpConnection::handleClose中。</p>
<ul>
<li>关闭连接。流程见下文</li>
</ul>
</li>
<li><p><strong>start</strong></p>
<ul>
<li>启动EventLoopThreadPool中的subloop</li>
<li>mainloop 开启listening queue 并注册监听listenfd到mainloop的Poller上。</li>
</ul>
</li>
<li><p>setsubThreadNum</p>
<ul>
<li>设置subReactor数量。<ul>
<li>num = 0. 则只有一个reactor，既负责监听、处理listening fd的新连接建立事件，又负责监听、处理已连接socket connfd的读写事件。<img src="/2022/10/18/muduo-Multi-Reactors/2022-10-18-21-24-53.png"></li>
<li>num &gt; 0. 则一个mainReactor num个subReacor。<ul>
<li>mainReactor 的mainloop负责监听处理listeningfd的新连接建立事件。 </li>
<li>subReactor 的subloop负责监听处理connfd的读写事件<br><img src="/2022/10/18/muduo-Multi-Reactors/2022-10-18-21-24-30.png"></li>
</ul>
</li>
</ul>
</li>
<li>可见 blog服务设计范式</li>
</ul>
</li>
</ul>
<ul>
<li>以及callback之间关系</li>
</ul>
<ul>
<li>还有，muduo中关于callback的使用。即function 和 bind的组合使用。</li>
<li>有一件大任务，需要分给几个组件来做，或者需要分成不同时期来做<ul>
<li>上层做不完的事情/不应当在此时调用的事情 ，上层将他自己要做的那一部分事情存入函数。将函数注册给下层。下层执行下层可以做的事情，并适时执行上层注册函数，来完成整个任务。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO模型</title>
    <url>/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="阻塞、非阻塞、同步、异步"><a href="#阻塞、非阻塞、同步、异步" class="headerlink" title="阻塞、非阻塞、同步、异步"></a>阻塞、非阻塞、同步、异步</h1><p><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-04-22-50-44.png"></p>
<p><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-04-23-22-56.png"></p>
<h2 id="网络IO阶段一：数据准备"><a href="#网络IO阶段一：数据准备" class="headerlink" title="网络IO阶段一：数据准备"></a>网络IO阶段一：数据准备</h2><ul>
<li><strong>数据准备：根据系统IO操作的就绪状态。</strong><ul>
<li>阻塞 blocking</li>
<li>非阻塞  non-blocking</li>
</ul>
</li>
</ul>
<ul>
<li><strong>解释</strong><ul>
<li>比如API recv</li>
<li>远端是否有数据过来，也即内核对应的sockfd的TCP缓冲区是否有数据可读</li>
<li>在<strong>阻塞</strong>时，如果远端没有数据过来，那么recv会阻塞在那里。</li>
<li>在<strong>非阻塞</strong>时，无论有没有数据过来，recv都会立刻返回。通过recv的返回值，判断状态。<ul>
<li>size == -1 &amp;&amp; errno = EAGAIN 非阻塞没数据</li>
<li>size = 0 网络对端关闭</li>
<li>size &gt; 0 读到的bytes数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="网络IO阶段二：数据读取"><a href="#网络IO阶段二：数据读取" class="headerlink" title="网络IO阶段二：数据读取"></a>网络IO阶段二：数据读取</h2><ul>
<li><p><strong>数据读写：根据应用程序和内核的交互方式</strong></p>
<ul>
<li>同步  synchronous</li>
<li>异步 asynchronous</li>
</ul>
</li>
<li><p><strong>解释</strong></p>
</li>
<li><p><strong>同步 synchronous</strong></p>
<ul>
<li>API recv </li>
<li>arg传sockfd，buf</li>
<li>(无论阻塞和非阻塞时)，如果数据就绪了，sockfdkernel的TCP缓冲区中有数据，那么会将os的内核缓冲区拷贝到应用程序的buf缓冲区，这段时间花的是应用程序自己的时间。等待直到拷贝完成后，recv才返回，应用程序才能向后走。</li>
</ul>
</li>
<li><p><strong>异步 asynchronous</strong></p>
<ul>
<li>传sockfd，buf，通知方式</li>
<li>os负责监听，tcp缓冲区是否有数据可读，有的话，则内核替我将数据从内核缓冲区拷贝到我传给他的buf。拷贝完后再通过约定好的通知方式通知我。这段拷贝的时间是其他进程花费的时间。不是本进程花费的时间</li>
</ul>
</li>
<li><p>也即同步需要自己监听 事件什么时候完成(数据从内核缓冲区被拷贝到用户缓冲区)</p>
</li>
<li><p>而异步不需要，当事情完成后，会有别人通知（数据的监听，数据的搬运(读写)都不需要应用程序来花费时间，都是内核做的）</p>
</li>
</ul>
<ul>
<li><strong>业务的同步异步</strong><ul>
<li>与IO的同步异步原理相同</li>
<li>是业务层面的处理逻辑</li>
<li>同步：A发起请求，等待B操作做完事情，得到返回值，继续处理。</li>
<li>异步：A操作告诉B操作它感性确定时间以及通知方式，A操作继续执行自己的业务逻辑了；等B监听到相应的事件发生后，B会通知A，A开始相应的数据处理逻辑。</li>
</ul>
</li>
</ul>
<ul>
<li>总结<ul>
<li>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；</li>
<li>异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果</li>
</ul>
</li>
</ul>
<ul>
<li><p>同步阻塞：int sz = recv(fd,buf,SIZE,0);</p>
</li>
<li><p>同步非阻塞：int sz = recv(fd,buf,SIZE,非阻塞);</p>
</li>
<li><p>异步阻塞：理论上有，但完全就是浪费时间，没必要，没人用。</p>
</li>
<li><p>异步非阻塞：异步一般都是非阻塞。</p>
</li>
<li><p><strong>描述逻辑</strong></p>
<ul>
<li>用一个IOAPi来讲，比如read/recv</li>
<li>在阻塞/非阻塞下的表现形式</li>
<li>接下来再介绍同步、异步（特殊API aio_read）</li>
</ul>
</li>
</ul>
<blockquote>
<p>陈硕大神原话：在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步<br>IO。<br><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-04-22-54-02.png"></p>
</blockquote>
<h1 id="Linux五种IO模型"><a href="#Linux五种IO模型" class="headerlink" title="Linux五种IO模型"></a>Linux五种IO模型</h1><p><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-25-16-25-49.png"></p>
<h2 id="Blocking-IO"><a href="#Blocking-IO" class="headerlink" title="Blocking IO"></a>Blocking IO</h2><p><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-25-16-02-10.png"></p>
<ul>
<li>同步阻塞</li>
<li>一直阻塞 效率不高。</li>
<li>分为两阶段<ul>
<li>等待数据就绪</li>
<li>拷贝数据从kernel buf -&gt; usr buf</li>
</ul>
</li>
</ul>
<h2 id="non-Blocking-IO"><a href="#non-Blocking-IO" class="headerlink" title="non-Blocking IO"></a>non-Blocking IO</h2><p><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-25-16-05-10.png"></p>
<ul>
<li>同步非阻塞</li>
<li>我的问题：<ul>
<li>真的，就在这里不断轮询有什么用？浪费时间还占用cpu。不如把cpu让给别的线程，在这非阻塞轮询还不如阻塞呢。那非阻塞有什么用？</li>
</ul>
</li>
<li>解决：<ul>
<li>non-blocking一般是和IO复用配合使用</li>
</ul>
</li>
</ul>
<h2 id="IO复用（IO-multiplexing）"><a href="#IO复用（IO-multiplexing）" class="headerlink" title="IO复用（IO multiplexing）"></a>IO复用（IO multiplexing）</h2><p><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-25-16-04-25.png"></p>
<ul>
<li><p>epoll/select/poll:同步。异步最大的特点是协商了一个通知事件机制，这里明显没有，就是在等待。</p>
</li>
<li><p>read同步</p>
</li>
<li><p>IO复用比起轮询和阻塞好在哪？</p>
<ul>
<li>一次返回多个事件，从而不用多次在内核态和用户态之间切换。</li>
</ul>
</li>
</ul>
<h2 id="Signal-Driven-信号驱动"><a href="#Signal-Driven-信号驱动" class="headerlink" title="Signal-Driven 信号驱动"></a>Signal-Driven 信号驱动</h2><p><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-05-20-18-01.png"></p>
<ul>
<li>在第一个阶段异步，在第二个阶段同步。</li>
<li>如果阻塞的话，需要一直阻塞</li>
<li>如果非阻塞的话，需要一直轮询检查</li>
<li>而信号通知机制，使得我们不必阻塞也不必轮询检查，可以去做应用程序自己的事情，同时减少了系统API的调用次数，提高效率。</li>
<li>很少用。因为信号异步 不好处理</li>
</ul>
<h2 id="Asychronous-异步"><a href="#Asychronous-异步" class="headerlink" title="Asychronous 异步"></a>Asychronous 异步</h2><p><img src="/2022/09/04/muduo-Linux_IO%E6%A8%A1%E5%9E%8B/2022-09-25-16-08-42.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> aio_fildes</span><br><span class="line">  <span class="keyword">off_t</span> aio_offset</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">void</span> *aio_buf</span><br><span class="line">  <span class="keyword">size_t</span> aio_nbytes</span><br><span class="line">  <span class="keyword">int</span> aio_reqprio</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">aio_sigevent</span></span></span><br><span class="line"><span class="class">  <span class="title">int</span> <span class="title">aio_lio_opcode</span></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>异步非阻塞，根本不消耗应用程序的时间，应用程序完全可以去做其他事情，等待内核通知即可</li>
<li>编写困难。</li>
</ul>
<h1 id="one-loop-per-thread"><a href="#one-loop-per-thread" class="headerlink" title="one loop per thread"></a>one loop per thread</h1><ul>
<li><strong>one loop per thread is usually a good model   ——libv作者</strong><ul>
<li>如果采用<strong>one loop per thread</strong>的模型，多线程服务器端编程就<strong>简化</strong>为如何<strong>设计一个高效，且易于使用的event loop，然后每个thread run 一个 event loop</strong>就行了。 再加上同步、互斥等。</li>
</ul>
</li>
<li><strong>event loop 是 non-blocking 网络编程的核心</strong></li>
</ul>
<h1 id="non-blocking-amp-IO-multiplexing"><a href="#non-blocking-amp-IO-multiplexing" class="headerlink" title="non-blocking &amp; IO multiplexing"></a>non-blocking &amp; IO multiplexing</h1><ul>
<li>在现实生活中，<strong>non-blocking 几乎总是和 IO multiplexing</strong> 一起使用，原因有两点：<ul>
<li><strong>单单non-blocking</strong>：不断轮询<strong>busy looping</strong>检查某个non-blocking IO操作是否完成，<strong>耗费时间，浪费CPU</strong>。没人这么做的</li>
<li><strong>单单IO-multiplex</strong>：IO-multiplex 一般不能和 blocking IO 用在一起，因为 blocking IO 中 read()/write()/accept()/connect() 都有可能<strong>阻塞当前线程</strong>，这样线程就没办法处理其他 socket上的 IO 事件了。<ul>
<li>例如：epoll返回一个可读事件，用户程序进行读取，会一直循环直到读完这个可读fd，如果我们用的是阻塞的socket的话，那么在read读完之后就会阻塞在这个read上，本线程在这里阻塞住，程序无法继续向下走，也无法返回到epoll中。</li>
</ul>
</li>
</ul>
</li>
<li>所以，当我们提到 non-blocking 的时候，实际上指的是<strong>non-blocking + IO-multiplexing</strong>，单用其中任何一个都没有办法很好的实现功能。</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-Buffer</title>
    <url>/2022/10/08/muduo-buffer/</url>
    <content><![CDATA[<ul>
<li>整理一下学习收获 先整理下muduo Buffer 因为属于是实现比较简单的组件。还比较巧妙。且便于移植。</li>
<li>muduo Buffer</li>
<li>参考 源码 以及 《Linux多线程服务器编程》</li>
</ul>
<span id="more"></span>

<h1 id="non-blocking-网络编程中-应用层Buffer的必要性"><a href="#non-blocking-网络编程中-应用层Buffer的必要性" class="headerlink" title="non-blocking 网络编程中 应用层Buffer的必要性"></a>non-blocking 网络编程中 应用层Buffer的必要性</h1><ul>
<li><p><strong>non-blocking的核心思想</strong>：</p>
<ul>
<li>为了可以最大限度的<strong>复用 thread-of-control</strong>，让<strong>一个thread服务于多个socket连接</strong>。<ul>
<li><strong>即，控制权应当尽量交给event loop</strong>（因为只有event loop才能接受新连接或者检测到socket的事件）</li>
<li><strong>即，不让reactor的loop在没必要阻塞的地方阻塞</strong>。</li>
<li><strong>IO thread 只能阻塞在 IO multiplexing函数</strong></li>
</ul>
</li>
<li>因此要避免阻塞在read/write/或者其他IO系统调用上</li>
</ul>
</li>
<li><p>TcpConnection中有一个inputBuffer和一个outputBuffer</p>
<ul>
<li>这里的intput output是针对user代码而言</li>
</ul>
</li>
</ul>
<h2 id="outputBuffer的必要性"><a href="#outputBuffer的必要性" class="headerlink" title="outputBuffer的必要性"></a>outputBuffer的必要性</h2><ul>
<li><p><img src="/2022/10/08/muduo-buffer/2022-10-08-22-08-27.png"></p>
</li>
<li><p><strong>概述</strong>：muduo中，user不会自己直接write socket，也不会直接操作outputBuffer，而是<strong>间接</strong>的。通过TcpConnection::send(),来决定是write socket 还是操作outputBuffer。</p>
<ul>
<li>不是所有数据都会先写入outputBuffer 再发送给socket的。也会有不用写入outputBuffer直接write给socket的。但不是用户调用write。用户调用TcpConnection::send(),之后就是send的逻辑了。决定write还是outputBuffer。用户不必再管。</li>
</ul>
</li>
<li><p>必要性</p>
<ul>
<li>场景：<ul>
<li>程序通过TCP连接发送100KB数据，但是在write调用中，os只接受了80KB。<ul>
<li>这也就是常说的：应用写的快，而内核发送数据慢，因此需要把待发送的数据写入缓冲区</li>
</ul>
</li>
<li>如果没有缓冲区的话，此时我们可以选择原地等待。等到socket的缓冲区可写。那么，此时程序的控制权就不在event loop了。</li>
<li>如果没有缓冲区的话，也可以不原地等待，而是直接将控制返回给event loop。那么，此时，剩下的20KB怎么办？<ul>
<li><strong>那么</strong>，就需要有一个<strong>outputBuffer</strong>，来接管这20KB。</li>
</ul>
</li>
</ul>
</li>
<li>关于责任：使用网络库的人不应当去关心如何发送数据，将数据发送了几次，应当只负责将数据交给网络库去发送（muduo中是提供TcpConnection::send()给user）。<ul>
<li>user —data—&gt; tcpConnection –send–&gt; socket</li>
</ul>
</li>
<li>因此，网络库中需要有一个outputBuffer，来接管上文中user生成的，网络库未发送完的20KB数据。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Buffer设计逻辑</strong>：<ul>
<li>感觉很合理啊。</li>
<li>对于每个TcpConnection都有一个outputBuffer</li>
<li>user想要发送XXKB。（通过调用TcpConnection::Send())<ul>
<li><strong>如果outputBuffer中没有数据的话</strong>，那么直接发送。<ul>
<li>如果一次发送完，那么并不需要将数据加入outputBuffer，也不需要在Poller上注册EPOLLOUT事件。</li>
<li>如果发送完还剩20KB的话，TcpConnection将未发送完的数据20KB保存在outputBuffer中，并再Poller上给fd注册POLLOUT事件。</li>
<li>之后，如果socket缓冲区变得可写，那么，event loop就会监测到该事件，并调用TcpConnection::handleWrite() 将outputBuffer中的剩余数据发送出去。</li>
<li>当outputBuffer中的数据写完时，Poller就停止监听POLLOUT。避免busy loop。</li>
</ul>
</li>
<li><strong>如果outputBuffer中有数据的话</strong>，那么不直接发送，而是先将这xxKBappend到outputBuffer的20KB的data之后，等到socket可写时，一并写入socket。而不是直接发送。</li>
<li>当该TcpConnection的Buffer中还有数据未写，也即Poller上仍监听该fd的POLLOUT事件时，如果程序想要关闭连接。那么，不会立刻关闭，而是先等到outputBuffer中的数据全都写完，再关闭链接。<ul>
<li>见TcpConnection::shutdown()<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  保证在IO thread中调用</span></span><br><span class="line"><span class="comment">//  当outputBuffer里面没有待发送数据时 关闭本connection的socket写端</span></span><br><span class="line"><span class="comment">//  当outputBuffer里面有待发送数据时   等handleWrite将outputBuffer全部写出之后 handleWrite会调用shutdownInLoop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  outputBuffer中的bytes已经全部发送完成</span></span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>())          </span><br><span class="line">    &#123;</span><br><span class="line">        socket_-&gt;<span class="built_in">shutdownWrite</span>();       <span class="comment">//  关闭写端</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果outputBuffer没全部发送</span></span><br><span class="line">        <span class="comment">//  之后也会调用到shutdownInLoop</span></span><br><span class="line">        <span class="comment">//  见handleWrite</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="inputBuffer的必要性"><a href="#inputBuffer的必要性" class="headerlink" title="inputBuffer的必要性"></a>inputBuffer的必要性</h2><ul>
<li><p><img src="/2022/10/08/muduo-buffer/2022-10-08-22-39-57.png"></p>
</li>
<li><p><strong>概述</strong>：socket从网卡中读来的数据 都会由TcpConnection先读入inputBuffer。然后，将inputBuffer交由user来处理。user拿到inputBuffer时，里面就已经有了这次读到的所有数据。</p>
</li>
<li><p><strong>必要性</strong></p>
<ul>
<li><p>场景：接收方需要接受2KB数据</p>
<ul>
<li>一次性收到2KB</li>
<li>分两次收到，一次600B，一次1400B</li>
<li>分两次收到，一次1KB</li>
<li>….</li>
<li>所以</li>
</ul>
</li>
<li><p>关于责任</p>
<ul>
<li>网络库在处理socket可读事件时，必须<strong>一次性把socket 接收缓冲区里的数据读完，user从网络库的Buffer里面取数据即可</strong>。（从kenrel的Buffer搬到应用层的Buffer），否则会反复触发POLLIN事件，造成busy-loop。<ul>
<li>如果网络库不提供缓冲区，仅仅通知user某个socket可读/可写. 或者只提供一个固定大小的缓冲区如char <a href="%E8%BF%99%E4%B8%8D%E5%B0%B1%E8%B7%9Fuser%E8%87%AA%E5%B7%B1%E8%B4%9F%E8%B4%A3buffer%E4%B8%80%E6%A0%B7">8192</a></li>
<li>那么user需要自己负责读取所有数据到user的应用层buffer。不方便。（如果user自己的buffer不够大，那么就需要读很多次）</li>
</ul>
</li>
<li><blockquote>
<p>网络库必然会遇到 “数据不完整” 的情况，如上，分多次收到一批数据。应对：收到的数据先放到inputBuffer中，等构成一条完成的消息再通知程序的业务逻辑。[这个实现还没看。应当是7.3节]</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Buffer设计思路</strong></p>
<ul>
<li>user不会自己操作read socket，而是操作TcpConnection的inputBuffer。</li>
<li>与user间接outputBuffer不同，user可以直接操作inputBuffer。</li>
<li>user在onMessage()中，收到的data已经被存储在inputBuffer中，user可以直接操作inputBuffer。<ul>
<li><code>void onMessage(const TcpConnectionPtr&amp; conn,Buffer *buffer,Timestamp time)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="inputBuffer相关代码"><a href="#inputBuffer相关代码" class="headerlink" title="inputBuffer相关代码"></a>inputBuffer相关代码</h2><ul>
<li>connfd刚被accept，就会将其读事件注册在Poller上。channel的callback就是TcpConnection::handleRead().<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectionEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 给新建立的connfd 注册读事件到Poller</span></span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>();           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  设置回调</span></span><br><span class="line">channel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead,<span class="keyword">this</span>,std::placeholders::_1));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  注册给channel 这个函数最终会被ioloop调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  将fd中可读的数据 读到inputBuffer中</span></span><br><span class="line">    <span class="keyword">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;handle read %lu bytes&quot;</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(),&amp;inputBuffer_,receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::handleRead&quot;</span>);</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="outputBuffer相关代码"><a href="#outputBuffer相关代码" class="headerlink" title="outputBuffer相关代码"></a>outputBuffer相关代码</h2><ul>
<li>user通过调用TcpConnection::send()来发送data。</li>
<li>user -&gt; send -&gt; sendInLoop。sendInLoop中的逻辑见上文中outputBuffer的设计逻辑。</li>
<li>poller监测到write事件时，loop会调用TcpConnection::handleWrite 将outputBuffer中的数据发送。</li>
<li>TcpConnection.cpp  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  send -&gt; sendInLoop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="keyword">const</span> std::string &amp;buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LOG_INFO(&quot;send bytes buf %s&quot;,buf.c_str());</span></span><br><span class="line">    <span class="keyword">int</span> n = buf.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = buf.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;test send %d : %s&quot;</span>,n,str);</span><br><span class="line">    <span class="keyword">if</span>(state_ == kConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  sendInLoop</span></span><br><span class="line">            <span class="comment">//  会根据 output queue中是否还有未发送数据</span></span><br><span class="line">            <span class="comment">//  来决定是直接发送buf 还是先将buf送入outputBuffer 再发送</span></span><br><span class="line">        <span class="keyword">if</span>(loop_-&gt;<span class="built_in">isInLoopThread</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(buf.<span class="built_in">c_str</span>(),buf.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(</span><br><span class="line">                &amp;TcpConnection::sendInLoop,</span><br><span class="line">                <span class="keyword">this</span>,</span><br><span class="line">                buf.<span class="built_in">c_str</span>(),</span><br><span class="line">                buf.<span class="built_in">size</span>()</span><br><span class="line">            ));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送数据：</span></span><br><span class="line"><span class="comment">    应用写的快 而内核发送数据慢</span></span><br><span class="line"><span class="comment">    需要把待发送的数据写入缓冲区</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *data,<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> remaning = len;</span><br><span class="line">    <span class="keyword">bool</span> faultError = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  之前调用过该connection的shutdown 不能再进行发送了</span></span><br><span class="line">    <span class="keyword">if</span>(state_ == kDisconnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;disconnected give up writing!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果output queue(outputBuffer_) 中没有任何数据的话，那么就直接发送给fd。</span></span><br><span class="line">        <span class="comment">//  表示channel第一次开始写数据 而且缓冲区没有待发送数据</span></span><br><span class="line">    <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;直接将data发送，而不是先送入outputBuffer&quot;</span>);</span><br><span class="line">        <span class="comment">//  output queue中没有待发送数据 因此 直接将data写给fd</span></span><br><span class="line">        nwrote = ::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),data,len);</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;nwrote = %d&quot;</span>,nwrote);</span><br><span class="line">        <span class="keyword">if</span>(nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  是否将data都发送完</span></span><br><span class="line">            remaning = len - nwrote;</span><br><span class="line">            <span class="keyword">if</span>(remaning == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  如果发送完了 那么就调用一下writeCompleteCallback_</span></span><br><span class="line">                <span class="comment">//  既然在这里 数据全部发送完成 就不用再给channel 设置 epollout事件了</span></span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                    std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  else ? </span></span><br><span class="line">            <span class="comment">//  没发送完的话不是应当write more data 吗 ？</span></span><br><span class="line">            <span class="comment">//  为什么没处理 ？</span></span><br><span class="line">                <span class="comment">//  在这个if外面处理了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//  nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(errno != EWOULDBLOCK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection::sendInLoop error&quot;</span>);</span><br><span class="line">                <span class="comment">//  对方socket重置</span></span><br><span class="line">                    <span class="comment">//  server收到</span></span><br><span class="line">                    <span class="comment">//  SIGPIPE</span></span><br><span class="line">                    <span class="comment">//  RESET</span></span><br><span class="line">                <span class="keyword">if</span>(errno == EPIPE || errno == ECONNRESET)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;errno == %s&quot;</span>,<span class="built_in">strerror</span>(errno));</span><br><span class="line">                    faultError = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  说明当前这一次write并没有把数据全部发送出去</span></span><br><span class="line">    <span class="comment">//  剩余的数据需要保存到缓冲区当中 </span></span><br><span class="line">    <span class="comment">//  然后给channel注册epollout事件</span></span><br><span class="line">    <span class="comment">//  poller发现tcp的发送缓冲区有空间</span></span><br><span class="line">    <span class="comment">//  会通知相应的sock-&gt;channel</span></span><br><span class="line">    <span class="comment">//  调用writeCallback_ 回调方法</span></span><br><span class="line">    <span class="comment">//  也就是TcpConnection::handleWrite方法 把发送缓冲区的数据全部发送完成为止</span></span><br><span class="line">    <span class="keyword">if</span>(!faultError &amp;&amp; remaning &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;data没能全部发送走 因此将剩余的data放入outputBuffer&quot;</span>);</span><br><span class="line">        <span class="comment">//  目前发送缓冲区剩余的待发送数据的长度</span></span><br><span class="line">        <span class="keyword">size_t</span> oldlen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="keyword">if</span>(oldlen + remaning &gt;= highWaterMark_</span><br><span class="line">            &amp;&amp; oldlen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMarkCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                std::<span class="built_in">bind</span>(highWaterMarkCallback_,<span class="built_in">shared_from_this</span>(),oldlen + remaning)</span><br><span class="line">            );   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  将data中没有发送的数据 存入outputBuffer</span></span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>((<span class="keyword">char</span>*)data+nwrote,remaning);</span><br><span class="line">        <span class="comment">//  这里一定要注册Channel的写事件</span></span><br><span class="line">        <span class="comment">//  否则poller不会给channel通知epollout</span></span><br><span class="line">        <span class="keyword">if</span>(!channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;将fd = %d的写事件 注册给poller&quot;</span>,channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">channel_-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite,<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//  outputBuffer中有未发送数据 且 tcp socket的写缓冲区可写的时候 loop会执行这个call back</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;fd = %d , outputBuffer data size = %ld &quot;</span>,channel_-&gt;<span class="built_in">fd</span>(),outputBuffer_.<span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="comment">//  channel_ 封装的fd 有注册在epoll上的writing事件</span></span><br><span class="line">    <span class="keyword">if</span>(channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//  outputBuffer中的bytes 写入 可写的fd</span></span><br><span class="line">        <span class="keyword">ssize_t</span> n = outputBuffer_.<span class="built_in">writeFd</span>(channel_-&gt;<span class="built_in">fd</span>(),&amp;savedErrno);</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  将已经写出的bytes取出 ：readerIdx向前移动nbytes</span></span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">            <span class="comment">//  如果已经没有数据可以从buffer中取出  可取bytes : [readerIdx,writerIdx) </span></span><br><span class="line">                <span class="comment">//  即buffer中的数据都已经写给fd</span></span><br><span class="line">                <span class="comment">//  那么我们需要立刻停止epoll对writable事件的监听</span></span><br><span class="line">            <span class="comment">//  !=0的话 代表buffer中还有可写数据 那么不必取消监听。epoll稍后应当检测到可写事件 然后继续调用本函数进行写</span></span><br><span class="line">            <span class="keyword">if</span>(outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  取消监听！！！</span></span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">                <span class="comment">//  执行写完成回调</span></span><br><span class="line">                <span class="keyword">if</span>(writeCompleteCallback_)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//  唤醒loop对应的thread线程 执行回调</span></span><br><span class="line">                        <span class="comment">//  这个writeCompleteCallback 是什么？</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">                        std::<span class="built_in">bind</span>(writeCompleteCallback_,<span class="built_in">shared_from_this</span>())</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  如果全部outputBuffer里面的数据全部写出 并且server已经要求关闭这个连接，但是之前由于outputBuffer里面有要写的数据 因此没有关闭连接 的话</span></span><br><span class="line">                <span class="comment">//  那么 此时 数据全部写出 就要调用刚才没执行的shutdownInLoop()</span></span><br><span class="line">                <span class="keyword">if</span>(state_ == kDisconnecting)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//  关闭socket的write方向</span></span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">LOG_INFO</span>(<span class="string">&quot;I&#x27;m going to write more data&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection : outputBuffer write error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;TcpConnection fd = %d is down , no more is writing\n&quot;</span>,channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Buffer实现"><a href="#Buffer实现" class="headerlink" title="Buffer实现"></a>Buffer实现</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>结构如下<br>  <img src="/2022/10/08/muduo-buffer/2022-10-09-19-53-46.png"></li>
<li>readable和writable都是针对Buffer来说的。<ul>
<li>readable : 可以从Buffer中读出的数据</li>
<li>writable : 还可以向Buffer中写入</li>
</ul>
</li>
<li>prependable = readInx</li>
<li>readable = writeIndex - readIndex</li>
<li>writable = buffer_.size() - writeIndex</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><img src="/2022/10/08/muduo-buffer/2022-10-09-20-41-31.png"></p>
<ul>
<li>Buffer中的readable writeable都是针对Buffer来说的。<ul>
<li>可从buffer中读出(读出来给fd) ；可向buffer中写入（从fd中读出来写给buffer）</li>
<li>[readerIdx,writerIdx) 有效数据 可从buffer中读出</li>
<li>[writerIdx,size)      剩余的可向buffer中写入的byte数</li>
</ul>
</li>
<li><strong>Interface for user</strong><ul>
<li>readFd fd               : 用户使用readFd   从fd读取数据 输入给Bufferd的writable区域[writeIdx,size)</li>
<li>writeFd  fd             : 用户使用writeFd  将Buffer中的readable数据 全部输入给fd文件</li>
<li>retrieveAllAsString     : 用户从buffer中拿走全部readable bytes。以string形式获得。会改变readIdx</li>
<li>append                  : Buffer使用者 通过append 向Buffer中增添数据。buffer数据增加最终只有一种方式：append (可能是通过readFd调用，也可能是直接调用）</li>
</ul>
</li>
<li>Important memeber Function<ul>
<li>makeSpace : 无需user自己调用。扩容/腾挪。确保有nbytes的writable</li>
<li>retrieve : 无需user自己调用。清除Buffer中已经被读走的bytes。（通过移动readerIdx）</li>
</ul>
</li>
<li>user不必关心Buffer的大小。Buffer是自适应扩张的。<ul>
<li>Buffer会自己扩充内存 管理writeIdx readIdx</li>
</ul>
</li>
<li>因此 user只需要负责 读数据到buffer，从buffer中拿出数据。</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-Thread-EventLoop</title>
    <url>/2022/10/18/muduo-Thread-EventLoop/</url>
    <content><![CDATA[<p>将loop和thread结合在一起的类 : EventLoopThread. one loop per thread</p>
<span id="more"></span>

<h1 id="EventLoopThreadPool"><a href="#EventLoopThreadPool" class="headerlink" title="EventLoopThreadPool"></a>EventLoopThreadPool</h1><p>EventLoopThread - subReactor<br>EventLoopThreadPool - subReactorPool</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul>
<li><p><strong>可复用于thread Pool。不只用于MuDuo</strong></p>
</li>
<li><p><strong>Thread class 封装了</strong></p>
<ul>
<li><ol>
<li>开启/结束/分离线程 </li>
</ol>
</li>
<li><ol start="2">
<li>注册线程函数 threadFunc</li>
</ol>
</li>
<li><ol start="3">
<li>记录线程信息 如tid,name…</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>重要成员</strong></p>
<ul>
<li>unique_ptr&lt;std::thread&gt; thread_<ul>
<li>不能直接造thread对象。因为thread对象一构造就开始运行。如果构造了thread对象，那么需要在构造函数初始化，那么一初始化线程就开始运行。</li>
</ul>
</li>
<li>ThreadFunc func_：thread func</li>
</ul>
</li>
</ul>
<ul>
<li><strong>重要函数</strong><ul>
<li>start : 开启thread，并记录tid(注意lock and cond避免data Race)</li>
<li>join : 等待thread结束<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Thread::start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::mutex mtx;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable cond;</span><br><span class="line">    <span class="comment">//  start thread</span></span><br><span class="line">    thread_ = <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::thread&gt;(<span class="keyword">new</span> <span class="built_in">std</span>::thread([&amp;](<span class="keyword">void</span>)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  临界区: tid_ , thread func内要写;开启thread的thread要读。</span></span><br><span class="line">        mtx.lock();</span><br><span class="line">        tid_ = CurrentThread::tid();</span><br><span class="line">        cond.notify_one();</span><br><span class="line">        mtx.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  threadFunc</span></span><br><span class="line">        func_();            <span class="comment">//  之后会注册成 EventLoopThread::threadFunc 在这其中创建EventLoop</span></span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  保证start返回时 新线程一定开始运行了。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!(tid_ != <span class="number">0</span>))&#123;</span><br><span class="line">            cond.wait(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    started_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="EventLoopThread"><a href="#EventLoopThread" class="headerlink" title="EventLoopThread"></a>EventLoopThread</h2><ul>
<li><p>EventLoopThread: <strong>将loop和thread结合在一起 ， 实现 one loop per thread</strong></p>
<ul>
<li>封装了 class Thread 和 EventLoop</li>
<li>实现 one loop per thread <ul>
<li>在 threadFunc中创建 EventLoop 对象 并运行loop.loop()：开启循环监听。</li>
<li>这样 通过EventLoopThread开启一个thread即代表开启一个loop。开启一个loop即代表开启了一个reactor。</li>
</ul>
</li>
<li><strong>所以一个EventLoopThread 其实 就可以看成一个 reactor</strong></li>
</ul>
</li>
<li><p><strong>重要成员</strong></p>
<ul>
<li>EventLoop *loop_ : 记录thread_中创建的EventLoop</li>
<li>Thread thread_   : 负责开启thread</li>
</ul>
</li>
<li><p><strong>重要函数</strong></p>
<ul>
<li>startLoop : 开启thread，记录loop_*<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">EventLoop* <span class="title">EventLoopThread::startLoop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    thread_.<span class="built_in">start</span>();      </span><br><span class="line">    <span class="comment">//  loop_临界区 : lock ; while(!cond) cond.wait ; unlock;</span></span><br><span class="line">    <span class="keyword">return</span> loop_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>threadFunc : 注册在Thread类。跑在thread上。创建EventLoop 并 loop.loop(). 实现 one loop per thread<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoopThread::threadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EventLoop loop;         </span><br><span class="line">    <span class="comment">//  loop_临界区 lock notify unlock</span></span><br><span class="line">    loop.<span class="built_in">loop</span>();          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="EventLoopTheadPool"><a href="#EventLoopTheadPool" class="headerlink" title="EventLoopTheadPool"></a>EventLoopTheadPool</h2><ul>
<li><p>EventLoopThreadPool：EventLoopThread池子。</p>
<ul>
<li>封装了</li>
</ul>
</li>
<li><p><strong>重要成员</strong></p>
<ul>
<li>vector&lt;unique_ptr<EventLoopThread>&gt; subReactors_ ：管理一堆subReactor，即EventLoopThread</EventLoopThread></li>
<li>vector&lt;EventLoop*&gt; loops_：记录一堆subReactor的loop</li>
</ul>
</li>
<li><p><strong>重要函数</strong></p>
<ul>
<li><p>start : 开启subReactors(EventLoopThreads)</p>
</li>
<li><p>getNextLoop : 轮询到一个subReactor的Loop，返回给上层。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoopThreadPool::start</span><span class="params">(<span class="keyword">const</span> ThreadInitCallback&amp; cb<span class="comment">/* = ThreadInitCallback()*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i&lt;numThreads_)</span><br><span class="line">    &#123;</span><br><span class="line">        EventLoopThread *t = <span class="keyword">new</span> <span class="built_in">EventLoopThread</span>(cb,name);</span><br><span class="line">        subReactors_.<span class="built_in">push_back</span>(unique_ptr&lt;EventLoopThread&gt;(t));</span><br><span class="line">        loops_.<span class="built_in">push_back</span>(t-&gt;<span class="built_in">startLoop</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  整个Server端中只有一个thread，将base放入baseloop(mainthread的eventloop_运行</span></span><br><span class="line">    <span class="keyword">if</span>(numThreads_ == <span class="number">0</span> &amp;&amp; cb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>(baseLoop_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>bind与shared_ptr</title>
    <url>/2022/10/08/muduo-bind%E4%B8%8Eshared-ptr/</url>
    <content><![CDATA[<p>bind : 传递值. 会导致shared_ptr的引用计数++<br>muduo中TCPConnectionPtr的生命周期介绍</p>
<span id="more"></span>

<h2 id="bind-只传递值-而非-引用"><a href="#bind-只传递值-而非-引用" class="headerlink" title="bind 只传递值 而非 引用"></a>bind 只传递值 而非 引用</h2><ul>
<li><p>在函数传参时，可能发生shared_ptr的拷贝，造成引用计数++</p>
<ul>
<li><strong>pass by value</strong> : <strong>如果传入的是个左值，会发生拷贝构造，引用计数++；如果传入的是个右值(即临时构造的shared_ptr)，那么发生移动构造，引用计数不变</strong></li>
<li><strong>pass by reference 如const&amp;</strong> : <strong>不拷贝，引用计数不变</strong></li>
<li>pass by value : 即函数的形参是一个非引用或者指针。pass by reference : 即函数的形参是一个引用&amp;。</li>
</ul>
</li>
<li><p>那么，<strong>bind</strong> class的成员函数时，由于要<strong>传入一个class对象的指针</strong></p>
<ul>
<li>这是一个pass by value的过程 </li>
<li>我们绑定上去的指针可以是shared_ptr/裸指针，但不能是weak_ptr</li>
<li>如果是以左值传入shared_ptr对象，那么引用计数++</li>
<li>如果是以右值传入shared_ptr临时量 / 或者传入裸指针，那么引用计数当然不变</li>
</ul>
</li>
<li><p><strong>bind –&gt; tuple</strong></p>
<ul>
<li><strong>只能pass by value，而不能pass by reference!!!!</strong></li>
<li><strong>pass by value : 如果传入的是个左值，会发生拷贝构造 ; 如果传入的是个右值，那么发生移动构造</strong></li>
<li><strong>哪怕这个函数的形参就是个 引用&amp;，但是我们如果绑定的话，绑定上去的对象也是会进行一个拷贝 然后赋值给形参！！（与直觉不同，因为我们正常形参是引用的话那么传入的也应当是一个引用，但是这里bind绑定的其实是一个值）</strong>（见f6 f7）</li>
<li><img src="/2022/10/08/muduo-bind%E4%B8%8Eshared-ptr/2022-10-27-19-46-54.png"></li>
</ul>
</li>
<li><p>testCode.cpp</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_from_this</span>() 返回的是一个<span class="keyword">this</span>的shared_ptr的临时量</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> :</span> <span class="keyword">public</span> std::enable_shared_from_this&lt;TestClass&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> call_back = function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">void</span>)&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;========testFunc start========&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//  shared_from_this() return a 临时的 shared_ptr，引用计数++。如果不用变量保存下来的话，这条语句过了之后就--。也就是只有这一条语句的use_count变了+1</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;+ shared_from_this() &quot;</span> &lt;&lt; <span class="built_in">shared_from_this</span>().<span class="built_in">use_count</span>() &lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;========testFunc end========&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBind</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;=======testBind start==========&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cb_ = std::<span class="built_in">bind</span>(&amp;TestClass::hello,<span class="built_in">shared_from_this</span>());          <span class="comment">//  ++</span></span><br><span class="line">        <span class="built_in">cb_</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;bind + shared_from_this() = &quot;</span>&lt;&lt;<span class="built_in">shared_from_this</span>().<span class="built_in">use_count</span>()&lt;&lt;endl;         <span class="comment">// ++ --</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;=======testBind end==========&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testPassAsValue</span><span class="params">(shared_ptr&lt;TestClass&gt; p)</span>                       <span class="comment">// ++</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;============testPassAsValue start============&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;p.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;============testPassAsValue end============&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testPassAsRef</span><span class="params">(<span class="keyword">const</span> shared_ptr&lt;TestClass&gt;&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;==========testPassAsRef start==============&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;p.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;==========testPassAsRef end================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">TestClass</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;~TestClass()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    call_back cb_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;TestClass&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> TestClass())</span></span>;</span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;                         <span class="comment">//  1</span></span><br><span class="line">    <span class="function">std::weak_ptr&lt;TestClass&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;                         <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;********************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//  bind 绑定指针 是传值 ，会导致引用计数 ++</span></span><br><span class="line">    std::<span class="built_in">bind</span>(&amp;TestClass::testFunc,sp)();             <span class="comment">// 3 = 1(sp) + 1(bind) + 1 (shared_from_this())</span></span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;                         <span class="comment">//  1</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;********************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">void</span>)&gt; f1 = std::<span class="built_in">bind</span>(&amp;TestClass::testBind,sp);</span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;                         <span class="comment">//  2 = 1(sp) + 1(f1 bind)</span></span><br><span class="line">    <span class="built_in">f1</span>();                                               <span class="comment">//  4 = 1(sp) + 1(bind) + 1(bind) + 1(shared_from_this())</span></span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;                         <span class="comment">//  3 = 1(sp) + 1(f1 bind) + 1(cb_ bind)</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;********************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(shared_ptr&lt;TestClass&gt;)&gt; f2 = std::<span class="built_in">bind</span>(&amp;TestClass::testPassAsValue,sp,std::placeholders::_1);    <span class="comment">//  4 = 1(sp) + 1(f1 bind) + 1(cb_ bind) + 1(f2 bind)</span></span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;          <span class="comment">//  4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">f1</span>();                                <span class="comment">//  5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">f2</span>(sp);                         <span class="comment">//  5</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;********************************&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> shared_ptr&lt;TestClass&gt;&amp; p)&gt; f3 = std::<span class="built_in">bind</span>(&amp;TestClass::testPassAsRef,sp,std::placeholders::_1);</span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;     <span class="comment">//  5 = 4 + 1(f3 bind)</span></span><br><span class="line">    <span class="built_in">f3</span>(sp);                    <span class="comment">// 5 = 4 + 1(f3 bind)  传引用不是传值 不会导致引用计数++</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;********************************&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">void</span>)&gt; f4 = std::<span class="built_in">bind</span>(&amp;TestClass::testPassAsValue,sp,sp);</span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;     <span class="comment">//  7 = 5 + 1(f4 bind) +1(f4 bind)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass by value but 传入右值</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;********************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">void</span>)&gt; f5 = std::<span class="built_in">bind</span>(&amp;TestClass::testFunc, shared_ptr&lt;TestClass&gt;(<span class="keyword">new</span> <span class="built_in">TestClass</span>()));          <span class="comment">//  移动构造</span></span><br><span class="line">    <span class="built_in">f5</span>();                           <span class="comment">//  2 = bind (临时量移动构造给别人) + shared_from_this()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*******************************************&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面证明了bind只能传递值</span></span><br><span class="line">    **哪怕这个函数的形参就是个 引用&amp;，但是我们如果绑定的话，绑定上去的对象也是会进行一个拷贝 然后赋值给形参！！**</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;TestClass&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> TestClass())</span></span>;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">void</span>)&gt; f6 = std::<span class="built_in">bind</span>(&amp;TestClass::testPassAsRef,p,p);</span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">use_count</span>()&lt;&lt;endl;       <span class="comment">//  3 = 1(define) + 1(bind) + 1(bind  bind只能传值 )</span></span><br><span class="line">    <span class="built_in">f6</span>();                            <span class="comment">//  3</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;*******************************************&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="function">shared_ptr&lt;TestClass&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> TestClass())</span></span>;</span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">const</span> shared_ptr&lt;TestClass&gt; &amp; )&gt; f7 = std::<span class="built_in">bind</span>(&amp;TestClass::testPassAsRef,p2,std::placeholders::_1);</span><br><span class="line">    cout&lt;&lt;p2.<span class="built_in">use_count</span>()&lt;&lt;endl;      <span class="comment">//  2 = 1(define) + 1(bind)</span></span><br><span class="line">    <span class="built_in">f7</span>(p2);                          <span class="comment">//  2 = 1(define) + 1(bind) 与上面的区别在于 bind 只能传值 而 这个形参 我们在调用的时候 是可以直接填引用进去的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">********************************</span><br><span class="line">========testFunc start========</span><br><span class="line">+ <span class="built_in">shared_from_this</span>() <span class="number">3</span></span><br><span class="line">========testFunc end========</span><br><span class="line"><span class="number">1</span></span><br><span class="line">********************************</span><br><span class="line"><span class="number">2</span></span><br><span class="line">=======testBind start==========</span><br><span class="line">hello</span><br><span class="line">bind + <span class="built_in">shared_from_this</span>() = <span class="number">4</span></span><br><span class="line">=======testBind end==========</span><br><span class="line"><span class="number">3</span></span><br><span class="line">********************************</span><br><span class="line"><span class="number">4</span></span><br><span class="line">=======testBind start==========</span><br><span class="line">hello</span><br><span class="line">bind + <span class="built_in">shared_from_this</span>() = <span class="number">5</span></span><br><span class="line">=======testBind end==========</span><br><span class="line">============testPassAsValue start============</span><br><span class="line"><span class="number">5</span></span><br><span class="line">============testPassAsValue end============</span><br><span class="line">********************************</span><br><span class="line"><span class="number">5</span></span><br><span class="line">==========testPassAsRef start==============</span><br><span class="line"><span class="number">5</span></span><br><span class="line">==========testPassAsRef end================</span><br><span class="line">********************************</span><br><span class="line"><span class="number">7</span></span><br><span class="line">********************************</span><br><span class="line">========testFunc start========</span><br><span class="line">+ <span class="built_in">shared_from_this</span>() <span class="number">2</span></span><br><span class="line">========testFunc end========</span><br><span class="line">*******************************************</span><br><span class="line"><span class="number">3</span></span><br><span class="line">==========testPassAsRef start==============</span><br><span class="line"><span class="number">3</span></span><br><span class="line">==========testPassAsRef end================</span><br><span class="line">*******************************************</span><br><span class="line"><span class="number">2</span></span><br><span class="line">==========testPassAsRef start==============</span><br><span class="line"><span class="number">2</span></span><br><span class="line">==========testPassAsRef end================</span><br><span class="line">~<span class="built_in">TestClass</span>()</span><br><span class="line">~<span class="built_in">TestClass</span>()</span><br><span class="line">~<span class="built_in">TestClass</span>()</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>还有，易知，weak_ptr的复制不会导致shared_ptr的引用计数改变</li>
</ul>
<h2 id="TcpConnectionPtr的生命周期"><a href="#TcpConnectionPtr的生命周期" class="headerlink" title="TcpConnectionPtr的生命周期"></a>TcpConnectionPtr的生命周期</h2><ul>
<li><p><strong>TcpConnection的引用存在于</strong></p>
<ul>
<li><strong>TcpServer中的<code>connections_&lt;name,TcpConnectionPtr&gt;</code>。shared_ptr。</strong>引用计数 = 1</li>
<li><strong>channel 中的weak_ptr 当handleEvent时 会lock为shared_ptr(即TcpConnectionPtr)</strong> 。引用计数++ 保证不在handleEvent时析构TcpConnection</li>
<li>还有就是在连接断开时的局部变量TcpConnectionPtr 以及 bind参数时候的拷贝TcpConnectionPtr。</li>
</ul>
</li>
<li><p><strong>一个TcpConnection何时析构？</strong></p>
<ul>
<li>断开连接后，TcpConnectionPtr = 0</li>
<li>即整个handleEvent(handleClose)结束之后(最后一个成员函数是connetionDestroyed），TcpConnectionPtr = 0，此时TcpConnection析构（channel也就跟着析构）</li>
</ul>
</li>
<li><p>将一条连接断开都需要做什么操作</p>
<ul>
<li>大概来讲 就是<ul>
<li>取消对该fd的监听 ：channel_-&gt;disableAll()             — TcpConnection内做(因为这是TcpConnection封装的成员)</li>
<li>执行user设置的callback：connectionCallback_(connPtr); — TcpConnection内做</li>
<li>将TcpConnection从TcpServer中的记录移除：connections_.erase(conn-&gt;name()); — TcpServer内做（因为这是TcpServer封装的成员）</li>
<li>channel从poller中删除掉                               — TcpConnection内做</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>TcpConnection析构流程 / 断开连接流程</strong></p>
</li>
<li><p><strong>poller -&gt;  channel::closeCallback -&gt; TcpConnection::handleClose -&gt; TcpServer::removeConnection -&gt; TcpConnection::connectionDestoyed</strong></p>
</li>
<li><p>在进入handleClose之后，不必担心TcpConnection会在执行完成前就被销毁，因为进入之前 就已经用一个weak_ptr做了lock提升，保证了引用计数至少为1</p>
</li>
<li><p><img src="/2022/10/08/muduo-bind%E4%B8%8Eshared-ptr/2022-10-27-22-04-50.png"></p>
</li>
<li><p><img src="/2022/10/08/muduo-bind%E4%B8%8Eshared-ptr/2022-10-27-22-20-11.png"></p>
</li>
<li><p>去掉一块错误注释 其余不变<img src="/2022/10/08/muduo-bind%E4%B8%8Eshared-ptr/2022-10-27-23-20-16.png"></p>
</li>
<li><p>相关代码</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  poller -&gt;  channel::closeCallback -&gt; TcpConnection::handleClose -&gt; TcpServer::removeConnection -&gt; TcpConnection::connectionDestoyed</span></span><br><span class="line"><span class="comment">//  之前注册给channel的关于关闭连接的回调操作都已经完成 </span></span><br><span class="line">    <span class="comment">//  且TcpConnection也一直保持着没有析构。</span></span><br><span class="line"><span class="comment">//  该函数结束之后，TcpConnection就会几乎马上被析构!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">connPtr</span><span class="params">(shared_from_this())</span></span>;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;shared_ptr cnt %ld&quot;</span>,connPtr.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="comment">//  3  = 1(channel::tie_.lock) + 1(TcpServer::connections_[connName] = conn;) + 1(connPtr)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  TcpServer::removeConnection</span></span><br><span class="line">    <span class="comment">//  **connections_.erase(TcpConnectionPtr)**</span></span><br><span class="line">    <span class="built_in">closeCallback_</span>(connPtr);            </span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;shared_ptr cnt %ld tcpconnection %p point to %p&quot;</span>,connPtr.<span class="built_in">use_count</span>(),connPtr.<span class="built_in">get</span>(),<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//  2 = 1(channel::tie_.lock) + 1(connPtr)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line"><span class="comment">//  removeConnection -&gt; removeConnectionInLoop</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  这里也证明了 即便形参是一个引用 即便正常调用函数传递的是个引用，可是，只要bind了，传递的就是一个值 会拷贝</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;shared_ptr cnt %ld\n&quot;</span>,conn.<span class="built_in">use_count</span>());              <span class="comment">//  3 没变</span></span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;shared_ptr cnt %ld\n&quot;</span>,conn.<span class="built_in">use_count</span>());              <span class="comment">//  2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  handleRead n = 0 -&gt; handleClose - &gt;removeConnection -&gt; removeConnectionInLoop -&gt; TcpConnection::connectionDestroyed</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;shared_ptr cnt %ld&quot;</span>,conn.<span class="built_in">use_count</span>());                <span class="comment">//  4 = 3+1 因为bind是拷贝值 会导致引用计数++</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  tcpconnection use count -- : tcpserver 从记录中删除该连接</span></span><br><span class="line">    connections_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());                   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;after erase shared_ptr cnt %ld&quot;</span>,conn.<span class="built_in">use_count</span>());    <span class="comment">//  3 = 1(channel::tie_.lock) + 1(connPtr) + 1(bind拷贝conn)</span></span><br><span class="line"></span><br><span class="line">    (conn-&gt;<span class="built_in">getLoop</span>())-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">        std::<span class="built_in">bind</span>(&amp;TcpConnection::connectionDestroyed,conn.<span class="built_in">get</span>())); <span class="comment">//  根据以上分析 传递裸指针也可 反正在这个函数里TcpConnectionPtr的引用计数一定不是0</span></span><br><span class="line"><span class="comment">//  connectionDestroyed : TcpConnection析构前调用的最后一个成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectionDestroyed</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>(); <span class="comment">// 把channel从poller中删除掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>连接断开时的相关日志如下</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[INFO] 2022-10-27-22-07-43.011788 : /home/shc/Muduo/src/TcpConnection.cpp (135) &lt;handleClose&gt;   TcpConnection::handleClose fd = 6 state = 3</span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.011795 : /home/shc/Muduo/src/EpollPoller.cpp (37) &lt;updateChannel&gt;   fd = 6 , events = 0 , index = 1</span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.011807 : /home/shc/Muduo/src/EpollPoller.cpp (90) &lt;update&gt;   fd = 6 is to be epolled or deleted <span class="keyword">in</span> loop 0x7ffcce544ab0 on thread 8121</span><br><span class="line">[INFO] 2022-10-27-22-07-43.011833 : /home/shc/Muduo/src/TcpConnection.cpp (146) &lt;handleClose&gt;   shared_ptr cnt 3</span><br><span class="line">[INFO] 2022-10-27-22-07-43.011856 : /home/shc/Muduo/src/TcpConnection.cpp (148) &lt;handleClose&gt;   shared_ptr cnt 3</span><br><span class="line">[INFO] 2022-10-27-22-07-43.011883 : testserver.cpp (40) &lt;onConnection&gt;   connection down : from 127.0.0.1:50216 to 127.0.0.1:6667!</span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.011944 : /home/shc/Muduo/src/TcpConnection.cpp (153) &lt;handleClose&gt;   shared_ptr cnt 3</span><br><span class="line">[INFO] 2022-10-27-22-07-43.011981 : /home/shc/Muduo/src/TcpServer.cpp (120) &lt;removeConnection&gt;   shared_ptr cnt 3</span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.012043 : /home/shc/Muduo/src/EventLoop.cpp (149) &lt;runInLoop&gt;   cb runInLoop <span class="keyword">in</span> loop 0x7ffcce544ab0 on thread 8121</span><br><span class="line">[INFO] 2022-10-27-22-07-43.012071 : /home/shc/Muduo/src/EventLoop.cpp (155) &lt;runInLoop&gt;   直接调用cb on loop 0x7ffcce544ab0 <span class="keyword">in</span> thread 8121</span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.012101 : /home/shc/Muduo/src/TcpServer.cpp (130) &lt;removeConnectionInLoop&gt;   shared_ptr cnt 4</span><br><span class="line">[INFO] 2022-10-27-22-07-43.012126 : /home/shc/Muduo/src/TcpServer.cpp (131) &lt;removeConnectionInLoop&gt;   TcpServer::removeConnectionInLoop [EchoServer] - connection EchoServer-127.0.0.1:6667<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.012169 : /home/shc/Muduo/src/TcpServer.cpp (137) &lt;removeConnectionInLoop&gt;   after erase shared_ptr cnt 3</span><br><span class="line">[INFO] 2022-10-27-22-07-43.012195 : /home/shc/Muduo/src/EventLoop.cpp (149) &lt;runInLoop&gt;   cb runInLoop <span class="keyword">in</span> loop 0x7ffcce544ab0 on thread 8121</span><br><span class="line">[INFO] 2022-10-27-22-07-43.012220 : /home/shc/Muduo/src/EventLoop.cpp (155) &lt;runInLoop&gt;   直接调用cb on loop 0x7ffcce544ab0 <span class="keyword">in</span> thread 8121</span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.012228 : /home/shc/Muduo/src/TcpConnection.cpp (332) &lt;connectionDestroyed&gt;   state_ = 0</span><br><span class="line">[INFO] 2022-10-27-22-07-43.012252 : /home/shc/Muduo/src/EpollPoller.cpp (109) &lt;removeChannel&gt;   fd = 6 , events = 0 , index = 2 <span class="keyword">in</span> loop 0x7ffcce544ab0 on thread 8121</span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.012274 : /home/shc/Muduo/src/EpollPoller.cpp (90) &lt;update&gt;   fd = 6 is to be epolled or deleted <span class="keyword">in</span> loop 0x7ffcce544ab0 on thread 8121</span><br><span class="line">[INFO] 2022-10-27-22-07-43.012311 : /home/shc/Muduo/src/TcpServer.cpp (148) &lt;removeConnectionInLoop&gt;   after removeConnectionInLoop</span><br><span class="line">[INFO] 2022-10-27-22-07-43.012344 : /home/shc/Muduo/src/TcpServer.cpp (124) &lt;removeConnection&gt;   shared_ptr cnt 2</span><br><span class="line"></span><br><span class="line">[INFO] 2022-10-27-22-07-43.012376 : /home/shc/Muduo/src/TcpConnection.cpp (160) &lt;handleClose&gt;   shared_ptr cnt 2 tcpconnection 0x56195873ad90 point to 0x56195873ad90</span><br><span class="line">[INFO] 2022-10-27-22-07-43.012405 : /home/shc/Muduo/src/TcpConnection.cpp (45) &lt;~TcpConnection&gt;   TcpConnection::ctor (0x56195873ad90) [EchoServer-127.0.0.1:6667<span class="comment">#1] on socket 6 with state 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-http</title>
    <url>/2023/01/10/muduo-http/</url>
    <content><![CDATA[<p>muduo httpServer原理以及使用</p>
<p>为什么要加个httpServer ?<br>因为之前做校园猫管理平台的时候，底层用的就是这个之前学习做的tinyMuduo.<br>但是由于时间紧张，当时只是client和server裸发送json字符串，没有使用正经的应用层协议，遂在期末结束后给原先光秃秃的tcp server加一层http.<br>基本都是看完Muduo之后默着写 然后再改的。。<br>不难，就是string处理琐碎烦人.</p>
<span id="more"></span>



<h2 id="相关类及使用"><a href="#相关类及使用" class="headerlink" title="相关类及使用"></a>相关类及使用</h2><ul>
<li><p>http部分就是基于tcp server之上，增加了几个内置的类和回调函数.是对tcpServer的使用. http部分负责解析http请求以及生成响应。并提供给用户注册回调函数的接口.</p>
<ul>
<li>用户负责注册的callback : 针对不同url以及method等 返回资源(实体体)和生成响应码(状态行),以及首部行. 实现的HTTPServer会帮助user将response存入Buffer并发送出去</li>
</ul>
</li>
<li><p>muduo http类图</p>
<ul>
<li><img src="/muduo-http/2023-02-22-11-05-31.png"></li>
</ul>
</li>
<li><p>相关类</p>
<ul>
<li>HTTPContext : FSM解析http request</li>
<li>HTTPRequest : 解析后的request信息存在这里</li>
<li>HTTPResponse : user向其中写入要发送的信息,然后http server会序列化到buf中,最后send出去.</li>
<li>HTTPServer:<ul>
<li>void HttpServer::onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf,Timestamp receiveTime)<ul>
<li>解析http请求，调用user的callback(httpCallback_)，发送生成的response.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>user使用很简单</p>
<ul>
<li>只需注册一个respond即可. 该callback负责根据已经解析好的http request 填充http response<blockquote>
<p><img src="/muduo-http/2023-02-22-11-12-26.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>更多注释见代码</p>
</li>
</ul>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><ul>
<li><p>http请求报文格式</p>
<ul>
<li>每行的末尾都是\r\n ; 首部行和实体体之间有一行\r\n</li>
<li>网上又将首部行称为请求头，实体体称为请求体</li>
<li><img src="/muduo-http/2023-02-21-19-25-13.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">请求行 requestline : GET /hello.txt HTTP/<span class="number">1.1</span>\r\n</span><br><span class="line">首部行 headerline  : User-Agent: curl/<span class="number">7.16</span><span class="number">.3</span> libcurl/<span class="number">7.16</span><span class="number">.3</span> OpenSSL/<span class="number">0.9</span><span class="number">.7l</span> zlib/<span class="number">1.2</span><span class="number">.3</span>\r\n</span><br><span class="line">首部行 headerline  : Host: www.example.com\r\n</span><br><span class="line">首部行 headerline  : Accept-Language: en, mi\r\n</span><br><span class="line">\r\n</span><br><span class="line">实体体 entity body</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>http响应报文格式</p>
<ul>
<li>每行的末尾都是\r\n ; 首部行和实体体之间有一行\r\n</li>
<li>网上又将状态行称为响应行, 首部行称为响应头 , 实体体称为响应体</li>
<li><img src="/muduo-http/2023-02-21-20-09-13.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">状态行 statusline : HTTP/<span class="number">1.1</span> <span class="number">200</span> OK\r\n</span><br><span class="line">首部行 headerline : Content-Encoding: gzip\r\n</span><br><span class="line">首部行 headerline : Content-Type: text/html\r\n</span><br><span class="line">首部行 headerline : Date: Thu, <span class="number">16</span> Jul <span class="number">2020</span> <span class="number">06</span>:<span class="number">45</span>:<span class="number">26</span> GMT\r\n</span><br><span class="line">首部行 headerline : Content-Length: <span class="number">78</span>\r\n</span><br><span class="line">首部行 headerline : Connection: keep-alive\r\n</span><br><span class="line">\r\n</span><br><span class="line">实体体 entity body : &lt;div&gt;&lt;div id=<span class="string">&quot;__status&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;&lt;div id=<span class="string">&quot;__redirect&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;&lt;div id=<span class="string">&quot;__switchtime&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>压测</p>
<ul>
<li>2核4G腾讯云服务器. Server设置1个mainReactor,1个subReactor<br><img src="/muduo-http/2023-02-22-12-23-54.png"><br>应该是由于网络原因,比Server在本地测试慢很多.本地压测能达到十万.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>关于weak_ptr的使用</title>
    <url>/2022/10/17/muduo-%E5%85%B3%E4%BA%8Eweak-ptr%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>weak_ptr的使用 : 延长TCPConnection生命周期，防止channel-&gt;handleEvent时被析构</p>
<span id="more"></span>


<h1 id="TcpConnection-channel-的-tie-before-handleEvent"><a href="#TcpConnection-channel-的-tie-before-handleEvent" class="headerlink" title="TcpConnection channel 的 tie before handleEvent"></a>TcpConnection channel 的 tie before handleEvent</h1><ul>
<li><p>muduo中在class channel里使用了weak_ptr</p>
</li>
<li><p>class Channel and class TcpConnection</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  tie this channel to the owner object managed by shared_ptr </span></span><br><span class="line">    <span class="comment">//  to prevent the owner object being destroyed during channel&#x27;s handleEvent;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tie</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;<span class="keyword">void</span>&gt; &amp;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tie_ = ptr;</span><br><span class="line">        tied_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Channel::handleEvent</span><span class="params">(<span class="keyword">const</span> Timestamp&amp; receiveTime)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//  channel的所有者是TcpConnection对象</span></span><br><span class="line">        <span class="keyword">if</span>(tied_)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  channel当前要处理tied_指向的TcpConnection的事件 </span></span><br><span class="line">            <span class="comment">//  提升成shared_ptr 防止在handleEvent的时候TcpConnection析构</span></span><br><span class="line">            std::shared_ptr&lt;<span class="keyword">void</span>&gt; guard = tie_.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span>(guard)       <span class="comment">//  我认为一般不会发生guard == null 除非外部拿到并移走了TcpConnection内部的channel资源</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">handlerEventWithGuard</span>(receiveTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  channel的所有者是Acceptor对象   没必要tie，因为Acceptor监听连接会贯穿server始终。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">handlerEventWithGuard</span>(receiveTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  pointed to TcpConnection</span></span><br><span class="line">    std::weak_ptr&lt;<span class="keyword">void</span>&gt; tie_;</span><br><span class="line">    <span class="comment">//  whether pointed to TcpConnection(与Acceptor区分开)</span></span><br><span class="line">    <span class="keyword">bool</span> tied_; </span><br><span class="line">    some callback; </span><br><span class="line">    <span class="comment">//  reigistered by TcpConnectionPtr or Acceptor</span></span><br><span class="line">    <span class="comment">//  weak_ptr在上层注册者是TcpConnectionPtr时起作用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpConnection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 连接建立</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectionEstablished</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//  防止channel执行回调时TcpConnection被析构</span></span><br><span class="line">        channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">        <span class="comment">// 给新建立的connfd 注册读事件到Poller</span></span><br><span class="line">        channel_-&gt;<span class="built_in">enableReading</span>();           </span><br><span class="line">        <span class="comment">//  user set the connectionCallback</span></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    EventLoop *loop_;  </span><br><span class="line">    std::unique_ptr&lt;Channel&gt; channel_; <span class="comment">//  channel for connfd to poller</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>问题：为什么channel要使用一个weak_ptr 并在 handleEvent之前lock住TcpConnection</strong> ? </p>
<ul>
<li>TcpConnection是拥有一个Channel的，它负责管理该Channel的生命周期，但是却必须把Channel的裸指针暴露给EventLoop（确切的讲是暴露给Poller），因为Poller需要对Channel的事件进行管理（添加、修改、删除）。<ul>
<li>也即channel、以及在其中注册的callback的生命周期都依赖于TcpConnection。</li>
<li>而TcpConnection又有可能在channel进行handleEvent的时候被销毁。<blockquote>
<p><img src="/2022/10/17/muduo-%E5%85%B3%E4%BA%8Eweak-ptr%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/2022-10-27-16-07-05.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>weak_ptr<void> tie_; </void></p>
<ul>
<li>弱指针，指向channel自己的所有者：TcpConnection对象。</li>
<li>channel在handleEvent之前，**lock提升为强智能指针(TcpConnection的引用计数+1)**（在lock之后 TcpConnection的引用计数才+1），防止在handleEvent的时候TcpConnection被析构，进而把当前正在调用的channel对象给析构，发生未定义事件。如果那样程序直接core dump都算个好结果。</li>
<li>channel_-&gt;tie(shared_from_this());结束之后，TCPConnection的引用计数并没有+1，因为只是传递给了一个弱智能指针，只有要handleEvent，即lock之后引用计数才++</li>
</ul>
</li>
<li><p>注意以上都是在一个loop的thread内对TcpConnection和channel的生命周期的管理。可见即便是单线程也有困难。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器设计范式</title>
    <url>/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>服务器模型介绍 学习自硬核课堂</p>
<span id="more"></span>

<h1 id="服务器设计范式"><a href="#服务器设计范式" class="headerlink" title="服务器设计范式"></a>服务器设计范式</h1><h2 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h2><ul>
<li>无论服务端设计什么样的模型，但其基本组件是不变的，不同的在于如何进行巧妙、高效的组合。<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-25-19-31-12.png"></li>
</ul>
<h2 id="迭代式"><a href="#迭代式" class="headerlink" title="迭代式"></a>迭代式</h2><ul>
<li>client在server端进行排队被server接收，因此并不适合繁忙Server。<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-25-19-33-35.png"></li>
</ul>
<h2 id="每个用户一个进程"><a href="#每个用户一个进程" class="headerlink" title="每个用户一个进程"></a>每个用户一个进程</h2><ul>
<li><p>main负责accept，child proces负责业务</p>
<ul>
<li>main 每当 accept一个conn时，就fork出一个子进程。子进程负责处理这个conn的业务逻辑。</li>
</ul>
</li>
<li><p>缺点：用户量大时，非常消耗资源。<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-25-19-36-44.png"></p>
</li>
<li><p>核心逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) </span><br><span class="line">&#123;</span><br><span class="line">      clilen = addrlen; <span class="comment">//把客户地址结构体大小复制一份</span></span><br><span class="line">      <span class="keyword">if</span> ( (connfd = <span class="built_in">accept</span>(listenfd, cliaddr, &amp;clilen)) &lt; <span class="number">0</span>) &#123; <span class="comment">//响应客户端请求,返回连接到客户端的套接字</span></span><br><span class="line">              <span class="keyword">if</span> (errno == EINTR) <span class="comment">//被信号打断则继续</span></span><br><span class="line">                      <span class="keyword">continue</span>;                <span class="comment">/* back to for() */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                      <span class="built_in">err_sys</span>(<span class="string">&quot;accept error&quot;</span>); <span class="comment">//其他错误无法忍受</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//创建一个子进程</span></span><br><span class="line">      <span class="keyword">if</span> ( (childpid = <span class="built_in">Fork</span>()) == <span class="number">0</span>) &#123;        <span class="comment">/* child process 在子进程中 */</span></span><br><span class="line">              <span class="built_in">Close</span>(listenfd);        <span class="comment">/* close listening socket 关闭监听套接字 */</span></span><br><span class="line">              <span class="built_in">web_child</span>(connfd);        <span class="comment">/* process request 在这个函数中响应客户的请求*/</span></span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//退出子进程</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Close</span>(connfd);                        <span class="comment">/* parent closes connected socket 父进程中关闭连接到客户端的套接字,继续监听等待客户端的连接 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="每个用户一个进程-提前创建好进程池-prefork模型"><a href="#每个用户一个进程-提前创建好进程池-prefork模型" class="headerlink" title="每个用户一个进程 + 提前创建好进程池 (prefork模型)"></a>每个用户一个进程 + 提前创建好进程池 (prefork模型)</h2><ul>
<li><p>main只负责fork，子进程负责accept和业务</p>
<ul>
<li>main提前fork出n个子进程，在每一个child process里面accept一个新来的IO连接conn， 并在该child process中处理该conn的业务逻辑。<ul>
<li>也即，accept接收连接 和 wechild业务处理 都是在child process中进行的。</li>
</ul>
</li>
</ul>
</li>
<li><p>所以当新来一个连接时，在多个子进程都可以accept，但最终只能有一个子进程接收该connection，accept处会存在竞争，所以需要lock。<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-25-19-50-27.png"></p>
</li>
<li><p>引入(进程池)池技术，有效的避免了在用户到来时进程执行fork的开销，然而需要在启动阶段预估判断多少个子进程，而且由于是多进程，耗费资源比较大，因此并发有限。</p>
</li>
<li><p>核心逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1. main提前fork出n个子进程</span></span><br><span class="line">  <span class="comment">//  每个子进程负责一个 connection 的 accept 和 业务处理(webchild)</span></span><br><span class="line">  <span class="built_in">my_lock_init</span>(<span class="string">&quot;/tmp/lock.XXXXXX&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nchildren; i++) <span class="comment">//用循环创建子进程池</span></span><br><span class="line">          pids[i] = <span class="built_in">child_make</span>(i, listenfd, addrlen);        <span class="comment">/* parent returns */</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//  fork</span></span><br><span class="line">        <span class="comment">//  parent 返回</span></span><br><span class="line">        <span class="comment">//  child 运行child_main() [accept() and webchild()]</span></span><br><span class="line">      <span class="function"><span class="keyword">pid_t</span></span></span><br><span class="line"><span class="function">      <span class="title">child_make</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> listenfd, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">              <span class="keyword">pid_t</span>        pid;</span><br><span class="line">              <span class="function"><span class="keyword">void</span>        <span class="title">child_main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> ( (pid = <span class="built_in">Fork</span>()) &gt; <span class="number">0</span>) <span class="comment">//创建子进程(并且在父进程中)</span></span><br><span class="line">                      <span class="keyword">return</span>(pid);                <span class="comment">/* parent 在父进程中,向本函数调用者返回子进程的pid */</span></span><br><span class="line">              <span class="comment">//  传递listenfd给child process</span></span><br><span class="line">              <span class="built_in">child_main</span>(i, listenfd, addrlen);        <span class="comment">/* never returns 在子进程中,调用这个函数进行处理 */</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* end child_make */</span></span><br><span class="line"><span class="comment">//  2. child thread runs accept接受连接 and webchild业务逻辑</span></span><br><span class="line"><span class="comment">/* include child_main */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">child_main</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> listenfd, <span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>                                connfd;</span><br><span class="line">        <span class="function"><span class="keyword">void</span>                        <span class="title">web_child</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        <span class="keyword">socklen_t</span>                clilen;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>        *<span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>            <span class="title">my_lock_wait</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span>            <span class="title">my_lock_release</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        cliaddr = <span class="built_in">Malloc</span>(addrlen); <span class="comment">//分配存放客户地址的地址结构体空间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child %ld starting\n&quot;</span>, (<span class="keyword">long</span>) <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">                clilen = addrlen;</span><br><span class="line">                <span class="comment">//  上锁 防止惊群</span></span><br><span class="line">                <span class="built_in">my_lock_wait</span>();</span><br><span class="line">                connfd = <span class="built_in">Accept</span>(listenfd, cliaddr, &amp;clilen); <span class="comment">//产生连接到客户的套接字</span></span><br><span class="line">                <span class="built_in">my_lock_release</span>();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">web_child</span>(connfd);                <span class="comment">/* process the request 响应客户的请求*/</span></span><br><span class="line">                <span class="built_in">Close</span>(connfd); <span class="comment">//关闭连接到客户的套接字</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="每个用户一个线程"><a href="#每个用户一个线程" class="headerlink" title="每个用户一个线程"></a>每个用户一个线程</h2><ul>
<li>相比于多进程模型，如果服务器主机提供支持线程，我们可以改用线程以取代进程。</li>
<li>main 每当accept一个conn时，就pthread_create,将新接收的连接(fd)交由subthread进行业务处理。<ul>
<li>main处理accept连接，subthread处理webchild业务<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-25-20-06-58.png"></li>
</ul>
</li>
<li>线程相比于进程的优势节省资源，一般场景够用了。但是如果一个web服务器并发量过万，可能同时会创建1w个线程，此时看看你的服务器支不支持的住哟。</li>
<li>核心逻辑<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) </span><br><span class="line">&#123;</span><br><span class="line">    clilen = addrlen;</span><br><span class="line">    iptr = <span class="built_in">Malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));   <span class="comment">//  分配一个int大小的空间(存放文件描述符),每次循环分配一个新的空间</span></span><br><span class="line">    *iptr = <span class="built_in">Accept</span>(listenfd, cliaddr, &amp;clilen);   <span class="comment">//  响应客户请求,返回连接到客户端的套接字</span></span><br><span class="line">      <span class="comment">//  创建一个线程来处理客户的请求,线程属性为默认,把连接到客户端的套接字当参数传递给线程</span></span><br><span class="line">    <span class="built_in">Pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, &amp;doit, (<span class="keyword">void</span> *) iptr); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="每个用户一个线程-提前创建好线程池"><a href="#每个用户一个线程-提前创建好线程池" class="headerlink" title="每个用户一个线程 + 提前创建好线程池"></a>每个用户一个线程 + 提前创建好线程池</h2><ul>
<li>与prefork模型类似，只不过是把进程换成了线程。<ul>
<li>子线程负责accept和webchild。accept处存在竞争,需要上锁。<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-25-20-18-01.png"></li>
</ul>
</li>
<li>核心逻辑<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  main创建线程池</span></span><br><span class="line">  <span class="comment">//  每个subthread 负责 accept连接 和 webchild业务处理</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) <span class="comment">//创建规定数目的线程并做相应的操作</span></span><br><span class="line">                <span class="built_in">thread_make</span>(i);                        <span class="comment">/* only main thread returns */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">thread_make</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">          <span class="function"><span class="keyword">void</span>        *<span class="title">thread_main</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line">          <span class="keyword">int</span>     *val;</span><br><span class="line">          val = <span class="built_in">Malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">          *val = i;</span><br><span class="line">          <span class="comment">//  创建线程,线程属性为null,线程id填写到线程结构体中,索引i按参数传递给线程</span></span><br><span class="line">          <span class="built_in">Pthread_create</span>(&amp;tptr[i].thread_tid, <span class="literal">NULL</span>, &amp;thread_main, (<span class="keyword">void</span> *) val); </span><br><span class="line">          <span class="keyword">return</span>;                <span class="comment">/* main thread returns */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">thread_main</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>                                connfd;</span><br><span class="line">        <span class="function"><span class="keyword">void</span>                        <span class="title">web_child</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        <span class="keyword">socklen_t</span>                clilen;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>        *<span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">        cliaddr = <span class="built_in">Malloc</span>(addrlen); <span class="comment">//分配客户端地址结构体空间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d starting\n&quot;</span>, *((<span class="keyword">int</span>*)arg));</span><br><span class="line">        <span class="built_in">free</span>(arg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">                clilen = addrlen;</span><br><span class="line">                <span class="built_in">Pthread_mutex_lock</span>(&amp;mlock);   <span class="comment">//  防止惊群</span></span><br><span class="line">                connfd = <span class="built_in">Accept</span>(listenfd, cliaddr, &amp;clilen); <span class="comment">//在互斥锁的保护下accept</span></span><br><span class="line">                <span class="built_in">Pthread_mutex_unlock</span>(&amp;mlock);</span><br><span class="line">                tptr[(<span class="keyword">int</span>) arg].thread_count++; <span class="comment">//这个线程处理的客户数目递增1</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">web_child</span>(connfd);                <span class="comment">/* process request 在此函数中响应客户的请求 */</span></span><br><span class="line">                <span class="built_in">Close</span>(connfd); <span class="comment">//关闭连接到客户的套接字</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="主线程统一accept-提前创建好线程池"><a href="#主线程统一accept-提前创建好线程池" class="headerlink" title="主线程统一accept + 提前创建好线程池"></a>主线程统一accept + 提前创建好线程池</h2><ul>
<li><p>主线程统一accept所有conn,每个subthread负责处理一个fd的业务逻辑</p>
<ul>
<li>main负责accept所有conn，每accept一个conn，就从先前创建好的线程池中唤醒一个线程，将fd传入给该subthread</li>
<li>不用对accept上锁，又避免了多线程accept的惊群效应<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-25-20-38-41.png"></li>
</ul>
</li>
<li><p>核心逻辑</p>
<ul>
<li>main线程accept连接之后，通过条件变量唤醒subthread来取走这个建立的conn的fd。subthread负责处理fd的业务。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 4create all the threads */</span></span><br><span class="line"><span class="comment">//  提前创建好线程池</span></span><br><span class="line">  <span class="comment">//  通过条件变量使得每个thread阻塞</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) <span class="comment">//在thread_make函数中循环创建线程并做相应处理</span></span><br><span class="line">        <span class="built_in">thread_make</span>(i);                <span class="comment">/* only main thread returns */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Signal</span>(SIGINT, sig_int); <span class="comment">//捕捉ctrl+c信号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        clilen = addrlen;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  主线程统一accept</span></span><br><span class="line">        connfd = <span class="built_in">Accept</span>(listenfd, cliaddr, &amp;clilen); <span class="comment">//响应客户请求,并返回连接到客户的套接字</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Pthread_mutex_lock</span>(&amp;clifd_mutex); <span class="comment">//给全局变量(线程信息结构体的数组)加锁</span></span><br><span class="line">        clifd[iput] = connfd; <span class="comment">//把描述符存入</span></span><br><span class="line">        <span class="keyword">if</span> (++iput == MAXNCLI) <span class="comment">//如果下标已经到达最大值,则回绕</span></span><br><span class="line">                iput = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如下条件成立说明主线程已经往数组中放入了过多的描述符,而仍没有线程去取出(一下子有太多的客户连接,线程忙不过来)</span></span><br><span class="line">        <span class="keyword">if</span> (iput == iget) <span class="comment">//如果线程取出描述符的下标和主线程放入描述符的下标相等,则出错</span></span><br><span class="line">                <span class="built_in">err_quit</span>(<span class="string">&quot;iput = iget = %d&quot;</span>, iput);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  唤醒负责处理fd的业务逻辑的subthread</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">Pthread_cond_signal</span>(&amp;clifd_cond);   <span class="comment">//  给条件变量发消息</span></span><br><span class="line">        <span class="built_in">Pthread_mutex_unlock</span>(&amp;clifd_mutex); <span class="comment">//  解锁互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="事件驱动-event-based（只讨论reactor）"><a href="#事件驱动-event-based（只讨论reactor）" class="headerlink" title="事件驱动 event-based（只讨论reactor）"></a>事件驱动 event-based（只讨论reactor）</h2><ul>
<li><p><strong>核心：利用IO复用接口</strong></p>
</li>
<li><p>反应器设计模式指的是由一个或多个客户机并发地传递给应用程序的服务请求。一个应用程序中的每个服务可以由几个方法组成，并由一个单独的事件处理程序表示，该处理程序负责调度特定于服务的请求。事件处理程序的调度由管理已注册事件处理程序的启动调度程序执行。服务请求的解复用由同步事件解复用器执行。也称为调度程序、通知程序。其核心是os的IO复用(epoll_开头的相关)接口。</p>
</li>
<li><p><strong>基本思路：</strong></p>
<ul>
<li>主线程往epoll内核事件表注册socket上的读事件。</li>
<li>主线程调用epoll_wait等待socket上数据可读。</li>
<li>当socket可读时，epoll_wait通知主线程，主线程则将socket可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，他从socket读取数据，并处理用户请求，然后再往epoll内核时间表中注册socket写就绪事件。</li>
<li>主线程epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列中的某个线程被唤醒，他往socket上写入服务器处理客户请求的结果。</li>
<li><strong>对比一下muduo，没有请求队列，而是通过eventfd?</strong></li>
</ul>
</li>
</ul>
<ul>
<li>优点<ul>
<li>响应快，不必为单个同步操作所阻塞，也不用考虑fd跨线程问题.</li>
<li>可扩展性，可以很方便的通过增加reactor实例（如multireactor）个数来利用CPU资源；</li>
<li>可复用性，reactor本身与具体事件处理逻辑无关，便于复用。</li>
</ul>
</li>
<li>缺点<ul>
<li>共享同一个reactor时，若出现较长时间的读写，会影响该reactor的响应时间，此时可以考虑thread-per-connection。（即每一个连接给一个线程）</li>
</ul>
</li>
</ul>
<h3 id="reactor-单线程模型"><a href="#reactor-单线程模型" class="headerlink" title="reactor 单线程模型"></a>reactor 单线程模型</h3><ul>
<li><p>The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handler</p>
</li>
<li><p><a href="https://blog.csdn.net/Rong_Toa/article/details/108923615">参考</a></p>
</li>
<li><p><a href="https://hardcore.feishu.cn/docs/doccnvF0IxXFmA9DOZzuAMvP8Kg#">参考</a></p>
</li>
<li><p><a href="https://github.com/Cstardust/Server-Programming-Model/commit/5bbe8e7e6c762d2bc6cdff01d7d67c9316e1af7e">源码</a></p>
</li>
<li><p>reactor 单线程模型 从 accept接收连接 到 connfd业务逻辑 都是在一个线程上处理的</p>
<ul>
<li>重要组件：<ul>
<li><strong>Reactor：负责epoll_wait</strong> </li>
<li><strong>dispatch：负责根据wait到的Event派发相应handler</strong></li>
<li><strong>handler：</strong><ul>
<li><strong>acceptor：负责连接的建立</strong></li>
<li><strong>read/write handler：业务处理</strong><br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-25-22-38-52.png"><br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-26-19-02-04.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>reactor单线程的另一种更通用的理解方式：</p>
<ul>
<li><strong>重要组件：</strong><ul>
<li><strong>Event事件：绑定了fd，events 以及handler</strong></li>
<li><strong>Reactor反应堆：存储了event的集合</strong></li>
<li><strong>Demultiplex事件分发器：基于IO复用 如epoll</strong></li>
<li><strong>EventHandler事件处理器：handler</strong></li>
</ul>
</li>
<li>和上面的图大同小异<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-26-18-59-54.png"><br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-26-18-51-54.png"><br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-26-18-53-34.png"></li>
</ul>
</li>
<li><p>消息处理流程：</p>
<ul>
<li>Reactor对象通过select监控连接事件，收到事件后通过dispatch进行转发。</li>
<li>如果是新来的connection，则由acceptor接受连接，并创建handler处理后续事件。</li>
<li>如果是connfd的读写事件，则Reactor会分发调用Handler来响应。<ul>
<li>按顺序逐个调用handler</li>
<li>一个服务端可以同时处理多个客户端，是指的一个服务端可以监听多个客户端的连接、读写事件，真正做业务处理还是“一夫当关，万夫莫开”的效果。(即只有处理完一个event，才能继续处理下一个event)</li>
</ul>
</li>
<li>handler会完成read-&gt;业务处理-&gt;send的完整业务流程。</li>
</ul>
</li>
<li><p>得益于epoll的高性能，一般场景够用了。我们的Redis就是使用的是单线程版的reactor。</p>
</li>
<li><p>单Reactor单线程模型只是在代码上进行了组件的区分，但是整体操作还是单线程，但是不能发挥出多核CPU的优势。handler业务处理部分没有异步。</p>
</li>
</ul>
<h3 id="单reactor-工作线程池"><a href="#单reactor-工作线程池" class="headerlink" title="单reactor + 工作线程池"></a>单reactor + 工作线程池</h3><ul>
<li>单线程的reactor，业务处理也在IO线程中，此时如果有耗时操作，会影响并发。因此我们使用工作线程池来异步耗时的操作。<br> <img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-26-18-22-17.png"></li>
</ul>
<h3 id="multi-reactor-版本1"><a href="#multi-reactor-版本1" class="headerlink" title="multi-reactor 版本1"></a>multi-reactor 版本1</h3><ul>
<li><p>在上文分析中，我们发现单线程的reactor太忙了，</p>
<ul>
<li>既当爹 ：监听listenfd的连接事件。</li>
<li>又当妈的：监听connfd的读写事件。</li>
<li>那我们干脆直接把他在拆开不就行了吗？这样的话，是不是能响应更多的并发了？</li>
</ul>
</li>
<li><p>图</p>
<ul>
<li><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-26-17-39-27.png"></li>
</ul>
</li>
<li><p>简化版</p>
<ul>
<li><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-26-17-54-42.png"></li>
</ul>
</li>
<li><p>不一定需要工作线程池。muduo就没有。muduo是个每个subthread上跑一个loop。也即每个subthread就是一个reactor single process（这就是subReactor）。每个loop上用一个thread负责监听和处理若干connfd的连接。而main线程 也即主reactor上跑的loop 是用来监听listenfd的。并把新建立的connfd派送给subReactor去监听。</p>
</li>
<li><p>muduo也没有task queue这个缓冲队列。而是通过eventfd唤醒相应subthread，去处理该subthread上的事件。</p>
</li>
<li><p>muduo的subthread = 0时，也即没有subreactor时，muduo实际上只跑了一个mainReactor。这个Reactor就是reactor single process。这个单线程 既监听并处理listenfd，又监听并处理connfd</p>
</li>
</ul>
<h4 id="Muduo-multiple-Reactor"><a href="#Muduo-multiple-Reactor" class="headerlink" title="Muduo multiple Reactor"></a>Muduo multiple Reactor</h4><ul>
<li>muduo库的Multiple Reactors模型<br><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-05-22-54-53.png"></li>
</ul>
<p><img src="/2022/09/05/muduo-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E8%AE%A1/2022-09-17-21-18-50.png"></p>
<h3 id="multi-reactor版本2"><a href="#multi-reactor版本2" class="headerlink" title="multi-reactor版本2"></a>multi-reactor版本2</h3><ul>
<li>其实这个版本是没有啥意思的，因为他出现前提是main reactor(即负责处理监听套接字的线程响应不过来)，天了噜，这个得多大的并发？我估计也就tomcat那种可能会用到，因此这个不具体给出。</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/11/04/test/</url>
    <content><![CDATA[<p>这是摘要</p>
<span id="more"></span>
<p>以下是正文</p>
<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><p>1</p>
<h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><p>1.1</p>
<h3 id="子子标题1"><a href="#子子标题1" class="headerlink" title="子子标题1"></a>子子标题1</h3><p>1.1.1</p>
<h1 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h1><p>2</p>
<h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><p>2.2</p>
<h3 id="子子标题2"><a href="#子子标题2" class="headerlink" title="子子标题2"></a>子子标题2</h3><p>2.2.2</p>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title>test02</title>
    <url>/2021/11/04/test02/</url>
    <content><![CDATA[<p>如何插入图片</p>
<span id="more"></span>
<p><img src="/2021/11/04/test02/2021-11-04-21-26-16.png"></p>
<h1 id="如何插入图片"><a href="#如何插入图片" class="headerlink" title="如何插入图片"></a>如何插入图片</h1><ul>
<li>过程<ul>
<li><code>hexo new xxx</code><ul>
<li>会生成一个同名文件夹</li>
</ul>
</li>
<li><code>ctrl + alt + v</code>  <ul>
<li>图片会自动到同名文件夹下。</li>
</ul>
</li>
</ul>
</li>
<li>有用插件 <ul>
<li><code>hexo-asset-image</code></li>
<li><code>hexo-renderer-ejs</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title>muduo-关于EventLoop的runInLoop与queueInLoop</title>
    <url>/2022/10/12/muduo-%E5%85%B3%E4%BA%8EEventLoop%E7%9A%84runInLoop%E4%B8%8EqueueInLoop/</url>
    <content><![CDATA[<p>关于queueInLoop调用时机</p>
<span id="more"></span>

<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ul>
<li><p>在看muduo源码时，始终有这个困惑：runInLoop和queueInLoop真的有必要分开吗？</p>
</li>
<li><p>首先 eventloop的loop中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    poller wait</span><br><span class="line">    handleEvents</span><br><span class="line">    doPendingFunctors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如下所示</p>
</li>
<li><p><strong>runInLoop</strong></p>
<ul>
<li>loop 所属 thread 内执行 runInLoop : <ul>
<li>必然是在handleEvents中，调用了runInLoop，此时处于LoopThread内，于是在io thread内直接执行cb。</li>
</ul>
</li>
<li>其他 thread 执行runInLoop : <ul>
<li>进入queueInLoop，把cb加入到pendingFunctor中。为了让io loop尽快执行我们的cb，于是我们wakeupFd。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>queueInLoop</strong></p>
<ul>
<li>loop 所属 thread 执行queueInLoop<ul>
<li>handleEvent中调用queueInLoop<ul>
<li>加入pendingFunctor，但无需wakeup。因为IO thread已经从Poller中离开，handleEvents之后就会执行cb。</li>
</ul>
</li>
<li>doPendingFunctors<ul>
<li>加入pendingFunctor，且需要wakeup。因为这个cb直到下次poller wait之后 才会被处理。(通过callingPendingFactors_判断是否需要wakeup)</li>
</ul>
</li>
</ul>
</li>
<li>其他thread 执行queueInLoop : cb放入队列，为了让io loop尽快执行我们的cb，于是我们wakeupFd。（这样下次IO thread运行到poller wait就会直接返回，如果不这样的话cb会被延迟处理）</li>
</ul>
</li>
<li><p>code</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  让loop对象执行回调函数cb</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="keyword">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  如果用户在当前(EventLoop所属线程)IO线程调用这个函数，回调会同步进行</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isInLoopThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果不在 那么放入队列</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  把cb放入队列 以待下次从poller wait中出来后执行cb</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="keyword">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  给loop添加新回调</span></span><br><span class="line">    <span class="comment">//  这个cb 会在loop的IO thread的epollwait之后 被调用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        pendingFunctors_.<span class="built_in">emplace_back</span>(cb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  只有当前queueInLoop()函数是被 loop所属的IO thread handleEvents 中被调用，才无须wakeup()</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">isInLoopThread</span>() || !callingPendingFactors_)       </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>();                                         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可见 也没什么区别，貌似全部都用runInLoop也未尝不可。</p>
</li>
<li><p><strong>但是，在muduo中，起码在我所看到的源码中，只在writeCompleteCallback和highWaterCallback的调用时，使用了queueInLoop</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">loop_-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">std::<span class="built_in">bind</span>(highWaterMarkCallback_,<span class="built_in">shared_from_this</span>(),oldlen + remaning)</span><br><span class="line">);   </span><br></pre></td></tr></table></figure></li>
<li><p>为什么要在这里使用？</p>
</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul>
<li><p>首先介绍highWaterMarkCallback和writeCompleteCallback使用姿势。这两个是由user设置的。user设置给TcpServer，TcpConnection从TcpServer中取用这两个函数</p>
<ul>
<li>考虑一个代理服务器有C和S两个链接，S向C发送数据，经由代理服务器转发，现在S的数据发送的很快，但是C的接受速率却较慢，如果本代理服务器不加以限制，那S到来的数据迟早会撑爆这C连接的发送缓冲区，</li>
<li>解决的办法就是当C的发送缓冲中堆积数据达到了某个标志的时候，调用highWaterMarkCallback去让S的连接停止接受数据，等到C发送缓冲的数据被发送完了，调用writeCompleteCallback再开始接受S连接的数据。这样就确保了数据不会丢失，缓冲不会被撑爆。</li>
</ul>
</li>
<li><p>那么为什么这两个回调要<strong>queueInLoop</strong>先放入队列再执行呢？原因如下</p>
</li>
<li><p>比如如果用户如果想在writeCompleteCallback中发送data,</p>
</li>
<li><p><strong>如果是queueInLoop</strong>的话，那么</p>
<ul>
<li>queueInLoop加入cb到队列，会等下次从poll返回之后执行doPend的时候才执行。下一轮cb中send的才会调用，而后又会触发下一轮调用的cb。不会造成busy loop，也不会seg。</li>
</ul>
</li>
<li><p><strong>如果是runInLoop</strong>的话，会发生什么？</p>
<ul>
<li><strong>会不断调用send 和 callback 导致 seg。</strong></li>
<li>原因如下：<ul>
<li>在<strong>IO线程中调用runInLoop,这个cb会立刻执行</strong></li>
<li>writeCompleteCallback_会在TcpConnection::send() 发送干净数据之后，会调用writeCompleteCallback。而writeCompleteCallback中又一次调用TcpConnection::send()，将msg发送干净之后，又会触发callBack…</li>
<li>这样<strong>不断相互触发，导致seg。</strong></li>
<li>错误使用write call back代码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onWriteComplete</span><span class="params">(<span class="keyword">const</span> TcpConnectionPtr &amp;conn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  as soon as send finished</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;be careful about stackoverflow\n&quot;</span>);</span><br><span class="line">    <span class="function">string <span class="title">msg</span><span class="params">(<span class="string">&quot;hope not stackoverflow!&quot;</span>)</span></span>;</span><br><span class="line">    conn-&gt;<span class="built_in">send</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
server<img src="/2022/10/12/muduo-%E5%85%B3%E4%BA%8EEventLoop%E7%9A%84runInLoop%E4%B8%8EqueueInLoop/2022-10-12-22-16-32.png"><br>client<img src="/2022/10/12/muduo-%E5%85%B3%E4%BA%8EEventLoop%E7%9A%84runInLoop%E4%B8%8EqueueInLoop/2022-10-12-22-16-11.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Muduo</category>
      </categories>
      <tags>
        <tag>Muduo</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-论文学习-mapreduce</title>
    <url>/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/</url>
    <content><![CDATA[<p>TODO</p>
<span id="more"></span>

<p><a href="https://zhuanlan.zhihu.com/p/391197032">go plugin</a></p>
<p><a href="http://c.biancheng.net/view/4281.html">go断言</a><br>在Go语言中类型断言的语法格式如下：<br>value, ok := x.(T)</p>
<p>其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。</p>
<p>该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：<br>如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。<br>如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。<br>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。</p>
<p><a href="https://cloud.tencent.com/developer/article/1825053">go sort</a></p>
<p><a href="https://www.cnblogs.com/xiaobaiskill/p/10648179.html">go package使用</a></p>
<p><a href="https://juejin.cn/post/6975144762818953246#heading-0">go httpserver</a></p>
<p>一开始 : 只有一个进程,不涉及分布式<br>main/mrsequential.go<br>借助wc.go<br>执行map和reduce<br>来统计*.txt<br>结果输出到more-out-0</p>
<p>lab1 : </p>
<p>mapreduce框架要完成的是何时以何种方式使用用户编写的map和reduce函数达到分布式解决问题的目的</p>
<p>user的map和reduce : mrapps/wc.go</p>
<p>mapreduce框架的<br>    master 进程 : main/mrmaster.go<br>        master具体代码 : mr/master.go<br>    worker 进程 : main/mrworker.go<br>        worker具体代码 : mr/worker.go</p>
<p>gob error encoding body: gob: type mr.TaskReply has no exported fields<br>定义rpc调用所需的数据结构时，其首字母没有大写，导致外部程序无法访问</p>
<p>使用go时，以大写字母开头的字段和变量将被”导出”，并且对其他包可见。 以小写字母开头的字段是”未导出”的，并且仅在其自己的包中可见。<br>encoding / gob包依赖于反射来编码值，并且只能看到导出的struct字段。<br>为了使事情变得可编码，请在您的stateNode结构中将要保存的每个字段名称的首字母大写</p>
<p><a href="https://blog.csdn.net/wang545054788/article/details/112991515">https://blog.csdn.net/wang545054788/article/details/112991515</a></p>
<p>关于包级的变量名和函数名，小写相当于private 大写则是public ?</p>
<p>每个worker都可以执行map和reduce工作，一种比较靠谱和简单的实现方式是让worker向master请求工作，由master决定分配什么工作给该worker</p>
<p>注意的是，以后每次修改mr下的代码后都要重新编译wc.go -&gt; wc.so</p>
<p>worker 和 master 其所使用的tsak都是同步的吗？是同一个吗？当然不是同一个吗。都不是一个进程 甚至不是一个机器。那么是同步的吗？</p>
<p>map 和 reduce 的代码 即函数代码 是在worker端的<br>但是执行任务的元数据 以及何时执行什么任务 是在master端的</p>
<p>目前的实现 最终是服务端正常退出 客户端是异常退出了<br>退出时机：服务端分发完全部reduce任务 并客户端都已经确定完成。客户端最后一次调用RPCReqest 请求不到任务的。服务端对此是server thread的一个协程（那也就是那个thread在一直loop)在一直loop<br>main thread 通过isDone看到符合退出条件 故直接exit<br>那么server thread也随之exit</p>
<p>客户端此时仍在rpc的call等待，server端异常退出 ，由tcp协议可知，server会发送fin flag，client端的应用层会看到eof。rpc的call返回。<br>得到一个全是默认值的TaskReply。<br>会匹配到DoMapTask 会利用其中信息open文件 由于文件不存在 故异常退出<br>明天看看能不能优化成正常退出</p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-09-45.png"></p>
<p>需要内存过多，一台机器上的内存解决不了。于是 解决方案：mapreduce</p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-10-58.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-15-33.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-18-54.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-19-05.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-19-27.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-19-59.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-25-52.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-27-04.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-27-49.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-32-52.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-32-59.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-34-06.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-38-53.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-39-02.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-44-09.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-44-59.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-45-53.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-45-59.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-46-11.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-46-23.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-47-18.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-18-26.png"></p>
<p>如果你可以在不构建分布式系统的情况下 通过在一台已知的计算机上解决该问题<br>那么就应该采用这种方式</p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-18.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-29.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-38.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-45.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-59.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-20-05.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-20-24.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-21-13.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-21-19.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-22-18.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-23-53.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-49-43.png"></p>
<p>mapreduce 是一种计算系统<br>存储，通信，计算</p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-51-03.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-51-24.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-51-32.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-51-37.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-32.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-40.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-46.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-50.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-58.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-01.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-03.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-06.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-08.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-12.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-16.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-33.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-36.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-40.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-43.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-55-10.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-55-26.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-55-32.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-56-16.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-56-25.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-11-17.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-11-50.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-12-05.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-13-08.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-13-14.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-16-41.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-16-48.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-16-53.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-16-57.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-17-04.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-17-10.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-17-20.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-23-22.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-24-14.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-24-17.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-24-38.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-27-31.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-40-53.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-41-39.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-42-11.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-03-32.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-04-05.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-05-08.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-05-17.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-07-53.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-08-01.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-08-07.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-08-19.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-12-16.png"></p>
<p>—————mapreduce———</p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-22-09-14-14.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-22-09-20-10.png"></p>
<p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-22-09-29-07.png"></p>
]]></content>
  </entry>
  <entry>
    <title>gdb调试</title>
    <url>/2022/09/15/%E5%B7%A5%E5%85%B7-gdb%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p><img src="/2022/09/15/%E5%B7%A5%E5%85%B7-gdb%E8%B0%83%E8%AF%95/2022-06-25-20-55-29.png"></p>
<h2 id="调试可执行文件"><a href="#调试可执行文件" class="headerlink" title="调试可执行文件"></a>调试可执行文件</h2><ul>
<li><p>编译项目时添加-g选项，二进制会带有调试信息</p>
</li>
<li><p>gdb + 二进制名字 开始调试程序</p>
</li>
<li><p>打断点</p>
<ul>
<li>break main：就是在要调试的程序入口设置断点</li>
<li>break 文件名:行号 chatservice.cpp:91</li>
<li>break 类名称::方法名 ChatService::login</li>
</ul>
</li>
<li><p>启动调试</p>
<ul>
<li>start:从main函数第一行代码开始执行</li>
<li>run:程序开始执行直到命中断点</li>
<li>continue:从当前指令向下执行直到下一个断点</li>
</ul>
</li>
<li><p>layout split 很好看啊。今天才知道。<br><img src="/2022/09/15/%E5%B7%A5%E5%85%B7-gdb%E8%B0%83%E8%AF%95/2022-09-15-08-26-44.png"><br><img src="/2022/09/15/%E5%B7%A5%E5%85%B7-gdb%E8%B0%83%E8%AF%95/2022-09-15-09-07-40.png"></p>
<ul>
<li>focus src / asm / cmd 鼠标聚焦在哪个窗口<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) focus src</span><br><span class="line">Focus <span class="built_in">set</span> to src window.</span><br><span class="line">(gdb) focus <span class="keyword">asm</span></span><br><span class="line">Focus <span class="built_in">set</span> to <span class="keyword">asm</span> window.</span><br><span class="line">(gdb) focus cmd</span><br><span class="line">Focus <span class="built_in">set</span> to cmd window.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>back trace : bt</p>
<ul>
<li>查看当前调用堆栈</li>
</ul>
</li>
<li><p>print + 变量名/reg名/值 m : p m</p>
<ul>
<li>查看变量值</li>
</ul>
</li>
<li><p>x + 变量名m/reg名/值 ： x m </p>
<ul>
<li>查看以m的值作为地址处的内存所存储的值</li>
</ul>
</li>
<li><p>watch + 变量名x : 监控变量x</p>
<ul>
<li>向下运行 直到该值改变时会停住</li>
</ul>
</li>
<li><p>info inferiors : 查看当前process</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info inferiors</span><br><span class="line">  Num  Description       Executable        </span><br><span class="line">* 1    process 6542      /home/shc/Code/try/lock/pmap </span><br></pre></td></tr></table></figure></li>
<li><p>info threads : 查看所有 thread</p>
</li>
<li><p>thread n : 切换线程</p>
</li>
<li><p>si , ni , s , n</p>
<ul>
<li>n/s都是C语言级的断点定位。 <ul>
<li>s会进入C函数内部,但是不会进入没有定位信息的函数（比如没有加-g编译的代码，因为其没有C代码的行数标记，没办法定位）。</li>
<li>n不会进入C函数内部。</li>
</ul>
</li>
<li>ni/si都是汇编级别的断点定位。<ul>
<li>si会进入函数内部的第一条汇编一句（C语言的函数 和 通过汇编跳转的函数都会进入）</li>
<li>ni不会进入汇编跳转的函数内部。</li>
</ul>
</li>
<li>归纳:<ul>
<li>当要进入没有调试信息的库函数调试的时候，用si是我已知的唯一的方法。</li>
<li>如果要进入汇编跳转到的函数比如callq addr,那么si是我已知的唯一的方法</li>
<li>当进入有调试信息的函数，用si和s都可以，但是他们不同，si是定位到汇编级别的第一个语句，但是s是进入到C级别的第一个语句</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>x/20i $pc : 显示当前PC后面的20条指令</li>
<li>disas $pc, $pc+20 : 显示接下来20byte的汇编指令</li>
<li>display/10i $pc    : gdb持续自动显示从pc起的10条指令</li>
</ul>
<ul>
<li>命令行工具：<ul>
<li>pmap + pid<ul>
<li>查看一个process的所有地址空间</li>
</ul>
</li>
<li>cat /proc/pid/maps<ul>
<li>查看一个process的所有地址空间。比pmap更详细。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="调试core-dump文件"><a href="#调试core-dump文件" class="headerlink" title="调试core dump文件"></a>调试core dump文件</h2><ul>
<li><p>专业的描述是segmentfault，通俗的讲就是程序挂掉了</p>
</li>
<li><p>ulimit -c：查看允许生成的core文件大小</p>
</li>
<li><p>ulimit -c unlimited：打开core文件开关</p>
</li>
<li><p>开始执行程序，程序挂掉之后发现二进制目录下面有core文件</p>
</li>
<li><p>gdb executableFile core文件 ：gdb调试core文件，快速发现程序出错代码</p>
<ul>
<li>会直接显示出程序在哪里挂掉</li>
<li>core文件是死去程序的遗言。调试core文件并不是调试我们编写的可执行文件，而是遗言，只读不写。</li>
</ul>
</li>
<li><p>所以遇到挂掉的程序，根本不用加日志，直接gdb调试core文件，就可以知道在哪里挂掉</p>
</li>
<li><p>知道在那里挂掉之后，就可以直接gdb调试可执行文件，设置断点。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>操作系统_semaphore实现</title>
    <url>/2023/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-semaphore%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>如jyy所说，cond和mutex配合在一起就是万能方案.<br>我也就不咋喜欢用信号量semaphore.<br>但这是个考点啊。遂用cond和mutex实现一下.</p>
<span id="more"></span>

<ul>
<li>思路 : 所谓 semaphore 就是初始计数可以不为1的mutex_lock ; 那么 我们可以将初始计数作为cond的条件,使用万能方法,和cond配合使用即可</li>
<li>code</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-Interrupt</title>
    <url>/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/</url>
    <content><![CDATA[<ul>
<li>Interrupt中断概述<ul>
<li>驱动(管理设备的代码)架构：Handler + Bottom</li>
<li>interrupt Handler : 即 Bottom</li>
<li>例子 : kernel读取用户字符传给shell,并显示在终端上<ul>
<li>PLIC路由中断;UART传输字符</li>
<li><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-17-02-42.png"></li>
</ul>
</li>
<li>Interrupt的并发性<ul>
<li>发出Interrupt的设备与cpu并行</li>
<li>中断会停止当前进程(user -&gt; uservec / kernel -&gt; kernelvec)</li>
<li>驱动的top和bottom是并行的.(一个cpu上跑top , 一个cpu上跑bottom)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>本篇有待复习、总结</p>
<span id="more"></span>


<h2 id="问题-及-解释"><a href="#问题-及-解释" class="headerlink" title="问题 及 解释"></a>问题 及 解释</h2><ul>
<li><p>interrupt是如何保存上下文以及将上下文重新加载的？（Interrupt也会进入uservec/kernelvec吗？会）</p>
<ul>
<li>和trap机制一样。都是用uservec或者kernelvec。</li>
</ul>
</li>
<li><p>console显示 $应当是不需要中断，而console上显示用户输入的字符则需要中断？</p>
<ul>
<li>console显示$ 就是驱动将$送入了uart，uart送入了console。</li>
<li>console显示用户输入字符，则是<ul>
<li>shell 读取 用户输入的字符（这过程中涉及中断），顺带驱动将读入的字符送入uart，再送到console。 <ul>
<li>所涉及的中断是，键盘键入字符给uart，也即，键盘上有字符输入需要kernel处理，也即键盘需要得到os关注，因此发出个中断。中断经由PLIC路由到os。kernel中的Interrupt Handler对此进行处理，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>uart到底是个什么？</p>
<ul>
<li>应该是个芯片吧。</li>
<li>我现在理解就是一个字符的转发站。一端是kernel code，一端是设备。在这两方之间进行字符的转发。</li>
<li>UART硬件可以看作一组映射到内存中的控制寄存器，对硬件的控制可以直接通过load和store特定内存来完成。UART内存映射地址开始于0x10000000或UART0（定义于memlayout.h）。每个控制寄存器的大小为1byte，偏移量定义于uart.c。</li>
<li>uart和网卡这些东西是什么关系？</li>
</ul>
</li>
<li><p>中断到底指的是什么？停止当前正在运行的进程？然后去处理来的字符？</p>
<ul>
<li>中断 是 设备希望得到 os关注时，所采取的手段。即向os发送一个中断，表示“我需要你处理一下”。不一定是设备产生了字符，也可能是其他事件。比如网卡接收了packet。</li>
</ul>
</li>
<li><p>uart和cpu是并行的吗？</p>
<ul>
<li>对。</li>
</ul>
</li>
</ul>
<ul>
<li>剩下的问题请 搜索 “未解决问题” 或者 “QUES”</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>一句话说明：user在键盘上敲下的按键，是怎么使得console上显示出来敲入的字符的？<ul>
<li>先前shell 调用read … -&gt; sys_read … -&gt; (驱动的top）consoleread（相对于InputBuffer是个Consumer的角色）， 此时 inputBuffer为空，sleep等待。</li>
<li>user按下按键，键盘发起中断，经PLIC路由达到一个CPU核。cpu核接收中断 保存上下文 跳转到相应的处理代码处，这里比方说是uservec -&gt; usertrap，usertrap根据PLIC(plic_claim)提供的信息，得知是哪个设备发出了中断，进行相应处理。这里是uart中断，故进入(驱动的Bottom)（即Interrupt Handler）（同时相对于inputBuffer来说是一个Producer的角色）uartintr()。uartintr中，调用uartget()从uart的reg中读出字符c，然后调用consoleintr(c)，其中1. 通过consputc(c)（最终到writeReg(c)将字符写入uart寄存器）来讲user键入的字符送入uart，然后uart负责送到console上；2. 将c放入驱动的inputBuffer，并唤醒之前由于inputBuffer为空而睡眠的consoleread。而后结束中断处理。层层返回，返回到usertrap，然后到了usertrapret，然后userretvec，继续shell。</li>
<li>如图<img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-17-02-42.png"></li>
</ul>
</li>
</ul>
<ul>
<li>对于uart来说可以看成有两个驱动。<ul>
<li>驱动1：一个是top是consolewrite（负责往outputBuffer中放字符） , buffer是outputBuffer , bottom是uartintr中的uartstart()（其实并不是一个Interrupt Handler，而仅仅是一个操作设备的代码，负责outputBuffer中的字符送入uart，uart将字符送入console）</li>
<li>驱动2：一个top是consoleread（负责从inputBuffer中读） , buffer是 inputBuffer,bottom是uartintr。（是个Interrupt Handler）（负责处理设备发出的中断，具体是读取uart送来的字符，放入inputBuffer，唤醒consoleread，并将字符echo到uart进而到console上）<ul>
<li>对于该驱动，其top和bottom是可以并行的。</li>
<li>如一个cpu核在consoleread，另一个cpu核接收了uart发出的中断，故执行uartintr。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>关于我以为的uart,PLIC的作用。正确性未知，反正我这么理解的。有待验证。<br><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-20-52-29.png"></li>
</ul>
<h1 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h1><h2 id="Interrup-与-syscall区别"><a href="#Interrup-与-syscall区别" class="headerlink" title="Interrup 与 syscall区别"></a>Interrup 与 syscall区别</h2><ul>
<li><p><strong>中断场景：硬件希望得到操作系统的关注。</strong></p>
<ul>
<li>网卡收到一个packet，网卡会生成一个中断</li>
<li>用户按下键盘，键盘会产生一个中断。</li>
</ul>
</li>
<li><p>中断发生时，os需要做的是 </p>
<ul>
<li>保存当前工作</li>
<li>处理中断<ul>
<li>这里的保存和恢复工作，与之前学的系统调用使用的trap很像。</li>
<li>所以系统调用，page fault，中断，都使用相同的机制。</li>
</ul>
</li>
<li>处理完成后，恢复之前的工作。</li>
</ul>
</li>
<li><p>中断Interrupt 和 系统调用syscall 的<strong>区别</strong></p>
<ul>
<li><strong>asynchronous</strong> <ul>
<li>Interrupt: 硬件发出Interrupt时，os的Interrupt handler与当前在cpu上运行的process没有任何关联。</li>
<li>syscall: syscall发生在process的上下文中。</li>
</ul>
</li>
<li><strong>concurrency</strong><ul>
<li>Interrupt: <strong>CPU和产生Interrupt的设备是真正并行的</strong>。我们必须管理这里的并行</li>
<li>比如网卡自己独立的处理来自网络的packet，然后在某个时间点产生中断，但是同时，CPU也在运行。</li>
</ul>
</li>
<li><strong>program device</strong><ul>
<li>我们这节课主要关注外部设备，例如网卡，UART，而这些设备需要被编程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="PLIC-与-CPU"><a href="#PLIC-与-CPU" class="headerlink" title="PLIC 与 CPU"></a>PLIC 与 CPU</h2><ul>
<li><strong>PLIC</strong> : 是个cpu核旁边的硬件，用于<strong>管理来自于外设的中断</strong><ul>
<li>CPU是通过<strong>Platform Level Interrupt Control</strong>，简称PLIC来处理设备中断。</li>
</ul>
</li>
<li><strong>PLIC位置</strong>如图：在cpu核旁边<ul>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-13-22-05-02.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>PLIC具体结构</strong>如下<ul>
<li>设备发出的中断到达PLIC时，PLIC会将中断路由到某个CPU核。如果所有cpu核都在处理中断，PLIC会保留中断直到有一个CPU核处理中断。</li>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-13-22-17-18.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>PLIC管理中断流程</strong>：<ul>
<li>PLIC会向CPU通知当前有一个待处理的中断。</li>
<li>其中一个CPU核会claim接收中断，这样PLIC就不会把中断发给其他CPU处理。</li>
<li>CPU核处理完中断后，CPU会通知PLIC。</li>
<li>PLIC将不再保存中断信息。</li>
</ul>
</li>
</ul>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><h3 id="什么是驱动"><a href="#什么是驱动" class="headerlink" title="什么是驱动"></a>什么是驱动</h3><ul>
<li><strong>驱动</strong><ul>
<li><strong>管理设备的代码称为驱动</strong></li>
<li>所有驱动都在<strong>内核</strong>中</li>
</ul>
</li>
<li>下面介绍<strong>uart</strong>设备的驱动</li>
</ul>
<h3 id="典型架构"><a href="#典型架构" class="headerlink" title="典型架构"></a>典型架构</h3><ul>
<li><p>典型架构：大部分<strong>驱动可分为两部分</strong>：<strong>bottom和top</strong></p>
</li>
<li><p><strong>bottom ： Interrupt Handler</strong></p>
<ul>
<li>bottom部分通常是Interrupt Handler。</li>
<li>当PLIC将中断送至CPU，CPU接收该中断，然后CPU会调用相应的Interrupr Handler。</li>
<li>Interrupt Handler 就是对 设备发出的中断进行响应，也即在操作发出中断的设备或者其他响应设备。它也并不运行在任何特定process的context，只是处理中断。</li>
</ul>
</li>
<li><p><strong>top : 用户进程 / 内核的其他部分调用的接口</strong></p>
<ul>
<li>对uart来说，top是read/write接口，这些接口可被更高级代码调用。</li>
</ul>
</li>
<li><p>驱动的典型架构如下</p>
<ul>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-13-23-12-01.png"></p>
</blockquote>
</li>
<li>通过buffer queue使得并行的cpu和设备解耦。</li>
<li>QUES1 : 这句话是想说明什么？老师的这句话是在说top部分不能直接从interrupt handler中读取数据，而是要从queue中读取的原因吧？ <ul>
<li><blockquote>
<p>通常对于Interrupt handler来说存在一些限制，因为它并没有运行在任何进程的context中，所以进程的page table并不知道该从哪个地址读写数据，也就无法直接从Interrupt handler读写数据。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Interrupt Handler中如何对设备进行操作、如何编程？</p>
<ul>
<li><blockquote>
<p>通常来说，编程是通过memory mapped I/O完成的。在SiFive的手册中，设备地址出现在物理地址的特定区间内，这个区间由主板制造商决定。操作系统需要知道这些设备位于<strong>物理地址空间的具体位置</strong>，然后再<strong>通过普通的load/store指令</strong>对这些地址进行编程。load/store指令实际上的工作就是<strong>读写设备的控制寄存器</strong>。</p>
</blockquote>
</li>
<li><blockquote>
<p>例如，<strong>对网卡执行store</strong>指令时，<strong>CPU会修改网卡的某个控制寄存器</strong>，进而<strong>导致网卡发送一个packe</strong>t。所以这里的<strong>load/store指令不会读写内存，而是会操作设备</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="中断开启"><a href="#中断开启" class="headerlink" title="中断开启"></a>中断开启</h2><ul>
<li>开启中断，也即使得CPU可以接受来自设备的中断。</li>
<li>我觉着大致可以分为三步<ul>
<li>令设备可以发出中断</li>
<li>令PLIC可以接收并路由中断</li>
<li>令CPU可以接受中断</li>
</ul>
</li>
</ul>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul>
<li>前置知识：RISCV中 与中断相关的寄存器<ul>
<li>$SIE (Supervisor Interrupt Enable)<ul>
<li>有3个bit。<ul>
<li>bit(E) : 代表UART外部设备的中断。</li>
<li>bit(S) : 代表软件中断</li>
<li>bit(T) : 代表定时器中断</li>
</ul>
</li>
</ul>
</li>
<li>$SSTATUS (Supervisor Statue)<ul>
<li>有1个bit 负责 打开、关闭中断。</li>
<li>$SIE负责单独控制特定的中断；$SSTAUS 负责控制所有中断</li>
<li>每个CPU核都有独立的$SIE $SSTATUS。</li>
</ul>
</li>
<li>$SIP (Supervisor Interrupt Pending)<ul>
<li>此时发生的中断类型</li>
</ul>
</li>
<li>$SCAUSE<ul>
<li>表明当前进入kernel的原因是中断</li>
</ul>
</li>
<li>$STVEC<ul>
<li>trap / page fault / Interrupt发生时，此时运行的user process的程序计数器。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="系统一开始是如何开启中断的"><a href="#系统一开始是如何开启中断的" class="headerlink" title="系统一开始是如何开启中断的"></a>系统一开始是如何开启中断的</h4><ul>
<li><p><strong>entry.S -&gt; start.c : void start()</strong></p>
<ul>
<li>所有的中断都设置在Supervisor mode</li>
<li>设置$SIE来接收External，软件和定时器中断</li>
<li>初始化定时器</li>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-10-04-14.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>start.C -&gt; main.c : int main(){}</strong></p>
<ul>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-09-56-51.png"></p>
</blockquote>
</li>
<li><strong>consoleinit</strong>：设置好uart芯片，使其可以产哼中断<ul>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-10-12-02.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-10-14-22.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>plicinit,plicinithart</strong> : 使得PLIC可以接受相应中断，并路由到cpu。<ul>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-10-14-54.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>scheduler -&gt; inrt_on</strong> : 设置$SSTATUS，使得CPU可以接收中断。<ul>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-10-17-08.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>至此，中断被完全打开，cpu可以接受来自设备的中断。</li>
</ul>
</li>
</ul>
<h2 id="前置知识：发生中断时如何进入相应C-code"><a href="#前置知识：发生中断时如何进入相应C-code" class="headerlink" title="前置知识：发生中断时如何进入相应C code"></a>前置知识：发生中断时如何进入相应C code</h2><ul>
<li><strong>发生中断时，进入kernel C Code之前的处理</strong>：（所有都是这样）<ul>
<li><ol>
<li><strong>清除$SIE</strong></li>
</ol>
<ul>
<li>防止CPU核被其他中断打扰。CPU核完成当前中断后，再恢复$SIE</li>
</ul>
</li>
<li><ol start="2">
<li><strong>保存当前PC到$SEPC</strong></li>
</ol>
</li>
<li><ol start="3">
<li><strong>保存当前mode</strong></li>
</ol>
</li>
<li><ol start="4">
<li><strong>设置mode为Supervisor mode</strong></li>
</ol>
</li>
<li><ol start="5">
<li><strong>PC设置为$STVEC。即跳转到相应的处理代码处。</strong></li>
</ol>
<ul>
<li>user态时发生的中断即跳转到uservec，kernel处发生的中断即跳转到kernelvec。</li>
<li>uservec -&gt; usertrap ; kernelvec -&gt; kerneltrap</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="console如何显示"><a href="#console如何显示" class="headerlink" title="console如何显示 $"></a>console如何显示 $</h2><h3 id="当没发生中断时"><a href="#当没发生中断时" class="headerlink" title="当没发生中断时"></a>当没发生中断时</h3><ul>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-16-19-08.png"></p>
</blockquote>
</li>
<li>打印$流程<ul>
<li>init.c -&gt; sh.c -&gt; getcmd -&gt; fprintf($) -&gt; write(fd, &amp;c, 1); -&gt; sys_write -&gt; filewrite -&gt;  devsw[CONSOLE].write -&gt; consolewrite -&gt; uartputc(c) -&gt; uartstart()</li>
</ul>
</li>
</ul>
<ul>
<li><p>该驱动要将字符传送到uart最后传送到console上，需要有个缓冲区。这里是个循环buffer。我称之为outputBuffer (queue)吧。</p>
<ul>
<li>code如下</li>
<li>uart_tx_r 指向当前要从buffer中读走的字符</li>
<li>uart_tx_w 指向当前要写入字符到buffer中的位置。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the transmit output buffer.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">uart_tx_lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_TX_BUF_SIZE 32</span></span><br><span class="line"><span class="keyword">char</span> uart_tx_buf[UART_TX_BUF_SIZE];</span><br><span class="line"><span class="keyword">int</span> uart_tx_w; <span class="comment">// write next to uart_tx_buf[uart_tx_w++]</span></span><br><span class="line"><span class="keyword">int</span> uart_tx_r; <span class="comment">// read next from uart_tx_buf[uar_tx_r++]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-13-27-39.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>TOP</strong> : consolewrite -&gt; void uartputc(int c)</p>
<ul>
<li><ol>
<li>将c写入给buffer queue。</li>
</ol>
</li>
<li><ol start="2">
<li>从buffer中取出char给uart，通知uart处理char。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a character to the output buffer and tell the</span></span><br><span class="line"><span class="comment">// UART to start sending if it isn&#x27;t already.</span></span><br><span class="line"><span class="comment">// blocks if the output buffer is full.</span></span><br><span class="line"><span class="comment">// because it may block, it can&#x27;t be called</span></span><br><span class="line"><span class="comment">// from interrupts; it&#x27;s only suitable for use</span></span><br><span class="line"><span class="comment">// by write().</span></span><br><span class="line"><span class="comment">//  将字符C写入驱动的buffer queue中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">uartputc</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acquire(&amp;uart_tx_lock);</span><br><span class="line">    <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//  循环buffer已经满了 则sleep，将CPU让给其他进程。</span></span><br><span class="line">        <span class="keyword">if</span>(((uart_tx_w + <span class="number">1</span>) % UART_TX_BUF_SIZE) == uart_tx_r)&#123;</span><br><span class="line">            <span class="comment">// buffer is full.</span></span><br><span class="line">            <span class="comment">// wait for uartstart() to open up space in the buffer.</span></span><br><span class="line">            sleep(&amp;uart_tx_r, &amp;uart_tx_lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  将char c 写入buffer，更新w指针。</span></span><br><span class="line">            uart_tx_buf[uart_tx_w] = c;</span><br><span class="line">            uart_tx_w = (uart_tx_w + <span class="number">1</span>) % UART_TX_BUF_SIZE;</span><br><span class="line">        <span class="comment">//  通知uart进行操作</span></span><br><span class="line">            uartstart();</span><br><span class="line">            release(&amp;uart_tx_lock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>BOTTOM</strong> : uartintr -&gt; consoleintr ,uartstart()</p>
</li>
<li><p>这里直接调用了其BOTTOM中的一部分:uartstart，并不是为了相应设备发出的中断，只是为了操作下设备。</p>
<ul>
<li><ol>
<li>从uart_tx_buf中取出一个char</li>
</ol>
<ul>
<li>int c = uart_tx_buf[uart_tx_r++];</li>
</ul>
</li>
<li><ol start="2">
<li>将该char送入uart.</li>
</ol>
<ul>
<li>WriteReg(THR, c);</li>
<li>也即，告诉uart，我这里有一个字节需要你来发送。</li>
</ul>
</li>
<li><ol start="3">
<li>数据送到uart后，系统调用即返回，user shell继续执行.</li>
</ol>
</li>
<li><ol start="4">
<li>与此同时，uart将数据送出，送到指定设备（console？）。</li>
</ol>
</li>
<li><p><strong>如果没发生中断的话，这里就是正常输出了$吧</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if the UART is idle, and a character is waiting</span></span><br><span class="line"><span class="comment">// in the transmit buffer, send it.</span></span><br><span class="line"><span class="comment">// caller must hold uart_tx_lock.</span></span><br><span class="line"><span class="comment">// called from both the top- and bottom-half.</span></span><br><span class="line"><span class="comment">//  通知设备执行操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">uartstart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(uart_tx_w == uart_tx_r)&#123;</span><br><span class="line">            <span class="comment">// transmit buffer is empty.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// the UART transmit holding register is full,</span></span><br><span class="line">            <span class="comment">// so we cannot give it another byte.</span></span><br><span class="line">            <span class="comment">// it will interrupt when it&#x27;s ready for a new byte.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  从uart_tx_buf中取出一个char,将该char送入uart</span></span><br><span class="line">        <span class="keyword">int</span> c = uart_tx_buf[uart_tx_r];</span><br><span class="line">        uart_tx_r = (uart_tx_r + <span class="number">1</span>) % UART_TX_BUF_SIZE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  maybe uartputc() is waiting for space in the buffer. </span></span><br><span class="line">        <span class="comment">//  唤醒等待空闲空间的uartputc()函数</span></span><br><span class="line">        wakeup(&amp;uart_tx_r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  将char写入uart的寄存器中</span></span><br><span class="line">        <span class="comment">//  也即，告诉uart，我这里有一个字节需要你来发送。</span></span><br><span class="line">        <span class="comment">//  数据送到uart后，系统调用即返回，user shell继续执行</span></span><br><span class="line">        <span class="comment">//  与此同时，uart将数据送出，送到指定设备(应该是console)。</span></span><br><span class="line">        WriteReg(THR, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="当发生中断时"><a href="#当发生中断时" class="headerlink" title="当发生中断时"></a>当发生中断时</h3><ul>
<li><p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-16-18-22.png"></p>
</li>
<li><p><strong>发生中断时，进入kernel C Code之前的处理</strong>：（所有都是这样）</p>
<ul>
<li>如上所述。</li>
</ul>
</li>
<li><p><strong>发生中断时，进入kernel C Code之后的流程</strong></p>
<ul>
<li>举例 ，当在我们向Console输出字符时，发生中断。</li>
<li>shell运行在user态,故跳转到usertrap。</li>
<li><strong>usertrap -&gt; devintr -&gt; uartintr -&gt; consoleintr , uartstart</strong> </li>
<li>usertrap<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>int devintr()<ul>
<li>获取中断号 : int irq = plic_claim();</li>
<li>根据中断号判断是哪个设备的中断，进行相应处理。我们的例子中会进入uartintr()<ul>
<li>if(irq == UART0_IRQ) uartintr();</li>
<li>if(irq == VIRTIO0_IRQ) virtio_disk_intr();</li>
<li>if(irq) printf(“unexpected interrupt irq=%d\n”, irq);<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check if it&#x27;s an external interrupt or software interrupt,</span></span><br><span class="line"><span class="comment">// and handle it.</span></span><br><span class="line"><span class="comment">// returns 2 if timer interrupt,</span></span><br><span class="line"><span class="comment">// 1 if other device,</span></span><br><span class="line"><span class="comment">// 0 if not recognized.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">devintr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint64 scause = r_scause();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((scause &amp; <span class="number">0x8000000000000000</span>L) &amp;&amp;</span><br><span class="line">        (scause &amp; <span class="number">0xff</span>) == <span class="number">9</span>)&#123;</span><br><span class="line">        <span class="comment">// this is a supervisor external interrupt, via PLIC.</span></span><br><span class="line">        <span class="comment">// irq indicates which device interrupted.</span></span><br><span class="line">        <span class="comment">//  获取中断号</span></span><br><span class="line">        <span class="keyword">int</span> irq = plic_claim();</span><br><span class="line">        <span class="comment">//  鉴定为uart发出中断</span></span><br><span class="line">        <span class="keyword">if</span>(irq == UART0_IRQ)&#123;</span><br><span class="line">            uartintr();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq == VIRTIO0_IRQ)&#123;</span><br><span class="line">            virtio_disk_intr();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(irq)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unexpected interrupt irq=%d\n&quot;</span>, irq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the PLIC allows each device to raise at most one</span></span><br><span class="line">        <span class="comment">// interrupt at a time; tell the PLIC the device is</span></span><br><span class="line">        <span class="comment">// now allowed to interrupt again.</span></span><br><span class="line">        <span class="keyword">if</span>(irq)</span><br><span class="line">            plic_complete(irq);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(scause == <span class="number">0x8000000000000001</span>L)&#123;</span><br><span class="line">        <span class="comment">// software interrupt from a machine-mode timer interrupt,</span></span><br><span class="line">        <span class="comment">// forwarded by timervec in kernelvec.S.</span></span><br><span class="line">        <span class="keyword">if</span>(cpuid() == <span class="number">0</span>)&#123;</span><br><span class="line">            clockintr();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// acknowledge the software interrupt by clearing</span></span><br><span class="line">        <span class="comment">// the SSIP bit in sip.</span></span><br><span class="line">        w_sip(r_sip() &amp; ~<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><strong>驱动的BOTTOM Interrupt Handler: void uartintr()</strong><ul>
<li>consoleintr()</li>
<li>uartstart()<ul>
<li>将shell存储在驱动中的buffer queue中的字符取出，送到uart的寄存器<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from trap.c.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">uartintr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// read and process incoming characters.</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> c = uartgetc();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">-1</span>)         <span class="comment">//  中断没字符 不读</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        consoleintr(c);     <span class="comment">//  读取终端输入的字符 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send buffered characters.</span></span><br><span class="line">    acquire(&amp;uart_tx_lock);</span><br><span class="line">    uartstart();            <span class="comment">//  将buffer queue中的char送入uart的寄存器。uart将char送到console</span></span><br><span class="line">    release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>实际上在提示符“$”之后，Shell还会输出一个空格字符，write系统调用可以在UART发送提示符“$”的同时，并发的将空格字符写入到buffer中。所以UART的发送中断触发时，可以发现在buffer中还有一个空格字符，之后会将这个空格字符送出。？？还不太理解。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>由上述可见，驱动的top部分和bottom部分解耦开。</strong>(通过buffer queue)<ul>
<li>top : consolewrite-&gt;uartput(c)</li>
<li>bottom :  void uartintr() : consoleintr() , uartstart()</li>
</ul>
</li>
</ul>
<h2 id="shell-如何-读取用户键入的-字符-并-传给shell程序-并-显示在终端上"><a href="#shell-如何-读取用户键入的-字符-并-传给shell程序-并-显示在终端上" class="headerlink" title="shell 如何 读取用户键入的 字符 并 传给shell程序 / 并 显示在终端上"></a>shell 如何 读取用户键入的 字符 并 传给shell程序 / 并 显示在终端上</h2><ul>
<li>类似于上面的驱动要将字符传送到uart最后传送到console上。那个驱动结构中有一个循环缓冲区。我就称之为outputBuffer queue吧。</li>
<li>同理，这里要将keyboard传给uart上的字符读到驱动中，驱动中也有一个循环缓冲区。我就称之为inputBuffer queue吧<ul>
<li>code如下，原理和那个outputBuffer一样。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// input</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INPUT_BUF 128</span></span><br><span class="line"><span class="keyword">char</span> buf[INPUT_BUF];</span><br><span class="line">uint r;  <span class="comment">// Read index</span></span><br><span class="line">uint w;  <span class="comment">// Write index</span></span><br><span class="line">uint e;  <span class="comment">// Edit index</span></span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如图<img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-17-02-42.png"></li>
</ul>
<h3 id="shell-从console中读取用户输入"><a href="#shell-从console中读取用户输入" class="headerlink" title="shell 从console中读取用户输入"></a>shell 从console中读取用户输入</h3><ul>
<li>这一部分还没发生中断。</li>
<li><strong>函数流程</strong>: (sh.c)gets -&gt; read -&gt; fileread -&gt; devsw[f-&gt;major].read -&gt; consoleread(int user_dst, uint64 dst, int n) -&gt;阻塞的读完指定bytes</li>
<li><strong>TOP : consoleread 核心逻辑</strong>如下：<ul>
<li>是驱动架构中的<strong>TOP</strong></li>
<li>读取buffer queue中的字符，遇到’\n’或者读完n bytes之后就返回到用户sh.c</li>
<li>当buffer queue中没有字符时，sleep等待。等待被唤醒。即等待bottom的InterruptHandler处理键盘的中断，将字符放入buffer queue。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// user read()s from the console go here.</span></span><br><span class="line"><span class="comment">// copy (up to) a whole input line to dst.</span></span><br><span class="line"><span class="comment">// user_dist indicates whether dst is a user</span></span><br><span class="line"><span class="comment">// or kernel address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">consoleread</span><span class="params">(<span class="keyword">int</span> user_dst, uint64 dst, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acquire(&amp;cons.lock);</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// wait until interrupt handler has put some input into cons.buffer.</span></span><br><span class="line">        <span class="comment">//  这不就是条件变量配合锁使用。</span></span><br><span class="line">        <span class="keyword">while</span>(cons.r == cons.w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  等待buffer中有可读数据</span></span><br><span class="line">            sleep(&amp;cons.r, &amp;cons.lock);</span><br><span class="line">        &#125;</span><br><span class="line">        c = cons.buf[cons.r++ % INPUT_BUF];</span><br><span class="line">        <span class="comment">// copy the input byte to the user-space buffer.</span></span><br><span class="line">        cbuf = c;</span><br><span class="line">        <span class="comment">//  将字符c传给user层地址空间</span></span><br><span class="line">        either_copyout(user_dst, dst, &amp;cbuf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        dst++;--n;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// a whole line has arrived, return to</span></span><br><span class="line">            <span class="comment">// the user-level read().</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;cons.lock);</span><br><span class="line">    <span class="keyword">return</span> target - n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="用户键入键盘-触发中断"><a href="#用户键入键盘-触发中断" class="headerlink" title="用户键入键盘,触发中断"></a>用户键入键盘,触发中断</h3><ul>
<li>用户键入键盘,触发中断,kernel的uartintr作为InterrupHandler进行处理。</li>
</ul>
<ul>
<li>usertrap -&gt; devintr -&gt; <strong>BOTTOM : uartintr</strong> -&gt; <strong>uartgetc , consoleintr , uartstart。</strong></li>
<li><strong>BOTTOM Interrupt Handler: uartintr</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from trap.c.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">uartintr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 其实我觉着这read 和 send两部分可以分成两个函数吧。。。。</span></span><br><span class="line">    <span class="comment">// read and process incoming characters.</span></span><br><span class="line">        <span class="comment">//  这里操作的buffer是inputBuffer(对于shell来说) 是一个为了从uart读入字符给上层的buffer</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> c = uartgetc();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        consoleintr(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// send buffered characters.</span></span><br><span class="line">        <span class="comment">//  这里操作的buffer是outputBuffer(对于shell来说) 是一个为了从将字符从上层送入uart的buffer。</span></span><br><span class="line">    acquire(&amp;uart_tx_lock);</span><br><span class="line">    uartstart();</span><br><span class="line">    release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>uartgetc : 从uart中读取1个字符</li>
<li>consoleintr : 将从uart读取的字符填充到buffer queue中，并唤醒consoleread。可以看出consoleintr是个producer的角色。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consoleintr</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acquire(&amp;cons.lock);</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF)&#123;</span><br><span class="line">            c = (c == <span class="string">&#x27;\r&#x27;</span>) ? <span class="string">&#x27;\n&#x27;</span> : c;</span><br><span class="line">            <span class="comment">// echo back to the user.</span></span><br><span class="line">            consputc(c);</span><br><span class="line">            <span class="comment">// store for consumption by consoleread().</span></span><br><span class="line">            cons.buf[cons.e++ % INPUT_BUF] = c;</span><br><span class="line">            <span class="comment">//  读取了一行 / 全部读取完了。</span></span><br><span class="line">            <span class="comment">//  那么 唤醒等待条件变量cons.r的consoleread</span></span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;\n&#x27;</span> || c == C(<span class="string">&#x27;D&#x27;</span>) || cons.e == cons.r+INPUT_BUF)&#123;</span><br><span class="line">                <span class="comment">// wake up consoleread() if a whole line (or end-of-file)</span></span><br><span class="line">                <span class="comment">// has arrived.</span></span><br><span class="line">                cons.w = cons.e;</span><br><span class="line">                wakeup(&amp;cons.r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>uartstart() : 感觉在这里没啥用处。或者说跟上面读取的键盘的字符没啥关系。因为uartstart把output buffer queue中的字符给uart。让其送到console。和我们上述读取键盘的字符时所用的buf不是一个buf。</li>
</ul>
</li>
</ul>
<ul>
<li>之后Consumer consoleread被唤醒。从input buffer queue 中读取字符到user态。返回到user层。</li>
</ul>
<h2 id="Inetrrupt的并发"><a href="#Inetrrupt的并发" class="headerlink" title="Inetrrupt的并发"></a>Inetrrupt的并发</h2><ul>
<li><p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-20-56-43.png"></p>
</li>
<li><p><strong>设备与CPU是并行运行的</strong></p>
<ul>
<li>如CPU将字符送入UART的reg之后就会返回Shell，而与此同时，UART正在并行的将字符传送给Console。此时Shell可能正在并行的调用write，向buffer queue中加入字符。</li>
</ul>
</li>
<li><p><strong>中断会停止当前运行的程序</strong></p>
<ul>
<li>对于user代码，无妨，因为中断会导致跳转到uservec trampoline，进行和syscall trap时一样的对用户上下文的保存。</li>
<li>QUES2：对于kernel，不成？<img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-13-14-27.png">我不理解。不是也有kernelvec吗</li>
</ul>
</li>
<li><p><strong>驱动的top和bottom部分是并行运行的</strong></p>
<ul>
<li>例如，Shell会在传输完提示符“$”之后再调用write系统调用传输空格字符，代码会走到UART驱动的top部分（注，uartputc函数），将空格写入到buffer中；但是同时在另一个CPU核，可能会收到来自于UART的中断，进而执行UART驱动的bottom部分，查看相同的buffer。如图<ul>
<li><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-17-01-58.png"></li>
</ul>
</li>
<li>所以一个驱动的top和bottom部分可以并行的在不同的CPU上运行。这里我们通过lock来管理并行。因为这里有共享的数据，我们想要buffer在一个时间只被一个CPU核所操作<ul>
<li>input/outputbuffer queue存在于内存中，并且只有一份，所以，所有的CPU核都并行的与这一份数据交互。所以我们才需要lock。</li>
<li><blockquote>
<p><img src="/2022/11/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-Interrupt/2022-11-14-13-55-15.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Interrupt的演进"><a href="#Interrupt的演进" class="headerlink" title="Interrupt的演进"></a>Interrupt的演进</h2><ul>
<li>直接摘mit</li>
</ul>
<p>概括<br>由于发生中断时，cpu要经过多步才能处理中断数据。因此，如果设备高速的产生中断，那么cpu将很难及时处理。因此，现在产生中断之前，硬件会执行大量操作以减轻cpu负担。因此硬件现在更复杂。</p>
<blockquote>
<p>最后我想介绍一下Interrupt在最近几十年的演进。当Unix刚被开发出来的时候，Interrupt处理还是很快的。这使得硬件可以很简单，当外设有数据需要处理时，硬件可以中断CPU的执行，并让CPU处理硬件的数据。<br>而现在，中断相对处理器来说变慢了。从前面的介绍可以看出来这一点，需要很多步骤才能真正的处理中断数据。如果一个设备在高速的产生中断，处理器将会很难跟上。？所以如果查看现在的设备，可以发现，现在的设备相比之前做了更多的工作。所以在产生中断之前，设备上会执行大量的操作，这样可以减轻CPU的处理负担。所以现在硬件变得更加复杂。</p>
</blockquote>
<p>概括<br>对于高性能设备，会很高速的产生中断，cpu不能即使处理。<br>因此，引入polling。通过轮询设备来获取数据（可以经常拿到数据），节省了中断的代价，而不是只通过interrupt。<br>对于高性能网卡，如果大量包传入，那么会使用polling，而非interrupt。</p>
<blockquote>
<p>如果你有一个高性能的设备，例如你有一个千兆网卡，这个网卡收到了大量的小包，网卡每秒可以生成1.5Mpps，这意味着每一个微秒，CPU都需要处理一个中断，这就超过了CPU的处理能力。那么当网卡收到大量包，并且处理器不能处理这么多中断**的时候该怎么办呢？<br>这里的解决方法就是使用polling。除了依赖Interrupt，CPU可以一直读取外设的控制寄存器，来检查是否有数据。对于UART来说，我们可以一直读取RHR寄存器，来检查是否有数据。现在，CPU不停的在轮询设备，直到设备有了数据。<br>这种方法浪费了CPU cycles，当我们在使用CPU不停的检查寄存器的内容时，我们并没有用CPU来运行任何程序。在我们之前的例子中，如果没有数据，内核会让Shell进程sleep，这样可以运行另一个进程。<br>所以，对于一个慢设备，你肯定不想一直轮询它来得到数据。我们会在没有数据的时候切换出来运行一些其他程序。但是如果是一个快设备，那么Interrupt的overhead也会很高，那么我们在polling设备的时候，是经常能拿到数据的，这样可以节省进出中断的代价。<br>所以对于一个高性能的网卡，如果有大量的包要传入，那么应该用polling。对于一些精心设计的驱动，它们会在polling和Interrupt之间动态切换（注，也就是网卡的NAPI）。</p>
</blockquote>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab3-pagetable</title>
    <url>/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/</url>
    <content><![CDATA[<p>地址映射关系 即 va -&gt; pa 的 映射</p>
<ul>
<li><p>在做<strong>本实验之前</strong>，xv6的虚拟内存机制如下</p>
<ul>
<li>对于kernel , 内核只有一张<strong>全局的kernel pagetable</strong>. 所有kernel thread 共用这一张pagetable. 通过MMU使用.</li>
<li>对于user , 每个user process的user thread 有一张<strong>user pagetable</strong>. user通过MMU使用.</li>
<li>但对于user传入kernel的va,kernel该如何使用user pgtbl来进行寻址呢 ? kernel 通过<strong>软件模拟</strong>(walkaddr)来查询user pgtbl 来进行user va的寻址.<ul>
<li>很显然，效率很低 不如硬件. 现代操作系统采用的也并非是这种机制.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本实验</strong> : 那么 为了让kernel可以直接通过硬件MMU来使用user pagetable. 我们实现如下措施</p>
<ul>
<li>(以下就是所谓的将<strong>内核页表和用户页表合并</strong>)<ul>
<li>为<strong>每</strong>一个process的<strong>kernel thread 都 分配一个 pagetable.</strong> </li>
<li>且在这个kernel thread pgtable<ul>
<li><ol>
<li>不但维护了kernel 的地址空间映射</li>
</ol>
</li>
<li><strong>2. 还要 维护user thread的user pgtable的地址空间的映射(va-&gt;pa)</strong></li>
</ul>
</li>
<li><strong>对于1.</strong> 我们应当 为 每个kernel thread pgtbl建立和 全局 kenrel pgtbl 基本一样的地址映射关系 (kvminitproc)</li>
<li><strong>对于2.</strong> 我们应当 将user thread pgtbl 的维护的地址映射关系 拷贝到 kernel thread pgtbl 的 [0,0XC00..00-1]处<ul>
<li>并在 user thread pgtbl 的地址映射关系发生改变时(pte的增加/删除/修改)，即时拷贝到kernel thread pgtbl上</li>
</ul>
</li>
</ul>
</li>
<li>合并之后，kernel 使用 user va的方式 就是 直接通过MMU在kernel thread pgtbl的user部分进行查询. 而不用通过walkaddr,提高效率</li>
</ul>
</li>
<li><p>下图就是一个合并user部分后的kernel thread pgtbl<br><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2022-11-08-15-41-06.png"></p>
</li>
<li><p><strong>本实验后</strong>，xv6的虚拟内存机制如下</p>
<ul>
<li><strong>3个pgtbtl</strong><ul>
<li>全局 kernel pgtbl (kernel的scheduler thread用)</li>
<li>user thread pgtbl (user thread用)</li>
<li>kernel thread pgtbl(包含user部分) (kernel 用)</li>
</ul>
</li>
<li>主流的OS也是用这种方法.</li>
</ul>
</li>
<li><p>关于 vm.c 注释见文</p>
</li>
<li><p>关于虚拟内存是否连续见文末</p>
</li>
</ul>
<span id="more"></span>

<h2 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h2><ul>
<li>简单递归</li>
<li>对于PTE，当PTE_V=1时，代表着该PTE有效。<ul>
<li>对于非叶子pte，代表整个pte指向下一级pgtbl，且可以被使用。</li>
<li>对于叶子pte，也即其所指向的physical page 有效的physical page，所谓有效，也即该pagetable建立了从virtual address 到这个 physical page的映射，也即这个physical page 归本pgtbl所有。</li>
</ul>
</li>
<li>当PTE = 0时，意味着本PTE第一次被使用，故其也没有指向下一级页表或是物理页。<ul>
<li>核心code<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(depth &gt; <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">  <span class="comment">//  pagetable = 512 ptes = 512 uint64 = 512 * 8 bytes = 4096 bytes</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)</span><br><span class="line">    &#123;</span><br><span class="line">      uint64 next = PTE2PA(pte);    <span class="comment">//  nextlevel_pagetable_or_mem_pa</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>,i,(<span class="keyword">void</span>*)pte,next);</span><br><span class="line">      vmprint((<span class="keyword">pagetable_t</span>)next,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="part2-：独立内核页表"><a href="#part2-：独立内核页表" class="headerlink" title="part2 ：独立内核页表"></a>part2 ：独立内核页表</h2><ul>
<li><p>独立内核页表  </p>
<ul>
<li>我们需要 将共享内核页表改成独立内核页表 ，使得每个进程拥有自己独立的内核页表。</li>
</ul>
</li>
<li><p>在这一部分，仅仅是让每个process有自己的kernel pagetable，但实际上，在这里，对于该proc的kernel page table，使用的方法都是和之前全局的kernel pagetable一样的。</p>
</li>
<li><p>proc.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="keyword">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="keyword">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="keyword">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="keyword">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack   //  kernel stack 不是直接映射</span></span><br><span class="line">  uint64 kstack_pa;             <span class="comment">//  kernel stack的physical address</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="keyword">pagetable_t</span> kpagetable;       <span class="comment">//  kernel page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RISCV-PGTABLE结构"><a href="#RISCV-PGTABLE结构" class="headerlink" title="RISCV PGTABLE结构"></a>RISCV PGTABLE结构</h3><h4 id="三级页表"><a href="#三级页表" class="headerlink" title="三级页表"></a>三级页表</h4><p><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2023-02-25-21-41-55.png"></p>
<h4 id="PTE结构"><a href="#PTE结构" class="headerlink" title="PTE结构"></a>PTE结构</h4><p><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2023-02-25-21-42-05.png"></p>
<ul>
<li>PTE分为两部分：物理地址页帧号和标志位。具体的结构如上图。<ul>
<li>保留位：第54-63位，共10位。</li>
<li>PPN: 物理页帧号，第10-53位，共44位。</li>
<li>Flags：标志位，第0-9位，共10位。其中第8-9位为保留位，暂不使用。<ul>
<li>第0位 Valid：该页表项有效。对于叶子页表来说，这个位置为1说明虚拟地址有映射到物理地址，否则说明没有该映射。对于次页表来说，为1说明有对应的叶子页表，对于根页表说明有对应次页表。</li>
<li>第1-3位 Readable/ Writable/ Executable： 该页表项是可读/写/执行（作为代码运行）的。通常我们只需要关心叶子页表项的这三个位，因为这代表对应的物理页帧的标志，而不是页表的标志。对于根页表和次页表的目录项，这三个位往往置为0。</li>
<li>第4位 User： 该页表项指向的物理页能在用户态访问。内核页表中的代码和数据我们不会将其给用户使用，所以会置0，但是用户页表的代码和数据应该要置1。同样，对于内核页表中的页表项，如果该位置1，则计算机的硬件不会允许内核访问对应地址，但可以通过其他的手段访问，后文会介绍。</li>
<li>其他位,查阅riscv-privileged.pdf 4.3~4.4</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h3><ul>
<li><p><strong>问题：proc的kernel pagetable都需要映射什么？</strong></p>
<ul>
<li>在本部分，与全局kernel pagetable的不同之处在于<ul>
<li>只需要映射自己proc的kernel stack</li>
<li>不需要映射CLINT</li>
</ul>
</li>
<li>实际上，在下一部分完成后，proc kernel pagetable的PLIC之下，还需映射到proc user pgtbl维护的地址空间（即user虚拟地址指向的物理地址）</li>
<li>详情见下一部分。</li>
<li>本部分只是负责建立一个不完全proc的kernel pgtbl，并替代全局kernel pgtbl，并不改变其他机制。</li>
</ul>
</li>
<li><p><strong>一个进程到底是什么？</strong></p>
<ul>
<li>感觉就是一堆上下文和代码。。</li>
</ul>
</li>
<li><p><strong>为什么要保留初始内核页表？</strong></p>
<ul>
<li>保留原有的全局 kernel pagetable</li>
<li>因为cpu上不是一直都在执行用户进程。当执行用户进程之前，需要切换成user的kpgtbl；执行结束后，需要切成全局的kpgtbl。因为user的kpgtbl此时可能已经在freeproc函数中被释放，如果继续使用user的kpgtbl，会crash。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">    <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">    <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">    <span class="comment">// before jumping back to us.</span></span><br><span class="line">    p-&gt;state = RUNNING;</span><br><span class="line">    c-&gt;proc = p;</span><br><span class="line">    <span class="comment">//  切换进程的同时 切换成proc的kernel pgtbl</span></span><br><span class="line">    kvminithartproc(p-&gt;kpagetable);</span><br><span class="line">    <span class="comment">//  运行p进程</span></span><br><span class="line">    swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line">    <span class="comment">//  没有user进程运行时 即 运行scheduler时 换回全局kernel pgtbl</span></span><br><span class="line">    kvminithart();</span><br><span class="line">    <span class="comment">// Process is done running for now.</span></span><br><span class="line">    <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">    <span class="comment">// cpu dosen&#x27;t run any user process now</span></span><br><span class="line">    c-&gt;proc = <span class="number">0</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>Step 1 ：proc中新添 pagetable_t kernel_pagetable 以及kstack_pa</p>
<ul>
<li>属于proc的kernel pagetable</li>
<li>kernel stack的物理地址</li>
</ul>
</li>
<li><p>Step 2 ：实现 pagetable_t kvminitproc()。</p>
<ul>
<li>模仿kvminit，创建进程的内核页表，并建立除了CLINT之外的映射。</li>
</ul>
</li>
<li><p>Step 3 ：修改procinit。</p>
<ul>
<li>procinit()：系统引导时（见kernel/main.c的main函数），用于给proc分配kernel stack的physical page 并在全局kernel pgtbl建立映射。</li>
<li>记录下kernel stack的physical address。为了之后allocproc分配进程创建proc kernel pagetable时，在proc kpgtbl中建立kernel stack的映射。</li>
</ul>
</li>
<li><p>Step 4 ：修改allocproc。</p>
<ul>
<li>allocproc何时被调用？<ul>
<li>在系统启动时被第一个process 和 fork 调用</li>
</ul>
</li>
<li>allocproc功能<ul>
<li>在进程表proc数组中查找UNSUEDPCB，<ul>
<li>如果找到，<ul>
<li>创建用户页表初始化在内核中运行所需的状态trapframe,user pagetable , kpgtable , 处于forkret的上下文等，并保持p-&gt;lock返回。</li>
</ul>
</li>
<li>如果没有PCB，或者内存分配失败<ul>
<li>return 0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>创建proc的kpgtbl，并在其中建立该proc的kstack的映射。 <ul>
<li>只是把本proc的kstack在全局的kernel pgtbl的映射又在proc的kernel pgtbl上又做了一次。virtual address 和 kernel address 都是一样的</li>
<li>之前记录kstack_pa就是为了在这里建立映射。</li>
<li>虚拟地址也是之前创建kstack时记录下的p-&gt;kstack<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;kpagetable = kvminitproc();</span><br><span class="line"><span class="comment">//  映射kstack</span></span><br><span class="line">kvmmapproc(p-&gt;kpagetable,p-&gt;kstack,p-&gt;kstack_pa,PGSIZE,PTE_R | PTE_W);</span><br><span class="line"><span class="comment">//  此时user pgtbl 除了trapframe和trampoline之外还没有section 无需同步 user kernel pgtbl</span></span><br><span class="line"><span class="comment">//  也即0xC000000之下 user pgtbl没有建立va-pa</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Step 5 ：scheduler 切换进程的同时切换pagetable。没有用户进程的时候切回全局kernel pgtbl</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kvminithartproc(p-&gt;kpagetable);</span><br><span class="line"><span class="comment">//  运行p进程</span></span><br><span class="line">swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"><span class="comment">//  没有user进程运行时 即 运行scheduler时 换回全局kernel pgtbl</span></span><br><span class="line">kvminithart();</span><br></pre></td></tr></table></figure></li>
<li><p>Step 6 ：进程结束时，释放proc的kpgtbl，但不释放其映射的物理内存。因为内核的代码和数据都是唯一的。只是有很多人指向而已.</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  释放以pgtbl为根节点的所有pgtbl，并将pgtbl的所有pte清0，但不释放映射到的物理内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freepgtblonly</span><span class="params">(<span class="keyword">pagetable_t</span> pgtbl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">512</span>;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pgtbl[i];</span><br><span class="line">    <span class="comment">//  前两级的pte</span></span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      freepgtblonly((<span class="keyword">pagetable_t</span>)child);   <span class="comment">//  释放下一级pte</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  对于叶子pte 不必操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  释放整个pgtbl自身</span></span><br><span class="line">  kfree((<span class="keyword">void</span>*)pgtbl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一遍过 yes!</p>
</li>
</ul>
<h2 id="part-3-：简化软件模拟地址翻译"><a href="#part-3-：简化软件模拟地址翻译" class="headerlink" title="part 3 ：简化软件模拟地址翻译"></a>part 3 ：简化软件模拟地址翻译</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>进程user态的虚拟地址 即 proc的user pgtbl维护的虚拟地址<br>进程内核（kernel） 态的虚拟地址 即 proc的kernel pgtbl维护的虚拟地址<br>全局的kernel pgtbl 即 全局的kernel pgtbl</p>
<ul>
<li><strong>在做part3之前，proc在内核态如何使用user态传递到kenerl的user virtual address – 通过walkaddr</strong>？ <ul>
<li>kernel从user态的va读取数据：copyin ; 写入数据到user的va：copyout</li>
<li>比如在copyin的时候，如果拿到了user态的虚拟地址，如果按照之前的流程的话，需要通过copyin函数，copyin函数通过walkaddr软件模拟翻译获得user va对应的pa，再读取pa的内容，将其复制进kernel_dst对应的pa的physical memory。</li>
<li><strong>软件模拟翻译</strong> : <ul>
<li>通过walkaddr去user pgtbl查找user va对应的pa的过程。效率低。不如MMU查找快。</li>
</ul>
</li>
<li>kernel_dst如何得到pa？<ul>
<li>经硬件MMU查询翻译得到。不是在软件层面实现的。</li>
<li>当cpu发出这条kernel_dst后，会经MMU查询全局的kernel pagetable 翻译成pa。</li>
</ul>
</li>
<li>大概意思如下<blockquote>
<p><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2022-11-08-13-55-40.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>即便在做完part2之后，上述情况也并无差别，只是将MMU查询使用的全局的kernel pagetable替换成了proc的kernel pagetable。proc的kpgtbl和全局的kpgtbl的区别只是CLINT，不影响上述行为。</li>
</ul>
<ul>
<li><strong>做完part3，如何使用user的传入kernel的va？ – 直接使用</strong><ul>
<li>手段：将proc的user pgtbl所维护的从va到pa的映射，拷贝到kernel pgtbl的中。</li>
<li>这样我们在kernel的时候，比如在copyin的时候，拿到user传来的user va，我们不必去walkaddr去查询user va对应的pa，而是直接使用就好。将va到pa的翻译交给MMU。这样，user的va 直接使用，kernel的va 本就直接使用，省去了walkaddr的过程，全权交给硬件实现物理地址的翻译，提高效率。<ul>
<li>因为此时cpu的$satp 是 proc的kernel pagetable。而我们又将整个user pgtbl维持的va到pa的映射关系，原封不动的搬到了proc 的 kernel pgtbl。</li>
<li>因此MMU可以使用user的va在kernel的pgtbl中找到对应的pte，得到对应的pa。</li>
</ul>
</li>
<li>copyin_new核心code如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyin_new</span><span class="params">(<span class="keyword">pagetable_t</span> user_pagetable, <span class="keyword">char</span> *kernel_dst, uint64 user_srcva, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">//  直接使用user的srcva 而不必先去walkaddr得到pa！</span></span><br><span class="line">  memmove((<span class="keyword">void</span> *) kernel_dst, (<span class="keyword">void</span> *)user_srcva, len);</span><br><span class="line">  stats.ncopyin++;   <span class="comment">// XXX lock</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2022-11-08-19-45-40.png"></li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p><strong>part3实现思路</strong>：</p>
<ul>
<li><strong>让proc的kpgtbl也维护一套user态的地址空间（拷贝并同步user pgtbl）</strong></li>
<li><strong>拷贝</strong>：开始，将proc的user pgtbl所维护的从va到pa的映射，拷贝到kernel pgtbl的中</li>
<li><strong>同步</strong>：user pgtbl发生改变的时候，将 变化的pte拷贝到user pgtbl中。所谓改变，即新增pte 、删除pte、改变pte的时候。<ul>
<li>具体什么函数会令user pgtbl改变？<ul>
<li>uvmalloc –&gt; mappages —&gt; walk(1)  </li>
<li>uvmdealloc –&gt; uvmunmap –&gt; kfree(pa) *pte = 0</li>
</ul>
</li>
<li>但是 如果是对那块已经建立的physical memory填充字节或者读取写入之类的云云（比如copyin copyout），就不必同步kernel pgtbl,因为映射关系没变，pte自然也没有变化</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>step</strong></p>
<ul>
<li><strong>step1</strong> : 将user pgtbl的pte复制到kernel中并同步变化.<ul>
<li><strong>用户页表是从虚拟地址0开始，用多少就建多少，但最高地址不能超过内核的起始地址，这样用户程序可用的虚拟地址空间就为0x0 - 0xC000000。</strong></li>
<li>也即，在user pgtbl变化的时候，将变化同步到kpgtbl中</li>
<li>故在growproc fork userinit exec中 调用u2kvmcopymappingonly。<ul>
<li>例如fork中<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span> || u2kvmcopymappingonly(np-&gt;kpagetable,np-&gt;pagetable,<span class="number">0</span>,p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(np);</span><br><span class="line">  release(&amp;np-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>还有在user pgtbl清空pte时 也要同步到kpgtbl中，也即uvmdalloc和kvmdeallocpgtblonly要配套使用。代码见growproc以及exec。</li>
</ul>
</li>
<li><strong>step2</strong> : copyin 替换为 copin_new</li>
</ul>
</li>
</ul>
<h3 id="3个pgtbl"><a href="#3个pgtbl" class="headerlink" title="3个pgtbl"></a>3个pgtbl</h3><ul>
<li><p>全局的kernel pgtbl</p>
<ul>
<li>仅包含内核的代码和数据的虚实地址映射，用户程序的代码和数据不包含在内。</li>
<li><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2022-11-08-15-42-52.png"></li>
<li>xv6内核的大部分虚实地址映射是<strong>恒等映射</strong>，虚拟地址和物理地址是一模一样的。对于既要读写虚拟页又要通过PTE管理物理页的xv6内核来说，这样的直接映射降低了复杂性。</li>
<li>从图中，我们可以看到，有两处虚拟地址<strong>不是直接映射</strong>的：<ul>
<li><strong>trampoline</strong> 页：它是用户态-内核态跳板，既被映射到内核虚拟空间的顶端，页被映射到用户空间的同样位置。</li>
<li><strong>kernel stack</strong>：每个进程都有自己的内核栈，它被映射到高位，这样在它下面可以保留一个未映射的守护页。</li>
</ul>
</li>
</ul>
</li>
<li><p>proc 的 user pagetable</p>
<ul>
<li><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2022-11-08-13-09-30.png"></li>
<li>上图是xv6的用户程序虚拟地址空间分布。<strong>其代码实现在kernel/exec.c中，exec使用proc_pagetable分配了TRAMPOLINE和TRAPFRAME的页表映射，然后用uvmalloc来为每个ELF段分配内存及页表映射，并用loadseg把每个ELF段载入内存。</strong></li>
<li>trampoline ：用户态-内核态跳板。</li>
<li>trapframe：用来存放每个进程的用户寄存器的内存空间。如果你想查看xv6在trapframe page中存放了什么，详见proc.h的trapframe结构体。</li>
<li>heap ：堆。程序初始化时堆没有分配任何空间。用户程序可以通过sbrk系统调用调整堆分配的空间，这会把新内存映射到页表中，也可以从页表中移除映射，释放内存。</li>
<li>stack：用户栈。xv6的用户栈只分配了一个页（PAGESIZE），放置在比堆更低的位置。通常操作系统会把用户栈放置在比堆更高的位置，这也是xv6和常见的操作系统做法不一样的地方。</li>
<li>guard page：守护页，用来保护Stack。如果stack耗尽了，它会溢出到Guard page，但是因为Guard page的PTE中Valid标志位未设置，会导致立即触发page fault，这样的结果好过内存越界之后造成的数据混乱。</li>
<li>data：用户程序的数据段。</li>
<li>text：用户程序的代码段。</li>
</ul>
</li>
<li><p>proc的kernel pgtbl</p>
<ul>
<li>与全局kernel最重要的不同在于 只维护了自己kernel stack的地址映射，以及多维护了用户态的地址空间。</li>
<li><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2022-11-08-15-41-06.png"></li>
<li><blockquote>
<p><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2022-11-08-15-49-05.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="vm-c"><a href="#vm-c" class="headerlink" title="vm.c"></a>vm.c</h2><h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><ul>
<li><p>pte_t * walk(pagetable_t pagetable, uint64 va, int alloc)</p>
<ul>
<li>遍历前两级页表，找到第三级页表，返回va对应的第三级页表的叶子PTE , 这个PTE有可能全0</li>
<li>alloc == 1<ul>
<li>创建遍历过程中需要遍历到的但不存在的pagetable，最后返回va对应的第三级页表的叶子PTE.如果这个pte原本是不存在的话，那么实际上返回的pte是0</li>
<li>success : return pte的地址</li>
<li>fail : return 0 创建失败</li>
</ul>
</li>
<li>alloc == 0<ul>
<li>不必创建遍历过程中需要遍历到的但不存在的pagetable，如果遍历到的pte还不存在或者需要遍历的页表不存在，那么直接返回0即可。</li>
<li>success : return pte的地址</li>
<li>fail : return 0 所需遍历的页表不存在</li>
</ul>
</li>
<li>只有当遍历到的三级页表在遍历前就全部存在，且第三级页表中的va对应的pte也之前就建立了对物理页的映射，才会得到返回有效的指向物理页的pte。</li>
<li>目前来看只有通过walk接口，才能创建三级页表。</li>
</ul>
</li>
<li><p>uint64 walkaddr(pagetable_t pagetable, uint64 va)</p>
<ul>
<li>根据va 去 pagetable里面查找相应的PTE , 进而得到pa。并不新增pte。也不会改变已有pte。对于pgtbl建立的映射关系没有影响。</li>
<li>success : 如果查到的PTE无效 / 无权限，返回0</li>
<li>fail : 如果查到的PTE有效，返回pa<ul>
<li>返回的pa也只是physical page的起始addr，因为舍弃了va的低12位。</li>
</ul>
</li>
</ul>
</li>
<li><p>int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</p>
<ul>
<li>在pagetable上（所代表的三级页表），建立从va到pa的映射。一个page一个page的建立映射，perm是指定的权限位。mappages结束后，维护va-&gt;pa的所需的页表以及pte都已经创建和初始化好。<ul>
<li>建立的映射关系：[va,va+size-1] -&gt; [pa,pa+size-1]。 使用的虚拟地址是连续的，传入的物理内存也是连续的</li>
<li>建立映射：*pte = PA2PTE(pa) | perm | PTE_V</li>
</ul>
</li>
<li>success : return 0;</li>
<li>fail : return -1; <ul>
<li>由于walk函数在创建pagetable自身的时候失败。</li>
</ul>
</li>
<li>mappages 不会kalloc要映射到的物理页，要映射到的物理页时调用mappages之前就准备好的。是传入的pa；但是mappages可能会kalloc所需的pagetables。</li>
</ul>
</li>
<li><p>int test_pagetable()</p>
<ul>
<li>检验当前使用的pagetable是全局的kernel pagetable 还是其他pagetable<ul>
<li>通过$satp比较</li>
</ul>
</li>
</ul>
</li>
<li><p>void freepgtblonly(pagetable_t pgtbl)</p>
<ul>
<li>释放以pgtbl为根节点的所有pgtbl，并将pgtbl的所有pte清0，但不释放映射到的物理内存</li>
</ul>
</li>
<li><p>void freewalk(pagetable_t pagetable)</p>
<ul>
<li>释放所有存在的pagetable，并且检测叶子page table上面的叶子 PTE 是否已经没有对dram的映射,如果害有对dram的映射，那么panic<ul>
<li>在此之前应当先销毁整个pgtbl所建立的映射关系。（如调用 uvmunmap使得pte清0，释放映射的物理内存）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于全局-kernel-pgtbl"><a href="#关于全局-kernel-pgtbl" class="headerlink" title="关于全局 kernel pgtbl"></a>关于全局 kernel pgtbl</h3><ul>
<li><p><strong>关于全局 kernel pagetable的</strong></p>
</li>
<li><p>void kvminit()</p>
<ul>
<li>建立好direct-map kernel_pagetable 但并没有启动pgtbl</li>
<li>建立了KERNBASE之下 IO设备的映射以及kernel data . kernel text 以及trampoline的映射</li>
</ul>
</li>
<li><p>void kvminithart()</p>
<ul>
<li>设置cpu当前使用页表为kernel_pagetable</li>
</ul>
</li>
<li><p>kvmmap(uint64 va, uint64 pa, uint64 sz, int perm)</p>
<ul>
<li>在kernel_pagetable上，建立从va到pa映射，大小为sz。建立失败则panic</li>
</ul>
</li>
<li><p>uint64 kvmpa(uint64 va)</p>
<ul>
<li>在kernel pagetable中 查找va对应的pa </li>
<li>success : return pa (PPN + offset)</li>
<li>fail : panic  <ul>
<li>一般在va对应的物理页并不存在或者没有建立映射时（即根据va查询到的pte所指向的物理页无效 PTE_V = 0）</li>
</ul>
</li>
<li>仅仅对kernel stack的va的对应的pa进行查询时有效。因为kernel pagetable只有kernel stack不是直接映射。（其实还有trampoline，不过那是pc指向的地址了）</li>
</ul>
</li>
</ul>
<h3 id="kernel-和-user-交互"><a href="#kernel-和-user-交互" class="headerlink" title="kernel 和 user 交互"></a>kernel 和 user 交互</h3><p><strong>kernel 和 user之间的数据交互 通过kernel 和user的pgtbl 以下是做lab之前</strong></p>
<ul>
<li><p>int copyout(pagetable_t user_pagetable, uint64 user_dstva, char *kernel_src, uint64 len)</p>
<ul>
<li>从kernel pagetable维护的src 的内容拷贝 len bytes 到 user pagetable维护的dst</li>
<li>success : return 0</li>
<li>fail : return -1</li>
<li>核心代码如下，去掉了一些页对齐的代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="comment">//  从kernel pagetable维护的src 的内容拷贝 len bytes 到 user pagetable维护的dst</span></span><br><span class="line"><span class="comment">//  success : return 0</span></span><br><span class="line"><span class="comment">//  fail : return -1</span></span><br><span class="line">copyout(<span class="keyword">pagetable_t</span> user_pagetable, uint64 user_dstva, <span class="keyword">char</span> *kernel_src, uint64 len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  src是全局 kpgtbl维护的虚拟地址，其和物理地址是恒等映射的关系。因此使用src实际上就是在使用物理地址 </span></span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="comment">//  查找user pgtbl 将va映射到的pa</span></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="comment">//  将pa src的内容复制到pa处  </span></span><br><span class="line">    memmove(pa0, src, n);</span><br><span class="line">    <span class="comment">//  continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>int copyin(pagetable_t user_pagetable, char *kernel_dst, uint64 user_srcva, uint64 len)</p>
<ul>
<li>从user pagetable维护的srcva 的内容拷贝 len bytes 到 kernel pagetable维护的dst</li>
<li>success : return 0</li>
<li>fail : return -1 . 查询srcva对应pa失败<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyin</span><span class="params">(<span class="keyword">pagetable_t</span> user_pagetable, <span class="keyword">char</span> *kernel_dst, uint64 user_srcva, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//  页对齐</span></span><br><span class="line">    va0 = PGROUNDDOWN(srcva);</span><br><span class="line">    <span class="comment">//  user的va翻译成了物理地址pa</span></span><br><span class="line">    pa0 = walkaddr(pagetable, va0);   </span><br><span class="line">    <span class="comment">//  这里可以成功运行 也不过是因为kernel_pagetable 在这个部分对 dram是恒等映射</span></span><br><span class="line">    <span class="comment">//  因为cpu还是会将pa当作kernel pagetable的va来进行翻译。翻译成pa。</span></span><br><span class="line">    <span class="comment">//  将user pgtbl维护的映射到pa0的内容 拷贝到kernel pgtbl维护的dst指向的地址的物理内存</span></span><br><span class="line">    memmove(dst, pa0 ,  n);</span><br><span class="line">    <span class="comment">//  continue      </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>int copyinstr(pagetable_t user_pagetable, char *kernel_dst, uint64 user_srcva, uint64 max)</p>
<ul>
<li>将user pagetable维护的srcva的地址的内容，拷贝kernel pagetable维护的dst。直到遇到’\0’</li>
</ul>
</li>
</ul>
<p><strong>完成part3之后</strong></p>
<ul>
<li>int copyin(pagetable_t user_pagetable, char *kernel_dst, uint64 user_srcva, uint64 len)<ul>
<li>从proc user pagetable维护的srcva 的内容拷贝 len bytes 到 proc kernel pagetable维护的dst</li>
<li><strong>此时proc的kpgtbl 也维护了srcva的虚拟地址，故不必去walkaddr，而是直接使用srcva</strong></li>
<li>success : return 0</li>
<li>fail : return -1 . <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyin_new</span><span class="params">(<span class="keyword">pagetable_t</span> user_pagetable, <span class="keyword">char</span> *kernel_dst, uint64 user_srcva, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">//  直接使用user的srcva 而不必先去walkaddr得到pa！</span></span><br><span class="line">  memmove((<span class="keyword">void</span> *) kernel_dst, (<span class="keyword">void</span> *)user_srcva, len);</span><br><span class="line">  stats.ncopyin++;   <span class="comment">// XXX lock</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="part-3-proc的kernel-pagetable"><a href="#part-3-proc的kernel-pagetable" class="headerlink" title="(part 3)proc的kernel pagetable"></a>(part 3)proc的kernel pagetable</h3><p><strong>part 3 : proc的kernel pagetable</strong></p>
<ul>
<li>pagetable_t kvminitproc()<ul>
<li>建立proc的kpgtable。仿照kvminit。不同之处在于没有映射CLINT。防止合并user页表时发生重合。</li>
</ul>
</li>
<li>void kvmmapproc(pagetable_t proc_kernel_pagetable, uint64 va, uint64 pa, uint64 sz, int perm)<ul>
<li>在proc_kernel_pagetable上，建立从va到pa映射，大小为sz。仅仅建立映射，而不负责kalloc映射到的physical page。失败则panic</li>
</ul>
</li>
<li>void kvminithartproc(pagetable_t kpgtbl)<ul>
<li>设置当前cpu使用页表为proc的kpgtbl</li>
</ul>
</li>
<li>int u2kvmcopymappingonly(pagetable_t kpgtbl,pagetable_t pgtbl,uint64 start,uint64 end)<ul>
<li>将user pgtbl 的pte拷贝给user kernel pagetable [start,end)范围最大为[0,PLIC)。仅仅拷贝映射关系而已。而不拷贝映射的物理内存。<ul>
<li>当user的pgtbl 有任何改动(增添或删除)的时候 将改动的pte拷贝给kernel pgtbl</li>
</ul>
</li>
</ul>
</li>
<li>uint64 kvmdeallocpgtblonly(pagetable_t kpgtbl, uint64 oldsz, uint64 newsz)<ul>
<li>解除proc 的 kernel pgtbl 的va从 [newsz,oldsz) 到pa的映射（即将相应pte清0），但不释放physical memory<ul>
<li>[newsz , oldsz) 应当包含于 [0,PLIC)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于proc的user-pagetable"><a href="#关于proc的user-pagetable" class="headerlink" title="关于proc的user pagetable"></a>关于proc的user pagetable</h3><p><strong>关于proc user pagetable</strong></p>
<ul>
<li><p>pagetable_t uvmcreate()</p>
<ul>
<li>创建一个PGSIZE大小的empty的user的pagetable(通过kalloc) </li>
<li>success ：return pagetable</li>
<li>fail    ：return 0</li>
</ul>
</li>
<li><p>void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)</p>
<ul>
<li>解除va到pa的映射（pa由pagetable查找）（即使得va对应的pte清0）</li>
<li>并释放pa对应的物理页(if dofree = 1)。</li>
<li>总共解除对npages个物理页的映射</li>
<li>fail : panic。查询pte失败 | te指向的物理页无效 | 查询到的pte不是个叶子 ? </li>
</ul>
</li>
<li><p>void uvminit(pagetable_t pagetable, uchar *src, uint sz)</p>
<ul>
<li>在(user的)pagetable上，从虚拟地址的0开始，建立从 virtual [0,PGSIZE-1) 到 physical [mem,mem+PGSIZE-1) 的映射</li>
<li>只是为了第一个进程，第一个进程需要运行initcode的text。src这段内存中装的是initcode的代码</li>
</ul>
</li>
<li><p>uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)</p>
<ul>
<li>为user pagetable 建立从virtual addr oldsz到virtual addr newsz的虚拟地址空间。为其申请物理内存并建立映射。</li>
<li>传入的oldsz 和 newsz 都是pgtbl的虚拟地址</li>
<li>success : return newsz <ul>
<li>返回pagetable维护的最大的虚拟地址</li>
</ul>
</li>
<li>fail : return 0;   当<ul>
<li>kalloc申请物理内存失败 / 建立mappages映射失败</li>
</ul>
</li>
</ul>
</li>
<li><p>uint64 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) </p>
<ul>
<li>pagetable维护的虚拟地址空间,从oldsz减到newsz。解除va到pa的映射 并释放physical page<ul>
<li>传入的oldsz和newsz都是pagetable上的虚拟地址</li>
</ul>
</li>
<li>return pgtbl当前维护的最大vaddr</li>
</ul>
</li>
<li><p>void uvmfree(pagetable_t pagetable, uint64 sz)</p>
<ul>
<li>释放user page table 所建立的 虚拟地址 到 物理地址的映射，并释放其所映射的物理内存<ul>
<li>uvmunmap</li>
</ul>
</li>
<li>释放user page table 自身<ul>
<li>freewalk(pagetable);</li>
</ul>
</li>
</ul>
</li>
<li><p>int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</p>
<ul>
<li>所谓uvmcopy 就是将old pgtbl所建立的映射关系以及物理内存 拷贝给 new pgtbl<ul>
<li>本函数令 new pgtbl 也像old pgtbl 一样，建立从[0,sz-1]到physical memory的映射.</li>
<li>传入的old pgtbl 所维护的映射是从[0,sz-1]到physical memory的映射</li>
<li>将old(parent) page table 所维护的va到pa的映射中physical memory的内容拷贝给new pagetable 所建立的va所对应的physical memory.</li>
</ul>
</li>
<li>success : return 0</li>
<li>fail : return -1</li>
<li>调用场合：Given a parent process’s page table, copy its memory into a child’s page table.</li>
</ul>
</li>
<li><p>void uvmclear(pagetable_t pagetable, uint64 va)</p>
<ul>
<li>将va在user pagetable对应的PTE标记为user无权限</li>
</ul>
</li>
</ul>
<hr>
<h2 id="琐碎问题"><a href="#琐碎问题" class="headerlink" title="琐碎问题"></a>琐碎问题</h2><ol>
<li>刚切换回scheduler的时候就需要换回全局 kernel pgtbl吗？. 是的</li>
<li>user pagetable 一定都在0xC00000之下吗? 怎么确定的 ? 我们实现时人为控制的.</li>
<li>scheduler：怎么switch之后 直接就运行了另一个进程呢？:通过swtch.S . 见后面的thread实验</li>
<li>uvmcopy 是不是只拷贝了text到heap的这段连续的。trapframe和trampoline不管。:对的</li>
</ol>
<ul>
<li>胡咧咧几句<ul>
<li>可以看到，相较于Linux，即便我们完成了本实验，xv6实现的虚拟内存还是较为简易的。<ul>
<li>Linux里面process的virtual address不见得都是连续的. 一段段连续的va的起始地址记录于task_struct中的vm_area_struct中.<blockquote>
<p><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2023-02-26-16-03-44.png"></p>
</blockquote>
</li>
<li>但是在xv6中，user process的virtual address是连续的. 除了顶部的trampoline和trapframe,就是下部的heap stack等. 换句话说,va只分成了两段(见下面的exec.c可以证明)<ul>
<li>顶部的 trampoline , trapframe</li>
<li>下部的 heap , stack , guard page , data , text<blockquote>
<p><img src="/2022/11/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab3-pagetable/2022-11-08-13-09-30.png"></p>
</blockquote>
</li>
<li>当然heap段一开始是空的,并没有va对应的pte记录在pgtable中. 需要uvmalloc</li>
<li>stack , guard page , data , text 一开始就有pte在pgtable中. 见exec()</li>
</ul>
</li>
<li>那么，对于user传入kernel的va<ul>
<li>linux 显然会先从vm_area_struct中,寻找,看该va是否属于某一区域. 不属于，则是非法va. 若属于，再看该va对应的pte的权限是否合法. </li>
<li>xv6 则简化很多，由于va连续，则kernel只需要检查va是否 &lt; sz &amp;&amp; &gt; 0即可. 不属于，则非法va. 属于，则再看该va对应的pte的权限是否合法.<ul>
<li>见copy on write实验</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>由exec.c可以看出 xv6的user processtext datat stack heap 的 va是连续的<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">exec</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">//  create a user pagetable</span></span><br><span class="line">  <span class="comment">//  0. 创建 pagetable</span></span><br><span class="line">  <span class="comment">//  1. 建立 trampoline 和 trapframe 的映射</span></span><br><span class="line">  pagetable = proc_pagetable(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  2. Load program into memory.</span></span><br><span class="line">  <span class="comment">//  建立了 data 段 和 text 段 的 va到pa(申请了phymem)</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="keyword">sizeof</span>(ph))&#123;</span><br><span class="line">    sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz);</span><br><span class="line">    loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Allocate two pages at the next page boundary.</span></span><br><span class="line">  <span class="comment">//  Use the second as the user stack.</span></span><br><span class="line">  <span class="comment">//  3. 建立了 stack 段 和 guard page段 的 va到pa的映射 (申请了phymem)</span></span><br><span class="line">  sz = uvmalloc(pagetable, sz, sz + <span class="number">2</span>*PGSIZE);</span><br><span class="line">  uvmclear(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">  sp = sz;</span><br><span class="line">  stackbase = sp - PGSIZE;</span><br><span class="line">    <span class="comment">//  int main(int argc,char *argv[])</span></span><br><span class="line">    <span class="comment">//  将 argv压入 stack </span></span><br><span class="line">    <span class="comment">//  Push argument strings, prepare rest of stack in ustack.</span></span><br><span class="line">    <span class="keyword">for</span>(argc) &#123;</span><br><span class="line">      sp -= <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">      sp -= sp % <span class="number">16</span>; <span class="comment">// riscv sp must be 16-byte aligned</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  记住main一开始的栈指针</span></span><br><span class="line">    p-&gt;trapframe-&gt;a1 = sp;      </span><br><span class="line"></span><br><span class="line">  <span class="comment">//  4. 解除kpgtbl的user部分的旧映射</span></span><br><span class="line">  kvmdeallocpgtblonly(p-&gt;kpagetable,p-&gt;sz,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  5. 将新的user pgtbl 同步到 kernel pgtbl上</span></span><br><span class="line">  <span class="keyword">if</span>(u2kvmcopymappingonly(p-&gt;kpagetable,pagetable,<span class="number">0</span>,sz)&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> bad;      </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  <span class="comment">//  6. 释放旧的user pgtbl</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> argc; <span class="comment">// this ends up in a0, the first argument to main(argc, argv)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab4-trap</title>
    <url>/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/</url>
    <content><![CDATA[<ul>
<li>part 2 : 利用栈桢，打印函数调用.</li>
<li>part 3 : 为xv6增加sys_sigalarm和sys_sigreturn系统调用<ul>
<li>sys_sigalarm : 注册callback以及超时时间</li>
<li>tick Interrupt : tick超时,返回user到callback</li>
<li>sys_sigreturn : user callback 结束. 通过该syscall 返回之前被tick超时打断的pc</li>
<li>实现重点是 在tick超时时 将 trapframe 进行备份,再返回user执行callback. 当user callback结束sys_sigreturn时,再将之前的trapframe替换出来. <ul>
<li>最主要原因是trapframe里面保存了epc（user进入kernel前的指令地址）,kernel返回user时一般pc返回到epc+4</li>
<li>所以要通过备份trapframe，来保证callback结束后可以返回到user正确的pc</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h1><p>Read the code in call.asm for the functions g, f, and main</p>
<ul>
<li>Q1 : Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?<ul>
<li>a0 , a1 , a2 , a3, a4, a5 , a6 , a7</li>
<li>a2 holds 13</li>
</ul>
</li>
<li>Q2 : Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)<ul>
<li>编译器将 f中对g的调用进行了内联</li>
<li>编译器将 main对f的调用进行了内敛。</li>
</ul>
</li>
<li>Q3 :At what address is the function printf located?<ul>
<li>0x630</li>
</ul>
</li>
<li>Q4 :What value is in the register ra just after the jalr to printf in main?       <ul>
<li>│$5 = (void (*)()) 0x38 ,jalr 指令的下一条汇编指令的地址</li>
<li><blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-04-08-51-54.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>Q5 :<ul>
<li>Run the following code.</li>
<li>unsigned int i = 0x00646c72; printf(“H%x Wo%s”, 57616, &amp;i);</li>
<li>What is the output ? <ul>
<li>HE110 World</li>
</ul>
</li>
<li>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output ? Would you need to change 57616 to a different value?<ul>
<li>i -&gt; 0x726c6400 </li>
<li>57616不需要,因为57616的十六进制就是0xe110</li>
</ul>
</li>
</ul>
</li>
<li>Q6<ul>
<li>printf(“x=%d y=%d”, 3);</li>
<li>what is going to be printed after ‘y=’?<ul>
<li>a2寄存器里原先是啥就输出啥 <blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-04-08-50-53.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>关于xv6的函数栈帧<ul>
<li>s0 : 当前栈帧的底部指针</li>
<li>sp : 栈顶指针<ul>
<li><blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-04-09-01-20.png"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># sp : 栈顶指针</span></span><br><span class="line"># s0 : 栈帧底指针</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="number">0</span>:	<span class="number">1141</span>                	addi	sp,sp,<span class="number">-16</span>   #  栈顶指针sp 下移<span class="number">16</span>字节</span><br><span class="line"><span class="number">2</span>:	e422                	sd	s0,<span class="number">8</span>(sp)       #  存栈底指针s0/fp到sp+<span class="number">8</span>的位置</span><br><span class="line"><span class="number">4</span>:	<span class="number">0800</span>                	addi	s0,sp,<span class="number">16</span>    #  将sp+<span class="number">16</span>即原sp的值作为新的栈帧</span><br><span class="line"><span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6</span>:	<span class="number">250</span>d                	addiw	a0,a0,<span class="number">3</span>     <span class="meta">#  x = x + 3</span></span><br><span class="line"><span class="number">8</span>:	<span class="number">6422</span>                	ld	s0,<span class="number">8</span>(sp)       #  从sp+<span class="number">8</span>恢复原栈帧到s0</span><br><span class="line">a:	<span class="number">0141</span>                	addi	sp,sp,<span class="number">16</span>    #  回收栈顶指针</span><br><span class="line">c:	<span class="number">8082</span>                	ret</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="PART2"><a href="#PART2" class="headerlink" title="PART2"></a>PART2</h1><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using PGROUNDDOWN(fp) and PGROUNDUP(fp) (see kernel/riscv.h. These number are helpful for backtrace to terminate its loop.</p>
<ul>
<li><p><strong>stack frame结构</strong></p>
<ul>
<li>s0 : 当前栈帧的底部指针。又称为frame pointer (fp)</li>
<li>sp : 栈的顶部指针<br><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-04-10-04-44.png"></li>
</ul>
</li>
<li><p>code</p>
<ul>
<li>逻辑：<ul>
<li><ol>
<li>通过reg s0 获取当前 frame 的 frame pointer</li>
</ol>
</li>
<li><ol start="2">
<li>打印调用该过程的 函数地址return address *(frame pointer - 8)</li>
</ol>
</li>
<li><ol start="3">
<li>找到上一级frame: prev frame pointer = frame pointer - 16<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  framepointer</span></span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="comment">//  cur_fp 当前遍历到的栈帧地址</span></span><br><span class="line">  <span class="keyword">for</span>(uint64 cur_fp = fp;cur_fp &gt;= PGROUNDDOWN(fp) ; )</span><br><span class="line">  &#123;</span><br><span class="line">    uint64 func = *((uint64*)(cur_fp - <span class="number">8</span>)); <span class="comment">//  调用本级函数的 上一级函数的调用本层函数的 代码地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,func);</span><br><span class="line">    cur_fp = *((uint64*)(cur_fp<span class="number">-16</span>));       <span class="comment">//  fp - 16 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>bug注意</p>
<ul>
<li>不是要打印每个函数stack frame的地址，因为栈帧是用来存放函数调用过程中的变量的。打印栈帧的地址只是打印了存放那些变量的内存的地址。</li>
<li>而我们要获知的是 函数调用的过程，也即，我们要按照调用过程打印出函数代码的地址，而不是其调用过程中栈帧的地址。</li>
<li>也即，打印return address 而非 prev frame fp</li>
</ul>
</li>
</ul>
<h1 id="PART3"><a href="#PART3" class="headerlink" title="PART3"></a>PART3</h1><ul>
<li><p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt/fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</p>
<ul>
<li>在本练习中，您将向 xv6 添加一个功能，该功能会在进程使用 CPU 时间时定期发出警报。这对于想要限制其占用的 CPU 时间的计算绑定进程，或者对于想要计算但又希望采取一些定期操作的进程可能很有用。更一般地说，您将实现用户级中断/错误处理程序的原始形式;例如，您可以使用类似的方式来处理应用程序中的页面错误。如果解决方案通过了警报测试和用户测试，则它是正确的。</li>
</ul>
</li>
<li><p>You should add a new sigalarm(interval, handler) system call. If an application calls sigalarm(n, fn), then after every n “ ticks “ of CPU time that the program consumes, the kernel should cause application function fn to be called. When fn returns, the application should resume where it left off. A tick is a fairly arbitrary unit of time in xv6, determined by how often a hardware timer generates interrupts. If an application calls sigalarm(0, 0), the kernel should stop generating periodic alarm calls.</p>
<ul>
<li>您应该添加新的 sigalarm（间隔、处理程序）系统调用。如果一个应用程序调用sigalarm（n，fn），那么在程序消耗每n个“滴答”的CPU时间之后，内核应该导致应用程序函数fn被调用。当 fn 返回时，应用程序应从中断的位置继续。在 xv6 中，滴答是一个相当任意的时间单位，由硬件计时器生成中断的频率决定。如果应用程序调用 sigalarm（0， 0），内核应停止生成周期性警报调用。</li>
</ul>
</li>
<li><p>You’ll find a file user/alarmtest.c in your xv6 repository. Add it to the Makefile. It won’t compile correctly until you’ve added sigalarm and sigreturn system calls (see below).</p>
<ul>
<li>您可以在 xv6 存储库中找到一个文件 user/alarmtest.c。将其添加到生成文件。在添加 sigalarm 和 sigreturn 系统调用之前，它不会正确编译（见下文）。</li>
</ul>
</li>
<li><p>alarmtest calls sigalarm(2, periodic) in test0 to ask the kernel to force a call to periodic() every 2 ticks , and then spins for a while. You can see the assembly code for alarmtest in user/alarmtest.asm, which may be handy for debugging. Your solution is correct when alarmtest produces output like this and usertests also runs correctly:</p>
<ul>
<li>alarmtest 在 test0 中调用 sigAlarm （2， periodic） 来要求内核每 2 个即时报价强制调用 periodic（），然后旋转一段时间。您可以在user/alarmtest.asm中看到alarmtest的汇编代码，这对于调试可能很方便。当 alarmtest 产生如下输出并且用户测试也正常运行时，您的解决方案是正确的：</li>
</ul>
</li>
</ul>
<h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><ul>
<li><p><strong>bug1</strong></p>
<ul>
<li>企图在alarm到时的时候，在kernel里面调用之前user注册到proc中的alarm_handler</li>
<li>结果访问了不可访问呢的区域，panic kerneltrap.</li>
<li>原因：user注册到proc结构体当中的callback:alarm_handler，其注册的函数地址是user pagetable维护的虚拟地址(在本例中是0x0)，而非kernel pagetable维护的虚拟地址。callback是在user process的text段而非kernel process的地址空间里。因此crash。</li>
<li><blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-04-16-31-01.png"><br><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-04-16-31-47.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>bug2</strong></p>
<ul>
<li>code<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">错误做法<span class="function">code</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(p-&gt;ticks_passed &gt;= p-&gt;ticks_interval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  替换trapframe</span></span><br><span class="line">  p-&gt;back_trapframe = p-&gt;trapframe;</span><br><span class="line">  p-&gt;trapframe = kalloc();              即便kalloc了。trampoline使用的也不是这里新kalloc的trapframe。不过kernel的C code 倒是会使用这个新kalloc的trapframe。因此，这妥妥的bug。crash。panic。</span><br><span class="line">  assert(p-&gt;trapframe!=<span class="number">0</span>,<span class="string">&quot;kalloc trapframe&quot;</span>);</span><br><span class="line">  *(p-&gt;trapframe) = *(p-&gt;back_trapframe);</span><br><span class="line">  p-&gt;trapframe-&gt;epc = (uint64) p-&gt;alarm_handler;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">正确<span class="function">code</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(p-&gt;ticks_passed &gt;= p-&gt;ticks_interval &amp;&amp; p-&gt;is_in_cb!=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  p-&gt;ticks_passed = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//  备份trapframe</span></span><br><span class="line">  *(p-&gt;back_trapframe) = *(p-&gt;trapframe);</span><br><span class="line">  <span class="comment">//  handler使用当前trapframe</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = (uint64) p-&gt;alarm_handler;</span><br><span class="line">  p-&gt;is_in_cb = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>擅自改变使用的trapframe地址。我一开始是每次需要使用alarm_handler的时候，就把原先的trapframe存起来，kalloc一个trapframe给alarm_handler使用，（通过改变proc中的trapframe指针指向）。这样做且不说效率，正确性上来讲就是错误的。<strong>原因见下</strong>。</li>
<li>看网上博客都说不这么做是因为效率原因，tmd，臭不要脸，人云亦云。</li>
<li><strong>前言</strong>：首先易知 <strong>trapframe这个结构体，在trampoline的uservec和userret汇编，以及kernel 的 C code中均被使用</strong>到。<ul>
<li><strong>在trampoline中，是通过user pagetable维护的虚拟地址0x3ffffffe000引用的</strong>.</li>
<li><strong>在kernel的C code中，是通过p-&gt;trapframe引用的，其地址使用的自然是kernel pagetable维护的物理地址。如 (struct trapframe <em>) 0x87f62000</em></strong>.</li>
<li>我们易知对于同一个user process ，kernel 的 C code 使用的user的trapframe自然也要和trampoline使用的user的trapframe保持一致，（因为是使用的应当同一个process的trapframe）也即该<strong>p-&gt;trapframe应当和trampoline通过0x3ffffffe000使用的是physical memory中的t同一个p-&gt;trapframe！否则就会crash！！</strong></li>
</ul>
</li>
<li><strong>接下来见错误原因</strong>：user pagetable维护的的trapframe地址是固定在0x3ffffffe000的。我们不能错误的使用一个新kalloc的trapframe。错误的认为他会被trampoline使用。<ul>
<li><strong>首先</strong>，这个新在kernel kalloc的trapframe，只在kernel的pagetable建立了从虚拟地址到物理地址的映射，user 的pagetable甚至都不知道kernel已经已经新给他kalloc了一个trapframe。除非你在给他的userpagetable映射一下，不过挺困难+麻烦的。</li>
<li><strong>其次</strong>，如后文所述，我们的trampoline的uservec和userret使用的始终是0x3ffffffe00处的trapframe。如果换一个新地址的trapframe，还要再改kernel传递给trampoline的参数。</li>
<li><strong>最后</strong>，如果我们没改userpagetable也没修改trampoline，那么，就会出现trampoline使用一个trapframe，同时kernel的C code使用另一个trapframe的现象。</li>
</ul>
</li>
<li>user pagetable维护的trapframe 0x3ffffffe000地址是什么时候需要被使用，被那里使用？<ul>
<li>答：在trampoline的uservec和userret被使用了。无论是uservec还是userret，trampoline始终使用的是user pagetable维护的0x3ffffffe000地址处的trapframe。</li>
<li><strong>uservec</strong> : 将user trapframe的地址从$sscratch(之前由kernel保存地址到这里的)加载到$a0中来使用<ul>
<li><blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-06-14-48-29.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>userret</strong> : 使用$a0中保存的user trapframe地址，返回user之前，将$a0保存在$sscratch中。<ul>
<li><blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-06-14-47-01.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-06-14-35-18.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-06-14-20-25.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>为什么user trapframe的地址0x3ffffffe000？trampoline中userret时$a0是如何获得该地址的?</strong><ul>
<li>为什么trapframe的地址0x3ffffffe000：<ul>
<li>是process刚一被kernel创建并分配的时候，就指定了这一块空间是trapframe，并建立在user pagetable建立了映射。</li>
<li><blockquote>
<p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-06-15-19-27.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>userret 中 $a0如何获得该地址<ul>
<li>kernel usertrapret<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"><span class="comment">// jump to trampoline.S at the top of memory, which </span></span><br><span class="line"><span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line"><span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">uint64 fn = TRAMPOLINE + (userret - trampoline);</span><br><span class="line"><span class="comment">//  pass user trapframe address and user page table satp</span></span><br><span class="line">((<span class="keyword">void</span> (*)(uint64,uint64))fn)(TRAPFRAME, satp);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h3><ul>
<li><strong>关于为什么在调用alarm_handler时 需要新用一个trapframe ， 将原先的trapframe备份起来。</strong><ul>
<li>因为如果没有将原先的trapframe保存起来的话，我们的handler继续使用原先的trapframe，那么当我们的handler结束后，调用syscall sigreturn结束alarm_handler，那么该user的pc该返回哪里？如果我们就这样不做任何改动，那么pc就是返回到alarm_handler的最后一条指令的下一条地址。可是显然，那是个错误的地址，。我们应当返回的是当时被ticks interrupt 进而执行alarm_handler 时 被打断的指令，继续执行那个指令。</li>
<li>因此，我们需要在执行alarm_handler执行之前保存其上下文trapframe（epc）备份起来（为了之后恢复）<ul>
<li>*(p-&gt;back_trapframe) = *(p-&gt;trapframe);</li>
</ul>
</li>
<li>然后将当前trapframe提供给alarm_handler去执行。<ul>
<li>p-&gt;trapframe-&gt;epc = (uint64) p-&gt;alarm_handler;</li>
</ul>
</li>
<li>最后在alarm_handler执行结束后调用sigreturn的时候，在sys_return中恢复上下文。<ul>
<li>sigreturn : *(p-&gt;trapframe) = *(p-&gt;back_trapframe);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h3><p><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2023-02-26-20-26-21.png"><br><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2023-02-26-20-25-10.png"></p>
<ul>
<li><strong>sigalarm</strong><br><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-06-16-55-53.png"></li>
<li><strong>alarm_handler触发</strong><br><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-06-16-56-06.png"></li>
<li><strong>sigreturn 返回</strong><br><img src="/2022/11/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab4-trap/2022-11-06-16-56-37.png"></li>
</ul>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul>
<li>还有一个问题待解决：<ul>
<li>handler执行需要用到原先的执行流的除了$epc的其他上下文吗？是有用还是有害？<ul>
<li>需要。有用。trapframe里的几乎都需要感觉。</li>
</ul>
</li>
<li>那么handler执行之后，改变的寄存器啥的，究竟是破坏了原先的pc流的trapframe，还是对原先的pc流有用？<ul>
<li>我第一想法是感觉handler改变的寄存器应该是对原先的pc流有用。</li>
<li>不过从代码上看，我们在sigreturn时，直接将原先的pc流的trapframe覆盖了当前handler执行完的trapframe，似乎是handler的上下文对原先的pc流不再有意义？<ul>
<li>问题：那如果有一个变量在handler时，由于频繁的++–，一直存在reg中，但是这个变量在pc流中handler之后又会被使用。如果不管handler执行后的reg的话，这个变量的改变值不会丢失吗？<ul>
<li>（我认为）会丢失，不过该syscall的设计者应当限制user的使用方式。从测试程序中可以看到，handler会强制和内存读写，而不会优化成对寄存器读写。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">62</span></span><br><span class="line"><span class="number">63</span> <span class="keyword">void</span> __attribute__ ((noinline)) foo(<span class="keyword">int</span> i, <span class="keyword">int</span> *j) &#123;</span><br><span class="line"><span class="number">64</span>   <span class="keyword">if</span>((i % <span class="number">2500000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">65</span>     write(<span class="number">2</span>, <span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="number">66</span>   &#125;</span><br><span class="line"><span class="number">67</span>   *j += <span class="number">1</span>;</span><br><span class="line"><span class="number">68</span> &#125;</span><br><span class="line"><span class="number">69</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON简介</title>
    <url>/2022/07/20/%E5%B7%A5%E5%85%B7-Json/</url>
    <content><![CDATA[<p>json for morden c++</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Json（JavaScript Object Notation）是一种轻量级的数据交换格式（也叫数据序列化方式）。JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。简洁和清晰的层次结构使得 Json 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
<li>道格拉斯·克罗克福特（Douglas Crockford）设计的JSON实际上是JavaScript的一个子集，故此，在Json中的数据类型有这几种。<ul>
<li>number：和JavaScript的number完全一致；</li>
<li>boolean：就是JavaScript的true或false；</li>
<li>string：就是JavaScript的string；</li>
<li>null：就是JavaScript的null；</li>
<li>array：就是JavaScript的Array表示方式——[]；</li>
<li>object：就是JavaScript的{ … }表示方式。</li>
<li>以及上面的任意组合。</li>
</ul>
</li>
<li>并且，JSON规定字符集必须是UTF-8，表示多语言就没有问题了。为了统一解析，JSON的字符串规定必须用双引号””，Object的键也必须用双引号””。</li>
<li>几乎所有编程语言都有解析JSON的库。而在JavaScript中，在语言层面内置了对象的<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021554858080">JSON序列化和反序列化的API。</a></li>
<li>感觉json对象就是一个key-value表，其中key-value都用string””表示，可能会存在一个key对应多个{key-value}的情况</li>
</ul>
<h2 id="好用的cpp库：JSON-for-Modern-C"><a href="#好用的cpp库：JSON-for-Modern-C" class="headerlink" title="好用的cpp库：JSON for Modern C++"></a>好用的cpp库：<a href="https://github.com/nlohmann/json">JSON for Modern C++</a></h2><ul>
<li>JSON for Modern C++ 是一个由德国大牛 nlohmann 编写的在 C++ 下使用的 JSON 库。具有以下特点<ul>
<li>直观的语法</li>
<li>整个代码由一个头文件组成 json.hpp，没有子项目，没有依赖关系，没有复杂的构建系统，使用起来非常方便</li>
<li>使用 C++ 11 标准编写</li>
<li>使用 json 像使用 STL 容器一样</li>
<li>STL 和 json 容器之间可以相互转换</li>
<li>严谨的测试：所有类都经过严格的单元测试，覆盖了 100％ 的代码，包括所有特殊的行为。此外，还检查了 Valgrind 是否有内存泄漏。</li>
<li>为了保持高质量，该项目遵循核心基础设施倡议(CII)的最佳实践</li>
</ul>
</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义json对象</span></span><br><span class="line">json js;</span><br><span class="line"><span class="comment">//  输出json对象</span></span><br><span class="line">cout&lt;&lt;json&lt;&lt;endl;</span><br><span class="line"><span class="comment">//  json -&gt; string</span></span><br><span class="line">string send_buf = js.<span class="built_in">dump</span>();</span><br><span class="line"><span class="comment">//  string -&gt; json</span></span><br><span class="line">json js = json::<span class="built_in">parse</span>(send_buf);</span><br></pre></td></tr></table></figure>

<h3 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h3><ul>
<li>就是把我们想要打包的数据，或者对象，直接处理成Json字符串<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;json.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  序列化示例1  普通数据序列化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msg_type&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    js[<span class="string">&quot;from&quot;</span>] = <span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;to&quot;</span>] = <span class="string">&quot;li si&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;hello,what are you doing?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;js&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    string send_buf = js.<span class="built_in">dump</span>();</span><br><span class="line">    cout&lt;&lt;send_buf&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// &#123;&quot;from&quot;:&quot;zhang san&quot;,&quot;msg&quot;:&quot;hello,what are you doing?&quot;,&quot;msg_type&quot;:2,&quot;to&quot;:&quot;li si&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#123;&quot;from&quot;:&quot;zhang san&quot;,&quot;msg&quot;:&quot;hello,what are you doing?&quot;,&quot;msg_type&quot;:2,&quot;to&quot;:&quot;li si&quot;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  序列化示例2     普通数据序列化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    <span class="comment">//  添加数组</span></span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//  添加key-value</span></span><br><span class="line">    js[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="comment">//  添加对象 (即一个msg数组里面有多个key-value)</span></span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;zhang san&quot;</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;liu shuo&quot;</span>] = <span class="string">&quot;bye&quot;</span>;</span><br><span class="line">    <span class="comment">//  上面等同于这句一次性添加数组对象</span></span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = &#123;&#123;<span class="string">&quot;zhang san&quot;</span>,<span class="string">&quot;hello2&quot;</span>&#125;,&#123;<span class="string">&quot;li si&quot;</span>,<span class="string">&quot;bye2&quot;</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;js&lt;&lt;endl;</span><br><span class="line"><span class="comment">//  &#123;&quot;id&quot;:[1,2,3,4,5],&quot;msg&quot;:&#123;&quot;li si&quot;:&quot;bye2&quot;,&quot;zhang san&quot;:&quot;hello2&quot;&#125;,&quot;name&quot;:&quot;张三&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  序列化示例2  容器序列化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    js[<span class="string">&quot;list&quot;</span>] = vec;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="string">&quot;a&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,<span class="string">&quot;b&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">3</span>,<span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    js[<span class="string">&quot;map&quot;</span>] = m;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;js&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;&quot;list&quot;:[1,2,3],&quot;map&quot;:[[3,&quot;c&quot;],[1,&quot;a&quot;],[2,&quot;b&quot;]]&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Json反序列化"><a href="#Json反序列化" class="headerlink" title="Json反序列化"></a>Json反序列化</h3><ul>
<li>当从网络接收到字符串为Json格式，可以用JSON for Modern C++ 直接反序列化取得数据或者直接反序列化出对象，甚至容器！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  反序列化取key</span></span><br><span class="line"><span class="function">string <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    json js;</span><br><span class="line">    js[<span class="string">&quot;msg_type&quot;</span>] = <span class="number">2</span>;</span><br><span class="line">    js[<span class="string">&quot;from&quot;</span>] = <span class="string">&quot;zhang san&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;to&quot;</span>] = <span class="string">&quot;li si&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = <span class="string">&quot;hello,what are you doing?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> js.<span class="built_in">dump</span>();   <span class="comment">//  return string send_buf</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string receive_buf = <span class="built_in">func1</span>();</span><br><span class="line">json js_buf = json::<span class="built_in">parse</span>(receive_buf);</span><br><span class="line">cout&lt;&lt;js_buf[<span class="string">&quot;msg_type&quot;</span>]&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;js_buf[<span class="string">&quot;from&quot;</span>]&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;js_buf[<span class="string">&quot;to&quot;</span>]&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;js_buf[<span class="string">&quot;msg&quot;</span>]&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// &quot;zhang san&quot;</span></span><br><span class="line"><span class="comment">// &quot;li si&quot;</span></span><br><span class="line"><span class="comment">// &quot;hello,what are you doing?&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====================================</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接反序列化vector容器</span></span><br><span class="line">string <span class="built_in">func2</span>()</span><br><span class="line">&#123;</span><br><span class="line">    json js;</span><br><span class="line">    <span class="comment">//  添加数组</span></span><br><span class="line">    js[<span class="string">&quot;id&quot;</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//  添加key-value</span></span><br><span class="line">    js[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="comment">//  添加对象 (即一个msg数组里面有多个key-value)</span></span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;zhang san&quot;</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>][<span class="string">&quot;li si&quot;</span>] = <span class="string">&quot;bye&quot;</span>;</span><br><span class="line">    <span class="comment">//  上面等同于这句一次性添加数组对象</span></span><br><span class="line">    <span class="comment">//  key&quot;msg&quot; 对应的value类型 还是一个&#123;&#123;&#125;&#123;&#125;&#125;json</span></span><br><span class="line">    js[<span class="string">&quot;msg&quot;</span>] = &#123;&#123;<span class="string">&quot;zhang san&quot;</span>,<span class="string">&quot;hello2&quot;</span>&#125;,&#123;<span class="string">&quot;li si&quot;</span>,<span class="string">&quot;bye2&quot;</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> js.<span class="built_in">dump</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string receive_buf = <span class="built_in">func2</span>();</span><br><span class="line">json js_buf = json::<span class="built_in">parse</span>(receive_buf);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;js_buf[<span class="string">&quot;id&quot;</span>]&lt;&lt;endl;           <span class="comment">//  [1,2,3,4,5]</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec = js_buf[<span class="string">&quot;id&quot;</span>];     <span class="comment">//  1 2 3 4 5 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x:vec)&#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;js_buf[<span class="string">&quot;name&quot;</span>]&lt;&lt;endl;</span><br><span class="line"><span class="comment">// json中的json类型应用json来接收</span></span><br><span class="line">json js_msg = js_buf[<span class="string">&quot;msg&quot;</span>];</span><br><span class="line">cout&lt;&lt;js_msg[<span class="string">&quot;zhang san&quot;</span>]&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;js_msg[<span class="string">&quot;li si&quot;</span>]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line"><span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="string">&quot;hello2&quot;</span></span><br><span class="line"><span class="string">&quot;bye2&quot;</span></span><br><span class="line"></span><br><span class="line">=============================================</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接反序列化map容器</span></span><br><span class="line">string <span class="built_in">func3</span>()</span><br><span class="line">&#123;</span><br><span class="line">    json js;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    js[<span class="string">&quot;list&quot;</span>] = vec;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,string&gt; m;</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">1</span>,<span class="string">&quot;a&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,<span class="string">&quot;b&quot;</span>&#125;);</span><br><span class="line">    m.<span class="built_in">insert</span>(&#123;<span class="number">3</span>,<span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    js[<span class="string">&quot;map&quot;</span>] = m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> js.<span class="built_in">dump</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  json中的数组类型可以用容器vector接收 ; unordered_map可用unordered_map /  json来接收</span></span><br><span class="line">string receive_buf = <span class="built_in">func3</span>();</span><br><span class="line">json js_buf = json::<span class="built_in">parse</span>(receive_buf);</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = js_buf[<span class="string">&quot;list&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">    cout&lt;&lt;v[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,string&gt; m = js_buf[<span class="string">&quot;map&quot;</span>];</span><br><span class="line">cout&lt;&lt;m[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">json jsm = js_buf[<span class="string">&quot;map&quot;</span>];</span><br><span class="line">cout&lt;&lt;jsm&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/json_learn/build$ ../bin/json_test </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">a</span><br><span class="line">[[<span class="number">3</span>,<span class="string">&quot;c&quot;</span>],[<span class="number">1</span>,<span class="string">&quot;a&quot;</span>],[<span class="number">2</span>,<span class="string">&quot;b&quot;</span>]]</span><br></pre></td></tr></table></figure>


<p>json里的数据类型都是本身的数据类型套一个 “ string “  “ int “<br>要取出本身的类型：js[“xxx”].get<string> js[“xxxx”].get<int><br>但好像不取也没影响？</int></string></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab5-lazy_allocation</title>
    <url>/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/</url>
    <content><![CDATA[<p>易知x86-64都实现了lazy allocation<br>例如malloc一块很大的内存，直到对这个内存进行写/读之前，都不会</p>
<p>为xv6实现懒分配lazy allocation</p>
<ul>
<li>lazy allocation<ul>
<li>目的 : 为防止sbrk大量内存但实际上并没有使用的情况</li>
<li>实现 : 通过 虚拟内存 和 page fault handler<ul>
<li>阶段1. 设定va为合法<ul>
<li>sbrk系统调用 : 仅仅设定user的这段va是合法的，而不分配内存建立映射。</li>
</ul>
</li>
<li>阶段2. 使用va触发pagefault, 进行响应(handle)<ul>
<li>pagefault handelr : 为va 分配一块physical page 并 建立映射</li>
<li>阶段2中对于va<ul>
<li>user使用无效 userva<ul>
<li>MMU –检测–&gt; trap –&gt; pagefault handler</li>
</ul>
</li>
<li>kernel使用无效 userva<ul>
<li>argaddr 中检测 –&gt; pagefault handelr</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li>pgfault handelr之后 返回到造成pgfault的指令继续执行.</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li>背景：实现lazy allocation之前：也即 eager allocation</li>
<li>通过<a href="https://man7.org/linux/man-pages/man2/sbrk.2.html">sbrk(bytes)</a> 向上扩展heap空间<ul>
<li><blockquote>
<p><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-20-39-19.png"></p>
</blockquote>
</li>
<li>这意味着，当sbrk实际发生或者被调用的时候，内核会分配一些物理内存，并将这些内存映射到用户应用程序的地址空间，然后将内存内容初始化为0，再返回sbrk系统调用。这样，应用程序可以通过多次sbrk系统调用来增加它所需要的内存。类似的，应用程序还可以通过给sbrk传入负数作为参数，来减少或者压缩它的地址空间。我们暂且只关注内存增加</li>
</ul>
</li>
<li>在XV6中，sbrk的实现<strong>默认是eager allocation</strong>。这表示了，一旦调用了sbrk，内核会立即分配应用程序所需要的物理内存。但是实际上，对于应用程序来说很难预测自己需要多少内存，所以通常来说，应用程序倾向于申请多于自己所需要的内存。这意味着，<strong>进程的内存消耗会增加许多，但是有部分内存永远也不会被应用程序所使用到</strong>。<ul>
<li>你或许会认为这里很蠢，怎么可以这样呢？你可以设想自己写了一个应用程序，读取了一些输入然后通过一个矩阵进行一些运算。你需要为最坏的情况做准备，比如说为最大可能的矩阵分配内存，但是应用程序可能永远也用不上这些内存，通常情况下，应用程序会在一个小得多的矩阵上进行运算。所以，程序员过多的申请内存但是过少的使用内存，这种情况还挺常见的。</li>
</ul>
</li>
<li>原则上来说，这不是一个大问题。但是<strong>使用虚拟内存和page fault handler</strong>，我们完全可以用某种更聪明的方法来解决这里的问题，这里<strong>就是利用lazy allocation</strong>。</li>
</ul>
<p>下面 称 未建立映射的va 为<br>只设定为合法，但是 在pgtbl中没有相应pte，或者相应的pte并没有指向物理内存</p>
<h1 id="part1-and-part2"><a href="#part1-and-part2" class="headerlink" title="part1 and part2"></a>part1 and part2</h1><ul>
<li>mit教授课上做的就是</li>
</ul>
<h2 id="lazy-alloc-核心思想"><a href="#lazy-alloc-核心思想" class="headerlink" title="lazy alloc 核心思想"></a><strong>lazy alloc 核心思想</strong></h2><ul>
<li><p>lazy allocation的<strong>核心思想</strong>很简单，如下。可<strong>分为两个阶段</strong>。</p>
<ul>
<li><strong>阶段1. 设定va为合法</strong><ul>
<li><strong>通过sbrk系统调用</strong><ul>
<li>设定user的这段va是合法的。通过将p-&gt;trapframe-&gt;sz增加来达成这一目的。仅仅做了这一件事。根本就没在user pgtbl上登记有关va的任何信息，也没分配physical page。</li>
</ul>
</li>
</ul>
</li>
<li><strong>阶段2. 使用va，触发pagefault 进行响应(handle)</strong><ul>
<li>关于如何对page fault响应，大致来说就是<ul>
<li>为va 分配一块physical page</li>
<li>将该page与触发page fault的va 在 user pgtbl中建立映射。</li>
<li>重新执行造成 page fault的指令(如load/store)</li>
</ul>
</li>
<li><strong>具体来讲，其阶段二也可分为两部分</strong><ul>
<li>user使用无效 userva</li>
<li>kernel使用无效 userva</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>kernel识别page fault 并进行响应</strong> (（pagefault handler）lazy allocation的所需 )<strong>的有效信息</strong></p>
<ul>
<li><strong>1. 触发page fault的va</strong>               <ul>
<li>($STVAL)</li>
</ul>
</li>
<li><strong>2. 进入trap(引起page fault的)原因类型</strong>     <ul>
<li>($SCAUSE)</li>
<li>比如从user进入usertrap可能有多种原因，而属于pagefault造成的进入kernel的只有三种：instruction page fault(12) , load page fault (13), store page fault(15)</li>
</ul>
</li>
<li><strong>3. 触发page fault的指令</strong>   <ul>
<li>($SEPC) ，保存在trapframe-&gt;epc中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><ul>
<li><strong>更改code如下：</strong></li>
<li>usertrap中增加handle page fault的分支（通过检测r_scause）<ul>
<li><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-21-13-33.png"></li>
</ul>
</li>
<li>growproc:<ul>
<li>sys_sbrk -&gt; growproc。原先是立刻分配sz大小的物理内存，现在改成只增长heap顶部的上界，也即将va设定为”合法”。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  只有sbrk会调用到这里</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">growproc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint sz;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    sz = p-&gt;sz;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// if((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == 0) &#123;</span></span><br><span class="line">        <span class="comment">//   return -1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//  只设定合法但不kalloc 也不建立映射</span></span><br><span class="line">        sz += n;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;sz = sz;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>isvalidva_proc<ul>
<li>检验va是否是应当进行lazy allocation的va（即是否是合法的va）（va应当是heap段的va） <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">isvalidva_proc</span><span class="params">(uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  Handle faults on the invalid page below the user stack.</span></span><br><span class="line"><span class="comment">//  Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> <span class="built_in">myproc</span>();</span><br><span class="line"><span class="keyword">if</span>(va &lt;= p-&gt;trapframe-&gt;sp || va &gt;= p-&gt;sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  p-&gt;trapframe-&gt;sp trap时保留的用户栈顶</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>uvmlazyalloc<ul>
<li>对于合法但未分配物理内存和建立映射的虚拟地址va，进行lazyalloc  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  对于合法但未分配物理内存和建立映射的虚拟地址va，进行lazyalloc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmlazyalloc</span><span class="params">(uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    va = PGROUNDDOWN(va);</span><br><span class="line">    <span class="comment">//  为va申请对应的physical mem</span></span><br><span class="line">    uint64 pa = (uint64) kalloc();</span><br><span class="line">    <span class="comment">//  oom</span></span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)&#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  申请成功 建立映射</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)pa,<span class="number">0</span>,PGSIZE);</span><br><span class="line">        <span class="comment">//  映射</span></span><br><span class="line">        <span class="keyword">if</span>(mappages(p-&gt;pagetable,va,PGSIZE,pa,PTE_W|PTE_R|PTE_U)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//  映射失败 释放pm</span></span><br><span class="line">            kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>uvmunmap<ul>
<li>防止释放合法但还没分配物理内存建立映射的va</li>
<li><blockquote>
<p><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-21-27-56.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h1><ul>
<li>uvmcopy<ul>
<li>fork时会调用uvmcopy，将parent process的heap段虚拟内存对应的pte拷贝给child的pte，并且还有分配物理内存去映射。显然引入lazy之后就不能这么干了。因为很可能parent的这些虚拟内存还只不过是还未建立映射的地址。自然不应该拷贝。</li>
<li><blockquote>
<p><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-21-32-17.png"><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-21-32-43.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="bug-及-解决"><a href="#bug-及-解决" class="headerlink" title="bug 及 解决"></a>bug 及 解决</h2><ul>
<li><p>以上这些函数都没花多长时间就改完了。。下面这个改了好长时间：</p>
</li>
<li><p>一直卡在sbrkarg test。</p>
</li>
<li><p>由lazy alloc 核心思想中所述，lazy alloc可分为两个阶段：1. 设定va为合法 和 2. 触发page fault并进行响应。</p>
</li>
<li><p>可具体来说，<strong>第二阶段触发page fault并进行响应可分为两种情况</strong> — 根据在user态还是kernel态触发page fault 来分类。具体如下所示</p>
</li>
</ul>
<h3 id="page-fault-的触发！"><a href="#page-fault-的触发！" class="headerlink" title="page fault 的触发！"></a><strong>page fault 的触发！</strong></h3><ul>
<li><p>思考问题：user态触发page fault和kernel触发有什么区别？触发后会跳转到哪里？user会进入usertrap，那么kernel会进入kernel trap吗？找到造成缺页的指令是哪条？是哪里检测出了page fault ? 当时这里没搞清晰，改bug改了一上午。见下。</p>
<ul>
<li>一开始误认为kernel 使用user传入的无效va，也会进入kernel trap（实际上不会）。结果在kernel trap里写了个page fault分支，没有反应。一直卡在sbrkarg。当时debug的时候发现会进入filewrite。改了蛮久才找出来。</li>
</ul>
</li>
<li><p>user态和kernel态使用无效的user va所发生的反应不同，一个触发 fault，一个没有。<strong>关键是在二者使用user va的方式不同，一个是MMU硬件查找，一个是walk模拟</strong>。</p>
</li>
</ul>
<h4 id="user-态触发-page-fault"><a href="#user-态触发-page-fault" class="headerlink" title="user 态触发 page fault"></a><strong>user 态触发 page fault</strong></h4><ul>
<li><strong>user态使用了一个user 无效的va , 会导致进入usertrap</strong> 。原因见下<ul>
<li><strong>user态发生的page fault</strong> （我认为）应当<strong>是由硬件MMU检测到的</strong><ul>
<li>为什么？因为此时cpu的$satp 是 user的pgtbl。此时是MMU来查找user pgtbl并返回pa的</li>
</ul>
</li>
<li>比如user先p = sbrk(PGSIZE); 然后赋值 *p = 100 ; </li>
<li>p是一个还没建立映射的虚拟地址</li>
<li>MMU根据va查看user的pgtbl后，发现pte是个空或者无效则会爆出pagefault，设置scause。而后进入trampoline，进入usertrap。</li>
<li>所以我们在usertrap处写一个page fault分支，是用于处理user态造成的page fault的。对于kernel态的，无能为力。</li>
</ul>
</li>
</ul>
<h4 id="kernel-态触发page-fault（实际上并没有page-fault）"><a href="#kernel-态触发page-fault（实际上并没有page-fault）" class="headerlink" title="kernel 态触发page fault（实际上并没有page fault）"></a><strong>kernel 态触发page fault（实际上并没有page fault）</strong></h4><ul>
<li><strong>kernel态使用了一个user 无效的va ，并不会进入kerneltrap</strong>。原因见下。</li>
<li>kernel使用user态无效的虚拟地址 发生在如下情况(简易取一种情况)<ul>
<li>user将user va 通过syscall传给kernel和kernel对user va的使用流程：举例write</li>
<li>user va = sbrk(xxxx);</li>
<li>write –user va–&gt; trampoline -&gt; usertrap —&gt; syscall -&gt; sys_write —-取出user va—&gt;filewrite —&gt; either_copyin –&gt; copyin –user va—&gt; walkaddr <ul>
<li>user va有效 —&gt; 使用user va，读取</li>
<li><strong>user va无效（未建立映射的、等待lazyalloc的地址）–&gt; 不读取，放弃copyin,return -1</strong>。 而后一层层return -1给sys_write。回到sycall，将-1作为系统调用返回值返回给user。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>由此观之，也即，当kernel使用未建立映射的user va时，即userpgtbl中user va对应的pte无效或不存在时，放弃使用（读取/写入）改user va，并return -1(fail)</strong></li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li><p><strong>当kenerl拿到user传入给kernel的user va时，就使得va进行lazyalloc的第二步：分配物理内存并建立映射。</strong></p>
</li>
<li><p><strong>argaddr</strong></p>
<ul>
<li>检验user va是否是heap上的user va，是没建立映射（防止重复建立映射）</li>
<li>uvmlazyalloc。为user va进行lazyalloc<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Retrieve an argument as a pointer.</span></span><br><span class="line"><span class="comment">// Doesn&#x27;t check for legality, since</span></span><br><span class="line"><span class="comment">// copyin/copyout will do that.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">argaddr</span><span class="params">(<span class="keyword">int</span> n, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  *ip为user传入的user空间的虚拟addr</span></span><br><span class="line">*ip = argraw(n);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  防止不是heap上懒分配的page</span></span><br><span class="line"><span class="keyword">if</span>(!isvalidva_proc(*ip)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//  防止重复分配physical memory、重复mappage建立映射</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte = walk(myproc()-&gt;pagetable,*ip,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//  当当前要使用的user的虚拟地址是一个未建立映射的虚拟地址（等待懒分配的），那么就lazyalloc它</span></span><br><span class="line"><span class="keyword">if</span>((pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shc syscall leads to kernel page fault!\n&quot;</span>);</span><br><span class="line">    uvmlazyalloc(*ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>成功pass  sbrkarg</p>
<ul>
<li><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-30-36.png"></li>
</ul>
</li>
<li><p>之前没改这里之前，一直卡在sbrkarg</p>
<ul>
<li>由上述解释可知，在没改之前，write会返回-1，故sbrktest会出现write sbrk failed。符合预期。</li>
<li><blockquote>
<p><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-37-35.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-33-58.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>改完！结束！</p>
</li>
</ul>
<hr>
<h3 id="补充：write使用va流程图-不看也tm-ok"><a href="#补充：write使用va流程图-不看也tm-ok" class="headerlink" title="补充：write使用va流程图 不看也tm ok"></a>补充：write使用va流程图 不看也tm ok</h3><ul>
<li><blockquote>
<p><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-20-01-55.png"><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-16-53.png"><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-18-28.png"><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-19-46.png"></p>
</blockquote>
</li>
<li><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-22-05.png"></li>
</ul>
<blockquote>
<p>唠叨文字版：user sbrk了一个地址 然后user使用系统调用write 并传入这个地址，比如write(fd, buf, sizeof(buf))（可以看sbrkarg，就是test这个的）。buf即为一个user态没建立映射的虚拟地址，kernel会使用（读取）这个addr。<br>从trampoline 进入 usertrap 进入syscall分支 进入sys_write ，在这里通过argaddr取出user传入的地址，之后调用filewrite使用了取出的user的va 。filewrite里又调用writei，wirtei调用either_copyin,either_copyin调用copyin（user的va作为srcva传入该函数）。copyin中通过walkaddr软件模拟来使用user的va，如果这个va有效，那么得到pa，然后使用pa进行一个写入。如果va无效，那么walkaddr查找pgtbl 就会没找到有效pte，就会返回0。<br>copyin发现pa为0，则return -1代表写入失败。顺着刚才描述的栈帧，一层层向上return，最后return -1给filewrite，然后return-1给write，回到sycall。存到trapframe，然后作为系统调用返回值返回给user层。</p>
</blockquote>
<hr>
<ul>
<li>下面这没啥p用，就是印证下理论</li>
<li>可以看到如果不处理，就会死循环<ul>
<li>不断缺页 不断进入usertrap.c这里的 pagefault分支</li>
<li>因为这个pagefault分支并没有对缺页做任何处理 只是直接返回到造成缺页的指令 不断执行这条指令 不断造成缺页。</li>
<li><img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-44-59.png"></li>
</ul>
</li>
</ul>
<h1 id="理论比较"><a href="#理论比较" class="headerlink" title="理论比较"></a>理论比较</h1><ul>
<li>和csapp上的理论上的page fault比较一下（linux也是csapp这么实现的）（图中也并没有画出kenerl如何使用无效va，只有user的pagefault 不过也正常，因为那造成的也不是page fault）<br>  <img src="/2022/11/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab5-lazy-allocation/2022-11-11-22-56-11.png"></li>
<li>相同之处 在于 当user引用为建立映射的va时，都会在dram中分配一个physical page ，去给userpgtbl建立va到pa的映射。</li>
<li>不同之处在于并没有实现和磁盘的交换操作，只是将dram中的physical page映射给了user va。</li>
<li>缺憾在于这样在dram满了的时候就无法再给user va 分配映射的物理内存了</li>
</ul>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab7-thread</title>
    <url>/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/</url>
    <content><![CDATA[<ul>
<li>part1 : 协程<ul>
<li>thread_yield -&gt; thread_schduler<br><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-27-08-55-15.png"></li>
</ul>
</li>
<li>cond_broadcast 唤醒后 没拿到lock的thread还需要再次被cond_broadcast吗 ?<ul>
<li>不需要</li>
<li>因为cond将一系列等待该cond的thread（BCD thread）串在了一起，当Athread broadcast广播唤醒该cond时，这一系列thread（BCDthread）都不再受阻于该cond约束。</li>
<li>之后谁拿到锁谁往下走就行了，与cond无关</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><ul>
<li>这个part实现的就是所谓的<strong>协程</strong><ul>
<li>这里的uthread完全都是在用户态的。</li>
<li>也即是一个进程中 多个user thread 对应 一个 kernel thread<ul>
<li>正常的线程，如pthread，都是一个user thread对应一个kernel thread。kernel scheduler thread 可以对pthread之间执行切换，而无需user thread自己控制切换。</li>
</ul>
</li>
<li>多个user thread 运行在 一个cpu core上</li>
<li>没有定时器中断来陷入kernel强制执行uthread之间的调度。<ul>
<li>因为kernel scheduler thread 只能看见 kernel thread。只能对kernel thread进行调度。</li>
<li>而这里是一个process里面，多个user thread 对应 一个 kernel thread。因此无法对user thread 进行调度。</li>
<li>需要user thread本身在合适的时候yield让出cpu，并切换到其他user thread上。</li>
</ul>
</li>
<li><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-27-08-55-15.png"></li>
</ul>
</li>
</ul>
<ul>
<li><p>写在前面：咱一开始想的不对，一开始以为这里要实现的uthread的切换机制和每个cpu核上的kthread的切换机制差不多，也是有一个scheduler thread。以为这里的main thread 实际上就是 scheduler thread。scheduler一直运行在我们main thread的stack上。。uthread切换到shcheduler thread 再切换到另一个uthread。不过看着看着就发现不是。因为每个uthread都直接调用了thread_scheduler。并且这scheduler也不是个死循环啊。就是一个普通函数。找到runnale uthread就跳出，并swtch到那个uthread。</p>
</li>
<li><p>每个uthread都可以自己发出yield出cpu，切换到其他runnable uthread的动作。也即。每个uthread都可以调用thread_scheduler函数。</p>
</li>
<li><p>大致逻辑如图，可以看到并没有像kernel thread切换时需要有一个shceduler thread作为中转。而是一个uthread直接scheduler并swtch到别的uthread。<br><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-23-19-50-00.png"></p>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>thread_switch needs to save/restore only the callee-save registers . Why?<ul>
<li>因为我们是通过thread_swtich以函数调用的形式切换线程，抛去线程相关的寄存器ra、sp需要被保存，剩下的需要保存的，就是可能被 [被调用过程改变的寄存器]，也即 被调用者保存的寄存器.</li>
<li>因为我们将线程切换包装成了函数调用的形式，正常C code中 A调用B（A函数B函数都是用C代码写的），那么编译器编译之后，会生成如下汇编代码：A调用B之前会自动的保存调用者保存的寄存器，进入B之后，B会自动的保存被调用者保存的寄存器。那么在本节中，B就是swtch函数，可是由于该函数是汇编编写，无需如Ccode一样编译成汇编，也就不会生成：进入B之后，自动的保存被调用者保存的寄存器 的 汇编代码。故这个swtch函数中，保存被调用者保存的寄存器的函数是由我们用汇编编写的。故swtch函数中需要保存 reg sa , sp 以及 被调用者保存寄存器</li>
<li>而相比之下 trampoline中 就不只是保存 被调用者保存的寄存器；因为user thread 切换成 kernel thread 并不是 C code中调用的函数调用，也即这个上下文切换并不是以函数调用的形式，程序在运行时可能随时会通过trampoline（如定时器中断）进入内核（如在正在执行密集计算指令的时候），并不是C代码通过函数调用进行的切换，属于是在某函数运行的中间突然触发切换，本身该函数的C代码编译后也并没有对这种情况进行处理，故我们在trampoline需要保存大量寄存器，既有caller 也有 callee(被调用者保存)。</li>
</ul>
</li>
</ul>
<blockquote>
<p>引申：内核调度器无论是通过时钟中断进入（usertrap），还是线程自己主动放弃 CPU（sleep、exit），最终都会调用到 yield 进一步调用 <strong>swtch</strong>。 <strong>由于上下文切换永远都发生在函数调用的边界（swtch 调用的边界），恢复执行相当于是 swtch 的返回过程，会从堆栈中恢复 caller-saved 的寄存器， 所以用于保存上下文的 context 结构体只需保存 callee-saved 寄存器，以及 返回地址 ra、栈指针 sp 即可。恢复后执行到哪里是通过 ra 寄存器来决定的（swtch 末尾的 ret 转跳到 ra）</strong><br>而 <strong>trapframe 则不同</strong>，<strong>一个中断可能在任何地方发生，不仅仅是函数调用边界，也有可能在函数执行中途，所以恢复的时候需要靠 pc 寄存器来定位。 并且由于切换位置不一定是函数调用边界，所以几乎所有的寄存器都要保存</strong>（<strong>无论 caller-saved 还是 callee-saved），才能保证正确的恢复执行。 这也是内核代码中 struct trapframe 中保存的寄存器比 struct context 多得多的原因</strong>。<br>另外一个，无论是程序主动 sleep，还是时钟中断，都是通过 trampoline 跳转到内核态 usertrap（保存 trapframe），然后再到达 swtch 保存上下文的。 恢复上下文都是恢复到 swtch 返回前（依然是内核态），然后返回跳转回 usertrap，再继续运行直到 usertrapret 跳转到 trampoline 读取 trapframe，并返回用户态。 也就是上下文恢复并不是直接恢复到用户态，而是恢复到内核态 swtch 刚执行完的状态。负责恢复用户态执行流的其实是 trampoline 以及 trapframe。<br><a href="https://blog.miigon.net/">来自</a></p>
</blockquote>
<ul>
<li><p>uthread程序执行流程：</p>
<ul>
<li>main thread : thread_init -&gt; thread_createabc -&gt; thread_scheduler -&gt; thread a/b/c</li>
<li>thread a/b/c: running func -&gt; yield -&gt; running func</li>
<li>end: scheduler -&gt; no runnable process -&gt; exit(-1)</li>
</ul>
</li>
<li><p>This sets a breakpoint at line 60 of uthread.c. The breakpoint may (or may not) be triggered before you even run uthread. How could that happen?</p>
<ul>
<li><blockquote>
<p>因为gdb的实现依赖于监视pc寄存器，我们在b some_func的时候实际上是记录的某个地址。如果uthread内的指令地址与内核的指令地址有重复，那么当内核运行到这个地址的时候就会触发本应该在uthread内的断点。此外，很容易验证不同的用户态程序也会干扰。比如在uthread内部的0x3b之类的地址打下个断点，再运行ls或者其他用户态程序，如果在0x3b地址的指令是合法的，那么也会触发本应该在uthread程序内部的断点。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>我所做的工作：</p>
</li>
<li><p><strong>thread_create</strong>：找到free的thread,为其分配task:func ,并初始化好线程任务地址(ra)以及ustack(sp),使其变成runnable。</p>
<ul>
<li>t-&gt;ucontext.ra = (uint64)func;:为了scheduler第一次调度到该uthread时知道跳转到哪里。— 跳转到thread 的 task func开始执行。</li>
<li>这里类似于allocproc。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_create</span><span class="params">(<span class="keyword">void</span> (*func)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;state = RUNNABLE;</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;t-&gt;ucontext,<span class="number">0</span>,<span class="keyword">sizeof</span>(t-&gt;ucontext)); </span><br><span class="line">    <span class="comment">//  初始化scheduler func第一次调度到该uthread时的需要跳转到的地址</span></span><br><span class="line">    <span class="comment">//  也即，记录了该uthread的任务函数的地址</span></span><br><span class="line">    t-&gt;ucontext.ra = (uint64)func;</span><br><span class="line">    <span class="comment">//  设置ustack</span></span><br><span class="line">    t-&gt;ucontext.sp = (uint64) t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>thread_schedule</strong>：找到runnable的uthread，通过swtch进行uthread切换。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>, *<span class="title">next_thread</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find another runnable thread. */</span></span><br><span class="line">next_thread = <span class="number">0</span>;</span><br><span class="line">t = current_thread + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">    t = all_thread;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">    next_thread = t;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  整个process 最后会从这里退出</span></span><br><span class="line"><span class="keyword">if</span> (next_thread == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread_schedule: no runnable threads\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    <span class="comment">//  要切换到的uthread</span></span><br><span class="line">    current_thread = next_thread;            </span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;ucontext,(uint64)&amp;current_thread-&gt;ucontext);</span><br><span class="line">    <span class="comment">//  之后从别的uthread切换回来时，回回到本uthread的这里，继续向下执行，离开shceduled函数</span></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>thread_switch</strong> : 和kernel的swtch一样。</p>
<ul>
<li>记录当前执行到的指令地址，也即本uthread的thread_swtch的下一条，以及本uthread的stack，以及callee save regs，以便之后切换回本uthread；</li>
<li>将runnable process的context替换进cpu.<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> 	.text</span><br><span class="line"><span class="meta">#   void swtch(struct context *old, struct context *new);</span></span><br><span class="line">#  将当前cpu上的reg保存在old 上，并将<span class="keyword">new</span> 加载到cpu的reg上</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   * save the old thread&#x27;s registers,</span></span><br><span class="line"><span class="comment">   * restore the new thread&#x27;s registers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">.globl thread_switch</span><br><span class="line">   thread_switch:</span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line"><span class="meta"># store from old</span></span><br><span class="line">sd ra, <span class="number">0</span>(a0)    <span class="meta"># return addr </span></span><br><span class="line">sd sp, <span class="number">8</span>(a0)    <span class="meta"># kernel thread stack pointer</span></span><br><span class="line">sd s0, <span class="number">16</span>(a0)   # 被调用者保存的寄存器</span><br><span class="line">sd s1, <span class="number">24</span>(a0)</span><br><span class="line">sd s2, <span class="number">32</span>(a0)</span><br><span class="line">sd s3, <span class="number">40</span>(a0)</span><br><span class="line">sd s4, <span class="number">48</span>(a0)</span><br><span class="line">sd s5, <span class="number">56</span>(a0)</span><br><span class="line">sd s6, <span class="number">64</span>(a0)</span><br><span class="line">sd s7, <span class="number">72</span>(a0)</span><br><span class="line">sd s8, <span class="number">80</span>(a0)</span><br><span class="line">sd s9, <span class="number">88</span>(a0)</span><br><span class="line">sd s10, <span class="number">96</span>(a0)</span><br><span class="line">sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># load from new</span></span><br><span class="line">ld ra, <span class="number">0</span>(a1)    <span class="meta"># return addr (scheduler 的swtch的下一行)</span></span><br><span class="line">ld sp, <span class="number">8</span>(a1)    <span class="meta"># scheduler thread stack pointer</span></span><br><span class="line">ld s0, <span class="number">16</span>(a1)   # 被调用者保存的寄存器</span><br><span class="line">ld s1, <span class="number">24</span>(a1)</span><br><span class="line">ld s2, <span class="number">32</span>(a1)</span><br><span class="line">ld s3, <span class="number">40</span>(a1)</span><br><span class="line">ld s4, <span class="number">48</span>(a1)</span><br><span class="line">ld s5, <span class="number">56</span>(a1)</span><br><span class="line">ld s6, <span class="number">64</span>(a1)</span><br><span class="line">ld s7, <span class="number">72</span>(a1)</span><br><span class="line">ld s8, <span class="number">80</span>(a1)</span><br><span class="line">ld s9, <span class="number">88</span>(a1)</span><br><span class="line">ld s10, <span class="number">96</span>(a1)</span><br><span class="line">ld s11, <span class="number">104</span>(a1)</span><br><span class="line">ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一遍过，一点儿bug没有。</p>
</li>
</ul>
<h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><p>这难度应该标成easy<br>把ph.c读一边就好了。</p>
<ul>
<li><p>This assignment uses the UNIX pthread threading library. You can find information about it from the manual page, with man pthreads</p>
</li>
<li><p>lock API</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line">pthread_mutex_init(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line">pthread_mutex_lock(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);     <span class="comment">// release lock</span></span><br></pre></td></tr></table></figure></li>
<li><p>ph.c : 我们尝试通过多线程对hash table k-v的插入操作进行加速，且不发生data race。</p>
</li>
<li><p>主要的两个thread函数</p>
<ul>
<li>put_thread<ul>
<li>如何进行加速：每个thread平摊 NKEYS 100000 / threads 个 put key。(应当可以整除，不整除的话 会漏掉余下的key没put)</li>
<li>对于multi-thread多线程，在这里会发生data race。因为会改变hash table。</li>
</ul>
</li>
<li>get_thread<ul>
<li>get_thread func 用于 验证在multi-thread在put时 是否发生了 data race</li>
<li>multi-thread在运行get_thread时不会发生data race，因为get_thread只读，不会改变hashtable。</li>
</ul>
</li>
</ul>
</li>
<li><p>策略：1个hash bucket 1个lock</p>
<ul>
<li>由于hash table采用的是挂链法。故我们为每个hash bucket分配1个lock即可。当改变(写)这个bucket对应的list的时候，用lock进行保护。over。</li>
<li><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-23-23-30-46.png"></li>
</ul>
</li>
</ul>
<ul>
<li>结果<ul>
<li>put速度随着线程数增大和提高。基本上是2倍了。</li>
<li>read速度没变化，因为每个thread做的read都是一样的,read也不需要加速，也不需要上锁保护。</li>
<li><blockquote>
<p><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-23-23-07-26.png"><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-23-23-08-41.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>注：<ul>
<li>尝试着再减小锁的粒度。感觉貌似效果不大，甚至是负优化？<ul>
<li>query a之后，获得lock之后，还需要再query校正。因为其他uthread可能插入了 a。故查询结果可能不对，故需要重新query。</li>
<li><blockquote>
<p><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-24-07-34-39.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-24-07-34-55.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>感觉是因为bucket的链表太长了。毕竟只有5个bucket。而keys总共有10000个。可以看到single thread的时候 就比之前single thread慢不少。<blockquote>
<p><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-23-23-02-31.png"><br><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-23-23-05-56.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>有时间还是看看linux的futex锁。。。</p>
</blockquote>
<h2 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h2><ul>
<li>API<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br></pre></td></tr></table></figure></li>
<li>pthread_cond_wait(&amp;cond,&amp;lock);<ul>
<li>(1) 释放绑定在当前线程上的lock锁</li>
<li>(2) 阻塞等待cond变量符合条件。（即等待另一个线程的pthread_cond_signal(&amp;cond))</li>
<li>(3) 前两个步骤结束后，给当前线程上lock锁，结束阻塞。如果没有得到锁，会阻塞等待。</li>
<li>拿到锁之后，然后才从block变成runnable状态，受cpu调度，继续执行</li>
<li>为什么pthread_wait()要对互斥锁先解锁再上锁？因为阻塞期间拿不到资源，所以要解锁。（上个锁也没用，锁啥阿）而被唤醒后（可以）要使用共享数据，所以要解锁。</li>
</ul>
</li>
</ul>
<h3 id="未解决问题"><a href="#未解决问题" class="headerlink" title="未解决问题"></a>未解决问题</h3><ul>
<li><strong>疑问</strong><ul>
<li>关于pthread_cond_broadcast的。假设一个A线程和BCD线程。BCD线程都等待在同一个mutex的cond上，易知当A线程调用pthread_cond_broadcast时，BCD中只有一个B线程拿到锁并成功的被唤醒。那么我的疑问在于，剩余的没拿到锁的CD线程呢？</li>
<li>对于这些没拿到锁的CD线程，是否需要有再一次的pthread_cond_broadcast来唤醒？</li>
<li><ol>
<li>也即，B线程在结束时需要再次调用pthread_cond_broadcast以唤醒剩余的CD线程？</li>
</ol>
</li>
<li><ol start="2">
<li>还是说，B线程不必再次调用pthread_cond_broadcast，只需要释放mutex即可，最开始A调用pthread_cond_broadcast会负责继续唤醒刚才没获得锁的剩余的CD线程。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="已解决"><a href="#已解决" class="headerlink" title="已解决"></a>已解决</h3><ul>
<li><strong>12说法都不对</strong></li>
<li><strong>结论</strong>：<ul>
<li><strong>B线程不必再次调用pthread_cond_broadcast，只需要释放mutex即可，剩余的CD线程拿到锁之后就继续向下走。</strong></li>
</ul>
</li>
<li>首先明确wait(cond)流程：1. 释放锁、2. 等待cond唤醒、3. 竞争锁。</li>
<li><strong>因为cond将一系列等待该cond的thread（BCD thread）串在了一起，当Athread broadcast广播唤醒该cond时，这一系列thread（BCDthread）都不再受阻于该cond约束</strong>。</li>
<li>cond唤醒后，BCDthread处于第3阶段。谁竞争到lock谁就继续向下走。比如说Bthread竞争到了lock，那么B会继续向下走，CD线程由于没有拿到lock而阻塞等待，当B释放lock之后，剩下的thread(CD thread)谁竞争到锁谁就继续向下走，与cond无关，不需要再度唤醒cond。<ul>
<li>虽然CD thread还阻塞在wait语句上，但已经不是因为cond了，与cond无关，而是因为卡在了第3步，没有竞争到锁，因而陷入阻塞。</li>
</ul>
</li>
<li>cond：需要别人唤醒。lock：自驱。</li>
</ul>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>其实就是hint2，第一次读的时候还没太明白说得是啥</p>
<ul>
<li>You have to handle the case in which one thread races around the loop before the others have exited the barrier. In particular, you are re-using the bstate.nthread variable from one round to the next. Make sure that a thread that leaves the barrier and races around the loop doesn’t increase bstate.nthread while a previous round is still using it.</li>
</ul>
</li>
<li><p><strong>逻辑错误</strong>：对于 本轮的 thread还没有全部离开barrier，下一轮的thread就进入barrier，使得将下一轮的thread的数量 计数在 本轮的 nthread中，造成错误。<br><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-26-22-02-56.png"><br><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-26-22-08-01.png"><br><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-26-22-39-57.png"></p>
</li>
<li><p>解决措施：添加一个finished_cond条件变量，代表上一轮round已经结束，也即上一轮的thread都已经离开barrier，可以开始本轮的thread计数，也即可以让本轮的thread进入barrier了。</p>
</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>我所做的工作</p>
</li>
<li><p>添加个finished_cond 以及 finished 配合 条件变量使用</p>
<ul>
<li>finished = 1时，代表上一轮已经结束，当前thread可以进入barrier</li>
<li>finished = 0时，代表上一轮没结束，正在运行，当前thread不可进入barrier。故 pthread_cond_wait when finished = 0。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">barrier</span> &#123;</span></span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> barrier_mutex;</span><br><span class="line">  <span class="keyword">pthread_cond_t</span> barrier_cond;</span><br><span class="line">  <span class="keyword">int</span> nthread;      <span class="comment">// Number of threads that have reached this round of the barrier</span></span><br><span class="line">  <span class="keyword">int</span> round;     <span class="comment">// Barrier round</span></span><br><span class="line">  <span class="comment">//  上一轮的thread 是否都已经从barrier中离开</span></span><br><span class="line">  <span class="keyword">pthread_cond_t</span> finished_cond;</span><br><span class="line">  <span class="keyword">int</span> finished;</span><br><span class="line">&#125; bstate;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>finished_cond：等待上一轮的所有thread全部离开barrier</p>
</li>
<li><p>barrier_cond： 等待本轮的所有thread全部到达barrier<br><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-26-22-20-02.png"></p>
</li>
<li><p>code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  <span class="comment">//  当上一轮结束了 再来启动下一轮的计数。  </span></span><br><span class="line">  <span class="keyword">while</span>(!(bstate.finished==<span class="number">1</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.finished_cond,&amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  确保上一轮thread都离开barrier之后，本轮thread真正进入barrier，并进行计数。</span></span><br><span class="line">  ++bstate.nthread;</span><br><span class="line">  <span class="comment">//  是否会存在，本轮的thread还没全部离开，下一轮的thread就来了的情况？</span></span><br><span class="line">    <span class="comment">//  我认为显然是会出现的。</span></span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread != nthread)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//  其他线程等待最后一个线程到达</span></span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex);</span><br><span class="line">    --bstate.nthread;</span><br><span class="line">    <span class="comment">//  告诉下一轮来的thread 本轮结束，不必再等，可以进入barrier。</span></span><br><span class="line">    <span class="keyword">if</span>(bstate.nthread == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bstate.finished = <span class="number">1</span>;            </span><br><span class="line">      pthread_cond_broadcast(&amp;bstate.finished_cond);      </span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">//  最后一个到达的线程</span></span><br><span class="line">    <span class="comment">//  告诉下一轮来的thread 本轮未结束，等着，不可进入barrier。</span></span><br><span class="line">    bstate.finished = <span class="number">0</span>;            </span><br><span class="line">    --bstate.nthread;</span><br><span class="line">    ++bstate.round;</span><br><span class="line">    <span class="comment">//  告诉下一轮来的thread 本轮结束，不必再等，可以进入barrier。</span></span><br><span class="line">    <span class="keyword">if</span>(bstate.nthread == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bstate.finished = <span class="number">1</span>;            </span><br><span class="line">      pthread_cond_broadcast(&amp;bstate.finished_cond);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  唤醒本轮的在barrier中等待的thread，告诉他们可以离开barrier。</span></span><br><span class="line">    pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>pass</p>
<blockquote>
<p><img src="/2022/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab7-thread/2022-11-26-22-37-53.png"></p>
</blockquote>
</li>
</ul>
<p>做完lab之后看一下initcode。</p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab8-lock</title>
    <url>/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/</url>
    <content><![CDATA[<ul>
<li><p>本节的重点</p>
<ul>
<li>一在于锁机制的优化</li>
<li>二在于物理内存如何分配</li>
<li>三在于buffer cache如何分配。</li>
<li>关于锁机制的优化，我基本上是参考<a href="https://blog.miigon.net/posts/s081-lab8-locks/">博客</a></li>
<li>至于buffer cache如何分配，在操作系统-xv6-文件系统 buffercache中也已经讲过。</li>
<li>下面重点介绍 物理内存是如何分配的，也即user是如何通过malloc申请到物理内存的。<br><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-09-51-43.png"></li>
</ul>
</li>
<li><p>物理内存分配流程</p>
<ul>
<li>kernel是如何组织free physical page的。<ul>
<li>xv6 : freelist</li>
</ul>
</li>
<li>kernel为user提供的sycall接口<ul>
<li>sbrk-&gt;sys_sbrk()</li>
</ul>
</li>
<li>user层是如何封装sbrk的。<ul>
<li>malloc and free (维护了user态的cache list)<br><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-14-01-22.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="xv6-物理内存分配流程"><a href="#xv6-物理内存分配流程" class="headerlink" title="xv6 物理内存分配流程"></a>xv6 物理内存分配流程</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>先看一下xv6中，physical memory是如何被组织起来的.</p>
<ul>
<li>kernel以freelist的形式将free physical memory 组织起来<ul>
<li><strong>kernel如何组织free physical page是一个值得优化的策略。本lab实现的就是优化该策略</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure>
<img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-10-18-22.png"></li>
</ul>
</li>
</ul>
<ul>
<li>初始化<ul>
<li>entry.S -&gt; start -&gt; main -&gt; kinit -&gt; freerange -&gt; kfree<blockquote>
<p><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-10-14-26.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><p>kalloc: 从freelist头部取下一个page 返回给调用者</p>
<blockquote>
<p><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-10-24-53.png"></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">        kmem.freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>kfree: 将一个无用的page 头插法插入freelist</p>
<blockquote>
<p><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-10-24-36.png"></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><ul>
<li><p><strong>malloc 和 free 共同维护了user态的cache list</strong></p>
</li>
<li><p>如果user直接调用syscall sbrk的话，则并没有通过cache list</p>
</li>
<li><p>物理内存分配相关API层次如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    user </span><br><span class="line"><span class="comment">///////////////////////         user态</span></span><br><span class="line">    <span class="built_in">malloc</span> / <span class="built_in">free</span></span><br><span class="line">**user cache <span class="built_in">list</span>**</span><br><span class="line"><span class="comment">///////////////////////</span></span><br><span class="line">    syscall : sbrk</span><br><span class="line"><span class="comment">///////////////////////    trap into kernel态</span></span><br><span class="line">    sys_sbrk</span><br><span class="line">    growproc</span><br><span class="line">    uvmalloc    deamalloc</span><br><span class="line">    kalloc      kfree       </span><br><span class="line">    mappage     unmap</span><br><span class="line">**<span class="built_in">free</span> physical pages in freelist** </span><br><span class="line"><span class="comment">///////////////////////</span></span><br><span class="line">    DRAM</span><br></pre></td></tr></table></figure></li>
<li><p><strong>整体图</strong><br>  <img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-14-01-22.png"></p>
</li>
</ul>
<h3 id="malloc-sbrk-n-gt-0"><a href="#malloc-sbrk-n-gt-0" class="headerlink" title="malloc (sbrk(n&gt;0))"></a>malloc (sbrk(n&gt;0))</h3><ul>
<li><p>user向kernel（也可能会是从user态的cache list中取出page）申请内存(malloc –&gt; sbrk (n&gt;0))</p>
<ul>
<li><strong>核心思路</strong>：<ul>
<li><strong>0.  先检查user态中的cache list中是否有足够的cache pages，如果有从cache list中取出内存则返回；如果没有则进入1：通过syscall sbrk向kernel请求free physical pages</strong></li>
<li><strong>1.  sbrk : kernel返回一个free physical page（即空闲物理页）给user。</strong> </li>
<li><strong>2.  在user pgtbl建立user va 到pa的映射</strong>。<br><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-13-28-25.png"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>kernel如何分配free physical page给user</strong>？这就涉及到可以<strong>优化的策略</strong>了。本lab的内容就是优化该策略。</p>
<ul>
<li><strong>xv6原先策略</strong>：所有free physical page都位于一个freelist上，所有cpu核使用同一个freelist。每个cpu核上的kernel可能会同时向freelist发出kalloc/kfree请求。因此需要采用一把大锁保护整个freelist。降低效率。<blockquote>
<p><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-11-19-58.png"></p>
</blockquote>
</li>
<li><strong>lab优化后策略</strong>：每个cpu核心拥有一个独立的freelist，physical page散布在这些freelist上，每个kernel要分配物理内存时，只会操作属于自己的freelist，这样可以减少锁竞争情况的发生。<blockquote>
<p><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-11-20-13.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>xv6 API流程</strong>：user -&gt; malloc -&gt; sbrk -&gt; sys_sbrk -&gt; growproc(n&gt;0) —-&gt; uvmalloc(va,sz) —-&gt; pa = kalloc —-&gt; mappages(va-&gt;pa)</p>
<ul>
<li><strong>kalloc</strong> : <strong>kernel从freelist中取下一个free page，并交给user process</strong></li>
<li><strong>如何交给user process ?</strong> : <strong>通过mappages , 建立user va 到 pa的映射</strong></li>
</ul>
</li>
</ul>
<h3 id="sbrk-n-lt-0"><a href="#sbrk-n-lt-0" class="headerlink" title="sbrk (n&lt;0)"></a>sbrk (n&lt;0)</h3><ul>
<li><strong>user释放kernel分配的内存，真正的还给kernel</strong>(sbrk(n) &lt; 0)<ul>
<li><strong>核心思路</strong><ul>
<li><strong>1. userpgtbl 解除 va 到pa的映射</strong></li>
<li><strong>2. kernel将page重新挂在freelist上</strong>。（重新作为freepage维护起来） </li>
</ul>
</li>
<li><strong>xv6 API流程</strong>：user -&gt; sbrk(n&lt;0) -&gt; sys_sbrk -&gt; growproc(n&lt;0) —-&gt; uvmdealloc(va) —&gt; <strong>munmap(va,pa)</strong>, <strong>kfree()</strong><ul>
<li><strong>munmap</strong> : 解除user对于va到pa的映射</li>
<li><strong>kfree</strong>：将不再映射到的phyiscal page重新挂到freelist</li>
</ul>
</li>
<li><blockquote>
<p><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-13-29-54.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><ul>
<li><strong>user释放内存到用户态</strong>(通过 free)<ul>
<li><strong>user态维护了一个cache list，里面存储的是user之前通过malloc-&gt;sbrk从kernel申请来的、没被使用的pages(page在这个cachelist中是以virtual address的形式）。</strong><ul>
<li><strong>也即，是物理内存分配机制在用户态维护的缓存。</strong></li>
<li><strong>这也应当是一个可以思考优化的策略</strong></li>
</ul>
</li>
<li>user 调用free(page)。会将该page加入user态的cache list，该page还是由user process占据，而非真正的释放、返回给kernel。</li>
<li><blockquote>
<p><img src="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/2022-12-17-12-53-01.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>物理内存的分配机制感觉也就如下几个关键点</p>
<ul>
<li><ol>
<li>kernel是<strong>如何组织</strong>free physical page的。（上述xv6是以freelist。优化方法为每个cpu核一个freelist。）因为这会影响到kernel是如何将free physical page分配给user，kernel又会如何回收free physical page。</li>
</ol>
</li>
<li><ol start="2">
<li>kernel为user提供的：直接获取/直接释放(即不涉及用户态缓存) physical page的系统调用<strong>接口</strong>是什么：sbrk-&gt;sys_sbrk()</li>
</ol>
</li>
<li><ol start="3">
<li>user层是如何封装sbrk的。一般都是将sbrk封装成malloc和free供给user使用。为什么封装？：一大作用就是<strong>缓存</strong>：<strong>为user process 在 用户态 维护了 一个 从kernel中申请来的内存的 缓存</strong>。缓存中存的是user暂时用不到的free pages。</li>
</ol>
<ul>
<li>xv6中是维护了一个cache list：<ul>
<li>malloc时先到cache list中寻找有无足够大的内存，没有则通过sbrk向kernel请求</li>
<li>free时则是将不用的内存放入cache list中</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>日后有时间应该会做个简单的malloc<br>然后研究下slab内存分配器和伙伴系统<br>所谓内存分配器和伙伴系统：内核做出的设计而非user<br>感受：把做的是哪个层次的事情给搞明白了，剩下的对于具体的设计方法，就是数据结构层面的事情了，就好办很多了。<br>学校赶人收拾行李了，回家再研究.</p>
<h2 id="伯克利-malloc-lab"><a href="#伯克利-malloc-lab" class="headerlink" title="伯克利 malloc lab"></a>伯克利 malloc lab</h2><p>TODO<br>malloc : 链表(显/隐) , 红黑树… </p>
<h2 id="slab内存分配器-amp-伙伴系统"><a href="#slab内存分配器-amp-伙伴系统" class="headerlink" title="slab内存分配器 &amp; 伙伴系统"></a>slab内存分配器 &amp; 伙伴系统</h2><p>TODO</p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab10-mmap</title>
    <url>/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/</url>
    <content><![CDATA[<ul>
<li><p>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</p>
</li>
<li><p>本实验实现了简易的mmap syscall(阉割版). 实现所谓的将”文件映射到内存”</p>
</li>
<li><p>对比</p>
<ul>
<li>现代OSmmap : disk -&gt; kernel buf. user va映射到kernel bu</li>
<li>实现的xv6mmap : disk -&gt; kernel buf -&gt; user physical mem. user va映射到 physical mem<ul>
<li>且没有实现MAP_PRIVATE,MAP_SHARED时的共享mem,也没实现MAP_PRIVATE的cow</li>
</ul>
</li>
</ul>
</li>
<li><p>实现关键 : lazy allocation</p>
<ul>
<li>mmap 先获取一块vma区域 但并不建立映射, 仅仅设定这块va合法 ; 当发生pgfault的时候，再读取文件相应内容 , 为va建立映射 , 然后返回.</li>
<li>munmap 就是解除vma内建立了映射的va</li>
</ul>
</li>
<li><p>mmap优势</p>
<ul>
<li>效率高，高于普通的read file<ul>
<li>比起read少一次拷贝. 映射到kenerl buf</li>
<li>减少陷入内核次数，减少上下文切换开销.(read每次都陷入)</li>
<li>lazy allocation(不必一次全部读入)</li>
</ul>
</li>
<li>更加方便user读写文件<ul>
<li>这也就是mmap所谓的 “映射文件到用户进程”。</li>
<li>user调用mmap之后 , 可以将对内存的读写看成对文件的读写,如何加载数据,如何落入磁盘 等都不需要user管.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>prot : 对内存权限 ; flags : 对file权限。 二者不可冲突</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在xv6中实现 mmap munmap<br>mmap：将用户的虚拟地址(user virtual address)映射到内核占有的物理内存。其中物理内存中保存的是自file中读出的数据。<br>munmap：解除映射。</p>
<ul>
<li><strong>vma</strong> : 约定将 vma 称为 user通过mmap建立映射时，被kernel选择的<strong>用户的虚拟地址</strong>范围的那一块区域的虚拟内存<ul>
<li>vma也即映射到的虚拟内存。也即mapping memory。</li>
</ul>
</li>
<li>将 mmap将vma映射到的真实的物理地址范围的物理内存（其中有file的数据） 称为 <strong>目标物理内存</strong></li>
</ul>
<ul>
<li><p><strong>API含义</strong></p>
</li>
<li><p><code>**void \*mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);***</code></p>
<ul>
<li><strong>addr</strong> : 0<ul>
<li>kernel替user选择，将user的哪部分虚拟地址范围作为映射区域。</li>
</ul>
</li>
<li><strong>length</strong> : vma区域的大小</li>
<li><strong>prot 对于内存权限</strong> : <ul>
<li>user关于vma虚拟内存区域/映射到的物理内存（一样，反正对vma读写就是在对physical mem读写）的权限，不可以和file的打开模式冲突。</li>
<li>The prot argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).</li>
<li><strong>PROT_READ</strong><ul>
<li>Pages may be read。vma的每页可以读。</li>
</ul>
</li>
<li><strong>PROT_WRITE</strong> <ul>
<li>Pages may be written。vma的每页可以写。</li>
</ul>
</li>
<li><strong>PROT_EXEC</strong>  <ul>
<li>Pages may be executed。vma的每页可执行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>flags 对于file的权限(写回标志) + process之间是否共享physical mem</strong><ul>
<li><strong>MAP_SHARED</strong><ul>
<li>Share this mapping.  Updates to the mapping are visible to other processes mapping the same region, and (in the case of  file-backed  mappings) are carried through to the underlying file.</li>
<li> 共享mapping。</li>
<li> <strong>1.</strong> 也即，当file相同时，不同process将各自的vma映射到同一块目标physical memory。一个process对vma进行修改（也即对vma映射到的physical memory修改），其他process都可以看到。（因为映射到的是同一physical mempry）</li>
<li> <strong>2.</strong> 且，当munmap解除vma到dram的映射时，会将physical memory的修改（通过dirty bit判断）写回disk上的file。</li>
<li> <strong>lab实现区别</strong>：对于MAP_SHARED , 本lab只实现了2，1的话lab没做要求。（对于MAP_SHARED，正常来讲，第一个process会lazy allocation分配vma映射到的physicalmem，其余process会直接指向该块physicalmem。然而本lab中实现的仅仅是每个process都lazy allocation一块physical mem）也即，本实验只是实现了将vma映射到的physical mem写回disk。</li>
</ul>
</li>
<li><strong>MAP_PRIVATE</strong><ul>
<li>Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried  through  to the underlying file.  </li>
<li>创建一个写时复制的映射。 </li>
<li>我理解的是：<ul>
<li><ol>
<li>当file相同时，第一个process会为vma进行lazy allocation一块phyiscal mem，其余的process再使用他们自己的vma时，先映射到第一个process lazy alloc的pm，然后当某个process发生写动作时，该process再进行copy on write。</li>
</ol>
</li>
<li><ol start="2">
<li>对于file加载进的physical mem的修改，在munmap解除映射时，不会落入disk。</li>
</ol>
</li>
</ul>
</li>
<li><strong>lab实现区别</strong>：然而本lab实现的，并没有实现copy on write，仅仅实现了对于每个process，当其要使用vma的某一page时，都要进行lazy allocation。也即每个process即使在读vma时，其映射到的physical mem也是各自独享的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>int munmap(void *addr, size_t length);</strong></p>
<ul>
<li>The munmap()  system  call  deletes the mappings for the specified address range, and causes further references to addresses within the range to generate invalid memory references.  The region is also automatically unmapped when the process is terminated.  On the other  hand,  closing  the file descriptor does not unmap the region.</li>
<li>解除从vma到physical mem的映射。后续process的vma变成无效的虚拟地址；</li>
<li>当进程exit时，vma区域会自动解除映射；</li>
<li>user close(fd)不会导致vma映射解除，也不会导致lazy allocation失败。<ul>
<li>After the mmap() call has returned, the file descriptor, fd, can be closed  immediately  without  invalidating the mapping</li>
<li>即当mmap返回后 关闭fd文件 映射依然有效。</li>
<li>因为mmap时会自动将struct file的引用计数++，防止被从ftable中替换走；知道munmap时，才会–struct file</li>
</ul>
</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>char *p = mmap(0, PGSIZE*2, PROT_READ, MAP_PRIVATE, fd, 0);<ul>
<li>0: kernel choose the virtual address。内核选择负责映射到的用户虚拟地址</li>
<li>PGSIZE*2 : 映射多少bytes内存</li>
<li>PROT_READ : the mapped memory is read-only。用户对这段用户虚拟地址只能读、不能写</li>
<li>MAP_PRIVATE : <ul>
<li>如果进程修改了这段映射的内存，修改的内容不会被写回文件、也不会与其他映射同一文件的进程共享。</li>
</ul>
</li>
<li>fd :file</li>
<li>0 : offset</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>mmap核心思想：</strong>（我感觉）<br>在user的va中划出一片区域，将文件内容映射其中。让user可以像操作内存数据一样，操作文件数据。也即使得user访问其virtual address就是在访问文件<br>更加方便user读写文件。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我所做的工作如下</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><ul>
<li><p>设计：将user process的最上方的可用虚拟地址，作为vma。也即自TRAPFRAME向下，选取虚拟内存区域作为vma。</p>
<ul>
<li><blockquote>
<p><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-11-18-58.png">    </p>
</blockquote>
</li>
</ul>
</li>
<li><p>struct <strong>vma</strong> : process用作映射到physical mem的virtual mem区域。(physical mem中是file的内容)，然后为proc结构体添加vma数组。</p>
<ul>
<li>是否有效、映射文件、映射范围、对mem(物理/虚拟一样，一个效果)的权限PROT、对file的权限(写回标志)、映射file的起始偏移量。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVMA 16</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> valid;      <span class="comment">//  是否有效</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span> <span class="comment">//  映射的文件</span></span><br><span class="line">    uint64 start;   <span class="comment">//  user该段映射的起始虚拟地址  根据上一次映射的最低地址和本次的sz来确定。PGSIZE对齐</span></span><br><span class="line">    uint64 sz;      <span class="comment">//  PGSIZE对齐。[start , end = start + sz - 1]</span></span><br><span class="line">    uint64 left;    <span class="comment">//  vma中剩余的还没被释放的bytes数量</span></span><br><span class="line">    <span class="keyword">int</span> prot;    <span class="comment">//  权限: 对mem的权限。PROT_READ PROT_WRITE</span></span><br><span class="line">    <span class="keyword">int</span> flag;    <span class="comment">//  权限: 对file的权限。MAP_PRIVATE MAP_SHARED 是否写回文件。是否和其他process共享physical mem</span></span><br><span class="line">    uint64 offset;  <span class="comment">//  映射文件的起始偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>实现 系统调用mmap</strong></p>
<ul>
<li><strong>思想</strong>：和之前的lazy allocation lab相同，分为两步<ul>
<li><strong>1. sys_mmap 将vma的这段虚拟地址标记为合法，但未建立映射</strong></li>
<li><strong>2. pgfault handler : lazy allocation。然后当user process使用该段虚拟地址、进而触发pagefault时，对其进行lazy allocation</strong>。<ul>
<li>与lazyalloc lab不同的是<ul>
<li>这里只需要考虑user使用未建立映射的user va</li>
<li>而不需要考虑kenrel使用未建立映射的user va</li>
<li>因为只有user会调用mmap</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实现sys_mmap</strong></p>
<ul>
<li>取user传参</li>
<li>判定prot、flag 和 file 权限是否矛盾</li>
<li><strong>寻找free的vma槽 并 计算 vma的start，end。</strong></li>
<li><strong>初始化vma</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_mmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. 取user传参</span></span><br><span class="line">    argaddr(<span class="number">0</span>,&amp;addr); argaddr(<span class="number">1</span>,&amp;sz); argint(<span class="number">2</span>,&amp;prot); </span><br><span class="line">    argint(<span class="number">3</span>,&amp;flag); argint(<span class="number">4</span>,&amp;fd); argaddr(<span class="number">5</span>,&amp;offset);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">//  获取fd的file</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 判定prot、flag 和 file 权限是否矛盾</span></span><br><span class="line">        <span class="comment">//  file不可读 user要求可读</span></span><br><span class="line">    <span class="keyword">if</span>( (!f-&gt;readable) &amp;&amp; (prot &amp; PROT_READ) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file can not read but you want to read\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  file不可写 user要求写file</span></span><br><span class="line">        <span class="comment">//  f-&gt;writable : file可写</span></span><br><span class="line">        <span class="comment">//  PROT_WRITE : user要求写映射内存</span></span><br><span class="line">        <span class="comment">//  flag : user要求将写的内容落入磁盘</span></span><br><span class="line">    <span class="keyword">if</span>( (!f-&gt;writable) &amp;&amp; ((prot &amp; PROT_WRITE) &amp;&amp; (flag &amp; MAP_SHARED)) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file can not write but you want to write\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 寻找free的vma槽 并 计算 vma的start，end。</span></span><br><span class="line">    sz = PGROUNDUP(sz);     <span class="comment">//  sz对PGSIZE对齐</span></span><br><span class="line">    uint64 mapuplimit = TRAPFRAME;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NVMA ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;vmas[i].valid == <span class="number">0</span> &amp;&amp; !found)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;vmas[i].valid = <span class="number">1</span>;</span><br><span class="line">            idx = i;</span><br><span class="line">            found = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  找到proc中最低的 可以提供给 mmap的 end虚拟地址</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;vmas[i].valid == <span class="number">1</span> &amp;&amp; mapuplimit &gt; p-&gt;vmas[i].start)</span><br><span class="line">        &#123;</span><br><span class="line">            mapuplimit = p-&gt;vmas[i].start;  <span class="comment">//  一定是对PGSIZE对齐的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4. 初始化vma</span></span><br><span class="line">    p-&gt;vmas[idx].f = f;</span><br><span class="line">    p-&gt;vmas[idx].sz = sz;</span><br><span class="line">    p-&gt;vmas[idx].left = sz;</span><br><span class="line">    p-&gt;vmas[idx].start = PGROUNDDOWN(mapuplimit - sz);  <span class="comment">//  start一定是PGSIZE对齐的 sz可能不是</span></span><br><span class="line">    p-&gt;vmas[idx].prot = prot;</span><br><span class="line">    p-&gt;vmas[idx].flag = flag;</span><br><span class="line">    p-&gt;vmas[idx].offset = offset;  </span><br><span class="line">    filedup(f);     <span class="comment">//  ++ref</span></span><br><span class="line">    <span class="comment">//  增加struct file 引用计数</span></span><br><span class="line">    <span class="comment">//  这样即使user关闭了文件，struct file也至少有一个引用计数由mmap的vma管理，防止struct file在ftable中被替换掉</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p-&gt;vmas[idx].start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>pagefault handler : lazy allocation</strong></p>
<ul>
<li>trap : 自不必说，判断是否落入vma区域<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pagefault %p cause %d\n&quot;</span>,r_stval(),r_scause());</span><br><span class="line">    uint64 pgault_va = r_stval();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  判断是否是被映射的地址范围 若是则获取相应vma</span></span><br><span class="line">    <span class="keyword">if</span>(!validMmap(pgault_va,&amp;vma))   </span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        uvmlazyMmap(vma,pgault_va);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>void uvmlazyMmap(struct vma* vma,uint64 pgault_va)</strong></p>
<ul>
<li>一言以蔽之：<ul>
<li><strong>为user process的pgfault_va所在的page进行lazyallocation（也即为va所在的虚拟页建立相应映射、映射到相应的物理页）。并且将file（由vma可知）的相应字节内容读入physical page</strong>。</li>
</ul>
</li>
<li><ol>
<li>分配要vma映射到的physical page</li>
</ol>
</li>
<li><ol start="2">
<li> 从disk读取data到pa 注意计算file读取的起始字节</li>
</ol>
</li>
<li><ol start="3">
<li> prot权限 – pte权限</li>
</ol>
</li>
<li><ol start="4">
<li> 建立映射 : (va所在virtual page)  —&gt; (physical page)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  每次处理一页</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmlazyMmap</span><span class="params">(struct vma* vma,uint64 pgault_va)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//  1. 分配要vma映射到的physical mem</span></span><br><span class="line">    uint64 pa = (uint64)kalloc();</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">void</span>*)pa,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line">    uint64 va = PGROUNDDOWN(pgault_va);     <span class="comment">//  va对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2.  从disk读取data到pa 注意计算file读取的起始字节</span></span><br><span class="line">    begin_op();</span><br><span class="line">    ilock(vma-&gt;f-&gt;ip);</span><br><span class="line">        <span class="comment">//  va - vma-&gt;start  --- 应当从file的第几个bytes开始读</span></span><br><span class="line">        <span class="comment">//  物理上的file应当从(offset开始的第几个bytes开始读) 其 &quot;第几个bytes&quot; 是和 (va相比与vm-&gt;start的差) 同步的。</span></span><br><span class="line">        <span class="comment">//  所以应当是 offset + va - vma-&gt;start</span></span><br><span class="line">        <span class="comment">//  如果不这样的话会读取错误的file内容</span></span><br><span class="line">    readi(vma-&gt;f-&gt;ip,<span class="number">0</span>,pa,vma-&gt;offset + (va - vma-&gt;start),PGSIZE);    <span class="comment">//  readi会处理PGSIZE超出文件剩余大小</span></span><br><span class="line">    iunlock(vma-&gt;f-&gt;ip);</span><br><span class="line">    end_op();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.  prot权限 -- pte权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">//  建立映射 : 一次映射一页。</span></span><br><span class="line">        <span class="comment">//  权限</span></span><br><span class="line">    <span class="keyword">int</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span>(vma-&gt;prot &amp; PROT_READ)</span><br><span class="line">        perm |= PTE_R;</span><br><span class="line">    <span class="keyword">if</span>(vma-&gt;prot &amp; PROT_WRITE)</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  **4.  建立映射**</span></span><br><span class="line">        <span class="comment">//  (va所在virtual page)  ---&gt; (physical page)</span></span><br><span class="line">    mappages(p-&gt;pagetable,va,PGSIZE,pa,perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>pgfaulthandler 之后user process再次使用该va即可.</p>
</li>
</ul>
<h3 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h3><p>int munmap(void *addr, size_t length);</p>
<ul>
<li><p><strong>uint64 sys_munmap(void)</strong></p>
<ul>
<li>作用：解除vma管理的va到pa的有效页的映射，并根据需要写回磁盘。（均由vmamunmap实现）</li>
<li><ol>
<li>检查user传入的addr是否合法</li>
</ol>
</li>
<li><ol start="2">
<li>计算释放范围对于释放范围以及对齐情况，本lab中没有corner case，</li>
</ol>
<ul>
<li>对于user传入的地址以及要映射的范围，从maptest中可以看出user传入的起始地址已经对PGSIZE对齐，传入的sz也和PGSIZE对齐。因此不必处理对齐也可过。如果真的处理全部corner case真是得不偿失了。这个实验的重点应该在与理解mmap流程、为什么比read/write file高效。</li>
<li>本lab中只需要实现如下三种地址范围的释放.<ul>
<li>[vma-&gt;start , x)   (x &lt;= vma-&gt;end)  x不必和PGSIZE对齐</li>
<li>[x , vma-&gt;end)     (x &gt;= vma-&gt;start)      x不必和PGSIZE对齐</li>
<li>[vma-&gt;start , vma-&gt;end)             the whole region</li>
<li>只是禁止dig a hole ： addr &gt; vma-&gt;start &amp;&amp; addr + sz &lt; getVmaEnd(vma) is forbiddened</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li><strong>核心：vmamunmap解除映射   vmamunmap(vma,start,sz,myproc()-&gt;pagetable);</strong></li>
</ol>
</li>
<li><ol start="4">
<li>释放vma槽<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_munmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    argaddr(<span class="number">0</span>,&amp;addr); argaddr(<span class="number">1</span>,&amp;sz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1. 检验addr和sz的合法性</span></span><br><span class="line">        <span class="comment">//  是否在vma中</span></span><br><span class="line">    <span class="keyword">if</span>(!validMmap(addr,&amp;vma)) fail</span><br><span class="line">        <span class="comment">//  检验munmap范围合法性 : not to dig a hole</span></span><br><span class="line">    <span class="keyword">if</span>(addr &gt; vma-&gt;start &amp;&amp; addr + sz &lt; getVmaEnd(vma)) fail</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 计算要munmap的范围（核心逻辑如下）</span></span><br><span class="line">    uint64 start = PGROUNDDOWN(addr);   <span class="comment">//  起始地址向下对齐</span></span><br><span class="line">    sz = sz</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. **解除映射**</span></span><br><span class="line">    <span class="comment">//  真正的核心实现逻辑在这个函数里</span></span><br><span class="line">    vmamunmap(vma,start,sz,myproc()-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4.  释放vma槽  </span></span><br><span class="line">    vma-&gt;left -= sz;</span><br><span class="line">    <span class="comment">//  如果vma的所有bytes都被释放</span></span><br><span class="line">    <span class="keyword">if</span>(vma-&gt;left == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vma-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        vma-&gt;left = <span class="number">0</span>;</span><br><span class="line">        fileclose(vma-&gt;f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>void vmamunmap(struct vma* vma , uint64 start , uint64 sz , pagetable_t pagetable)</strong></p>
<ul>
<li>sys_munmap的核心函数，真正负责解除映射的函数</li>
<li><strong>1. 解除vma管理的 从 [start,start+sz) 到 pa 的 有效页的映射，释放physical mem</strong><ul>
<li>所谓有效页，我的意思是指那些在[start,start+sz)范围之内，已经建立了映射的虚拟页，解除他们的映射。对于无效的地址，也即vma中没有被lazy allocation建立映射的地址，则不必理会。</li>
<li>pte = walk(pgtbl,va,0);</li>
<li>*pte = 0;</li>
<li>kfree(PTE2PA(pte))</li>
</ul>
</li>
<li><strong>2. 并在需要时将physical mem中的内容写入disk</strong> <ul>
<li>如果vma管理的映射区域为MAP_SHARED，且该page之前修改过，则将该page（writei）落入磁盘.   writei(vma-&gt;f-&gt;ip,0,pa,dest_file_byte,PGSIZE);<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">参考<span class="function">uvmunmap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmamunmap</span><span class="params">(struct vma* vma , uint64 start , uint64 sz , <span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(uint64 a = start ; a &lt; start + sz; a +=PGSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  如果userva真的建立了到pa的映射</span></span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">        &#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        <span class="comment">//  如果map_shared 且 确实写过 则 写入disk file</span></span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_D) &amp;&amp; (vma-&gt;flag &amp; MAP_SHARED))</span><br><span class="line">        &#123;</span><br><span class="line">            begin_op();</span><br><span class="line">            ilock(vma-&gt;f-&gt;ip);</span><br><span class="line">            uint64 dest_file_byte = vma-&gt;offset+(a-vma-&gt;start);   <span class="comment">//  要写入的file的起始bytes</span></span><br><span class="line">            uint64 bytes_to_write = start + sz - a;               <span class="comment">//  总共还有多少bytes要写</span></span><br><span class="line">            <span class="keyword">if</span>(bytes_to_write &gt;= PGSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// writei(vma-&gt;f-&gt;ip,1,a,dest_file_byte,PGSIZE);  使用user_va  ok</span></span><br><span class="line">                writei(vma-&gt;f-&gt;ip,<span class="number">0</span>,pa,dest_file_byte,PGSIZE);    <span class="comment">//  使用pa</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>      <span class="comment">//  如果不足1PGSIZEs</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// writei(vma-&gt;f-&gt;ip,1,a,dest_file_byte,bytes_to_write);  使用user_va  ok</span></span><br><span class="line">                writei(vma-&gt;f-&gt;ip,<span class="number">0</span>,pa,dest_file_byte,bytes_to_write);  <span class="comment">//  使用pa</span></span><br><span class="line">            &#125;</span><br><span class="line">            iunlock(vma-&gt;f-&gt;ip);</span><br><span class="line">            end_op();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  清空PTE</span></span><br><span class="line">        *pte = <span class="number">0</span>;     </span><br><span class="line">        <span class="comment">//  释放mem</span></span><br><span class="line">        kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><ul>
<li>下面考虑并发。修改fork</li>
<li><strong>fork</strong><ul>
<li><strong>child拷贝parent的有效vma信息</strong></li>
<li>但是child只copy了parent vma区域信息，并没有为child分配物理内存建立映射。</li>
<li>也即只是说child和parent<strong>使用一样的虚拟地址</strong>范围用作vma区域，但是并<strong>没有映射到同样的物理内存</strong>，child的vma也并没有立刻建立到物理内存的映射。</li>
<li>child要等到自己陷入pagefault后，再做如上pgfaulthandler处理，分配物理内存、建立映射。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire(&amp;np-&gt;lock);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NVMA;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vmas[i].valid)</span><br><span class="line">    &#123;</span><br><span class="line">        np-&gt;vmas[i] = p-&gt;vmas[i];     </span><br><span class="line">        filedup(p-&gt;vmas[i].f);      <span class="comment">//  增加struct file 引用计数 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">np-&gt;state = RUNNABLE;</span><br><span class="line">release(&amp;np-&gt;lock);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>exit时自动解除映射  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  清空vma，关闭文件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NVMA;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;vmas[i].valid)</span><br><span class="line">        &#123;</span><br><span class="line">            vmamunmap(&amp;p-&gt;vmas[i],p-&gt;vmas[i].start,p-&gt;vmas[i].sz,p-&gt;pagetable);</span><br><span class="line">            fileclose(p-&gt;vmas[i].f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;p-&gt;vmas[i],<span class="number">0</span>,<span class="keyword">sizeof</span>(p-&gt;vmas[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>拿下<br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-30-06.png"></p>
<h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><ul>
<li><p>写mmap的时候的疑问</p>
</li>
<li><p>易知vma管理了映射区域数据，其中就有struct file*。那么在user读写mmap映射到的vma虚拟内存时，kenrel需要去改变file的偏移量吗？</p>
<ul>
<li>我觉得不应该会。因为和read fd write fd不同，read write时，user知道自己是在对文件进行操作；而mmap时user知道他只是在对一块内存中选取地址进行操作，只是其中有文件内容罢了。故不应该改变file偏移量。</li>
</ul>
</li>
<li><p>关于MAP_SHARED ,在子进程对vma区域进行操作时，可以直接向父进程一样，为子进程的vma区域进行lazy allocation；更好的解决方式是 使得子进程的vma指向(父进程的vma指向的dram)，也即父子进程共享同一块dram区域（该块dram中装的是file的data）。</p>
<ul>
<li>我这里实现的是前者，感觉后者有点复杂。父进程munmap时还有看其有几个子进程，是否已经全部munmap，或许还要考虑其他的，目前还没想好.如果两个进程之间没有父子关系，该如何做，又是另一种情况。</li>
</ul>
</li>
<li><p>当mmap之后，还没munmap之前，如果user关闭了文件会怎么样？也即close(fd)</p>
<ul>
<li>On the other hand, closing the file descriptor does not unmap the region.</li>
<li>即close(fd)，对mapped memory无影响，user仍可以正常都写。</li>
<li>filedup作用：<ul>
<li>所谓打开一个文件，其实也就是拿到它的inode，拿到inode才可以读写相应数据。而我们又将inode*存储在struct file里，因此打开文件就是拿到相应的struct file。</li>
<li>filedup就是增加file的引用计数，防止其被从ftable中踢掉。当struct file的引用计数降为0的时候，则会被其他inode的struct file替换。而user是通过自己的fd-file表引用struct file的，（其表中存储的是file*）那么user就会通过fd引用到错误的struct file。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关于效率（拷贝次数）"><a href="#关于效率（拷贝次数）" class="headerlink" title="关于效率（拷贝次数）"></a>关于效率（拷贝次数）</h2><ul>
<li><strong>mmap 加载file到physical mem，然后user映射读取 和 user自己读取file有什么区别？为什么高效？</strong></li>
</ul>
<h3 id="XV6中mmap"><a href="#XV6中mmap" class="headerlink" title="XV6中mmap"></a>XV6中mmap</h3><ul>
<li><strong>结论：在xv6中，两者效率似乎并无高低之分，因为拷贝的次数都是相同的。</strong><ul>
<li><strong>都是需要2次拷贝</strong><ul>
<li><ol>
<li><strong>从 disk 读进 kernel buffer cache</strong>，</li>
</ol>
</li>
<li><ol start="2">
<li><strong>然后从kernel buffer cache 拷贝到 user va 映射到的 physical mem</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>首先，对于mmap</strong></p>
<ul>
<li><strong>user使用mmap读取文件数据流程：</strong><ul>
<li>mmap : return mapped memory address</li>
<li>read / write mapped memory</li>
<li>munmap : 解除映射。vma管理的虚拟地址范围 全部解除映射后，mapped memory 就不可再被引用。</li>
</ul>
</li>
<li>映射关系如图<ul>
<li><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-16-53-57.png"></li>
</ul>
</li>
<li>data拷贝逻辑如图<ul>
<li>disk -&gt; kernel buffer cache -&gt; user process  </li>
<li><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-05-03.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mmap</span></span><br><span class="line">    <span class="comment">//  open for get fd</span></span><br><span class="line">    fd = open(f, O_RDWR)</span><br><span class="line">    <span class="comment">//  mmap</span></span><br><span class="line">    p = mmap(<span class="number">0</span>, PGSIZE*<span class="number">3</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//  it&#x27;s ok to close</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  read / write mapped memory</span></span><br><span class="line">    <span class="comment">// check that the mapping still works after close(fd). (read)</span></span><br><span class="line">    _v1(p);       </span><br><span class="line">    <span class="comment">// write the mapped memory.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PGSIZE*<span class="number">2</span>; i++)</span><br><span class="line">        p[i] = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  munmap mapped memory</span></span><br><span class="line">    <span class="comment">// unmap just the first two of three pages of mapped memory.</span></span><br><span class="line">    munmap(p, PGSIZE*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// unmap the rest of the mapped memory.</span></span><br><span class="line">    munmap(p+PGSIZE*<span class="number">2</span>, PGSIZE);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>然后，对于read/write，拷贝逻辑并无不同。</p>
<ul>
<li>disk -&gt; kernel buffer cache -&gt; user process phyiscal mem<br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-23-48.png"><br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-26-34.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(path, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">read(fd, &amp;de, <span class="keyword">sizeof</span>(de));</span><br><span class="line">读写 de.<span class="function">member</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(fd,&amp;de,<span class="keyword">sizeof</span>(de))</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li><p>和xv6不同，拷贝次数少一次。没有从kernel buffer到user physical mem的拷贝。</p>
</li>
<li><p><strong>至于所说的linux中的mmap比read高效，其中一点原因应当是指就拷贝次数而言，mmap比read少一次</strong></p>
<ul>
<li><strong>mmap直接将user va映射到了kernel buffer cache。而非新alloc一个physical page。这个实现应该是xv6得option challenge。</strong></li>
<li><strong>Your solution probably allocates a new physical page for each page read from the mmap-ed file, even though the data is also in kernel memory in the buffer cache</strong>. <strong>Modify your implementation to use that physical memory, instead of allocating a new page</strong>. This requires that file blocks be the same size as pages (set BSIZE to 4096). You will need to pin mmap-ed blocks into the buffer cache. You will need worry about reference counts.</li>
</ul>
</li>
<li><p>没有做optional challenge，不过实现完之后应当是这样。</p>
<ul>
<li><strong>当user第一次使用vma管理的虚拟地址时，file data 从disk —&gt; 读到 kernel buffer。然后将user pagetable上建立从user va 到 kernel buffer的映射</strong></li>
<li><strong>可以看到，并没有未该vma新alloc一个physical page去映射，而是直接将user的va映射到buffer cache上，减少了一次从kernel buffer cache到user phyical mem的拷贝，效率比read更高。（read还要拷贝一次）</strong><br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-19-04-30.png"><br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-19-12-58.png"></li>
</ul>
</li>
<li><p><strong>lazy allocation</strong> : </p>
<ul>
<li>虽然没有为user va新alloc一块physical page，不过也可以称得上是lazy allocation</li>
<li>因为lazy allocation的思想就是要推迟va建立映射的时间，尽可能的推迟为va分配映射到的physical page。而这里确实是将va的映射推迟到了其被使用时才建立，只不过是没新alloc罢了，新建立的映射是从va到buffer cache的映射。</li>
</ul>
</li>
<li><p><strong>Optional Challenge</strong></p>
<ul>
<li>感觉把下面的都实现了的话，才能算是一个现代os中的mmap<blockquote>
<p>If two processes have the same file mmap-ed (as in fork_test), share their physical pages. You will need reference counts on physical pages.<br>Your solution probably allocates a new physical page for each page read from the mmap-ed file, even though the data is also in kernel memory in the buffer cache. Modify your implementation to use that physical memory, instead of allocating a new page. This requires that file blocks be the same size as pages (set BSIZE to 4096). You will need to pin mmap-ed blocks into the buffer cache. You will need worry about reference counts.<br>Remove redundancy between your implementation for lazy allocation and your implementation of mmap-ed files. (Hint: create a VMA for the lazy allocation area.)<br>Modify exec to use a VMA for different sections of the binary so that you get on-demand-paged executables. This will make starting programs faster, because exec will not have to read any data from the file system.<br>Implement page-out and page-in: have the kernel move some parts of processes to disk when physical memory is low. Then, page in the paged-out memory when the process references it.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="小结-mmap优势"><a href="#小结-mmap优势" class="headerlink" title="小结 mmap优势"></a>小结 mmap优势</h2><ul>
<li><p><strong>mmap优势</strong></p>
</li>
<li><p><strong>优势1：在于效率高，高于普通的read file</strong></p>
<ul>
<li><p>效率高原因如下</p>
</li>
<li><p><strong>1. 减少拷贝次数</strong>，如上讨论。</p>
<ul>
<li><strong>mmap</strong> 在读取va对应保存的内容时，<strong>内核只需要一次拷贝数据</strong>。<ul>
<li>optional Challenge中实现</li>
<li>以下为第一次使用va时触发的pgfault ，陷入内核，进入handler所做的工作<ul>
<li>disk —-&gt; kernel buffer cache</li>
<li>建立va 到 kernel buffer cache的映射</li>
</ul>
</li>
<li>然后回到user态，user再度读写va即可。 </li>
</ul>
</li>
<li>而<strong>read</strong> 读取va对应保存的内容时，<strong>内核需要拷贝两次数据</strong>。<ul>
<li>read时也需要进入一次内核。<ul>
<li>disk —&gt; kernel buffer cache 一次拷贝</li>
<li>kernel buffer cache —&gt; user process physical mem 两次拷贝</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>2. 减少陷入内核次数，减少上下文切换开销</strong></p>
<ul>
<li>通过mmap映射文件 : 对于一个page中的va，第一次使用该va，会触发pgfault，陷入内核，pgfault handler会进行lazy alloc处理（如1和上节linux所述）。而后，再次使用该page中的va，则不会触发pgfault，也就不会进入内核，直接在user态读写va即可。因为整个page都已经建立了映射。</li>
<li>而read，每次read都需要陷入内核。</li>
<li>如下，通过mmap减少大量陷入内核的次数.<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//  read: 每次read都要进入一次内核</span></span><br><span class="line">    <span class="keyword">char</span> de;</span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">        read/write de</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  mmap : 每个page进入一次内核即可(使用到哪个page就为哪个page进入内核建立映射)</span></span><br><span class="line">    <span class="keyword">char</span> *p = mmap(<span class="number">0</span>, PGSIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGSIZE; i++) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[i] != <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mismatch at %d, wanted &#x27;A&#x27;, got 0x%x\n&quot;</span>, i, p[i]);</span><br><span class="line">        err(<span class="string">&quot;v1 mismatch (1)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>3. 共享物理内存</strong></p>
<ul>
<li>当多个进程将同一页面映射到内存时，数据可以在这些进程之间共享。<ul>
<li>对于 只读 PROT_READ 的PAGE可以完全共享。</li>
<li>对于PROT_WRITE &amp;&amp; MAP_PRIVATE 的PAGE，可以通过COW节省开销。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优势2 ： 更加方便user读写文件</strong> ：</p>
<ul>
<li>在user的va中划出一片区域，将文件内容映射其中。让user可以像操作内存数据一样，操作文件数据。</li>
<li>也即**使得user读写va就是在读写file的内容(在物理内存中读写而非磁盘上)**。</li>
<li>也因此，对于随机访问，不用频繁 lseek。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>优势3：lazy allocation</strong><ul>
<li>mmap的另一个特点：<strong>lazy allocation</strong></li>
<li>某种程度上说也提高了效率<ul>
<li>user使用mmap之后，kernel不会立刻将file全部内容读取physical mem，然后为user va建立映射。而是等待usr使用到相应的va，才会触发pagefault，进入kenerl，handler处理，读取内容，建立映射。</li>
</ul>
</li>
<li>并且感觉也为user提供了方便<ul>
<li>user调用mmap之后，不必管file的内容如何加载到mem，也不用管如何建立映射，也不用管数据如何落回磁盘。user只需要简单地认为，这块内存里就存有file的数据即可，user只需要负责对其进行读写罢了,以及最后munmap，并且知道可以根据我们的需要落入磁盘。其余的都不必管。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>解释：mmap所谓的 “映射文件到用户进程” ：</strong><ul>
<li><strong>读取文件内容，建立user va到dram的映射</strong></li>
<li>所谓的映射：实际上就是将disk上file的内容读到一块physical mem，然后将user的pagetabl上，建立va到physical mem的映射</li>
<li>之所以叫映射，应当是和mmap的实现无关，只是因为从user的角度看起来，很像是将file的内容映射到user的一段va中<ul>
<li>mmap之后，user读写相应va就是在读写file的内容(在物理内存中读写而非磁盘上)</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab6-cow</title>
    <url>/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/</url>
    <content><![CDATA[<ul>
<li><p>本实验之前 fork之后 child process 立刻 拷贝 parent的physical mem 并建立映射.</p>
</li>
<li><p>本实验之后 ：不必拷贝. copy on write.</p>
<ul>
<li>思想：推迟为child分配和复制物理内存页，直到实际需要副本。</li>
<li>实现<ul>
<li><ol>
<li>fork , 进行假分配</li>
</ol>
</li>
<li><ol start="2">
<li>copy on write , 进行真分配</li>
</ol>
<ul>
<li>根据physical page的ref cnt(是否为1)来判断是否需要cow</li>
<li>cow分为三部分<ul>
<li>复制物理内存</li>
<li>取消pte的cow标志位</li>
<li>proc的pgtbl上建立映射</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li>cow之后 返回到造成pgfault的指令继续执行.</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>哪个process copy on write ? </p>
<ul>
<li>哪个process先写，就哪个porcess的pgtbl进行copy on write. </li>
</ul>
</li>
<li><p>当parent process A fork 出 BCDE process 后 </p>
<ul>
<li><ol>
<li>A写. 触发pgfault</li>
</ol>
<ul>
<li>则A进行cow. 且A只会影响自己的pgtbl. 不会改变BCDE的pgtbl</li>
</ul>
</li>
<li><ol start="2">
<li>BCD写. 触发pgfault</li>
</ol>
<ul>
<li>则BCD进行cow. 同1</li>
</ul>
</li>
<li><ol start="3">
<li>E写. </li>
</ol>
<ul>
<li>尽管此时只有E一个proc引用该mem，但仍然会pagefault. 因为E的pgtbl上的pte并没有任何改变. 仍然有cow的标志位</li>
<li>故E也进入pgfault handler.(walkaddrforwrite)</li>
<li>E发现physical page的ref cnt = 1 , 故不再需要复制物理内存,重新建立映射. 直接去掉cow标志位即可返回.</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>xv6 中的 fork() 系统调用将父进程的所有用户空间内存复制到子进程中。</p>
</li>
<li><p>如果父级很大，复制可能需要很长时间。更糟糕的是，工作往往大部分都被浪费了</p>
<ul>
<li>例如，子进程中的 fork() 后跟 exec() 将导致子进程丢弃复制的内存，可能从未使用过大部分内存。</li>
<li>当Shell处理指令时，它会通过fork创建一个子进程。fork会创建一个Shell进程的拷贝，所以这时我们有一个父进程（原来的Shell）和一个子进程。Shell的子进程执行的第一件事情就是调用exec运行一些其他程序，比如运行echo。现在的情况是，fork创建了Shell地址空间的一个完整的拷贝，而exec做的第一件事情就是丢弃这个地址空间，取而代之的是一个包含了echo的地址空间。这里看起来有点浪费。</li>
</ul>
</li>
<li><p>另一方面，如果我们让parent和child映射同一个page的话，那么当父母和孩子有一个需要对其进行写，那么就需要一个拷贝副本。</p>
</li>
<li><p>由此，就有了<strong>copy on write</strong> : 写时复制</p>
<ul>
<li>copy on write 的目的时推迟为child process 的 page table分配要映射到的物理页，一直使用parent的物理页。直到这个物理页被写的时候，才会拷贝一个page的副本给child process 的 pgtbl去映射。</li>
<li>也即，<strong>推迟为child分配和复制物理内存页，直到实际需要副本（如果有的话）</strong>。</li>
</ul>
</li>
<li><p><strong>hint</strong><br><img src="/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/2022-11-18-11-40-42.png"></p>
</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li><p>下面称<strong>cow pte / va</strong>为</p>
<ul>
<li>该 pte / va 还没有分配属于自己的映射到的physical page，和另一个pgtbl的pte共同映射一个物理页。</li>
<li>*pte &amp;= ~PTE_W<ul>
<li>不可写，当发生写动作时触发pgfault</li>
</ul>
</li>
<li>*pte |= PTE_RSW_1<ul>
<li>在pgfault handler中 ，通过该位判断是否是cow 的pte，是则如下处理</li>
<li>当发生对该pte对应的va的写动作时，会为该pte kalloc一个physical page 去映射。</li>
</ul>
</li>
</ul>
</li>
<li><p>再简洁一点，约定 </p>
<ul>
<li><strong>假分配</strong>：<strong>使得一个pte/va成为cow pte /va。</strong></li>
<li><strong>真分配</strong>：<strong>为一个cow pte/va 分配其属于自己映射到的physical page，并更新pte。使其从一个cow pte/va变成一个普通的pte/va。</strong>  </li>
</ul>
</li>
<li><p>我所做的工作如下</p>
</li>
</ul>
<h3 id="1-fork-进行假分配"><a href="#1-fork-进行假分配" class="headerlink" title="1. fork , 进行假分配"></a>1. fork , 进行假分配</h3><p><strong>令fork时不会立刻分配内存，并对pte进行假分配</strong><br>手段：先修改fork中的相关函数：uvmcopy，并添加leafptecow。</p>
<ul>
<li><strong>修改uvmcopy：使得fork时不会立即分配物理内存给child。</strong><ul>
<li>uvmcopy在fork中被调用，用于拷贝old user pagetable 给 new user pagetable</li>
<li>原先是新kalloc一块physical page然后映射到new user pagetable的va，现在变为直接将old user pagetable映射到的physical page(pp) 给 new user pagetable去映射。<ul>
<li>mappages(new_pgtbl, i, PGSIZE, old_pa, flags)</li>
</ul>
</li>
<li>并且在new user pgtbl映射到 pp 时，将pp的引用计数+1。<ul>
<li>incref(pa);</li>
</ul>
</li>
</ul>
</li>
<li><strong>添加leafptecow：使得pte为cow的pte。（其实可以将这步优化到上一步uvmcopy中去做，不过懒得做了，就这样吧）</strong><ul>
<li>下述的pte为child的user pgtbl和parent的user pgtbl的有效叶子pte。（text、data、stack、heap段的，不包括trampoline和trapframe段的）</li>
<li>使得pte均为可读不可写，以便在user对该pte指向的内存进行写时触发异常。<ul>
<li>*pte &amp;= ~(PTE_W)</li>
</ul>
</li>
<li>标记pte为copy on write的pte，这样才能和其他原本就是只读的pte区分开。<ul>
<li>取pte中的RSW中的一位作为cow的标志位。</li>
<li>*pte |= PTE_RSW_1。</li>
<li><blockquote>
<p><img src="/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/2022-11-18-08-14-32.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-copy-on-write-进行真分配"><a href="#2-copy-on-write-进行真分配" class="headerlink" title="2. copy on write , 进行真分配"></a>2. copy on write , 进行真分配</h3><p>当发生写造成的<strong>pagefault时，进行copy on write</strong>。也即实现对写造成的pgfault的handler。也即<strong>对pte进行真分配</strong>。<br>这里就可分为<strong>两种情况</strong>下的pagefault。与lazy allocation类似。<br>分为在<strong>user和在kernel</strong>。</p>
<ul>
<li><p><strong>一种是在user态对cow的va进行写</strong>，</p>
<ul>
<li>此时对于user pgtbl的使用是由mmu来负责的。mmu检测到pte为只读，故触发pagefault，进入usertrap。</li>
<li>因此，需要在usertrap对这种pagefault进行处理。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  检验页面写错误</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(r_scause() == <span class="number">15</span>)&#123;    </span><br><span class="line"><span class="comment">//  发生页面错误的va</span></span><br><span class="line">uint64 va = r_stval();</span><br><span class="line"><span class="comment">//  处理pagefault : 分配新physical mem，建立新映射，不再和另一process pgtbl 映射在同一physical mem</span></span><br><span class="line"><span class="keyword">int</span> ret = walkaddrforwrite(p-&gt;pagetable,va);</span><br><span class="line"><span class="comment">//  没有内存了. 杀掉process.不杀掉的话会陷入死循环. 回到user,发现还是不可写.然后硬件触发.然后继续到这里.还是没内存.循环往复.</span></span><br><span class="line"><span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">  p-&gt;killed = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>另一种是在kernel态，想对user cow的va进行写</strong>。</p>
<ul>
<li>此时对于user pgtbl的使用是由软件模拟的（即walkaddr），故不会触发page fault。是一种不会触发page fault的page faulthhhh，这个page fault需要我们自己来检验，并处理。</li>
<li>因此，在copyout中，对user的cow的va进行检测并处理。核心代码如下，也是通过walkaddrforwrite进行检测并处理。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddrforwrite(pagetable,va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>核心函数：walkaddrforwrite</strong>   </p>
<ul>
<li>uint64 walkaddrforwrite(pagetable_t pgtbl,uint64 va)</li>
<li><strong>功能</strong>：传入va及对应的pgtbl，并返回一个va映射到的可写的pa地址。<strong>且如果之前对va进行了假分配。那么这里会对va进行真分配。</strong></li>
<li><strong>逻辑：</strong><ul>
<li><strong>如果pte是个cow的pte</strong>，<ul>
<li><strong>如果其指向的physical page的引用计数为1</strong>，那么直接改变该pte的控制位，并返回指向的物理内存。（因为此时只有一个user pgtbl占据这个physical page，直接变成PTE_W可写并取消RSW位即可。）</li>
<li><strong>如果其指向的physical page的引用计数不为1</strong>，那么为va分配新的physical page，取消原先pte的映射（会改变old physical page的引用计数），并建立pte到新pa的映射。</li>
</ul>
</li>
<li><strong>如果pte不是个cow的pte</strong><ul>
<li>那么直接返回其映射到的pa即可。</li>
</ul>
</li>
</ul>
</li>
<li>所以可以看到，写的这个walkaddrforwrite，也可以作为page fault handler。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">walkaddrforwrite</span><span class="params">(<span class="keyword">pagetable_t</span> pgtbl,uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= MAXVA) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = walk(pgtbl,va,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//  检测pte是否有效 --- 即va是否有效</span></span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span> || *pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  需要copy on write</span></span><br><span class="line">    <span class="keyword">if</span>(((*pte) &amp; PTE_W) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(((*pte) &amp; PTE_RSW_1) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;pte is supposed to be cow when pte_w == 0&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getref(PTE2PA(*pte))&lt;=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                *pte |= PTE_W;</span><br><span class="line">                *pte &amp;= ~PTE_RSW_1; </span><br><span class="line">                <span class="keyword">return</span> PTE2PA(*pte);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            uint64 old_pa = PTE2PA(*pte);</span><br><span class="line">            uint64 mem = (uint64) kalloc();</span><br><span class="line">            <span class="comment">//  没有空余内存了</span></span><br><span class="line">            <span class="keyword">if</span>(mem == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>;         </span><br><span class="line">            memmove((<span class="keyword">void</span>*)mem,(<span class="keyword">const</span> <span class="keyword">void</span>*)old_pa,PGSIZE);</span><br><span class="line">            uvmunmap(pgtbl,PGROUNDDOWN(va),<span class="number">1</span>,<span class="number">1</span>);   <span class="comment">//  munmap 1 : --ref_cnt</span></span><br><span class="line">            <span class="comment">//  建立va到新pa的新映射</span></span><br><span class="line">            mappages(pgtbl,PGROUNDDOWN(va),PGSIZE,mem,PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">            <span class="keyword">return</span> mem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  不需要copy on write</span></span><br><span class="line">    <span class="keyword">return</span> PTE2PA(*pte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-physical-page的引用计数"><a href="#3-physical-page的引用计数" class="headerlink" title="3. physical page的引用计数"></a>3. physical page的引用计数</h3><p><strong>重点：对physical page的引用计数</strong></p>
<ul>
<li><p>对DRAM段每一个physical page进行引用计数。</p>
<ul>
<li>范围为<code>[kernel text/data即first address after kernel,PHSTOP)</code>。</li>
<li>因为user process的pgtbl只会映射到这里的physical page。</li>
</ul>
</li>
<li><p>注意freelist上的引用计数必须都是0；kfree时检查引用计数，当为0时才能将该pp放回freelist。</p>
</li>
<li><p><strong>什么结构来引用计数：数组</strong></p>
<ul>
<li>对每一个pp的引用计数，需要用一个lock来保护。防止不同process对同一pp的ref_cnt进行操作，导致data race。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDX(pa) ((pa - KERNBASE) / PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN ((PHYSTOP - KERNBASE) / PGSIZE + 5)</span></span><br><span class="line"><span class="comment">//  仅限DRAM进行引用计数 即 pa位于 KERNBASE PHYSTOP之间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ref</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ref_cnt;</span><br><span class="line">&#125; refs[MAXN];</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>何时改变引用计数：</strong></p>
<ul>
<li><strong>++ref_cnt</strong><ul>
<li><strong>kalloc时</strong>，需要++ref_cnt。也即，将physical page 从freelist上摘下来时，需要令ref_cnt = 1。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">        kmem.freelist = r-&gt;next;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">if</span>(r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">        incref((uint64)r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>uvmcopy时</strong>，当对pte进行一个假分配后，也即令一个pte成为cow pte后，需要对其映射到的pa进行一个++ref_cnt。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(mappages(<span class="keyword">new</span>, i, PGSIZE, pa, flags);</span><br><span class="line"><span class="comment">//  对于两个user pgtbl都使用的mem，则引用计数++</span></span><br><span class="line">incref(pa);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>–ref_cnt</strong><ul>
<li>当<strong>kfree时</strong>，需要–ref_cnt，当ref_cnt为0时再释放pp.  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    <span class="comment">//  check whether the pa is legal</span></span><br><span class="line">    <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">        panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = ((uint64)pa - KERNBASE) / PGSIZE;</span><br><span class="line">    <span class="keyword">if</span>(idx &lt;= <span class="number">0</span> ) panic(<span class="string">&quot;idx is expected to be &gt; 0 &quot;</span>);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;(refs[idx].lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(--refs[idx].ref_cnt &lt; <span class="number">0</span>) panic(<span class="string">&quot;&gt;= 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((refs[idx].ref_cnt) == <span class="number">0</span>)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">        <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">        r = (struct run*)pa;</span><br><span class="line">        r-&gt;next = kmem.freelist;</span><br><span class="line">        kmem.freelist = r;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;(refs[idx].lock));</span><br><span class="line">    </span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>bug</p>
<ul>
<li><ol>
<li>一开始想在run结构体增加成员 ref_cnt 代表该page正在引用的次数。</li>
</ol>
<ul>
<li>想想就不行。不能在run里增加成员。因为那个也是physical page的头部。当把pg分配出去，那个结构体就被覆盖了。何谈引用计数</li>
<li>所以单独建一个数组，来表示每个pg的引用次数。</li>
</ul>
</li>
<li><ol start="2">
<li>一开始想在mappages和munmap的时候，增加/减少引用计数。而并不是在kalloc和kfree时。结果一输入命令就panic init exiting.</li>
</ol>
<ul>
<li>不能这样。因为一开始kernel pgtbl就会建立所有映射，可也没有kalloc。如果按如上方案的话，在kfree的时候，ref_cnt的引用计数应当为1，(并且我们还只对dram进行计数，还需要判断)。</li>
<li><blockquote>
<p><img src="/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/2022-11-17-08-09-48.png"></p>
</blockquote>
</li>
<li>如果只是这样倒也罢了。可是还有一些其他地方只kalloc了，却并没有建立映射。并且从逻辑上来讲这个引用计数就应当只涉及调用了fork的user pgtbl，这样做会引入kernel pgtbl，徒增复杂性。且如hint所说，kfree() should only place a page back on the free list if its reference count is zero。调试的时候就这里耗时醉酒，赶紧放弃这种计数方法。</li>
<li>改成在kfree和kalloc和uvmcopy时维护计数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><ol start="4">
<li>exec不需要修改</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="5">
<li>开机成功</li>
</ol>
<ul>
<li>大部分时间都耗在了开机能正常运行命令之前，开机成功之后直接过了cowtest，然后usertests也几分钟就改完了。爽!<ul>
<li>usertests过不去的test看一眼是咋写的，然后改一下就行。能正常运行命令就应该是逻辑没错误了，test出来的是极限/故意写错的情况。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h3><ul>
<li><ol>
<li><strong>修改fork时遇到的bug</strong></li>
</ol>
<ul>
<li>我之前将pgtbl的所有pte都改变成cow的page了。结果陷入了死循环，连$都没打印出来。在这里卡了好久。<ul>
<li>调试之后发现是在从usertrapret出去之后到trampoline的userret，然后sret之后就陷入了死循环，不断进入kerneltrap再出去。</li>
<li>原因：我认为是这样的，因为将userpgtbl映射到trapframe的pte设置为不可写，而后会有动作对trapframe进行了写，且当时(usertrapret中有intr_off)关中断。当sret打开中断后，cpu接受中断，进入kerneltrap，没处理，再离开，再进入。如此死循环。</li>
</ul>
</li>
<li><strong>所以注意child拷贝parent只是拷贝了text,data,stack,heap段，也即只有这些段是需要copy on write的。剩下的trapframe和trapoline不是cow的</strong>。</li>
</ul>
</li>
<li><ol start="2">
<li><strong>copy on write时遇到的问题，解决</strong>。</li>
</ol>
<ul>
<li>关于getref(PTE2PA(*pte) &lt;= 1)</li>
<li>关于walkaddrforwrite的问题<ul>
<li>如果1child 1parent<ul>
<li>那么如果是一个child写的话，那么除了将child本身的这个pte重新建立映射之外，还需要将其parent置为可写。</li>
<li>那么如果是一个parent写的话，那么除了将parent本身的这个pte重新建立映射之外，还需要将其child置为可写，那么如何获取其child？</li>
</ul>
</li>
<li>如果多child 1parent<ul>
<li>那么1child写了，只是将1child本身的相应pte进行更新，其余的仍然映射到那个pg，仍然只读</li>
<li>如果1parent写了，只是将1parent本身的相应pte进行更新，其余的仍然映射到那个pg，仍然只读</li>
<li>只有当最后一个写proc的时候（即其他proc都已经写过），才不需要新建mem，改变pte，重新建立映射，只要将置成pte可写，然后直接写内存即可。</li>
</ul>
</li>
<li>显然上述想法有些可笑，不必在一个user的pte进行真分配的时候考虑其他process。每个process只考虑izji就可以。</li>
</ul>
</li>
<li>所以通过pagefault handler时检查physical page的引用计数解决上述问题。当引用计数为1时代表只有一个人引用这个内存。</li>
</ul>
</li>
<li><ol start="3">
<li><strong>引用计数时遇到的bug</strong></li>
</ol>
<ul>
<li><ol>
<li>一开始想在run结构体增加成员 ref_cnt 代表该page正在引用的次数。</li>
</ol>
<ul>
<li>想想就不行。不能在run里增加成员。因为那个也是physical page的头部。当把pg分配出去，那个结构体就被覆盖了。何谈引用计数</li>
<li>所以单独建一个数组，来表示每个pg的引用次数。</li>
</ul>
</li>
<li><ol start="2">
<li>一开始想在mappages和munmap的时候，增加/减少引用计数。而并不是在kalloc和kfree时。结果一输入命令就panic init exiting.</li>
</ol>
<ul>
<li>不能这样。因为一开始kernel pgtbl就会建立所有映射，可也没有kalloc。如果按如上方案的话，在kfree的时候，ref_cnt的引用计数应当为1，(并且我们还只对dram进行计数，还需要判断)。</li>
<li><blockquote>
<p><img src="/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/2022-11-17-08-09-48.png"></p>
</blockquote>
</li>
<li>如果只是这样倒也罢了。可是还有一些其他地方只kalloc了，却并没有建立映射。并且从逻辑上来讲这个引用计数就应当只涉及调用了fork的user pgtbl，这样做会引入kernel pgtbl，徒增复杂性。且如hint所说，kfree() should only place a page back on the free list if its reference count is zero。调试的时候就这里耗时醉酒，赶紧放弃这种计数方法。</li>
<li>改成在kfree和kalloc和uvmcopy时维护计数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><ol>
<li>ok : fork在什么时候被调用。cow和那些pgtbl有关，与kernel pgtbl有关吗？</li>
</ol>
<ul>
<li>fork只会由user process调用</li>
<li>只和user pgtbl有关。   <ul>
<li>cow va只会在fork情况下产生。而fork又只会由sys_fork调用，也即，只会由用户程序通过fork()调用。因此cow只和user pgtbl有关。</li>
</ul>
</li>
<li>对于kernel pagetable 很显然不会有copy on write发生，因为全局始终只有一个kernel pagetable。且child拷贝pagetable也不会拷贝kernel pagetable。最一开始的fork拷贝的是initcode的pgtbl吧？</li>
</ul>
</li>
<li><ol start="2">
<li>ok : mem被映射和被使用并不是完全相同的概念。</li>
</ol>
<ul>
<li>对于kernel pagetable 映射了所有的physical memory ，但是却并没有都使用。因此 mappages时不可ref_cnt++。</li>
<li>但是对于user pgtbl，其映射了一块另一个user pgtbl的所拥有的mem，即代表这块mem为本user pgtbl所拥有，则引用计数++。因此kalloc和uvmcopy都需要ref_cnt++。</li>
</ul>
</li>
<li><ol start="3">
<li>ok : kernel给user分配dram段内存需要通过kalloc，那么kernel自己使用dram段的内存呢？</li>
</ol>
<ul>
<li>也需要。</li>
<li>诚然，kernel在刚一开始就全权拥有所有物理内存，鉴于直接映射，kernel也可以直接使用dram的物理内存。不过还是要通过kalloc来获取一下，以防止其使用的内存被其他地方使用或者被user使用。如下kernel使用kalloc给kernel使用</li>
<li><blockquote>
<p><img src="/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/2022-11-17-09-08-22.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li><ol start="4">
<li>同学问的问题：父进程对一个地址进行了写 触发pagefault,进行了copy on write之后，子进程再写还会不会触发page fault？</li>
</ol>
<ul>
<li>会, 因为u</li>
<li>会 , fork的时候比如说父进程fork出ABCDEF这些个进程，他们的pagetable是一样的。（因为子进程拷贝了父进程的pagetable），然后当某一进程比如说A进程在用户态对A进程的virtual address写，会触发pagefault，因为pte之前在fork的时候就被标记成需要copy on write的，对该pte引用的地址写会被mmu检测并触发pagefault，然后在pagefault handler中，会在该A进程的page table上，找到这个va对应的pte，修改pte，为这个va建立一个到新一块物理页的映射（不再是之前和其他进程共用的物理页），然后将pte的标志位置成不需要copy on write的。然后，当又有B进程对该va进行写入，那么，同理，B pagetable的pte仍然是被标志成需要copy on write的，所以他也会触发pagefault，同样会进入pagefaulthandler，进行新物理页的分配。</li>
</ul>
</li>
</ul>
<blockquote>
<p><img src="/2022/11/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab6-cow/2022-11-16-22-26-44.png"></p>
</blockquote>
<p>大部分时间都耗在了开机之前<br>开机成功之后直接过了cowtest<br>然后usertests也几分钟就改完了.爽!</p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab总结</title>
    <url>/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>历时2月有余。完成了lab1-lab10。由于疫情遣返一堆事儿，故net-work lab只能有时间再做了。<br>不得不说，跟这门课真的是相见恨晚，之前不清不楚的知识点和机制，在阅读xv6的代码时都有了更为清晰的认知。<br>比如一个进程究竟是怎么被划分成用户线程和内核线程的？（内核进程：就是在内核维护了进程陷入内核后的函数调用栈）<br>比如页表究竟是如何运作的？我原先甚至都不知道页表还分成用户页表和内核页表，内核究竟是如何使用用户传入的虚拟地址的？（进程的内核页表中维护了用户的地址空间）<br>比如系统调用究竟是如何使得进程陷入内核的？通过trap，那么trap机制究竟是如何做到的？ecall -&gt; trampoline -&gt; 保存用户线程上下文（cpu regs）到结构体trapframe，加载trapframe之前保存的进程的内核线程的信息到cpu上，用户页表切换成内核页表，然后跳转到kernel C code usertrap。然后就是内核根据用户陷入内核的原因以及传入参数，通过一系列函数syscall实现系统调用。<br>比如进程切换究竟是如何实现的？内核究竟是如何调度不同进程的？内涵和为什么调度不了用户态线程？：内核中的上下文分为每个进程的内核线程，以及一个调度器线程。会有定时器中断等机制，使得os陷入内核，执行调度器线程，其会寻找一个runnable的内核线程（也即寻找一个runnbale的进程），然后运行该内核线程；该内核线程离开内核态时，os就会在用户态运行该进程的用户线程。如此，就实现了进程切换。这也解释了内核为什么不会调度同一个进程的用户态线程，因为内核的调度器线程只能看到进程的内核线程，看不到用户态线程。<br>比如用户究竟是如何拿到物理内存的？我们常说的malloc啥的，究竟是在那一层次做出的设计。<br>又比如常说的内核的buffer，是在哪里？是dram里吗？是，就是xv6中的bcache，所有和disk的交互都要通过bacche<br>又比如socket buffer，是在哪里？：有点忘了，大概是net.c通过kalloc申请出的一些内存用作socket buffer。<br>又比如lazy allocation? 是如何工作的？：先声明user的一段虚拟地址为合法但不建立映射，然后在用户第一次使用到该地址时，再通过pgfault陷入内核，在进程的user pagetable上为该地址建立虚拟地址到物理地址映射。<br>又比如cow 是如何实现的？: fork时假分配,哪些process先write,那些process cow真分配<br>又比如mmap 如何实现的 ? 为什么叫映射 ? 为什么高效 ? :基于lazy allocation实现. 高效: 直接映射到buffer<br>又比如文件系统 </p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-lab9-文件系统</title>
    <url>/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>实现二级间接块、实现软链接系统调用</p>
<span id="more"></span>

<h1 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实验目的：就是扩增一个inode所能引用的datablock大小</p>
<ul>
<li><p>原先inode的结构如下</p>
<ul>
<li>addrs[0,11]是直接块</li>
<li>addrs[12]是一级间接块</li>
<li>总共能引用的block 数量为 268 = 12 + 256<br><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-09-07-35.png"></li>
</ul>
</li>
<li><p>改动后的结构如下</p>
<ul>
<li>addrs[0,10]是直接块</li>
<li>addrs[11]一级间接块</li>
<li>addrs[12]二级间接块</li>
<li>总共能引用的block 数量为 65803 = 11 + 256 + 256*256<br><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-09-17-09.png"></li>
</ul>
</li>
<li><p>我愿将single indirect block 称为一级块表, double indirect block 称为二级块表</p>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li><p>以下为我所做的工作</p>
</li>
<li><p>struct inode和dinode中的addrs数组</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line"><span class="keyword">short</span> type;           <span class="comment">// File type  文件 / 目录 / 特殊文件 / 0表示inode空闲</span></span><br><span class="line"><span class="keyword">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line"><span class="keyword">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line"><span class="keyword">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">uint addrs[NDIRECT+<span class="number">2</span>];   <span class="comment">// Data block addresses 保存inode代表的文件的内容的磁盘块号</span></span><br><span class="line"><span class="comment">// 11 * direct block + 1 single indirect block + 1 * double indirect block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>bmap </p>
<ul>
<li>功能: 查询并返回ip所引用的第bn个datablockno。过程中按需分配datablock。</li>
<li>可以看成是<strong>将inode的逻辑块号转化成disk上的物理块号</strong>。</li>
<li>修改：增添对于二级块表的从逻辑到物理的映射的处理<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">bmap</span><span class="params">(struct inode *ip, uint bn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint addr, *a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1. NDIRECT = 11 </span></span><br><span class="line">    <span class="comment">//  11 个 direct block</span></span><br><span class="line">    <span class="comment">//  如果inode的bn为直接地址块，且还没引用datablock</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">        <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">        ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">    bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. NINDIRECT = 256</span></span><br><span class="line">    <span class="comment">//  1 个 single indirect block</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">        <span class="comment">//  Load indirect block, allocating if necessary.</span></span><br><span class="line">        <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">        ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        <span class="comment">//  get indirect block cache</span></span><br><span class="line">        bp = bread(ip-&gt;dev, addr);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="comment">//  如果第bn项并没有指向一个block，则为其balloc分配一个freeblock，并记录</span></span><br><span class="line">        <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">        a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        log_write(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);   <span class="comment">//  bread brelse 搭配</span></span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bn -= NINDIRECT;</span><br><span class="line">    <span class="comment">//  3. DOUBLE_NINDIRECT = 256 * 256</span></span><br><span class="line">    <span class="comment">//  1 个 double indirect block</span></span><br><span class="line">    <span class="keyword">if</span>(bn &lt; DOUBLE_NINDIRECT)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  addr pointed to the first level indirect block </span></span><br><span class="line">        <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+NINDIRECT]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ip-&gt;addrs[NDIRECT+NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">        &#125;</span><br><span class="line">        bp = bread(ip-&gt;dev,addr);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="keyword">int</span> n = bn / NINDIRECT;</span><br><span class="line">        <span class="keyword">int</span> m = bn % NINDIRECT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  the first level indirect block pointed to the second level indirect block</span></span><br><span class="line">        <span class="keyword">if</span>((addr = a[n]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[n] = addr = balloc(ip-&gt;dev);  <span class="comment">//  modify cache</span></span><br><span class="line">            log_write(bp);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  the second level indirect block pointed to the target data block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">m_bp</span> =</span> bread(ip-&gt;dev,addr);</span><br><span class="line">        uint *m_a = (uint*)m_bp-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>((addr = m_a[m]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_a[m] = addr = balloc(ip-&gt;dev);</span><br><span class="line">            log_write(m_bp);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(m_bp);</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果块号超过NDIRECT+NINDIRECT，则bmap调用panic崩溃</span></span><br><span class="line">    panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>同理，在itrunc释放块表的时候也需要释放下二级块表</p>
<ul>
<li>注意不要忘记清空addrs本身<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">itrunc</span><span class="params">(struct inode *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">    uint *a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放所有直接引用的disk上的块 并清空addrs</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">            bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">            ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放所有间接引用的disk上的块 并清空addrs</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">        walkfreeblock(ip-&gt;addrs[NDIRECT],ip);</span><br><span class="line">        ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放double indirect block 及 其所引用的block</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT + NINDIRECT])</span><br><span class="line">    &#123;</span><br><span class="line">        bp = bread(ip-&gt;dev,ip-&gt;addrs[NDIRECT + NINDIRECT]);</span><br><span class="line">        a = (uint*)bp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j&lt;NINDIRECT;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j])</span><br><span class="line">                walkfreeblock(a[j],ip);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bp);</span><br><span class="line">        <span class="comment">//  释放二级块表本身</span></span><br><span class="line">        bfree(ip-&gt;dev,ip-&gt;addrs[NDIRECT + NINDIRECT]);</span><br><span class="line">        ip-&gt;addrs[NDIRECT + NINDIRECT] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  inode代表的文件大小为0</span></span><br><span class="line">    ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  更新inode之后 应当立刻落入磁盘记入日志</span></span><br><span class="line">    iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>工具函数</p>
<ul>
<li>释放single indirect block所引用的256个datablock，并释放一级块标自身所占的datablock</li>
<li>传入一级块表的所在的datablock的blockno，以及disk编号<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  blockno是一块direct address blockno</span></span><br><span class="line"><span class="comment">//  其中所有的数据都是指向datablock。也即都是datablockno</span></span><br><span class="line"><span class="comment">//  walkfreeblock : 存储在释放blockno中引用的所有datablock</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walkfreeblock</span><span class="params">(<span class="keyword">int</span> indirect_blockno,struct inode *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span> =</span> bread(ip-&gt;dev,indirect_blockno);</span><br><span class="line">    uint* pd = (uint*)bp-&gt;data;   <span class="comment">//  pointer to datablock</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;NINDIRECT;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pd[k])</span><br><span class="line">        bfree(ip-&gt;dev,pd[k]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);                       <span class="comment">//  不要忘记释放自身cache</span></span><br><span class="line">    bfree(ip-&gt;dev,indirect_blockno);  <span class="comment">//  不要忘记释放自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="PART2"><a href="#PART2" class="headerlink" title="PART2"></a>PART2</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>约定路径为path:path处有个entry指向该inode<br>软链接文件的inode为:symbolic inode</p>
<ul>
<li>目标：为xv6实现软链接系统调用。</li>
</ul>
<ul>
<li>int symlink(char *target, char *path)<ul>
<li>在路径path，创建一个symbloic inode，导向target下的inode</li>
<li>即便目标target inode并不存在，symlink也可以成功。只是当open symbolic inode时会fail。</li>
<li>success : return 0;</li>
<li>fail : return -1</li>
<li>open symbolic inode时，如果trace到的还是一个symbloic inode，那么递归的追踪下去，直到深度超过上限。</li>
<li>You do not have to handle symbolic links to directories for this lab.</li>
</ul>
</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul>
<li>我所做的工作如下</li>
<li>新增一种inode类型：T_SYMLINK，代表symbolic inode</li>
<li>open新增一种访问权限:O_NOFOLLOW<ul>
<li>When a process specifies O_NOFOLLOW in the flags to open, open should open the symlink (and not follow the symbolic link).</li>
</ul>
</li>
</ul>
<ul>
<li><p>uint64 <strong>sys_symlink</strong>(void)</p>
<ul>
<li>创建一个symbolic inode</li>
<li>向该symbolic inode的datablock写入数据:char *target。当open的时候访问该target路径对应的inode<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_symlink</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> target[MAXPATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> path[MAXPATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    begin_op();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1. 创建一个symbolic inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">ip</span> =</span> namei(path); </span><br><span class="line">    <span class="keyword">if</span>(ip==<span class="number">0</span>)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  如果之前没有，创建inode</span></span><br><span class="line">        ip = create(path,T_SYMLINK,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ip == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        itrunc(ip);                     <span class="comment">//  清空inode的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//  如果之前就有,那么写覆盖datablock即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        ilock(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 向该symbolic inode的datablock写入数据:char *target。当open的时候访问该target路径对应的inode </span></span><br><span class="line">    <span class="keyword">int</span> ret = writei(ip,<span class="number">0</span>,(uint64)target,<span class="number">0</span>,MAXPATH);</span><br><span class="line">    <span class="keyword">if</span>(ret != MAXPATH) </span><br><span class="line">    &#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iunlockput(ip);     <span class="comment">//  注意这里应当是iunlockput而非iunlock</span></span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>sys_open</strong></p>
<ul>
<li>增添两部分</li>
<li><ol>
<li>对于访问symbolic inode</li>
</ol>
<ul>
<li>递归的找到target inode 然后访问</li>
</ul>
</li>
<li><ol start="2">
<li>对于以O_NOFOLLOW方式访问symbolic inode</li>
</ol>
<ul>
<li>直接访问symbolic inode<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_open</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    begin_op();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  create 创建inode</span></span><br><span class="line">    <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    <span class="comment">//  寻找已有inode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//  open(&quot;/testsymlink/b&quot;, O_RDWR)</span></span><br><span class="line">        <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  1. trace symlink . </span></span><br><span class="line">        <span class="comment">//  失败则返回NULL ,syscall return -1。</span></span><br><span class="line">        <span class="comment">//  成功则获得目标inode指针 , syscall return fd。</span></span><br><span class="line">        <span class="keyword">if</span>(ip-&gt;type == T_SYMLINK &amp;&amp; ((omode &amp; O_NOFOLLOW) == <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ip = dfs_trace_symlink(ip,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ip == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                end_op();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  2. </span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ilock(ip);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">            iunlockput(ip);</span><br><span class="line">            end_op();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  从ftable中分配free struct file 来承载inode + 从p-&gt;ofile中分配free fd 来索引struct file</span></span><br><span class="line">    <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f)</span><br><span class="line">        fileclose(f);</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line"></span><br><span class="line">    iunlock(ip);</span><br><span class="line">    end_op();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>工具函数 <strong>dfs_trace_symlink</strong><ul>
<li>递归的追踪symbolic inode</li>
<li>如果超出最大深度,则返回0</li>
<li>如果是要target路径的inode不存在，则返回0</li>
<li>如果本inode是个非symbolic inode，那么返回该inode</li>
<li><strong>注意在读写inode之前（如通过readi读取），一定要先通过ilock(inode)锁定</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  fail : return 0</span></span><br><span class="line"><span class="comment">//  success : return locked inode*</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode* <span class="title">dfs_trace_symlink</span><span class="params">(struct inode *ip,<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  如果超出最大深度,则返回0</span></span><br><span class="line">    <span class="comment">//  如果是要target路径的inode不存在，则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(h &gt; <span class="number">10</span> || ip == <span class="number">0</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意！！！</span></span><br><span class="line">    <span class="comment">//  在读写inode的元数据或内容之前，代码必须使用ilock锁定inode</span></span><br><span class="line">    ilock(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果本inode是个软链接inode，那么一路追踪到非软链接inode</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_SYMLINK) <span class="keyword">return</span> ip; </span><br><span class="line">    <span class="keyword">char</span> target[MAXPATH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = readi(ip,<span class="number">0</span>,(uint64)target,<span class="number">0</span>,MAXPATH);</span><br><span class="line">    <span class="keyword">if</span>(ret != MAXPATH) panic(<span class="string">&quot;open symlink&quot;</span>);</span><br><span class="line"></span><br><span class="line">    iunlockput(ip);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>* <span class="title">ne</span> =</span> namei(target);</span><br><span class="line">    <span class="keyword">return</span> dfs_trace_symlink(ne,h+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h3><ul>
<li><strong>遇见bug：</strong><ul>
<li>在sys_symlink中，不再引用inode时我只是iunlock(inode)，并没有iunlockput(inode)，造成panic virtio_disk_intr status</li>
<li>iunlock(inode ip) <ul>
<li>只是释放了当前thread对于该ip的占有，不意味着该ip对本thread已经无用，意味着稍后该ip仍会存在于inode cache，不会从inode cache中踢出。长此会造成inode cache满。</li>
</ul>
</li>
<li>iunlockput(inode ip) <ul>
<li>iunlock (inode) : 不但释放了当前thread对于该ip的占有</li>
<li>iput(inode) : 还多了一步，也即释放了本thread对于ip的引用（通过减小ip的ref）<ul>
<li>意味着本thread再也不会引用该ip。如此，ip的ref引用计数降至0，那么该ip就可以从inodecache中替换走。</li>
</ul>
</li>
</ul>
</li>
<li>不过我还是不知道为什么这样会造成panic virtio_disk_intr status。我以为应当造成的是iget: no inodes。</li>
</ul>
</li>
</ul>
<ul>
<li>拿下<br><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-09-44-23.png"></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>话说path追踪的时候会用到entry吗？<br>会。<br>最一开始的directory inode 如何得到 ？<br>  开始path追踪时，会天然的得到path最一开始所在的目录inode<br>  因为该path 要么是一个绝对路径（从root’/‘开始），要么是一个相对路劲（从本目录开始），这两个都可以直接得到。<br>如何用到entry？<br>追踪时会扫描当前追踪到的directoy inode的entry，检查是否有path中的目标下一级（根据name是否是下一级目标enrty）的entry。<br>如果有，则使用该entry（通过inum）索引到的inode，继续遍历该direcoty inode。<br>如果该inode不是directry inode，且name等于path的最后一级元素，则搜索inode成功。</p>
<h3 id="文件表-文件描述符表-file-inode"><a href="#文件表-文件描述符表-file-inode" class="headerlink" title="文件表 文件描述符表 file inode"></a>文件表 文件描述符表 file inode</h3><ul>
<li><p><strong>对比一下Linux中的概念</strong></p>
</li>
<li><p>Linux中的<strong>全局的文件表</strong>，在xv6中体现为<strong>全局的ftable</strong></p>
<ul>
<li><strong>所有打开的文件以struct file的形式都存在于ftable</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>每个进程的文件描述符表</strong></p>
<ul>
<li>fd table</li>
<li>&lt;fd - struct file *&gt; </li>
<li><strong>fd table 的 file* 指向ftable里的 file</strong>。struct file又指向inode<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-11-25-56.png"></p>
</li>
</ul>
<ul>
<li><strong>我们用户程序是如何使用file的？</strong><ul>
<li><strong>打开file并以fd来引用他</strong></li>
<li><strong>open -&gt; sys_open</strong>   <ul>
<li>sys_open <ul>
<li><ol>
<li>创建(create)/找到(namei)已有文件</li>
</ol>
</li>
<li><ol start="2">
<li><strong>从全局的ftable中分配free struct file 作为该文件结构体</strong></li>
</ol>
<ul>
<li><strong>filealloc()</strong></li>
</ul>
</li>
<li><ol start="3">
<li><strong>从进程的fd表ofile中分配fd来给该struct file*。也即，在fd表中记录了fd-struct file*</strong></li>
</ol>
<ul>
<li><strong>fdalloc()</strong></li>
</ul>
</li>
<li><ol start="4">
<li>设置struct file的一些metadata如权限</li>
</ol>
</li>
<li><ol start="5">
<li>return fd to user</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>之后用户在即可<strong>通过fd来引用文件</strong>。<ul>
<li>fd -&gt; struct file -&gt; inode</li>
</ul>
</li>
<li>如read(fd, &amp;de, sizeof(de)<ul>
<li><strong>read -&gt; sys_read</strong><blockquote>
<p><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-11-10-18.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>name是inode的属性吗？</strong></p>
<ul>
<li>不是的。name是entry的属性。entry通过inum索引到inode。</li>
<li>entry(name,inum)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  文件夹中的一系列entry 而非 文件夹</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">ushort inum;    <span class="comment">//  用于索引inode</span></span><br><span class="line"><span class="keyword">char</span> name[DIRSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>我们在<strong>目录下看到的，实际上是一个个条目entry</strong>。ls时是读取了并打印了目录下的所有entry。</p>
<blockquote>
<p><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-10-38-30.png"></p>
</blockquote>
</li>
<li><p>directory 和 entry 和 其他inode的关系<br><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-11-42-41.png"></p>
</li>
</ul>
<h3 id="硬链接、软链接"><a href="#硬链接、软链接" class="headerlink" title="硬链接、软链接"></a>硬链接、软链接</h3><ul>
<li><strong>什么是硬链接？</strong><ul>
<li><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-10-03-32.png"></li>
<li>name是entry的属性；hardlink是inode(dinode)的属性。</li>
<li><strong>硬链接：引用本inode的entry的数量</strong><ul>
<li>entry是真实存在于disk上的结构,断电之后还会保存在磁盘里面</li>
<li>一个entry指向一个inode，就是该inode一条硬链接hardlink。</li>
<li>多个entry指向同一个inode，就是该inode的多条hardlink。</li>
<li>hardlink!=0时，该disk上的dinode就不会被释放。当nlink = 0时，就在disk上真正释放该inode。xv6中相关函数为iput。</li>
</ul>
</li>
<li>可以看到，硬链接并不是文件，也即并不是inode，不以inode的形式存在。而是作为directory inode的数据存在于其datablock中。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>什么是软链接?</strong><ul>
<li>与硬链接不同，硬链接是entry，而<strong>软链接是个文件，以inode的形式存在</strong></li>
<li><strong>软链接的datablock中存储的是 target inode path</strong></li>
<li>通过open访问软链接inode时，通过其datablock的存储的路径去访问那个路径对应的inode。<br><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-07-11-37-47.png"></li>
</ul>
</li>
</ul>
<ul>
<li><strong>如何利用path找到对应inode的？</strong><ul>
<li>接口：namex(path)</li>
<li>namex(path) -&gt; dirlookup(dp,name) -&gt; iget(inum)</li>
<li>将path一级级，逐级拆分出一个个name。</li>
<li>在每一级拆分出一个name之后，<ul>
<li>通过dirlookup在当前directory inode下查找出name对应entry，进而得到inum。<ul>
<li>dirlookup 遍历directory inode的datablock的entry</li>
</ul>
</li>
<li>得到inum之后，通过iget(inum)，遍历inode cache，(从中找出/从磁盘加载出)inum匹配的inode</li>
<li>在非最后一轮，得到的inode应该是个directory inode</li>
</ul>
</li>
<li>拆解到最后一轮，iget所得到的inode就是path最后一个element的inode。</li>
</ul>
</li>
</ul>
<p><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2023-03-03-12-56-39.png"></p>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-thread</title>
    <url>/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/</url>
    <content><![CDATA[<ul>
<li><p>线程调度流程 : user thread A -&gt; kernel thread A -&gt; scheduler thread -&gt; kernel thread B -&gt; user thread B<br><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-19-12-06.png"></p>
</li>
<li><p>xv6和OS的线程调度策略 : pre-emptive scheduling(定时器中断) + voluntary scheduling(kernel thread主动swtch)</p>
</li>
<li><p>xv6的3个thread  </p>
<ul>
<li>user process的user thread (上下文在trapframe)</li>
<li>user process的kernel thread (上下文在trapframe和context)</li>
<li>每个cpu核 的 scheduler thread (上下文在cpu.context)</li>
</ul>
</li>
<li><p>thread切换核心 : swtch</p>
<ul>
<li>用于实现 kernel thread 和 scheduler thread的切换</li>
<li>切换return addr , kernel stack pointer , callee saved regs</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><h2 id="待完成问题"><a href="#待完成问题" class="headerlink" title="待完成问题"></a>待完成问题</h2><ul>
<li><p><strong>线程是什么？</strong></p>
<ul>
<li>从几个角度来说吧应该。</li>
<li>先列下来。</li>
<li>从构成的角度来说<ul>
<li>。。。与progress对比一下。</li>
<li>thread是process中的一条指令流，使用process的地址空间及其他context。每个thread都应当有自己的stack。thread之间应当是共享process的地址空间的。</li>
<li>os应当支持一个用户进程的一个用户线程对应一个内核线程。xv6中内核线程和用户线程不是共享地址空间的。一个是user pagetable，一个是kernel pagetable。正常linux来说，也即在我们做完实验3page table之后的页表机制，user thread和kernel thread用的都是同一个pagetable。</li>
<li>感觉说的有待完善。。。。</li>
</ul>
</li>
<li>从编程的角度来说<ul>
<li>是os提供的一种执行多任务的抽象机制。</li>
<li>类似于event-driven progarmming中的reactor模型等。都是执行多个任务的逻辑流。</li>
<li>在所有的支持多任务的方法中，线程技术并不是非常有效的方法，但是线程通常是最方便，对程序员最友好的，并且可以用来支持大量不同任务的方法。</li>
<li>感觉可以再多说一点reactor模型相关的。。太累了。。改天复习reactor模型。</li>
</ul>
</li>
</ul>
</li>
<li><p>switch的ret什么时候执行？当再次切换回来的时候执行？</p>
<ul>
<li>不对，是顺序执行的。只不过由于$ra被改变，ret的时候会ret到另一处对swtch的调用处</li>
</ul>
</li>
<li><p>switch ret之前cpu使用的就变成了另一个线程的栈？可是pc也没有改变呀？如何做到的？</p>
<ul>
<li>pc不含有效信息，指示栈的就是$sp</li>
</ul>
</li>
<li><p>xv6进程和线程的关系？</p>
<ul>
<li><strong>process由2个thread组成</strong>  <ul>
<li>user thread</li>
<li>kernel thread</li>
</ul>
</li>
<li>且存在限制，一个进程要么是其user thread 在运行，要么是在kernel thread运行(系统调用/响应中断)，要么不运行。永远不会2个thread同时运行。</li>
</ul>
</li>
<li><p>所以说kernel的那个proc结构体 实际上是kenrel thread的结构体是吗？</p>
<ul>
<li>不只是。<strong>proc是整个process的结构体</strong>。</li>
<li>其中记录了<ul>
<li><strong>process本身的状态信息</strong>，如pid , state , parent process , name等</li>
<li>和process中的<strong>user thread</strong>的所用的user pagetable , user的heap大小 , user的trapframe等</li>
<li>以及process中的<strong>kernel thread 的context</strong>等。(用于kernel thread 在swtch保存前一刻kernel thread的状态)</li>
</ul>
</li>
<li>所以，通过mycpu()，我们可以获得当前正在运行的线程所属的process。不过从逻辑上来讲，我们也就不应当在scheduler thread中调用mycpu()。因为scheduler不属于任何process。是单独的一个线程。</li>
</ul>
</li>
<li><p>说说kernel thread到底是个啥</p>
<ul>
<li>感觉就是进入kernel的C code之后，调用kernel的C code，所形成的函数栈帧。</li>
</ul>
</li>
<li><p>intena记录在acquire之前的中断状态</p>
</li>
<li><p>一个进程让出之后，会不会又运行这个进程？</p>
</li>
<li><p>struct proc proc[NPROC = 64];</p>
<ul>
<li>至多有64个process，故至多有64个user thread 和64个kernel thread(64个kstack) + 每个cpu核上一个scheduler thread+带的kstack。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>xv6里一个进程的用户线程和内核线程</strong>也不是共享地址空间的啊。页表都不一样。为啥教授还说是一个进程里的用户线程和内核线程？ </p>
<ul>
<li>在xv6中，这两个线程比较特殊，确实不是共享地址空间。</li>
<li>但是对于主流的linux系统，其pagetable的机制就和我们在page table实验所完成的一样。user thread 和 kernel thread使用的是同一个page table。</li>
</ul>
</li>
<li><p>切换地址空间了是不是就是代表一定切换进程了？那么从user到kernel是否应当叫做切换了进程？用户进程切换到内核进程。</p>
<ul>
<li>不应当。都是一个进程里的。原因见上。</li>
</ul>
</li>
<li><p>linux进程的线程的pagetable是不是分开的？是么？不是吧？</p>
<ul>
<li>我觉得一个进程的多个线程共用同一个的pagetable。没验证。。。改天验证。。。太累了。。。仅仅是觉得。。。。</li>
</ul>
</li>
</ul>
<h2 id="thread-概述"><a href="#thread-概述" class="headerlink" title="thread 概述"></a>thread 概述</h2><ul>
<li><p><strong>线程的作用</strong> / 为什么计算机需要多线程？</p>
<ul>
<li><strong>首先</strong>，我们可能会要求计算机<strong>分时复用</strong>的执行任务，而不是在一段时间里只执行一个任务</li>
<li><strong>其次</strong>，多线程可以让程序的<strong>结构</strong>变得<strong>简单</strong>。</li>
<li><strong>最后</strong>，使用多线程可以<strong>利用多核cpu</strong>以获得更快的速度。<ul>
<li>常见的做法是将程序进程拆分，分给多个线程运行，运行在不同的cpu核上。</li>
</ul>
</li>
<li>线程可以认为是一种在有<strong>多个任务</strong>时，用于<strong>简化编程的一种抽象机制</strong>。<ul>
<li>感觉也是一种<strong>event-driven programming</strong> 编程模型。</li>
<li>event-driven programming或者state machine，这些是在一台计算机上<strong>不使用线程但又能运行多个任务</strong>的技术。</li>
<li>在所有的支持多任务的方法中，线程技术并不是非常有效的方法，但是线程通常是最方便，对程序员最友好的，并且可以用来支持大量不同任务的方法。<ul>
<li>所以那些事务驱动模型，如单线程的reactor 实际上不也是个并发的程序？也是个执行多任务的编程方法。只不过不是os自己提供的抽象出来的线程，而是用户自己通过代码实现的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>线程的状态</strong></p>
<ul>
<li>程序计数器PC: 当前线程执行的指令位置</li>
<li>保存变量的寄存器reg。</li>
<li>程序栈stack: 每个线程都有自己的stack，stack记录了函数调用过程，并反应了当前线程的执行点。</li>
<li>变量</li>
<li>堆</li>
<li>….</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>如何管理多个线程</strong>运行？两种策略结合</p>
<ul>
<li><ol>
<li>利用<strong>多核cpu</strong>，每个cpu上运行一个thread</li>
</ol>
</li>
<li><ol start="2">
<li><strong>一个cpu在多个thread</strong>之间来回切换。</li>
</ol>
</li>
</ul>
</li>
<li><p>xv6的thread<strong>是否共享内存</strong></p>
<ul>
<li><strong>内核线程 kernel thread</strong><ul>
<li>所有kernel thread共享内核内存。</li>
<li>每一个用户进程都有个kernel thread执行来自用户线程的syscall</li>
</ul>
</li>
<li><strong>用户线程 user thread</strong><ul>
<li>用户线程之间没有共享内存。</li>
<li>每个用户进程都有独立的地址空间，并且包含了一个user thread，user thread控制了user process code的执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux中</p>
<ul>
<li>实现了一个用户进程中包含多个线程（xv6没有实现，xv6中一个进程只有一个用户线程）</li>
<li>一个进程的多个线程共享地址空间。</li>
</ul>
</li>
</ul>
<h2 id="thread切换流程"><a href="#thread切换流程" class="headerlink" title="thread切换流程"></a>thread切换流程</h2><ul>
<li>流程图镇楼<ul>
<li><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-19-12-06.png"></li>
<li>当进入kernel的C code之后，运行的就是process 的 kernel thread了。</li>
</ul>
</li>
</ul>
<p>如何实现thread切换？：scheduler调度器<br>如何保存线程状态并恢复？：那些是需要保存的、保存在哪里<br>如何处理计算密集型线程？：对于长时间的计算任务，线程不会自愿的让出cpu给其他线程运行，所以需要一种机制，能夺走计算密集型线程对cpu的控制，之后再运行。</p>
<ul>
<li><p>下面是<strong>如何处理计算密集型任务</strong>。</p>
<h3 id="定时器机制"><a href="#定时器机制" class="headerlink" title="定时器机制"></a>定时器机制</h3></li>
<li><p>机制：<strong>利用定时器中断</strong></p>
<ul>
<li>内核利用定时器中断将对cpu的控制从计算密集型线程的手中夺走</li>
<li>每个cpu核上，都存在一个硬件设备，会定时产生中断。xv6与其他os一样，将这个中断传输到了kernel中。中断打断并处理如下<blockquote>
<p><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-12-02-06.png"><br><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-12-01-47.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="流程概述-pre-emptive-voluntary-scheduling"><a href="#流程概述-pre-emptive-voluntary-scheduling" class="headerlink" title="流程概述 pre-emptive / voluntary scheduling"></a>流程概述 pre-emptive / voluntary scheduling</h3><ul>
<li><p><strong>pre-emptive scheduling 抢占式调度：</strong></p>
<ul>
<li>用户代码本身不想让出cpu，但是timer interrupt会导致cpu的控制权被拿走，yield给scheduler thread，<ul>
<li>例如中断处理的流程。</li>
</ul>
</li>
<li>相反的是<strong>voluntary scheduling 非抢占式调度</strong></li>
</ul>
</li>
<li><p><strong>在xv6和其他os中，线程调度这样实现</strong></p>
<ul>
<li><strong>pre-emptive 和 voluntary的结合</strong></li>
<li><strong>定时器中断 会强制的将cpu控制权从user process(的user thread)传递到kernel (user process的kernel thread)，之后kernel会代表user process 进行 voluntary scheduling。</strong><ul>
<li><strong>pre-emptive</strong>：中断的强制，哪怕这些用户进程一直占用cpu不愿让开，通过中断，kernel也可以从user process夺得cpu控制权。</li>
<li><strong>voluntary</strong>：kernel如何代表user process使用voluntary scheduling ? <ul>
<li><strong>kernel thread</strong>内核线程 的 timer interrupt handler 会将 cpu 让<strong>s(yield)给 scheduler thread调度器线程</strong>。<strong>通过swtch</strong><ul>
<li>这就是kernel 代表 user process 进行 voluntary的让出了cpu</li>
<li>如何yield：保存当前cpu上正在运行的内核线程。,将scheduler thread的上下文替换到当前cpu上.</li>
</ul>
</li>
<li>然后<strong>scheduler thread 会选择一个runnable的kernel thread 并swtch到cpu上</strong>。<ul>
<li>这也就是 kernel 代表 user process 进行 voluntary的 将 控制 传递给了 另一个 user process</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>尽管我们这节课主要是基于定时器中断来讨论，但是实际上XV6切换线程的绝大部分场景都不是因为定时器中断，比如说一些系统调用在等待一些事件并决定让出CPU。exit系统调用会做各种操作然后调用yield函数来出让CPU，这里的出让并不依赖定时器中断</p>
</li>
<li><p>相关的进程状态</p>
<ul>
<li>RUNNING：线程正在当前cpu上运行<ul>
<li>PC和reg在cpu中，正在被使用</li>
</ul>
</li>
<li>RUNNABLE：线程还没有在某个cpu上运行，一旦有空闲的cpu就可以运行<ul>
<li>PC和reg被保存在内存中某处。</li>
</ul>
</li>
<li>SLEEPING：线程在等待一些IO事件，只会在IO事件发生了以后运行。</li>
<li>线程调度就是将当前的running process 变成 runnable process</li>
</ul>
</li>
</ul>
<h3 id="一些需要注意的东西"><a href="#一些需要注意的东西" class="headerlink" title="一些需要注意的东西"></a>一些需要注意的东西</h3><ul>
<li><p><strong>xv6中总共有3种thread</strong></p>
<ul>
<li><strong>user process的user thread</strong><ul>
<li>在不运行时，其线程状态会保存在trapframe中</li>
<li>有自己的用户栈</li>
</ul>
</li>
<li><strong>user process的kernel thread</strong><ul>
<li>在不运行时，其线程状态会保存在proc.context中</li>
<li>有自己的内核栈</li>
</ul>
</li>
<li><strong>每个cpu核 的 scheduler thread</strong><ul>
<li>在不运行时，其线程状态会保存在cpu.context中</li>
<li>每个scheduler thread都有自己独立的栈。scheduler thread的所有内容，都和user thread不一样。是在系统启动时设计好的。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进程 process</strong></p>
<ul>
<li><strong>process由2个thread组成</strong><ul>
<li>user thread</li>
<li>kernel thread</li>
</ul>
</li>
<li>且存在限制，一个进程要么是其user thread 在运行，要么是在kernel thread运行(系统调用/响应中断)，要么不运行。永远不会2个thread同时运行。</li>
</ul>
</li>
</ul>
<ul>
<li><p>xv6并没有实现用户线程直接让出cpu，<strong>内核会在如下场景下让出cpu</strong></p>
<ul>
<li>定时器触发<ul>
<li>内核总是会让当前进程yield出cpu，因为我们需要交织执行所有可执行的线程。</li>
</ul>
</li>
<li>调用系统调用并等待I/O<ul>
<li>如进程调用syscall read进入kernel，read会等待磁盘IO，此时read syscall code-&gt;sleep()-&gt;sched()-&gt;swtch()</li>
</ul>
</li>
</ul>
</li>
<li><p>所谓的<strong>context switching</strong></p>
<ul>
<li>一个 thread 切换到 另一个 thread</li>
<li>一个 user process 切换到 另一个 user process的完整过程。</li>
<li>用户空间和内核空间的切换</li>
<li>内核线程kernel thread和调度器线程scheduler thread的切换</li>
</ul>
</li>
<li><p><strong>小结</strong></p>
<ul>
<li>一个cpu核在同一时间只会做一件事情，也即只会运行一个线程，线程切换造成了多个线程同时运行在一个cpu核上的假象。<ul>
<li>user process的user thread</li>
<li>user process的kernel thread</li>
<li>cpu核 的 scheduler thread</li>
</ul>
</li>
<li>一个thread不会同时运行在多个cpu核上<ul>
<li>要么运行在一个cpu核上</li>
<li>要么状态被保存在context(kernel thread)/ trapframe(user thread)中，没有被运行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="thread切换核心-swtch"><a href="#thread切换核心-swtch" class="headerlink" title="thread切换核心 : swtch"></a>thread切换核心 : swtch</h3><ul>
<li><p><strong>thread切换的核心</strong></p>
</li>
<li><p><strong>swtch</strong></p>
<ul>
<li>void swtch(struct context *old, struct context *new);</li>
<li>Save current registers in old. Load from new.    </li>
<li>将当前cpu上的reg保存在old中，并将new加载到cpu的reg上</li>
<li>这也就是 实现了 所谓的 context switching的函数，用于在kernel thread 和 scheduler thread之间进行上下文切换。</li>
<li>调用情况如下：<ul>
<li>p-&gt;context 是 kernel thread的上下文。mycpu()-&gt;context 是该cpu核的scheduler thread 上下文。</li>
<li>sched中：swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<ul>
<li><code>cpu reg ----store into---&gt; kernel thread.context (mem)</code></li>
<li><code>scheduler context (mem) ----load into---&gt; cpu reg</code> </li>
</ul>
</li>
<li>scheduler：swtch(&amp;c-&gt;context, &amp;p-&gt;context);<ul>
<li><code>cpu reg ----store into---&gt; scheduler context (mem)</code> </li>
<li><code>kernel thread.context (mem) ----load into---&gt; cpu reg</code></li>
</ul>
</li>
</ul>
</li>
<li>所谓的保存到mem和加载到reg的<strong>context</strong>是<ul>
<li><strong>$ra</strong> : ret的返回地址</li>
<li><strong>$sp</strong> : thread对应的stack pointer</li>
<li><strong>s[1,11]</strong> : 被调用者保存的寄存器</li>
<li>并没有保存PC，因为PC并不是有效信息，随着code执行，PC会一直改变，没意义。我们关心的应当是swtch之后，thread应道跳到哪行code继续执行，以及其函数栈帧。那么，所要关注的寄存器就是ra和sp</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>code如下：kernel thread -&gt; scheduler thread</strong></p>
<ul>
<li>kernel thread 由 usertrap -&gt; yield -&gt; sched -&gt; swtch</li>
<li>在swtch中 保存kernel thread context 并加载 scheduler thread context<ul>
<li><blockquote>
<p><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-14-09-09.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-13-02-18.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>可以看到，在将scheduler的ra以及sp加载cpu reg之后，ret的返回地址以及函数调用栈帧bt都变成了scheduler thread的。</li>
<li>swtch —ret–&gt; scheduler thread<ul>
<li><blockquote>
<p><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-14-32-13.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-14-16-29.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-14-18-51.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>同理：scheduler thread -&gt; kernel thread</strong><ul>
<li><blockquote>
<p><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-14-36-18.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-14-35-00.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：<strong>scheduler thread 调用了swtch函数，但是我们从swtch函数返回时，实际上是返回到了对于switch的另一个调用处：kenrel thread 对swtch的调用处</strong>，而不是scheduler thread的调用。</p>
<ul>
<li>通过改变ra来达成此种效果，也就达成了切换线程的效果。</li>
<li>也即，比如kernel thread a调用swtch，由于在swtch对ra以及其他context进行了替换，故这个swtch函数结束后，ret就跳转到了另一处代码。非本次swtch调用处，而是scheduler 对 swtch的调用处。</li>
</ul>
</li>
<li><p>thread切换过程中，<strong>cpu上的reg是唯一不稳定的状态，需要保存并恢复</strong>，因为我们想在新的线程中也使用相同的一组寄存器；而所有其他在内存中的数据（如heap、stack）会保存在内存中不被改变，所以不用特意保存并恢复。</p>
</li>
</ul>
<h3 id="scheduler-thread"><a href="#scheduler-thread" class="headerlink" title="scheduler thread"></a>scheduler thread</h3><ul>
<li><strong>下面是scheduler函数</strong><ul>
<li>选择一个runnable的进程，将其context替换进cpu，然后运行。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">scheduler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    <span class="keyword">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) </span><br><span class="line">    &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) </span><br><span class="line">    &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == RUNNABLE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  令cpu运行kernel thread p</span></span><br><span class="line">        <span class="comment">//  即将运行p，故先设置状态为RUNNING</span></span><br><span class="line">        p-&gt;state = RUNNING;   </span><br><span class="line">        <span class="comment">//  即将运行p，故先设置cpu上正在运行的proc为p</span></span><br><span class="line">        c-&gt;proc = p;          </span><br><span class="line">        <span class="comment">//  context switching , 切换到kernel thread p。之后cpu run kernel thread</span></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);  </span><br><span class="line">        <span class="comment">//  after a while</span></span><br><span class="line">        <span class="comment">//  从swtch返回。</span></span><br><span class="line">        <span class="comment">//  kernel thread p 切换回 scheduler thread</span></span><br><span class="line">        <span class="comment">//  此时cpu上没有任何正在运行的kernel thread 和 user thread。只有scheduler thread</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) </span><br><span class="line">    &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">    intr_on();</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="关于lock"><a href="#关于lock" class="headerlink" title="关于lock"></a>关于lock</h4><ul>
<li><p><strong>关于锁p-&gt;lock的使用</strong></p>
</li>
<li><p>acquire(p-&gt;lock) release(p-&gt;lock)<strong>流程</strong>如下</p>
<ul>
<li>从kernel thread -&gt; scheduler<ul>
<li>kernel thread yield 上的锁 由 切换到 scheduler的swtch之后 释放 </li>
</ul>
</li>
<li>从scheduler -&gt; kernel thread<ul>
<li>scheduler 上的锁 由 切换到 kernel thread的swtch之后 释放。</li>
</ul>
</li>
<li><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-15-38-54.png"></li>
</ul>
</li>
<li><p><strong>p-&gt;lock作用</strong></p>
<ul>
<li>在以下两个场景中，都是为了<strong>线程切换的原子性</strong>。<ul>
<li>防止在我们这个线程切换还没完成的时候，另一个cpu核上的scheduler thread看到并使用该线程。</li>
</ul>
</li>
<li><strong>线程切换步骤概述：设置p-&gt;state，保存当前thread context，替换成要切换的thread的context</strong></li>
<li><strong>1. kernel thread -&gt; schedulers</strong><ul>
<li><ol>
<li>p-&gt;state = RUNNABLE;</li>
</ol>
</li>
<li><ol start="2">
<li>swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);</li>
</ol>
<ul>
<li>2.1 将当前kernel thread的context保存($ra,$sp,regs)</li>
<li>2.2 cpu上的reg替换成scheduler thread的context。</li>
</ul>
</li>
</ul>
</li>
<li><strong>2. scheduler -&gt; kernel thread</strong><ul>
<li><ol>
<li>p-&gt;state = RUNNING</li>
</ol>
</li>
<li><ol start="2">
<li>swtch(&amp;c-&gt;context, &amp;p-&gt;context);  </li>
</ol>
<ul>
<li>2.1 将当前scheduler thread的context保存($ra,$sp,regs)</li>
<li>2.2 cpu上的reg替换成kernel thread的context。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对每个proc的第一次swtch"><a href="#对每个proc的第一次swtch" class="headerlink" title="对每个proc的第一次swtch"></a>对每个proc的第一次swtch</h2><ul>
<li><p>allocproc中为什么要设置context？为了scheduler对被分配的proc的第一次swtch。</p>
<ul>
<li>刚变成runnable的proc还没有被放在cpu上运行。其变成running需要由scheduler thread调度。scheduler通过swtch将runnable thread.context替换到cpu上。</li>
<li>一般情况下，runnable thread.context 是该thread对应的proc的kernel thread在sched的时候，通过swtch将自身context保存起来，以待下次scheduler调度到该thread时替换进来。</li>
<li>可是，对于该proc第一次由runnable变成running，被scheduler调度，其context则不是由上次swtch保存好的，而是由allocproc中，对$ra和$sp进行的初始化。ra初始化成forkret-&gt;usertrapret。$sp自然就是本kernel thread的ktsack。</li>
</ul>
</li>
<li><p>allocproc 会被 启动时的userinit和系统调用fork调用</p>
</li>
<li><p>fork调用allocproc</p>
<ul>
<li><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-16-33-44.png"></li>
</ul>
</li>
<li><p>allocproc</p>
<ul>
<li><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-18-13-08.png"></li>
</ul>
</li>
<li><p><strong>一个process刚被fork出来的时候，一直处于内核态kernel thread ，且没有被运行。直到scheduler之后，才会swtch到该process。由于一开始刚fork出来时设置的ra为forkret，因此回swtch到process的forkret，然后usertrapret 经由trampoline到process的user thread，开始运行。</strong></p>
</li>
</ul>
<h2 id="Linux-如何区分进程和线程"><a href="#Linux-如何区分进程和线程" class="headerlink" title="Linux 如何区分进程和线程"></a>Linux 如何区分进程和线程</h2><ul>
<li>process 和 thread在 linux kernel中都是通过task_struct表述，那么linux kernel如何区分一个task_struct 代表的是process还是thread ？ <ul>
<li>通过比较tgid和pid。相等，则为进程；不等，则为线程。</li>
<li><img src="/2022/11/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-thread/2022-11-22-20-43-33.png"></li>
</ul>
</li>
<li>tgid : thread group ID<ul>
<li>任何一个process，如果只有一个main thread，那么，tgid = pid（即为process A.pid）。</li>
<li>但是，如果一个process A创建了其他线程a1。那么thread a1有自己的pid，而thread a1.tgid = main thread.pid（即为process A.pid）。<ul>
<li>一个thread group中的所有thread使用和该thread group leader相同的PID，并被存放在tgid成员中。</li>
<li>只有leader的pid设置为=tgid。</li>
</ul>
</li>
<li>getpid()系统调用返回的是当前thread的tgid值而不是pid值。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-文件系统2</title>
    <url>/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2/</url>
    <content><![CDATA[<p>创建写入文件例子<br>有待复习</p>
<span id="more"></span>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li><p>分为3个阶段</p>
<ul>
<li><ol>
<li>创建文件</li>
</ol>
</li>
<li><ol start="2">
<li>将”hi”写入文件</li>
</ol>
</li>
<li><ol start="3">
<li>将”\n”写入文件</li>
</ol>
</li>
</ul>
</li>
<li><p>echo “hi” &gt; x<br><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2/2022-12-01-09-57-19.png"></p>
</li>
<li><p>createfile</p>
<ul>
<li><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2/2022-12-06-17-42-26.png"></li>
<li><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2/2022-12-06-17-42-21.png"></li>
<li>write 33 : 将filex inode标记为将要被使用<ul>
<li>sys_open -&gt; create -&gt; ialloc分配inode -&gt; dip-&gt;type = type -&gt; log_write保存修改</li>
</ul>
</li>
<li>write 33 : 修改filex inode的link等属性<ul>
<li>sys_open -&gt; create -&gt; ip-&gt;nlink = 1; -&gt;iupdate -&gt; log_write保存修改</li>
</ul>
</li>
<li>write 70 : 写父目录的data block，也即新增的一个entry：包含了filex name以及inode编号。<ul>
<li>sys_open -&gt; create -&gt; dirlink(parent_inode,name,node-&gt;inum) 写根目录的data block -&gt; logwrite保存修改</li>
</ul>
</li>
<li>write 32 : 写父目录的inode。因为大小改变<ul>
<li>sys_open -&gt; create -&gt; dirlink 写根目录的inode -&gt; logwrite保存</li>
</ul>
</li>
<li>write 33 : 再次更新了文件x的inode<ul>
<li>新文件的inode所引用的block大小置为0</li>
</ul>
</li>
</ul>
</li>
<li><p>write “hi” to file</p>
<ul>
<li><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2/2022-12-06-17-51-49.png"></li>
<li>write 45 : 寻找free的datablock 并更新bitmap<ul>
<li>sys_write -&gt; filewrite -&gt; writei -&gt; bmap -&gt; balloc分配block，修改bitmap的相应标志位 -&gt; log_write保存</li>
</ul>
</li>
<li>write 595 : 上一步在bitmap中找到的datablock的free data block是595<ul>
<li>sys_write -&gt; filewrite -&gt; writei -&gt; copyin -&gt; log_write保存修改</li>
</ul>
</li>
<li>write 595 : 同上一步</li>
<li>write 33 : 更新inode.size；direct block number 1st = 595<ul>
<li>这两个信息都会通过write 33一次更新到磁盘上的inode中</li>
</ul>
</li>
</ul>
</li>
<li><p>write “\n” to file</p>
<ul>
<li><img src="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2/2022-12-06-17-53-13.png"></li>
<li>write 595 : 上一步在bitmap中找到的datablock的free data block是595<ul>
<li>sys_write -&gt; filewrite -&gt; writei -&gt; copyin -&gt; log_write保存修改</li>
</ul>
</li>
<li>write 33 : 更新inode.size；</li>
</ul>
</li>
</ul>
<h3 id="并发举例-bget并发"><a href="#并发举例-bget并发" class="headerlink" title="并发举例:bget并发"></a>并发举例:bget并发</h3><ul>
<li>关于<strong>多个process同时create</strong>，其并发的正确性在bread-&gt;bget得到保证。<ul>
<li><blockquote>
<p>情况举例：有多个进程同时调用bget的话，其中一个可以获取bcache.lock并扫描buffer cache list。此时，其他进程是没有办法修改buffer cache list的。之后，进程会查找block numberX是否被缓存在buffer cache list中。如果在的话将block cache的ref_cnt加1，表明当前进程对block cache有引用，之后再释放bcache的锁。如果有第二个进程也想扫描buffer cache list，那么这时它就可以获取bcache.lock。假设第二个进程也要获取block numberX的cache，那么它也会对相应的block cache的引用计数加1。最后这两个进程都会尝试对block 33的block cache调用acquiresleep函数。</p>
</blockquote>
</li>
<li>struct bcache和buf 详情见后文。</li>
<li><strong>bcache.lock : 保护buf list</strong><ul>
<li>如果要修改buf list的结构 及其上的 buf meta信息，必须先acquire(&amp;bcache.lock)</li>
</ul>
</li>
<li><strong>buf.lock : 保护block cache自身</strong><ul>
<li>也即在保护struct buf.data[BSIZE]。要访问data[BSIZE],必须先acquiresleep(&amp;b-&gt;lock);<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct buf*</span></span><br><span class="line"><span class="function"><span class="title">bget</span><span class="params">(uint dev, uint blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    acquire(&amp;bcache.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the block already cached?</span></span><br><span class="line">    <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">        b-&gt;refcnt++;</span><br><span class="line">        release(&amp;bcache.lock);</span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not cached.</span></span><br><span class="line">    <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">    <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">        b-&gt;dev = dev;</span><br><span class="line">        b-&gt;blockno = blockno;</span><br><span class="line">        b-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">        release(&amp;bcache.lock);</span><br><span class="line">        acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="sleeplock"><a href="#sleeplock" class="headerlink" title="sleeplock"></a>sleeplock</h2><ul>
<li><p>acquiresleep</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquiresleep</span><span class="params">(struct sleeplock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    acquire(&amp;lk-&gt;lk);</span><br><span class="line">    <span class="keyword">while</span> (lk-&gt;locked) &#123;</span><br><span class="line">        sleep(lk, &amp;lk-&gt;lk);</span><br><span class="line">    &#125;</span><br><span class="line">    lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">    lk-&gt;pid = myproc()-&gt;pid;</span><br><span class="line">    release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>由上可知，sleeplock就是比spinlock多了个切换线程，那么<strong>为什么block cache 也即 struct buf 使用 sleeplock ?</strong></p>
<ul>
<li>在持有spinlock的过程中会关闭中断，而磁盘读取完成会发起中断。如果buf使用spinlock，那么就我们就永远收不到来自磁盘的中断，也就无法从磁盘读取数据。（至少对单核cpu是这样）</li>
<li>所以buf使用sleep lock，持有锁的时候不关闭中断。且当在阻塞在acquiresleep的时候，cpu并没有空转，而是将cpu让出。</li>
<li>(当中断发生时，另一个process（记当前正在cpu上运行的process）会进入 对于读取cpu完成的中断处理函数，该handler会通过wakeup唤醒刚才在sleeplock上等待读取数据的process。 )</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-debug方法</title>
    <url>/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>xv6 debug基本方法</p>
<span id="more"></span>

<h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><ul>
<li><a href="http://hitsz-cslab.gitee.io/os-labs/lab2/part5/#1-ecall">参考</a></li>
</ul>
<h2 id="调试kernel代码"><a href="#调试kernel代码" class="headerlink" title="调试kernel代码"></a>调试kernel代码</h2><h3 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h3><ul>
<li>.gdbinit  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> set confirm off</span><br><span class="line"><span class="number">2</span> set architecture riscv:rv64</span><br><span class="line"><span class="number">3</span> target remote <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">26000</span></span><br><span class="line"><span class="number">4</span> symbol-file kernel/kernel</span><br><span class="line"><span class="number">5</span> set disassemble-next-line <span class="keyword">auto</span></span><br><span class="line"><span class="number">6</span> set riscv use-compressed-breakpoints yes</span><br></pre></td></tr></table></figure></li>
<li>make qemu-gdb : 开启gdb server</li>
<li>gdb-multiarch : 连接gdb server</li>
<li><blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-29-22-29-14.png"></p>
</blockquote>
</li>
</ul>
<h3 id="VsCode"><a href="#VsCode" class="headerlink" title="VsCode"></a>VsCode</h3><ul>
<li>.gdbinit  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> set confirm off</span><br><span class="line"><span class="number">2</span> set architecture riscv:rv64</span><br><span class="line"><span class="number">3</span> <span class="meta"># target remote 127.0.0.1:26000</span></span><br><span class="line"><span class="number">4</span> symbol-file kernel/kernel</span><br><span class="line"><span class="number">5</span> <span class="meta"># symbol-file user/_ls</span></span><br><span class="line"><span class="number">6</span> set disassemble-next-line <span class="keyword">auto</span></span><br><span class="line"><span class="number">7</span> set riscv use-compressed-breakpoints yes</span><br></pre></td></tr></table></figure></li>
<li>terminal : make qemu-gdb CPUs=1</li>
<li>debug console : attach to gdbServer </li>
<li><blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-29-22-34-51.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-29-22-35-25.png"></p>
</blockquote>
</li>
</ul>
<h2 id="调试user代码"><a href="#调试user代码" class="headerlink" title="调试user代码"></a>调试user代码</h2><h3 id="Console-1"><a href="#Console-1" class="headerlink" title="Console"></a>Console</h3><ul>
<li>.gdbinit  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> set confirm off</span><br><span class="line"><span class="number">2</span> set architecture riscv:rv64</span><br><span class="line"><span class="number">3</span> target remote <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">26000</span></span><br><span class="line"><span class="number">4</span> <span class="meta"># symbol-file kernel/kernel</span></span><br><span class="line"><span class="number">5</span> symbol-file user/_ls</span><br><span class="line"><span class="number">6</span> set disassemble-next-line <span class="keyword">auto</span></span><br><span class="line"><span class="number">7</span> set riscv use-compressed-breakpoints yes</span><br></pre></td></tr></table></figure></li>
<li><blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-29-22-39-33.png"></p>
</blockquote>
</li>
</ul>
<h3 id="VsCode-1"><a href="#VsCode-1" class="headerlink" title="VsCode"></a>VsCode</h3><ul>
<li>Step1: terminal : make qemu-gdb。</li>
<li>Step2: 点击左侧按钮运行与调试，并点击左上角绿色三角（Attach to gdb)</li>
<li>Step3 : debug console : interrupt</li>
<li>Step5 : debug console : b *0x27a，即将断点置于ls程序入口</li>
<li>Step6 : debug console : file user/_ls。加载ls的调试符号 ; then continue</li>
<li>Step7 : terminal : (运行应用程序)ls</li>
<li>debug console  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reading symbols from /home/shc/OSLab/xv6-<span class="built_in">labs</span><span class="number">-2020</span>/kernel/kernel...</span><br><span class="line">The target architecture is assumed to be riscv:rv64</span><br><span class="line"><span class="number">0x0000000000001000</span> in ?? ()</span><br><span class="line">=&gt; <span class="number">0x0000000000001000</span>:	<span class="number">97</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>	auipc	t0,<span class="number">0x0</span></span><br><span class="line">**interrupt**</span><br><span class="line">Thread <span class="number">1</span> received signal SIGINT, Interrupt. scheduler () at kernel/proc.c:<span class="number">465</span> \n <span class="number">465</span>	    intr_on();</span><br><span class="line">**b *<span class="number">0x27a</span>**</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x27a</span></span><br><span class="line">**file user/_ls**</span><br><span class="line">Reading symbols from user/_ls...</span><br><span class="line">**c**</span><br><span class="line">Continuing.</span><br><span class="line">Thread <span class="number">2</span> hit Breakpoint <span class="number">1</span>, main (argc=<span class="number">0</span>, argv=<span class="number">0x6c</span> &lt;fmtname+<span class="number">108</span>&gt;) at user/ls.c:<span class="number">75</span></span><br><span class="line"><span class="number">75</span>	&#123;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过readelf确认应用程序入口点<img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-29-22-57-25.png"><br><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-29-22-58-24.png"></p>
</blockquote>
</li>
</ul>
<h2 id="调试系统调用-kernel-gt-user-gt-kernel"><a href="#调试系统调用-kernel-gt-user-gt-kernel" class="headerlink" title="调试系统调用 kernel -&gt; user -&gt; kernel"></a>调试系统调用 kernel -&gt; user -&gt; kernel</h2><ul>
<li><p>step1 : gdb client 连接 gdb server，一开始是kenrel。</p>
</li>
<li><p>step2 : 加载user文件,打断点</p>
<ul>
<li>file user/_ls ; break [line at user program使用的system call]</li>
<li><blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-30-18-42-06.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>step3 : break point at (你想要调试的系统调用)(这里时fstat syscall); and then breakpoint at ecall</strong></p>
<ul>
<li>bug : 按理来说这时候page table应该是user的page table，不知道为什么这里时kernel的page table ? </li>
<li>b 38 ; b [at ecall] (ecall的语义类似于x86-64的syscall)<blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-30-18-44-35.png"><br><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-30-18-45-43.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>step4 : 进入trampoline (进入kenrel前的最后阶段)</strong></p>
<ul>
<li><p><strong>break at start of trampoline</strong></p>
<blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-30-19-02-43.png"><br><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-30-18-46-57.png"></p>
</blockquote>
</li>
<li><p><strong>break at end of trampoline</strong> </p>
<blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-30-18-48-31.png"></p>
</blockquote>
<ul>
<li>如何知道trampoline最后jr t0的addr是0x3ffffff08e？<ul>
<li>x/40i $pc显示当前PC后面的40条汇编</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>si从trampoline中出来。进入kernel的usertrap</strong></p>
<ul>
<li>记得file kernel/kernel 因为现在要调试kernel<blockquote>
<p><img src="/2022/10/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%BB%93%E6%9E%84/2022-10-30-18-50-16.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>step5: 成功进入kernel，接下来就是正常的调试 kernel的C code</p>
</li>
</ul>
<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-xv6-文件系统(日志)</title>
    <url>/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ul>
<li>xv6文件系统解析<ul>
<li>重点在bcache和log</li>
<li>有待复习</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="问题及解释"><a href="#问题及解释" class="headerlink" title="问题及解释"></a>问题及解释</h2><p>一句话描述：如何通过name找到inode？<br>等会画一下一个完整的文件系统调用。</p>
<p>一句话描述：日志系统如何防止系统崩溃使得disk处于不一致状态？</p>
<p>ok<br>日志loggedblock在buf list中这是显然<br>但是log header除了在struct log header中 在写入disk的过程中还会产生个在buflist中的副本<br>回答：都是为了写入磁盘嘛，必须途径buffer cache层的辣</p>
<p>目录为什么不能sys_link？<br>硬链接不支持directory。ubuntu下 hard link not allowed for directory。xv6下的 sys_link 也会检查要增加link的inode是否是directory；若是，则失败。<br>为什么 ?<br><img src="/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-04-22-33-53.png"></p>
<p>ok<br>涉及的文件有点多啊<br>最底层的buf：bio.c<br>日志的实现：log.c<br>file system 对inode的维护以及日志的使用… ：fs.c<br>上层使用file system的接口：file.c<br>系统调用：sys_file.c</p>
<p>ok<br>文件系统通过调用virtio_disk_rw，实现对设备的写操作<br>ques : virtio_disk_rw如何确定从disk的哪个位置读？通过buf.dev和buf.block no确定</p>
<p>ok<br>待解决问题：cpu到底在什么时候和磁盘进行交互？而不是和内存缓存？<br>所有和磁盘交互的动作都必须先进入buffer cache层，然后通过disk驱动程序virtio_disk_rw对磁盘进行读写<br>其余时候cpu都是在和内存交互</p>
<p>ok<br>bcache里缓存的都是inode block吗。有data block吗?。当然有。bcacehe可以缓存disk上的任意block。</p>
<p>ok<br>待解决问题：inode 什么时候应该有ondisk 什么时候应该用memory<br>bread找到的dinode是On-disk inode structure<br>iget找到的是in-memory copy of an inode<br>这俩之前有何区别联系？<br>有的属性只有mem中的inode有，而disk上的dinode没有。如inode.ref 是说当前内核在内存中有多少C指针引用该inode，仅仅是为了内核正确运行，而这个信息显然不必存在disk上，故dinode没有。</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ul>
<li><p><strong>文件系统背后的机制</strong></p>
<ul>
<li>对硬件的抽象</li>
<li>crash safety</li>
<li><strong>如何在磁盘上排布文件系统</strong><ul>
<li>重启计算机时，磁盘上的所有数据(如目录和文件)都能恢复。</li>
<li><strong>file system的工作之一就是将所有的数据结构以一种能够在重启之后重新构建file system存放在disk上</strong></li>
</ul>
</li>
<li>性能<ul>
<li>尽量避免写磁盘<ul>
<li>文件系统所在的硬件设备很慢。如SSD为0.1到1ms完成读写一个disk block；HDD通常是在10ms量级。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>API角度看文件系统功能</strong></p>
<ul>
<li>open(“/x/y”,–);<ul>
<li>human readable pathname  </li>
</ul>
</li>
<li>write(fd , “abc” , 3);<ul>
<li>implicit offset : write没有传入offset，所以具体写到文件的那个位置是由fs负责维护的。</li>
</ul>
</li>
<li>link(“/x/y”,”/x/z”);<ul>
<li>multiple names : 为同一个文件指定多个名字，因此fs需要负责跟踪指向同一文件的多个文件名。</li>
</ul>
</li>
<li>unlink(“x/y”)</li>
<li><blockquote>
<p>除此之外，我还想提一点。文件系统的目的是实现上面描述的API，也即是典型的文件系统API。但是，这并不是唯一构建一个存储系统的方式。如果只是在磁盘上存储数据，你可以想出一个完全不同的API。举个例子，数据库也能持久化的存储数据，但是数据库就提供了一个与文件系统完全不一样的API。所以记住这一点很重要：还存在其他的方式能组织存储系统。我们这节课关注在文件系统，文件系统通常由操作系统提供，而数据库如果没有直接访问磁盘的权限的话，通常是在文件系统之上实现的（注，早期数据库通常直接基于磁盘构建自己的文件系统，因为早期操作系统自带的文件系统在性能上较差，且写入不是同步的，进而导致数据库的ACID不能保证。不过现代操作系统自带的文件系统已经足够好，所以现代的数据库大部分构建在操作系统自带的文件系统之上）。</p>
</blockquote>
</li>
<li>fs如何实现上述功能? (fs的核心数据结构?)</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><p><strong>file system的核心数据结构</strong></p>
</li>
<li><p><strong>inode</strong></p>
<ul>
<li>一个inode代表一个文件。</li>
<li>fs通过uint inum识别、引用inode<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   inode中的信息完全足够用来实现read/write系统调用，至少可以找到哪个disk block需要用来执行read/write系统调用 </span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    uint dev;           <span class="comment">// Device number</span></span><br><span class="line">    uint inum;          <span class="comment">// Inode number 用于识别inode</span></span><br><span class="line">    <span class="keyword">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">    <span class="keyword">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">    <span class="keyword">short</span> major;</span><br><span class="line">    <span class="keyword">short</span> minor;</span><br><span class="line">    <span class="keyword">short</span> nlink;        <span class="comment">//  指向inode的数量</span></span><br><span class="line">    uint size;          <span class="comment">//  file大小</span></span><br><span class="line">    uint addrs[NDIRECT+<span class="number">1</span>];  <span class="comment">//  direct and indirect block number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><img src="/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-01-13-11-28.png"></p>
</li>
<li><p>利用inode的direct number和indirect block number找到block</p>
<ul>
<li>假设需要读取file的第8000个字节，那么你该读取哪个data block呢？从inode的数据结构中该如何计算呢？<ul>
<li>blockth: 8000 / block_size(1024) = 7。也即file的第8000个byte是file的第几个data block。之后便可依托类似多级页表的机制找到data block地址</li>
<li>bytesth: 8000 % block_size(1024) = 7。得知位于data block的第几个byte</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>file descriptor</strong></p>
<ul>
<li>与user交互</li>
<li>维护对于文件的offset</li>
</ul>
</li>
</ul>
<h2 id="层次如下"><a href="#层次如下" class="headerlink" title="层次如下"></a>层次如下</h2><ul>
<li>程序mkfs设置对应于引导扇区、超级块、日志块、inode块和位图块的比特位。<ul>
<li>Disk layout: [ boot block | sb block | log | inode blocks | free bit map | data blocks ]</li>
</ul>
</li>
</ul>
<p>以下约定xxx的元数据为<br>描述xxx的数据，是描述xxx的状态如lock，也包括描述其data的位置、大小等相关信息</p>
<p>以下约定 不被独占 为 当前thread没有对该对象lock上锁</p>
<ul>
<li><strong>file system 的 层次结构</strong><ul>
<li><strong>disk 磁盘</strong> <ul>
<li>实际保存数据的存储设备，正是这些设备提供了持久化存储，</li>
</ul>
</li>
<li><strong>buffer cache / block cache</strong><ul>
<li>全是data block的缓存? 不是的。disk上的block都可以缓存到这里</li>
<li>缓存disk的数据到内存</li>
</ul>
</li>
<li><strong>logging</strong><ul>
<li>crash safety</li>
</ul>
</li>
<li><strong>inode cache</strong><ul>
<li>为了向单个inode提供同步synchronization。<ul>
<li>大家可以同步的、正确的、访问同一个inode，inode cache保证了对inode并发访问的正确性。</li>
</ul>
</li>
</ul>
</li>
<li>Directory</li>
<li>Pathname</li>
<li>Fd</li>
<li><img src="/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-01-13-09-16.png"></li>
<li>实际上所有的文件系统都有组件对应这里不同的分层</li>
</ul>
</li>
</ul>
<h2 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h2><ul>
<li>术语<ul>
<li><strong>sector</strong> <ul>
<li>磁盘驱动可以读写的最小单元，它过去通常是512字节</li>
</ul>
</li>
<li><strong>block</strong><ul>
<li>是操作系统或者文件系统视角的数据。它由文件系统定义，在XV6中它是1024字节。所以XV6中一个block对应两个sector。通常来说一个block对应了一个或者多个sector</li>
</ul>
</li>
<li>有的时候，人们也将磁盘上的sector称为block。所以这里的术语也不是很精确</li>
</ul>
</li>
</ul>
<ul>
<li><p>fs 将磁盘看作一个巨大的block数组 : block[0,n-1]</p>
</li>
<li><p>类似于ext2</p>
<ul>
<li><blockquote>
<p><img src="/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-01-13-10-05.png"></p>
</blockquote>
</li>
<li><img src="/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-03-14-31-46.png"></li>
<li><strong>70 个meta block</strong></li>
<li><strong>199930 个data block</strong></li>
</ul>
</li>
<li><p><strong>70个meta block</strong></p>
<ul>
<li>block 0 <ul>
<li><strong>boot sector</strong> / 没用</li>
</ul>
</li>
<li>block 1<ul>
<li><strong>super block</strong> : 描述fs信息，如fs由多少block组成<ul>
<li>there should be one superblock per disk device, but we run with only one device</li>
<li>xv6里面只有一个device（待解决问题：感觉这个所谓的device说得就是disk.）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Disk layout:</span></span><br><span class="line"><span class="comment">// [ boot block | super block | log | inode blocks |</span></span><br><span class="line"><span class="comment">//                                          free bit map | data blocks]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mkfs computes the super block and builds an initial file system. The</span></span><br><span class="line"><span class="comment">// super block describes the disk layout:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">    uint magic;        <span class="comment">// Must be FSMAGIC</span></span><br><span class="line">    uint size;         <span class="comment">// Size of file system image (blocks)</span></span><br><span class="line">    uint nblocks;      <span class="comment">// Number of data blocks</span></span><br><span class="line">    uint ninodes;      <span class="comment">// Number of inodes.</span></span><br><span class="line">    uint nlog;         <span class="comment">// Number of log blocks</span></span><br><span class="line">    uint logstart;     <span class="comment">// Block number of first log block</span></span><br><span class="line">    uint inodestart;   <span class="comment">// Block number of first inode block</span></span><br><span class="line">    uint bmapstart;    <span class="comment">// Block number of first free map block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>[block2,block32)<ul>
<li><strong>log block</strong></li>
</ul>
</li>
<li>[block32 , block45)<ul>
<li><strong>inode</strong> block<ul>
<li>1个inode 64 bytes</li>
<li>1个block 1024bytes</li>
</ul>
</li>
</ul>
</li>
<li>[block45 , block70)<ul>
<li><strong>bitmap block</strong> : data block 是否 free</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>199930 个data block</strong></p>
<ul>
<li>[block46,block1000)<ul>
<li><strong>data blocks</strong></li>
<li>file和目录内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Buffer-Cache"><a href="#Buffer-Cache" class="headerlink" title="Buffer Cache"></a>Buffer Cache</h2><p>bio.c<br><strong>Buffer Cache是唯一与磁盘直接交互的模块.</strong><br><strong>上层通过buffer cache 读写磁盘.</strong></p>
<p>以下约定，将disk上的block 被缓存在 内存中的 buf list上的buf<br>称为 block cache。亦或者称为 block buf 亦或 block cache buf 亦或称为buf<br>以block cache和buf为主</p>
<p>xv6中 内存中的所有东西要写入磁盘，都必须先拷贝进buffer cache层的buf 然后再落入磁盘</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><strong>同步保证正确性</strong>：<strong>同步</strong>对磁盘块的访问，以确保磁盘块在内存中只有一个副本，并且一次只有一个内核线程使用该副本<ul>
<li>Buffer cache每个buf使用一个sleeplock，以确保每个缓冲区（因此也是每个磁盘块）每次只被一个线程使用</li>
</ul>
</li>
<li><strong>加速</strong>：<strong>缓存常用块</strong>，以便不需要从慢速磁盘重新读取它们。。</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-01-21-48-59.png"></p>
<ul>
<li>cache list<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>       <span class="comment">//  保护buf链表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span>       </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></li>
<li>block cache : struct buf(.data[])<ul>
<li>其中buf.data[BSIZE] 就是 disk上 block的cache。也即，buf就是block 的副本缓冲区。</li>
<li>buf的其他字段是关于cache的元数据<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> valid;   <span class="comment">// buf是否包含block副本  has data been read from disk?</span></span><br><span class="line">  <span class="keyword">int</span> disk;    <span class="comment">// buf内容是否已经交给磁盘 does disk &quot;own&quot; buf?</span></span><br><span class="line">  uint dev;</span><br><span class="line">  uint blockno;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span>  </span><br><span class="line">  uint refcnt;  <span class="comment">//  有多少proc在使用</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span></span><br><span class="line">  uchar data[BSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>区分<ul>
<li>kalloc.c : memory allocator 是将dram用一个个大小为4KB的page以freelist形式管理起来。</li>
<li>bio.c : 这里管理磁盘缓存是通过将一部分dram用一个个大小为1KB (1024Bytes)的buf以list形式管理起来。每一个buf都是一个block的cache(因为disk上一个block的大小就是1024bytes)<ul>
<li>这个list上面的buf是所有的buf，既有free的又有非free的。是否free通过ref_cnt判断。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>struct buf* <strong>bread</strong>(uint dev, uint blockno)<ul>
<li>上层调用bread以获取一个上锁的block的locked buffer。</li>
<li>上层调用者在内存中独占的读写该buf。</li>
<li>由流程可知，获取的该locked buffer，必然是一个最新的填充了目标block(dev + blockno)的内容的缓存块。</li>
<li><strong>如果</strong>调用者<strong>修改</strong>了buf，那么在释放缓冲区之前<strong>必须调用bwrite</strong>将更改的数据<strong>写入磁盘</strong>。</li>
<li>流程<ul>
<li><ol>
<li>bget获取locked buffer</li>
</ol>
</li>
<li><ol start="2">
<li>如果buffer不是block的副本，也即buf.valid = 0。那么通过<strong>virtio_disk_rw</strong>与磁盘交互，读取出data到buffer中<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return a locked buf with the contents of the indicated block.</span></span><br><span class="line"><span class="function">struct buf*</span></span><br><span class="line"><span class="function"><span class="title">bread</span><span class="params">(uint dev, uint blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line">  <span class="comment">//  get locked buffer prepared for dev blockno</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="comment">//  如果buffer里面本身没有dev blockno的数据</span></span><br><span class="line">  <span class="keyword">if</span>(!b-&gt;valid) &#123;</span><br><span class="line">    <span class="comment">//  从disk读入到buf   </span></span><br><span class="line">    virtio_disk_rw(b, <span class="number">0</span>);</span><br><span class="line">    b-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>void <strong>bwrite</strong>(struct buf *b)<ul>
<li>通过<strong>virtio_disk_rw</strong>与磁盘交互，将上层在mem中修改过的buf真正的写入磁盘</li>
</ul>
</li>
<li>void <strong>brelse</strong>(struct buf *b)<ul>
<li>释放buf的锁，并–引用计数</li>
<li>kernel thread结束对buf的使用后，必须通过调用brelse释放buf。</li>
<li>当ref_cnt = 0，将buf移动到list末尾。</li>
</ul>
</li>
<li>static struct buf* <strong>bget</strong>(uint dev, uint blockno)<ul>
<li>扫描buf list，查找具有给定设备dev和扇区号block no的缓冲区buf。<ul>
<li>如果存在这样的缓冲区，bget增加引用计数，获取缓冲区的sleeplock。然后返回locked的缓冲区。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">  <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">    b-&gt;refcnt++;</span><br><span class="line">    release(&amp;bcache.lock);</span><br><span class="line">    acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果对于dev和blockno，不存在其buf，那么bget就要分配一个buf作为dev的block no的cache。采用lru算法，查找最近的b-&gt;ref_cnt = 0的buf。<ul>
<li>Bget编辑该buf元数据以记录新设备dev和扇区号blockno</li>
<li>并令<strong>b-&gt;valid = 0，确保了bread将从磁盘读取块数据，而不是错误地使用该buf以前的内容</strong>，增加引用计数，并获取其sleeplock。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Not cached.</span></span><br><span class="line"><span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line"><span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">  <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;dev = dev;</span><br><span class="line">    b-&gt;blockno = blockno;</span><br><span class="line">    b-&gt;valid = <span class="number">0</span>;   <span class="comment">//  确保了bread将从磁盘读取块数据，而不是错误地使用该buf以前的内容</span></span><br><span class="line">    b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">    release(&amp;bcache.lock);</span><br><span class="line">    acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><ul>
<li>对于<strong>struct bcache 和 buf</strong>的修改需要遵守以下几点<strong>原则</strong>.</li>
<li><strong>1. bcache.spinlock</strong> : <ul>
<li>bcache.lock用于保护有关缓存哪些块的信息</li>
<li>对bcache做任何修改，都必须持有bcache.spinlock</li>
</ul>
</li>
<li><strong>2. buf.sleeplock</strong> : <ul>
<li>buf.sleeplock保护block cache(buf)的读写</li>
<li>对disk上block的cache，即对buf.data[BSIZE]做访问，都必须持有buf.sleeplock。</li>
<li>确保了任何时候只有一个进程可以读写block cache</li>
<li>也就确保了读者看到写操作，写者之间的写操作也不会混乱。</li>
</ul>
</li>
<li><strong>3. <strong>只有在</strong>buf.ref_cnt</strong> = 0时，才驱逐block cache。<ul>
<li>也即在buf.ref_cnt &gt; 0时，block不会被block cache修改。</li>
</ul>
</li>
<li><strong>4. 1个block只能有1个block cache</strong>，也即1个block只有1个struct buf<ul>
<li><blockquote>
<p>如果buffer cache中有两份block 33的cache将会出现问题。假设一个进程要更新inode19，另一个进程要更新inode20。如果它们都在处理block 33的cache，并且cache有两份，那么第一个进程可能持有一份cache并先将inode19写回到磁盘中，而另一个进程持有另一份cache会将inode20写回到磁盘中，并将inode19的更新<strong>覆盖</strong>掉。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>5.<strong>如果调用者修改了缓冲区buf，那么在释放缓冲区之前</strong>必须调用bwrite</strong>将更改的数据写入磁盘 </li>
<li>在bcache.lock临界区域之外获取buf.sleeplock是安全的，且也有其作用<ul>
<li>非零b-&gt;refcnt用于防止buf被重新用于不同的磁盘块。</li>
<li>如bpin()</li>
</ul>
</li>
<li><strong>ps : 在bread(bget)和brelse之间，用户持有其获得的buf.lock，可以独占的对其进行读写</strong></li>
</ul>
<h2 id="Log-日志"><a href="#Log-日志" class="headerlink" title="Log 日志"></a>Log 日志</h2><p>log.c</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul>
<li>崩溃会造成磁盘上的文件系统处于不一致的状态。我理解的不一致：一件事情做到一半，正常来讲应该要么做要么没做<ul>
<li>例如，假设在文件截断（将文件长度设置为零并释放其内容块）期间发生崩溃。根据磁盘写入的顺序，崩溃可能会<ul>
<li>留下对标记为空闲的内容块的引用的inode，<ul>
<li>引用已释放块的inode在重新启动后可能会导致严重问题。重新启动后，内核可能会将该块分配给另一个文件，现在我们有两个不同的文件无意中指向同一块。如果xv6支持多个用户，这种情况可能是一个安全问题，因为旧文件的所有者将能够读取和写入新文件中的块，而新文件的所有者是另一个用户。</li>
</ul>
</li>
<li>也可能留下已分配但未引用的内容块。<ul>
<li>相对来说是良性的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Xv6通过简单的<strong>日志</strong>记录形式<strong>解决</strong>了文件系统操作期间的<strong>崩溃问题。</strong><ul>
<li>xv6系统调用<strong>不会直接写入磁盘上相应的文件系统数据结构。相反，它会在磁盘上的log（日志）中放置它希望进行的所有磁盘写入的描述</strong>。<ul>
<li>log_write: 通过写入logheader记录disk上的哪些block需要被修改，并通过bpin保持其cache不被覆盖。</li>
</ul>
</li>
<li>一旦logheader记录了所有事务的所有的系统调用，它就会向磁盘写入一条特殊的commit（提交）记录，表明日志包含一个完整的操作。</li>
<li>然后，日志系统将写内容复制到磁盘上的文件系统数据结构。</li>
<li>完成这些写入后，日志系统将擦除磁盘上的日志。</li>
</ul>
</li>
</ul>
<h3 id="关于流程、崩溃及恢复"><a href="#关于流程、崩溃及恢复" class="headerlink" title="关于流程、崩溃及恢复"></a><strong>关于流程、崩溃及恢复</strong></h3><ul>
<li><img src="/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-11-16-52-31.png"></li>
</ul>
<p>崩溃后重启，file system如何通过日志恢复磁盘？一言以蔽之：install_trans() : 读取disk 上的logheader，将logged block中的data拷贝到disk上的指定block。</p>
<ul>
<li><p><strong>0. 事务还在内存中 并没有提交</strong></p>
<ul>
<li>也即 所有的被修改的datablock cache 也即struct logheader中对于修改的记录都是在内存中，还没有落入磁盘</li>
<li><strong>crashA：完整的丢失写入数据</strong>。<ul>
<li>如果此时发生crash，data全部位于内存中，则重启周recover无法恢复。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>1. commit：提交事务</strong>(事务被提交前，全部位于内存中)。</p>
<ul>
<li>这里所谓的事务，就是一堆需要落入磁盘的操作(系统调用)</li>
<li>事务的提交分为，两个阶段<ul>
<li> <strong>1.1 write_log</strong>. 提交了日志系统中所有已完成事务中修改了的目标block的cache，将其提交到disk的logged block中。</li>
<li> <strong>1.2 write_head</strong>. 提交了日志系统中所有已完成事务的记录，也即本日志中事务中有哪些block需要被修改的记录</li>
</ul>
</li>
<li>完成这12阶段，即disk上已经有了完整的所有已完成事务的记录 以及 修改内容</li>
<li><strong>crashC（已完成1.1、1.2）</strong>：即便此时系统发生崩溃，重启时通过recover_from_log也可以<strong>完全恢复</strong>disk：将logged block根据logheader拷贝到相应的inode/bitmap/datablock中</li>
<li><strong>crashB(已完成1.1）</strong>：如果只完成了1,但是没有完成2,系统就崩溃了，那么无妨，这种<strong>崩溃是良性</strong>的，不会导致文件系统/disk处于不一致状态。因为这种崩溃<strong>在disk上留下的是已分配但未引用的datablock</strong>。也即 logged block被填充了，但是logheader block并没有记录他们这些loggedblock被修改了，也即并没有引用这些logged block。会造成完整的磁盘上的内容缺失。这些已分配但是未引用的logged block<strong>稍后会被覆盖</strong>。</li>
<li><strong>crashB</strong>：如果在完成1的过程中崩溃，同上</li>
<li>如果在完成2的过程中崩溃，咋整？岂不是真的寄掉了？。<ul>
<li>胡咧咧一个解释：由于2过程要写入的header block只有一个块，假定对一个块的写入是原子的。因此，崩溃时要么对这个块没进行一点写入，要么已经写完了这个块。也即对该块的写入是原子的。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>2. install_trans : 处理(安装)事务</strong></p>
<ul>
<li>完成1.1 1.2阶段之后，就是安装事务了</li>
<li>根据logheader block中的记录，将logged block复制到其相应的inode/bitmap/datablock中</li>
<li>处理完之后，日志对于这些事务的记录header block以及内容logged block就没有作用了。</li>
<li>如果2崩溃了，没关系，disk区域上的log块仍然在，recover时可以正常恢复。</li>
</ul>
</li>
<li><p><strong>3. 清空日志记录</strong></p>
<ul>
<li>清空headerblock。清除日志系统中对于事务的记录。</li>
<li><strong>crashD</strong>：此时crash，无妨。recover时重新安装一遍之前安装过的block即可。无影响。</li>
</ul>
</li>
<li><p>从代码中可以看到</p>
<ul>
<li>xv6允许一次commit多个事务，也就是说允许多个事务并发。（都begin_op,然后都end_op)</li>
<li>但是当在commit时，就不允许再开启新事务了，需要等待commit完成。</li>
</ul>
</li>
</ul>
<h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><ul>
<li>想要对disk进行操作时，<ul>
<li>写begin_op标志事务开始，</li>
<li>然后通过bget拿到block对应的cache，之后对cache进行读写操作。</li>
<li>操作完成之后，通过log_write记入日志，</li>
<li>然后end_op标志事务结束<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">begin_op();           <span class="comment">//  开启事务</span></span><br><span class="line">...</span><br><span class="line">bp = bread(...);      <span class="comment">//  获取目标的block cache</span></span><br><span class="line">bp-&gt;data[...] = ...;  <span class="comment">//  对block cache进行读写修改</span></span><br><span class="line">log_write(bp);        <span class="comment">//  日志记录需要修改的block</span></span><br><span class="line">...</span><br><span class="line">end_op();             <span class="comment">//  结束并提交事务</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>日志的一个示例使用发生在filewrite. 事务如下所示 .<ul>
<li>这段代码被包装在一个循环中，该循环一次将大的写操作分解为几个扇区的单个事务，以避免日志溢出。</li>
<li>作为此事务的一部分，对writei的调用写入许多块：文件的inode、一个或多个位图块以及一些数据块。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">begin_op(); </span><br><span class="line">ilock(f-&gt;ip); </span><br><span class="line">r = writei(f-&gt;ip, ...); </span><br><span class="line">iunlock(f-&gt;ip); </span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><ul>
<li><p>disk上的log区域为如下</p>
<ul>
<li><strong>header block</strong><ul>
<li>磁盘上对所有已提交事务的记录<ul>
<li>也即指示应当将哪些 logged block 复制到哪些 block 中</li>
<li>包括一个数量n以及需落入的块号</li>
<li>在内存中的表现就是 struct logheader{}</li>
</ul>
</li>
</ul>
</li>
<li><strong>logged block</strong><ul>
<li>内存中的block cache 先落入disk上的logged block</li>
<li>然后再根据header block的指示，将disk上的logged block 复制到 目标block</li>
</ul>
</li>
<li><strong>unlogged block</strong><ul>
<li>空闲的，等待cache落入的block</li>
</ul>
</li>
</ul>
</li>
<li><p>内存中的表现形式如下</p>
</li>
<li><p>header block 在内存中就是 struct logheader。也就是说headerblock就这俩数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Contents of the header block, used for both the on-disk header block</span></span><br><span class="line"><span class="comment">// and to keep track in memory of logged block# before commit.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> n;                  <span class="comment">//  总共有多少个block被修改</span></span><br><span class="line">  <span class="keyword">int</span> block[LOGSIZE];     <span class="comment">//  需要修改的block编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>n = 0 , 表示日志中没有事务</li>
<li>n !=0 , 表示日志包含一个完整的已commit的事务 , 并具有n个logged block</li>
</ul>
</li>
<li><p>整个日志系统的状态以及元数据都在struct log中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="keyword">int</span> start;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">int</span> outstanding; <span class="comment">// 预定日志空间的事务数</span></span><br><span class="line">  <span class="keyword">int</span> committing;  <span class="comment">// in commit(), please wait.</span></span><br><span class="line">  <span class="keyword">int</span> dev;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> <span class="title">lh</span>;</span>    <span class="comment">//  记录了哪些block需要被修改</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">log</span> <span class="title">log</span>;</span>   <span class="comment">//  日志系统</span></span><br></pre></td></tr></table></figure>
<ul>
<li>committing : 日志系统是否正在执行commit</li>
<li>outstanding : 预定日志空间的事务数。只有当减少至0的时候才会commit。</li>
<li>logheader : 如上</li>
<li>dev : 哪个磁盘的文件系统。xv6中只有一个磁盘，故只有一个文件系统。</li>
</ul>
</li>
</ul>
<h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><ul>
<li><p><strong>begin_op</strong> : 标志开始当前事务</p>
<ul>
<li>等待日志系统commit完成，且有足够的未被使用的log block<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  正在提交。等待</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">  sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br></pre></td></tr></table></figure></li>
<li>++log.outstanding : 为本次事务预定日志空间<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"><span class="comment">//  开启日志</span></span><br><span class="line"><span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">release(&amp;<span class="built_in">log</span>.lock);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>log_write</strong> : 通过写入logheader，并通过bpin保持其cache不被覆盖。</p>
<ul>
<li>充当bwrite的代理。</li>
<li>在内存中记录disk上的哪些block需要被修改。<ul>
<li>logheader block[] 记录</li>
</ul>
</li>
<li>在磁盘上的日志中预定一个槽位<ul>
<li>logheader.n++</li>
</ul>
</li>
<li>保持将要落入磁盘的block cache，防止被覆盖。<ul>
<li>bpin<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1. 更新log header ，将块的扇区号blockno记录在内存中</span></span><br><span class="line"><span class="comment">//  如果b对应的block no已经被记录了，那么不必再记录(重复记录也无妨)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorbtion</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  幂等操作 无论是否是新增blockno</span></span><br><span class="line"><span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">  <span class="comment">//  2. bpin将该block的buf固定在cache中</span></span><br><span class="line">  bpin(b);            <span class="comment">//  防止struct buf b 被释放</span></span><br><span class="line">  <span class="comment">//  3. 在磁盘的日志块中预定一个槽位</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n++;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>endop</strong> : 标志当前事务完成，告知日志；若此时日志中没有未完成的事务，则执行commit。</p>
<ul>
<li>核心代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"><span class="comment">//  标志完成一个事务</span></span><br><span class="line">--<span class="built_in">log</span>.outstanding;     </span><br><span class="line"><span class="comment">//  如果日志中的所有事务均已完成 则 commit 日志</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123; </span><br><span class="line">  do_commit = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  commit日志 if do_commit = 1</span></span><br><span class="line"><span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">  <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">  <span class="comment">// to sleep with locks.</span></span><br><span class="line">  commit();</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.committing = <span class="number">0</span>; <span class="comment">//  提交完成</span></span><br><span class="line">  wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>commit</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一次commit可能涉及多个事务的写入。</li>
<li><strong>write_log</strong> : 将日志记录落入磁盘<ul>
<li>根据logheader中的记录，将被修改的 目标block cache 落入 disk上的 log block</li>
<li>目标block cache –copy into–&gt; log block cache –落入–&gt; disk log block<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">write_log</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>);     <span class="comment">// 新从disk读出来的unlogged block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// 之前访问修改的cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);                  <span class="comment">// copy into log block cache</span></span><br><span class="line">    bwrite(to);                                            <span class="comment">// write the log into disk</span></span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>write_head</strong> : 将日志记录头落入磁盘<ul>
<li>将 logheader 落入 disk上的 header block</li>
<li>logheader –copy–&gt; headerblock cache —落入—&gt; disk上的headerblock<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk. through buffer list</span></span><br><span class="line"><span class="comment">// This is the true point at which the</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">write_head</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (struct logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>install_trans</strong> : 处理已经提交的事务：将日志安装到磁盘上。<ul>
<li>根据logheader中的记录，将保存在log cache的内容落入其原本应当在的inode/bitmap/data/…block</li>
<li>核心逻辑</li>
<li>log cache –&gt; 目标block cache –&gt; disk 目标block<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">install_trans</span><span class="params">(<span class="keyword">int</span> recovering)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>);    <span class="comment">// read log block</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]);  <span class="comment">// read dst</span></span><br><span class="line">      memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);                 <span class="comment">// copy block cache to dst cache</span></span><br><span class="line">      bwrite(dbuf);                                           <span class="comment">// write dst cache to disk </span></span><br><span class="line">      brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>清空disk上的headerblock<ul>
<li>log.lh.n = 0;</li>
<li>write_head();<ul>
<li>log header记录的需要修改的block的数量为0，即等价于header block没有记录任何日志，即清空headerblock。那么就可以认为日志系统中没有任何被commit的事务，也即没有任何loggged block。</li>
<li>这必须在下一个事务开始写入日志块之前发生，以便崩溃不会导致使用一个事务的头块和后续事务的日志块进行恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>recover_from_log</strong> : 它读取日志头，如果有已经commited的事务，则将logged block 拷贝到相应的block中</p>
<ul>
<li>fsinit -&gt; initlog -&gt; recover from log<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover_from_log</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  read_head();      <span class="comment">//  从disk logheaderblock 读出 记录到 mem中的 struct logheader</span></span><br><span class="line">  install_trans(<span class="number">1</span>); <span class="comment">// if committed, copy from log to disk</span></span><br><span class="line">  <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">  write_head(); <span class="comment">// clear the log</span></span><br><span class="line"><span class="comment">//  清空已经处理完的事务 以便后续记录新的事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Inode-Cache层"><a href="#Inode-Cache层" class="headerlink" title="Inode Cache层"></a>Inode Cache层</h2><h3 id="Inode结构"><a href="#Inode结构" class="headerlink" title="Inode结构"></a>Inode结构</h3><ul>
<li><p>术语inode（即索引结点）有2种含义。</p>
<ul>
<li><ol>
<li>指包含文件大小和数据块编号列表的磁盘上的数据结构(struct dinode)</li>
</ol>
</li>
<li><ol start="2">
<li>指内存中的inode，它包含磁盘上inode(dinode)的副本以及内核中所需的额外信息。(struct inode)</li>
</ol>
</li>
</ul>
</li>
<li><p>An <strong>inode</strong> <strong>describes a single unnamed file</strong>.</p>
</li>
<li><p><strong>disk上的inode</strong>：The <strong>inode disk structure holds metadata</strong>: </p>
<ul>
<li><p>the file’s type, its size, the number of links referring to it, and <strong>the list of blocks holding the file’s content</strong>.</p>
</li>
<li><p><strong>dinode : inode在磁盘上的结构</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="comment">//  meta data</span></span><br><span class="line">  <span class="keyword">short</span> type;           <span class="comment">// File type  文件 / 目录 / 特殊文件 / 0表示inode空闲</span></span><br><span class="line">  <span class="keyword">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="keyword">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="keyword">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  <span class="comment">//  the list of blocks holding the file&#x27;s content</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses 保存inode代表的文件的内容的磁盘块号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>nlink</strong> : 引用本inode的<strong>entry</strong>目录项的数量(<strong>entry是真实存在于disk上的结构</strong>,断电之后还会保存在磁盘里面)</p>
<ul>
<li>当nlink = 0时，就在disk上真正释放该inode。</li>
<li>这就是<strong>硬链接</strong>。</li>
<li>tips：<ul>
<li>之前还没看xv6的时候，总看有的sb资料说 硬链接不占磁盘空间，当时觉得扯淡。怎么可能呢？现在解释如下</li>
<li>硬链接hard link就是一个个directory下的一个个entry。其只是不占据inode blocks而已，但也要占磁盘空间啊。entry存储在directory的data block下</li>
<li>至于软连接，xv6里面并没有实现。</li>
</ul>
</li>
</ul>
</li>
<li><p>addrs : </p>
<ul>
<li>[0,11] direct block</li>
<li>[12] indirect block</li>
</ul>
</li>
<li><p><img src="/2022/11/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2022-12-06-09-34-11.png"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>inode cache 内存中的inode</strong> : <strong>The kernel keeps a cache of in-use inodes in memory to provide a place for synchronizing access to inodes used by multiple processes.</strong><ul>
<li>The cached inodes include book-keeping information that is not stored on disk: ip-&gt;ref and ip-&gt;valid.</li>
<li><strong>作用：1. 为多个进程访问inode提供同步（主要）</strong></li>
<li>作用：2. 缓存，加速</li>
<li><strong>icache and inode : inode在内存中的结构</strong>：<ul>
<li><strong>inode cache : a cache of in-use inode</strong><ul>
<li>inode cache 是 活跃的inode的集合。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span>       <span class="comment">//  1. 保证同一个dinode在inode中最多出现一次。 2.  维护inode.ref的正确性。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">inode</span>[<span class="title">NINODE</span>];</span></span><br><span class="line">&#125; icache;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>struct inode</strong> : <ul>
<li>是disk上dinode的在内存的缓存，只有C指针引用某个inode时，icache中才会存储该inode<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  The cached inodes include book-keeping information that is not stored on disk: ip-&gt;ref and ip-&gt;valid.</span></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="keyword">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="comment">//  确保独占的访问 inode的size，data block等</span></span><br><span class="line">  <span class="keyword">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="keyword">short</span> major;</span><br><span class="line">  <span class="keyword">short</span> minor;</span><br><span class="line">  <span class="keyword">short</span> nlink;        <span class="comment">//  引用本inode的目录项的数量</span></span><br><span class="line">  uint size;          <span class="comment">//  文件大小吧，感觉应该是指向的datablock的大小之和。</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];    <span class="comment">//  最终都指向 block number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>ref</strong> : 内存中引用本struct inode的C指针数量<ul>
<li>如果ref = 0，那么，icache就可以将该struct inode从缓存中踢掉。</li>
<li>与什么软链接、硬链接无关</li>
<li>C指针是存在于内存的，不是磁盘里真实存在的东西。</li>
</ul>
</li>
<li>valid : struct inode是否已经从磁盘中读取dinode部分<ul>
<li>如果valid = 0，那么，重新从disk读取。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="接口-2"><a href="#接口-2" class="headerlink" title="接口"></a>接口</h3><h3 id="datablock分配"><a href="#datablock分配" class="headerlink" title="datablock分配"></a>datablock分配</h3><ul>
<li><p><strong>balloc : datablock分配器</strong></p>
<ul>
<li>遍历bitmap,通过bread获取free data block的cache,并返回其block no。<ul>
<li>注意只是将该free data block加载进了cache，返回了blockno。并没有独占该block cache 也即并没有lock该block cache</li>
<li>这个工具函数就不放代码了，见注释吧，挺简单。</li>
<li>注意下对于meta blocks的bit : super block , logging , inodes ,bitmap。在mkdfs中，bitmap就将其全部将其置为1，这样才符合bitmap指向datablock的逻辑。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>bfree : datablock释放器</strong></p>
<ul>
<li>static void bfree(int dev, uint b)</li>
<li>(我认为)真正的释放disk上的data block b<ul>
<li>并没有将buf清0，而是仅仅通过将bitmap的相应bit清0来代表该block里面的数据已经没用，可以被覆盖，也即该block是一个free block ，可以再被分配。</li>
<li>当然是commit之后生效。</li>
</ul>
</li>
<li>核心逻辑<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bi = b % BPB;</span><br><span class="line">m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)</span><br><span class="line">  panic(<span class="string">&quot;freeing free block&quot;</span>);</span><br><span class="line"><span class="comment">//  清空该bit</span></span><br><span class="line">bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">log_write(bp);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="inode分配"><a href="#inode分配" class="headerlink" title="inode分配"></a>inode分配</h4><ul>
<li><strong>iget</strong>: <strong>从inode cache中 返回 编号为inum的inode</strong><ul>
<li>iget(uint dev, uint inum)</li>
<li>Does not lock the inode and does not read it from disk</li>
<li><strong>返回一个不被独占的inode。</strong></li>
<li>如果这个inum对应的inode之前被使用过<ul>
<li>那么在icache中就可以找到该inode，</li>
<li>++ref，返回即可<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  ip-&gt;ref++ 代表内存中引用struct inode结构体的人又多了一个。</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">    ip-&gt;ref++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1 ip-&gt;type = %d\n&quot;</span>,ip-&gt;type);</span><br><span class="line">    release(&amp;icache.lock);</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如果这个inum对应的inode之前没使用过，<ul>
<li>那么在icache中找不到该inode，替换icache中无用的inode，</li>
<li>对inode 进行 inode独有的metadata的初始化.(dinode的metadata之后会从disk读)<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  ref = 0 , 即该struct inode已经内存中无人引用。</span></span><br><span class="line"><span class="comment">//  那么将其替换掉</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// Remember empty slot.</span></span><br><span class="line">    empty = ip;</span><br><span class="line"><span class="comment">//  初始化inode的metadata</span></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;  <span class="comment">//  dev and inum</span></span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;      <span class="comment">//  引用为1</span></span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>ialloc</strong> : 从inode cache获取一个已经初始化了inode metadata的free inode<ul>
<li>返回的是个没独占的inode。</li>
<li>核心逻辑<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct inode*</span></span><br><span class="line"><span class="function"><span class="title">ialloc</span><span class="params">(uint dev, <span class="keyword">short</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    <span class="comment">//  获取disk上第inum个inode所属的block buf(位于buf list)</span></span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));      </span><br><span class="line">    <span class="comment">//  获取该dinode</span></span><br><span class="line">    dip = (struct dinode*)bp-&gt;data + inum%IPB;    </span><br><span class="line">    <span class="comment">//  free dip</span></span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  </span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip));</span><br><span class="line">      dip-&gt;type = type;       <span class="comment">//  声明该dinode被使用</span></span><br><span class="line">      log_write(bp);          <span class="comment">//  落入磁盘</span></span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="comment">//  返回一个inode cache中的inode</span></span><br><span class="line">        <span class="comment">//  可以看到此时返回的inode 其中的type和dip-&gt;type并不一致。那么如何解决？：在调用者获取了该inode之后，会对属于dinode的metadata进行初始化</span></span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum); </span><br><span class="line">    <span class="comment">// in-memory copy of an inode</span></span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>可以看到ialloc的调用情景,在获取inode之后，会对struct inode中dinode的metadata部分进行初始化。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ip = ialloc(dp-&gt;dev, type);</span><br><span class="line">ilock(ip);</span><br><span class="line">ip-&gt;major = major;</span><br><span class="line">ip-&gt;minor = minor;</span><br><span class="line">ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">iupdate(ip);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p><strong>ilock</strong></p>
<ul>
<li><ol>
<li>acquire(sleeplock) </li>
</ol>
</li>
<li><ol start="2">
<li>根据需要从磁盘中读取struct inode中尚未读取的dinode部分</li>
</ol>
</li>
<li><strong>在读写inode的元数据或内容之前，代码必须使用ilock锁定inode</strong></li>
<li>将inode指针的获取与锁定分离有助于在某些情况下避免死锁，例如在目录查找期间。多个进程可以持有指向iget返回的inode的C指针，但一次只能有一个进程锁定inode。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ilock</span><span class="params">(struct inode *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  1. ilock(inode)</span></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock);</span><br><span class="line">  <span class="comment">//  2. 从磁盘中读取struct inode中尚未读取的dinode部分</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (struct dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>iput</strong></p>
<ul>
<li>iput(struct inode *ip)</li>
<li><ol>
<li>放下本thread对于inode的引用</li>
</ol>
<ul>
<li>ip-&gt;ref–;</li>
<li>如果inode的ref降至0，那么意味着inode cahce中的该inode在内存中无人引用。此后在iget中可以将其替换掉。</li>
</ul>
</li>
<li><ol start="2">
<li>如果此刻已经无人再引用该inode，且其对应的dinode的nlink = 0(也即硬链接计数为0，也即没有entry指向该inode)</li>
</ol>
<ul>
<li>那么该inode不只留在内存中无用，留在磁盘中也无用。那么如下</li>
<li>inode大小置0并释放其所引用的addrs + 标记为未分配 + 写入磁盘</li>
</ul>
</li>
<li>iput中释放inode的锁定协议值得仔细研究<ul>
<li>先不研究了。。。要学不完了。。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>iunlock</strong></p>
<ul>
<li>释放inode的lock<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iunlock</span><span class="params">(struct inode *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  releasesleep(&amp;ip-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>inode指针的获取和上锁进行分离</strong></p>
<ul>
<li><strong>iget</strong> : inode cache中 inode指针的获取</li>
<li><strong>ilock</strong> : 对 inode cache中 inode进行lock</li>
<li>作用：有助于在某些情况下<strong>避免deadlock</strong>，<ul>
<li>例如在<strong>目录查找</strong>期间 : 多个进程可以持有指向iget返回的inode的C指针，但一次只能有一个进程锁定inode。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>iupdate</strong></p>
<ul>
<li>作用：将inode cache中对inode的修改，落入disk上的dinode中.</li>
<li>inode cache —copy into–&gt; dinode block cache –落入-&gt; disk dinode</li>
<li>inode cache直写：每次修改inode之后，必须立刻执行iupdate，将其落入disk</li>
<li>简单，不放代码了。</li>
</ul>
</li>
</ul>
<h4 id="inode使用"><a href="#inode使用" class="headerlink" title="inode使用"></a>inode使用</h4><ul>
<li><p><strong>bmap</strong></p>
<ul>
<li>bmap(struct inode *ip, uint bn)</li>
<li><strong>作用:z</strong> 返回inode指向的第bn个datablock的blockno，并根据需要分配datablock<ul>
<li>The bn argument is a “logical block number” – a block number within the file, relative to the start of the file. The block numbers in ip-&gt;addrs[], and the argument to bread(), are disk block numbers. You can view bmap() as mapping a file’s logical block numbers into disk block numbers.</li>
<li>如直接块插槽没有指向的block，则balloc为其分配</li>
<li>如没有indirect block，则balloc为其分配</li>
<li>如间接块插槽没有指向的block，则balloc为其分配。</li>
</ul>
</li>
<li>并不独占datablock cache</li>
<li>ip-&gt;addrs[]或间接块中条目为零表示未分配块。<ul>
<li>通过balloc分配datablock (bmap获取并返回free datablock的blockno)</li>
</ul>
</li>
<li>感觉很像vm.c里的一些函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint <span class="title">bmap</span><span class="params">(struct inode *ip, uint bn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  如果inode的直接块并没有指向datablock</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  间接块</span></span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line">  <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">//  如果indirect间接块为0 ，那么为其分配balloc一个freeblock作为indirect block</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="comment">//  得到indirect block</span></span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="comment">//  indirect block的条目bn没有指向datablock</span></span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果blockno 超过NDIRECT+NINDIRECT，则bmap调用panic崩溃</span></span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>itrunc</strong></p>
<ul>
<li><strong>清空inode</strong> : 释放inode所引用的块，并置inode代表的文件大小为0<ul>
<li><ol>
<li>释放其所指向的所有直接块(disk 上)</li>
</ol>
</li>
<li><ol start="2">
<li>释放其所指向的所有间接块(disk 上)</li>
</ol>
</li>
<li><ol start="3">
<li>文件大小置为0</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>readi</strong></p>
<ul>
<li>int readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)</li>
<li><strong>作用</strong>：读取从inode代表的文件的第off个bytes开始(从disk / buf)，读取n个bytes到dst中</li>
<li>调用了bmap</li>
<li>disk(datablock) ——-&gt; block cache —copyinto—&gt; user/kernel virtual adddress</li>
<li>和巡逻机<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readi</span><span class="params">(struct inode *ip, <span class="keyword">int</span> user_dst, uint64 dst, uint off, uint n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  确保起始指针偏移量不超过文件的末尾。</span></span><br><span class="line">  <span class="keyword">if</span>(off &gt; ip-&gt;size || off + n &lt; off)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//  确保最多只能读取到文件末尾</span></span><br><span class="line">  <span class="keyword">if</span>(off + n &gt; ip-&gt;size)</span><br><span class="line">    n = ip-&gt;size - off;</span><br><span class="line">  <span class="comment">//  开始读取inode指向的datablock</span></span><br><span class="line">  <span class="comment">//  将data从disk copy到内核内存再copy到用户内存</span></span><br><span class="line">    <span class="comment">//  total:总共读了file的多少bytes ; off:读到file的第几个byte了 ; dst : user virtual address</span></span><br><span class="line">  <span class="keyword">for</span>(tot=<span class="number">0</span> ; tot&lt;n ; tot+=m, off+=m, dst+=m)&#123;</span><br><span class="line">    <span class="comment">//  bmap(ip, off/BSIZE) : 获取file的第off个bytes对应的block no</span></span><br><span class="line">    bp = bread(ip-&gt;dev, bmap(ip, off/BSIZE));</span><br><span class="line">    <span class="comment">//  将buf拷贝到用户内存user_dst</span></span><br><span class="line">    either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m);</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>wirtei</strong></p>
<ul>
<li>writei(struct inode *ip, int user_src, uint64 src, uint off, uint n)</li>
<li>用户从inode指向的第off个bytes开始，写n个bytes，从src address到disk</li>
<li>user/kernel addr -&gt; block cache -&gt; disk</li>
<li>代码略。类似readi</li>
</ul>
</li>
</ul>
<ul>
<li><strong>stati</strong><ul>
<li>stati(struct inode *ip, struct stat *st)</li>
<li>Copy stat information from inode</li>
<li>Caller must hold ip-&gt;lock</li>
</ul>
</li>
</ul>
<h2 id="Directory-目录层"><a href="#Directory-目录层" class="headerlink" title="Directory 目录层"></a>Directory 目录层</h2><h3 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h3><ul>
<li><p><strong>目录也是一个文件，因此也是一个inode来代表</strong></p>
<ul>
<li>directory <strong>inode</strong> : <ul>
<li>type = T_DIR</li>
<li>其addrs所指向的datablock，其中包含的data都是一个个entry，代表directory下的子文件/子目录</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>entry的结构如下：</strong></p>
<ul>
<li>entry不是file，并不需要由inode代表，而仅仅是一个directory的inode的datablock中的数据。其结构如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  目录项、entry。文件夹中的一系列代表其下的文件/文件夹的东西就叫entry. </span></span><br><span class="line"><span class="comment">//  dirent不是文件夹，之前还误以为是文件夹。傻冒。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum;    <span class="comment">//  用于索引inode</span></span><br><span class="line">  <span class="keyword">char</span> name[DIRSIZ];  <span class="comment">//  一</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="接口-3"><a href="#接口-3" class="headerlink" title="接口"></a>接口</h3><ul>
<li><strong>dirlookup</strong><ul>
<li>struct inode* dirlookup(struct inode *dp, char *name, uint *poff)</li>
<li>在目录directory中搜索具有给定名称的条目entry。<ul>
<li>调用了readi,iget</li>
<li>如果找到<ul>
<li><ol>
<li>将*poff设置为条目在目录中的字节偏移量</li>
</ol>
</li>
<li><ol start="2">
<li>通过iget获得的未锁定的inode 并 return unlocked inode*</li>
</ol>
</li>
</ul>
</li>
<li>如果没找到<ul>
<li>return 0<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">  <span class="comment">//  每轮读出一个entry : struct dirent</span></span><br><span class="line">  readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de);</span><br><span class="line">  <span class="comment">//  当前的entry所能索引到的inode 和name是否匹配</span></span><br><span class="line">  <span class="keyword">if</span>(namecmp(name, de.name) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// entry matches path element</span></span><br><span class="line">    *poff = off;</span><br><span class="line">    inum = de.inum;</span><br><span class="line">    <span class="comment">//  返回该entry所对应的inode</span></span><br><span class="line">    <span class="keyword">return</span> iget(dp-&gt;dev, inum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>dirlink</strong><ul>
<li>int dirlink(struct inode *dp, char *name=xxx, uint inum=123)</li>
<li>作用：在directory dp下 ，新增一个entry。entry的name是xxx，指向的inode是123</li>
<li>调用了dirlookup,readi,writei , 核心逻辑见下。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dirlink</span><span class="params">(struct inode *dp, <span class="keyword">char</span> *name, uint inum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Check that name is not present.</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  找到空闲的entry </span></span><br><span class="line">  <span class="keyword">for</span>(off = <span class="number">0</span>; off &lt; dp-&gt;size; off += <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">    readi(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de));</span><br><span class="line">    <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  写入name和inum</span></span><br><span class="line">  <span class="built_in">strncpy</span>(de.name, name, DIRSIZ);</span><br><span class="line">  de.inum = inum;</span><br><span class="line">  <span class="comment">//  写入disk (如果现有的size里面没有free entry 那么就会增添新entry , 扩展dp-&gt;size)</span></span><br><span class="line">  writei(dp, <span class="number">0</span>, (uint64)&amp;de, off, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Pathname-路径层"><a href="#Pathname-路径层" class="headerlink" title="Pathname 路径层"></a>Pathname 路径层</h2><ul>
<li><p><strong>工具函数：skipelem</strong>  </p>
<ul>
<li>static char* skipelem(char *path, char *name)</li>
<li>skipelem 将path中的 第一个path element(应该是个文件夹名字)取出拷贝到name中 , 返回path中除去path element之后剩余的内容<ul>
<li>对于取出的给name的path element，如果是路径末尾的最后一个path element，那么就是个file的名字；如果不是路径末尾的最后一个path element，即中间的pathelement，则是一个directory的名字。</li>
<li>可以去除/</li>
<li>返回null时就代表name现在保存的已经是path中最后一个element</li>
<li>传入的*path = ‘\0’时，返回nullptr，且不改变name</li>
</ul>
</li>
<li>如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;path left: %s\n&quot;</span>,skipelem(<span class="string">&quot;/123///456/789/&quot;</span>,name));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name : %s\n&quot;</span>,name);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;path left: %s\n&quot;</span>,skipelem(<span class="string">&quot;aaaa&quot;</span>,name));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name : %s\n&quot;</span>,name);</span><br><span class="line"></span><br><span class="line">name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;path left: %s\n&quot;</span>,skipelem(<span class="string">&quot;&quot;</span>,name));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;name : %s\n&quot;</span>,name);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>namex</strong></p>
<ul>
<li>static struct inode* namex(char *path, int nameiparent, char *name)</li>
<li>nameiparent = 0 : 返回path最后一个element(file/directory)的inode，并将最后一个element的名字拷贝到name中</li>
<li>nameiparent = 1 : 返回path最后一个element(file/directory)的的parent的inode，并将最后一个element的名字拷贝到name中</li>
<li>从哪里查找的？: <ul>
<li> 将path一级级，逐级拆分出一个个name，在当前directory inode下查找出(dirlookup)inode；</li>
<li> 然后将该inode，作为下一级name的directory node，也即在这个刚查出来的inode下，查找name对应的inode。</li>
<li> 一级级查找，直到查到path的最后一级别的inode。返回即可。</li>
</ul>
</li>
</ul>
</li>
<li><p> namex过程可能需要很长时间才能完成：它可能涉及多个磁盘操作来读取路径名中所遍历目录的索引节点和目录块（如果它们不在buffer cache中）。</p>
</li>
<li><p> Xv6经过精心设计，如果一个内核线程对namex的调用在磁盘I/O上阻塞，另一个查找不同路径名的内核线程可以同时进行。Namex分别锁定路径中的每个目录，以便在不同目录中进行并行查找。</p>
</li>
<li><p>struct inode* namei(char *path)</p>
<ul>
<li>返回path最后一个element的inode</li>
<li>return namex(path, 0, name);</li>
</ul>
</li>
<li><p>struct inode* nameiparent(char *path, char *name)</p>
<ul>
<li>返回path最后一个element的父目录的inode</li>
<li>return namex(path, 1, name);</li>
<li>可用于在某dir路径下创建新entry。</li>
</ul>
</li>
</ul>
<h2 id="fd-文件描述符层"><a href="#fd-文件描述符层" class="headerlink" title="fd 文件描述符层"></a>fd 文件描述符层</h2><h3 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h3><ul>
<li>为什么可以多个process同时打开一个文件？答案就是如下结构体 struct file。</li>
<li><strong>struct file</strong>{} : 文件结构体<ul>
<li>inode或管道的封装，加上一个I/O偏移量<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">  <span class="keyword">int</span> ref;          <span class="comment">// reference count  当前内存中有几个人正在使用该文件</span></span><br><span class="line">  <span class="keyword">char</span> readable;</span><br><span class="line">  <span class="keyword">char</span> writable;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// FD_PIPE</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span>  <span class="comment">// FD_INODE and FD_DEVICE</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE</span></span><br><span class="line">  <span class="keyword">short</span> major;       <span class="comment">// FD_DEVICE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>每次调用open都会创建一个新的打开文件（一个新的struct file）：如果多个进程独立地打开同一个文件，那么不同的实例将具有不同的I/O偏移量。</li>
<li>另一方面，单个打开的文件（同一个struct file）可以多次出现在一个进程的文件表中，也可以出现在多个进程的文件表中</li>
<li>如果一个进程使用open打开文件，然后使用dup创建别名，或使用fork与子进程共享，就会发生这种情况。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>struct ftable</strong> : <strong>文件表file table 存储所有struct file</strong><ul>
<li>file table : 每个槽位都是个struct file容器，存储所有打开的文件，即创建的struct file<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> <span class="title">file</span>[<span class="title">NFILE</span>];</span></span><br><span class="line">&#125; ftable;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>文件描述符表 : 每个进程都有的一个fd表</strong></p>
<ul>
<li>proc结构体中有<strong>struct file *ofile[NOFILE];</strong>  // Open files</li>
<li>这就是常说的文件描述符表/fd表</li>
<li><strong>是每个process 由 fd 到 struct file的索引表</strong></li>
</ul>
</li>
<li><p><strong>可以看到，struct inode和struct file本身并不具有name属性，实际上都是entry中附加包含的</strong>。</p>
</li>
</ul>
<h3 id="接口-4"><a href="#接口-4" class="headerlink" title="接口"></a>接口</h3><ul>
<li><p><strong>filealloc</strong></p>
<ul>
<li>struct file* filealloc(void)</li>
<li>作用：从ftable中返回一个free的struct file容器给调用者用于承载文件。<ul>
<li>仅仅是在操作struct file<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">acquire(&amp;ftable.lock);</span><br><span class="line"><span class="keyword">for</span>(f = ftable.file; f &lt; ftable.file + NFILE; f++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref == <span class="number">0</span>)&#123;</span><br><span class="line">    f-&gt;ref = <span class="number">1</span>;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">release(&amp;ftable.lock);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>fdalloc</strong></p>
<ul>
<li>fdalloc(struct file *f)</li>
<li>将 struct file记录在process的文件描述符表ofile中的空闲位置，为用户提供一种方式：通过free fd来索引struct file<ul>
<li>记录file: process-&gt;ofile[fd] = f</li>
<li>返回fd</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>filedup</strong></p>
<ul>
<li>重复引用file</li>
<li>f-&gt;ref++;</li>
</ul>
</li>
<li><p><strong>fileclose</strong></p>
<ul>
<li>作用：释放引用,若对file的ref降至0,则iput其inode<ul>
<li>操作struct file，有可能操作inode<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fileclose</span><span class="params">(struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    release(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  f.ref == 0;</span></span><br><span class="line">  ff = *f;</span><br><span class="line">  <span class="comment">//  清空ftable记录</span></span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="comment">//  释放file的inode</span></span><br><span class="line">  begin_op();</span><br><span class="line">  iput(ff.ip);</span><br><span class="line">  end_op();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>fileread</strong></p>
<ul>
<li>通过readi,在file-&gt;inode中读取数据送入用户内存。（读取的起点是struct file.offset）</li>
<li>核心逻辑如下<ul>
<li>检查readable/writable是否允许该操作，然后将调用传递给pipe / inode的实现<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fileread(struct file *f, uint64 addr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  ilock(f-&gt;ip);</span><br><span class="line">  <span class="comment">//  f-&gt;off即为操作文件时的起始偏移量</span></span><br><span class="line">  r = readi(f-&gt;ip, <span class="number">1</span>, addr, f-&gt;off, n);</span><br><span class="line">  f-&gt;off += r;</span><br><span class="line">  iunlock(f-&gt;ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>filewrite</strong></p>
<ul>
<li>通过writei,向file-&gt;node写数据</li>
<li>检查打开模式是否允许该操作，然后将调用传递给管道或inode的实现<ul>
<li>核心逻辑如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; bytes_to_write)&#123;</span><br><span class="line">  begin_op();</span><br><span class="line">  ilock(f-&gt;ip);</span><br><span class="line">  r = writei(f-&gt;ip, <span class="number">1</span>, addr + i, f-&gt;off, n1);</span><br><span class="line">  f-&gt;off += r;</span><br><span class="line">  iunlock(f-&gt;ip);</span><br><span class="line">  end_op();</span><br><span class="line">  i+=r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>通过fileread和filewrite可以看出，xv6中，文件的read和write共同维护同一个offset.</p>
</li>
<li><p>且可以看出，得益于ilock(file.inode)，使得各个进程可以原子的更新offset；即，使得对同一文件的同时多次写入不能覆盖彼此的数据，尽管他们的写入最终可能是交错的。</p>
</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ul>
<li><strong>sys_link</strong><ul>
<li>作用：<strong>新建立一条硬链接 从 new entry 索引到 现有inode</strong>。</li>
<li>直观来看就是在编辑目录，为现有的inode新增一个名字。通过创建个指向现有inode的entry实现。</li>
<li>下面约定叫老文件old对应的inode,即需要新增链接的这个node,称为目标inode</li>
<li>trapframe传入old,new<ul>
<li>old : 目标inode的name</li>
<li>new : 新entry的路径</li>
</ul>
</li>
<li>逻辑<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sys_link(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//  old : 老文件的name</span></span><br><span class="line">  <span class="comment">//  new : 即将新建立的entry，我们将要让该entry指向old inode。注意这个new不是file，而是一个entry</span></span><br><span class="line">  <span class="comment">//  目的 : 要在new所在的directory,建立一个新entry(old_inum , new_entry_name)</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">new</span>[MAXPATH], old[MAXPATH];  </span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"><span class="comment">//  操作目标inode : ++nlink</span></span><br><span class="line">&#123;  </span><br><span class="line">  ip = namei(old);      <span class="comment">//  根据name old获取对应的inode</span></span><br><span class="line">  ilock(ip);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  check whether ip is directory ; if true , fail;</span></span><br><span class="line">  ip-&gt;nlink++;</span><br><span class="line"></span><br><span class="line">  iupdate(ip);</span><br><span class="line">  iunlock(ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  操作new的parent inode : 创建entry(old_inum,new)</span></span><br><span class="line">&#123;</span><br><span class="line">  dp = nameiparent(<span class="keyword">new</span>, name);</span><br><span class="line">  ilock(dp);</span><br><span class="line">  dirlink(dp, name, ip-&gt;inum);    <span class="comment">//  directory dp下 新增entry(inum,name)</span></span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  iput(ip);</span><br><span class="line">&#125;</span><br><span class="line">  end_op();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> 硬链接不支持directory。ubuntu下 hard link not allowed for directory。xv6下的 sys_link 也会检查要增加link的inode是否是directory；若是，则失败</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>sys_unlink</strong></p>
<ul>
<li>删除entry,–inode.nlink<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;entry, <span class="number">0</span>, <span class="keyword">sizeof</span>(entry));</span><br><span class="line">writei(entry, <span class="number">0</span>, (uint64)&amp;entry, off, <span class="keyword">sizeof</span>(entry));</span><br><span class="line">ip-&gt;nlink--;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>create</strong></p>
<ul>
<li>static struct inode* create(char *path, short type, short major, short minor)</li>
<li><strong>作用</strong>：<strong>新创建一个inode</strong>，并在path处创建一个entry指向该inode。注意更新其parent directory。</li>
<li>返回一个<strong>独占的inode</strong></li>
<li>简单来说，就是创建新node 并给其新name</li>
<li>逻辑如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  create 为新inode创建一个新名称的新entry</span></span><br><span class="line"><span class="comment">//  返回一个被锁定的inode</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode* <span class="title">create</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">short</span> type, <span class="keyword">short</span> major, <span class="keyword">short</span> minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  找到path 最后一个 element的 parent directory</span></span><br><span class="line">  dp = nameiparent(path, name);</span><br><span class="line"></span><br><span class="line">  ilock(dp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  如果之前存在 视为成功</span></span><br><span class="line">  <span class="keyword">if</span>((ip = dirlookup(dp, name, <span class="number">0</span>)) != <span class="number">0</span>)&#123;</span><br><span class="line">    iunlockput(dp);</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  if name对应的entry对应的inode并不存在 , 那么进行分配inode</span></span><br><span class="line">  <span class="comment">//  get初始化了inode metadata的i弄得</span></span><br><span class="line">  ip = ialloc(dp-&gt;dev, type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  inode 中dinode meta data初始化</span></span><br><span class="line">  ilock(ip);</span><br><span class="line">  ip-&gt;major = major;</span><br><span class="line">  ip-&gt;minor = minor;</span><br><span class="line">  ip-&gt;nlink = <span class="number">1</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  如果create是要创建一个目录 , 也即 inode要作为一个目录的inode</span></span><br><span class="line">  <span class="keyword">if</span>(type == T_DIR)&#123;  <span class="comment">// Create . and .. entries.</span></span><br><span class="line">    dp-&gt;nlink++;  <span class="comment">// for &quot;..&quot;</span></span><br><span class="line">    <span class="comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span></span><br><span class="line">    iupdate(dp);  <span class="comment">//  write through</span></span><br><span class="line">    <span class="comment">//  在inode下，新增自带的. 和 .. entry</span></span><br><span class="line">    dirlink(ip, <span class="string">&quot;.&quot;</span>, ip-&gt;inum);</span><br><span class="line">    dirlink(ip, <span class="string">&quot;..&quot;</span>, dp-&gt;inum);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  在parent directory下 创建索引新建inode的entry</span></span><br><span class="line">  dirlink(dp, name, ip-&gt;inum);</span><br><span class="line"></span><br><span class="line">  iunlockput(dp);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>sys_open、sys_mkdir和sys_mknod都利用了create</p>
</li>
<li><p><strong>sys_mkdir</strong>: 创建文件夹</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">begin_op();</span><br><span class="line">ip = create(path, T_DIR, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">iunlockput(ip);</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure></li>
<li><p><strong>sys_open</strong>: 创建文件</p>
<ul>
<li><ol>
<li>以某种方式获得inode</li>
</ol>
<ul>
<li>O_CREATE标志，调用create</li>
<li>否则，调用namei<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  如果open被传递了O_CREATE标志，它将调用create（kernel/sysfile.c:301）。</span></span><br><span class="line"><span class="comment">//  create ilock(inode)</span></span><br><span class="line"><span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">  ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//  否则，它将调用namei（kernel/sysfile.c:307）</span></span><br><span class="line"><span class="comment">//  namei不ilock(inode),因此需要sys_open自己ilock</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ip = namei(path)</span><br><span class="line">  ilock(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="2">
<li>为新建的inode 分配 free struct file 和 free fd。</li>
</ol>
<ul>
<li>从全局的ftable中分配free struct file 来作为文件容器，承载inode。</li>
<li>将 struct file记录在process的文件描述符表ofile中的空闲位置，为用户提供一种方式：通过free fd来索引struct file。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  从ftable中分配free struct file 来承载inode</span></span><br><span class="line"><span class="comment">//  从ofile中分配free fd 来索引struct file</span></span><br><span class="line">f = filealloc();</span><br><span class="line">fd = fdalloc(f);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ol start="3">
<li>填充该文件<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f-&gt;type = FD_INODE;</span><br><span class="line">f-&gt;off = <span class="number">0</span>;</span><br><span class="line">f-&gt;ip = ip;                         <span class="comment">//  inode挂在struct file上</span></span><br><span class="line">f-&gt;readable = !(omode &amp; O_WRONLY);  <span class="comment">//  根据mode指明权限</span></span><br><span class="line">f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"><span class="comment">// if mode为O_TRUNC</span></span><br><span class="line">itrunc(ip);</span><br><span class="line">iunlock(ip);</span><br><span class="line">end_op();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="4">
<li>return fd</li>
</ol>
<ul>
<li>给user返回file索引：fd。</li>
<li>结束。文件至此创建完毕。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>首先，文件系统是一个位于磁盘的数据结构</li>
<li>关注block cache的实现，这对于性能来说是至关重要的，因为读写磁盘是代价较高的操作，可能要消耗数百毫秒，而block cache确保了如果我们最近从磁盘读取了一个block，那么我们将不会再从磁盘读取相同的block。</li>
</ul>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统xv6-系统调用</title>
    <url>/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>本文介绍xv6的trap流程</p>
<ul>
<li><p>user空间和kernel空间的切换称为<strong>trap</strong></p>
<ul>
<li>xv6 系统调用 是如何在user和kernel空间进行切换的 ? </li>
</ul>
</li>
<li><p>关键步骤及指令如下</p>
<ul>
<li>user <strong>ecall</strong> <ul>
<li>提高程序的权限 , 保存当前地址($sepc) , 记录trap原因(r_scause()) , 跳转到trampoline</li>
</ul>
</li>
<li><strong>trampoline uservec</strong><ul>
<li>将cpu reg中user的上下文保存进trapframe,如user stack pointer , return addr 等; 并将 kernel thread的上下文聪trapframe加载进cpu reg. 如kernel stack pointer , func to jump , kernel pgtbl($satp). 然后跳转到usertrap()</li>
</ul>
</li>
<li><strong>usertrap</strong> <ul>
<li>根据陷入kernel的原因($scause),执行动作如syscall().</li>
</ul>
</li>
<li><strong>usertrapret</strong> <ul>
<li>即将离开kernel , 将kernel上下文保存进trapframe , 以便下次陷入内核时trampoline将其加载进来. 跳到userret</li>
</ul>
</li>
<li><strong>trampoline userret</strong> <ul>
<li>切换到 user pagetable , 将user上下文从trapframe加载进来. 跳转回user($sepc)</li>
</ul>
</li>
<li>user <strong>ret</strong> : 跳到user程序的下一指令</li>
</ul>
</li>
<li><p>之前有人问我个问题hhh，当复习了。</p>
<ul>
<li>从用户到内核需要的寄存器哪些会发生改变啊?</li>
<li>答：</li>
<li><blockquote>
<p>比说ecall吧. 他得改变代表权限的reg,从user mode改成supverisor mode ； 还得改变保存$PC到$sepc reg.；还得设置$scause reg代表trap的原因；进入trampoline的uservec之后，得把之前user态时候cpu上的reg保存进内存，然后将该process的kernel thread的上下文加载到cpu的reg上. 比如说kernel stack pointer加载到$sp ; 还得改变$satp,切换成kernel pagetable来切换地址空间,</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<span id="more"></span>



<h1 id="xv6-系统调用"><a href="#xv6-系统调用" class="headerlink" title="xv6 系统调用"></a>xv6 系统调用</h1><h1 id="TRAP机制"><a href="#TRAP机制" class="headerlink" title="TRAP机制"></a>TRAP机制</h1><ul>
<li>用户空间和内核空间的切换通常被称为trap，而trap涉及了许多小心的设计和重要的细节，这些细节对于实现安全隔离和性能来说非常重要。<ul>
<li>因为很多应用程序，要么因为系统调用，要么因为page fault，都会频繁的切换到内核中。所以，trap机制要尽可能的简单，这一点非常重要。</li>
</ul>
</li>
</ul>
<ul>
<li>一些重要寄存器<ul>
<li>PC (Program Counter Register) : <ul>
<li>程序计数器 </li>
</ul>
</li>
<li>MODE : <ul>
<li>当前是supervisor mode还是user mode</li>
<li>当我们在运行Shell的时候，自然是在user mode</li>
<li>vm.c中的函数全部是内核的一部分，运行在supervisor mode下</li>
</ul>
</li>
<li>SATP (Supervisor Address Translation and Protection) <ul>
<li>page table的物理内存地址</li>
</ul>
</li>
<li>STVEC (Supervisor Trap Vector Base Address Register)<ul>
<li>指向了内核中处理trap指令的起始地址。</li>
</ul>
</li>
<li>SEPC (Supervisor Exception Program Counter)<ul>
<li>trap过程中保存PC值</li>
<li>是为了之后从kernel return 到 usrspace时 可以知道要回到哪条指令。</li>
</ul>
</li>
<li>SSRATCH (Supervisor Scratch Register)<ul>
<li>sscratch points to where the process’s p-&gt;trapframe is mapped into user space, at TRAPFRAME</li>
</ul>
</li>
<li>SCAUSE<ul>
<li>通过trap机制进入到supervisor mode的原因</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-19-17-02.png"></p>
</blockquote>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="user态"><a href="#user态" class="headerlink" title="user态"></a>user态</h4><ul>
<li>user态<ul>
<li>我们跟踪sh.c中的write系统调用</li>
</ul>
</li>
</ul>
<h4 id="ecall"><a href="#ecall" class="headerlink" title="ecall"></a><strong>ecall</strong></h4><ul>
<li>指令如下 <ul>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-19-23-02.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>并不是ecall之后就完全进入了内核的C代码，还有很远的距离。</li>
<li>ecall作用，简要来说就是 提高程序的权限，跳转到特定的地址.</li>
<li><strong>那么ecall 都做了什么? ecall只做了四件事。</strong><ul>
<li><strong>1. ecall将代码从user mode改到supervisor mode</strong><ul>
<li>这也就是所谓的用户态运行非特权指令，内核态运行特权和非特权指令。</li>
<li>话说用户态不能访问内核态得地址空间在xv6中究其原因是user process和kernel 用的根本不是一个页表。那么在linux中也是这个原因吧。</li>
</ul>
</li>
<li><strong>2. ecall将当前PC的值（即user态ecall代码所在地址）保存在了$sepc reg。以便将来返回。</strong></li>
<li><strong>3. 设置 $scause reg 去反映 trap 的原因 (ecall, 8)</strong></li>
<li><strong>4. ecall会使得PC跳转到 $ svec reg指向的指令。</strong><ul>
<li>在从trap是从user进入kernel的这一步骤，也即，PC指向<strong>tramopline的uservec段</strong>。</li>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-19-40-48.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-19-49-31.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>以上三个操作都是硬件负责实现的。</li>
</ul>
</li>
<li><strong>syscall语义 ： 进入kernel</strong><ul>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-10-29-19-48-55.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>ecall 语义 ：类似syscall,进入kernel</strong><ul>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-10-30-19-10-57.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>ecall : 即将进入trapmpoline。不是ecall之后就完全陷入了内核!<ul>
<li>注意此时还是user page table</li>
</ul>
</li>
</ul>
<h4 id="trapframe"><a href="#trapframe" class="headerlink" title="trapframe"></a><strong>trapframe</strong></h4><ul>
<li>先说一下<strong>trapframe(0x3fffffe000)</strong><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// kernel code usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter to return to</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li> <strong>用于保存进程寄存器现场的内存</strong></li>
<li> <strong>每个userprocess</strong>都有一段trapframe</li>
<li>trapframe保存的重要内容:<ul>
<li><strong>sepc reg 被保存在p-&gt;trapframe-&gt;epc中</strong><ul>
<li>p-&gt;trapframe-&gt;epc = r_sepc();</li>
<li><strong>sepc : process 在user态时的程序计数器</strong>。<ul>
<li>process如何实现从kernel中返回待user?(如何进行向用户代码的跳转)<ul>
<li>在trampoline userret，最后一句sret指令 : 会将pc设置成$sepc reg。</li>
<li>而在userret之前的usertrapret：w_sepc(p-&gt;trapframe-&gt;epc);。会将之前（比如user刚进入usertrap时的sepc reg），保存在p-&gt;trapframe-&gt;epc中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>内核的 : 还有kernel pagetable , kernel stack pointer , usertrap()地址等</li>
<li>还有其他user寄存器等</li>
</ul>
</li>
</ul>
<h4 id="trampoline-uservec"><a href="#trampoline-uservec" class="headerlink" title="trampoline uservec"></a><strong>trampoline uservec</strong></h4><blockquote>
<p>trampoline.S (汇编代码)</p>
<ul>
<li>对 ecall 瞬间的状态做快照，保存到trapframe处。</li>
<li>填充 struct trapframe (proc.h)</li>
<li>利用 $sscratch (S-mode scratch ) 保存所有寄存器</li>
<li>切换到内核栈 (相当于切换到进程对应的 “内核线程”, L2)</li>
<li>切换到内核地址空间<ul>
<li>修改 $satp (S-mode address translation and protection)</li>
<li>sfence.vma</li>
</ul>
</li>
<li>跳转到 tf-&gt;kernel_trap<ul>
<li>痛苦时间解除，进入 C 代码</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p>再简要说一下<strong>trampoline</strong></p>
<ul>
<li>功能：<strong>对 ecall 瞬间的状态做快照，保存到trapframe处。</strong></li>
</ul>
</li>
<li><p><strong>问题1：为什么切换到页表之后不会崩溃？明明映射都不同了？</strong></p>
<ul>
<li>csrw satp, t1 # 切换页表</li>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-16-13-28.png"></p>
</blockquote>
</li>
<li>原因见下</li>
<li><strong>user process 和 kernel process 唯一相同的映射就是trampoline page</strong>。<ul>
<li>即在user virtual address 和 kernel virtual process 的trampoline page 都映射到了同一块DRAM</li>
</ul>
</li>
<li><strong>也正是因此，保证了我们在从user切换到kernel pagetable时不会异常终止</strong>。<ul>
<li>因为切换的过程中就是在执行trampoline的uservec代码。且切换完成后，寻址的结果不会改变，我们可以在同一代码序列执行程序而不崩溃。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>call之后我们进入了uservec</p>
</li>
<li><p><strong>ecall并不会切换page table，这是ecall指令的一个非常重要的特点。所以这意味着，trap处理代码必须存在于每一个user page table中</strong>。</p>
</li>
<li><p><strong>因此每个user的process的虚拟地址里的顶部都是trampoline</strong></p>
</li>
<li><p>刚进入trampoline的uservec</p>
<ul>
<li><strong>使用的还是user的page table</strong>。即所看到的、所使用的地址仍然是user pagetable维护的虚拟地址</li>
<li>我们找到<strong>trampoline的内容也是通过user的page table维护的虚拟地址0x3ffffff000找到</strong>的。</li>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-19-47-39.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>trampoline都做了什么：<ul>
<li><strong>将当前cpu上运行的user process的上下文从cpu reg上存入user process的trapframe中。</strong>，即 保护用户寄存器。<ul>
<li>save user’s context from cpu reg into dram(trapframe)</li>
<li>如何实现保护用户寄存器？(利用 $sscratch (S-mode scratch ) 保存所有寄存器)<ul>
<li><ol>
<li>XV6在每个user page table映射了trapframe page，这样每个进程都有自己的trapframe page(这个位置的虚拟地址总是0x3ffffffe000)</li>
</ol>
</li>
<li><ol start="2">
<li>如何找到user process的trapframe ? : sscratch 指向的地址是trapframe的虚拟地址.</li>
</ol>
<ul>
<li>trapframe的地址是怎么出现在SSCRATCH寄存器中的？<ul>
<li>在内核前一次切换回用户空间时，内核会执行set sscratch指令，将这个寄存器的内容设置为0x3fffffe000，也就是trapframe page的虚拟地址。所以，当我们在运行用户代码，比如运行Shell时，SSCRATCH保存的就是指向trapframe的地址。之后，Shell执行了ecall指令，跳转到了trampoline page，这个page中的第一条指令会交换a0和SSCRATCH寄存器的内容。所以，SSCRATCH中的值，也就是指向trapframe的指针现在存储与a0寄存器中。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>将当前cpu上运行的user process之前保存在trapframe中的一些kernel context需要用到的上下文加载进cpu的reg</strong><ul>
<li>ld user process context from dram(trapframe) to cpu reg</li>
<li><strong>内核栈指针：cpu sp reg = kernel_sp</strong><ul>
<li>切换到内核栈 (相当于切换到进程对应的 “内核线程”, L2)</li>
<li>我认为作用是之后 对于改userprocess trap陷入内核之后 的 在内核的函数调用所开辟的栈帧，都是建立在这个kernel_sp的栈帧中的。</li>
</ul>
</li>
<li>当前cpu ：p-&gt;trapframe-&gt;kernel_hartid</li>
<li>内核处理trap的函数：t0 = p-&gt;trapframe-&gt;kernel_trap</li>
<li><strong>当前页表替换为全局内核页表：satp = p-&gt;trapframe-&gt;kernel_satp</strong><ul>
<li>切换到内核地址空间</li>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-16-37-37.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>跳转到usertrap:jr t0</strong><ul>
<li>从trampoline跳转到内核的C code中。</li>
<li><strong>以kernel stack，kernel page table跳转到usertrap函数</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>uservec code<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uservec:    </span><br><span class="line"><span class="meta"># trap.c sets stvec to point here, so traps from user space start here,</span></span><br><span class="line"><span class="meta"># in supervisor mode, but with a user page table.</span></span><br><span class="line"><span class="meta"># sscratch points to where the process<span class="meta-string">&#x27;s p-&gt;trapframe is mapped into user space, at TRAPFRAME.</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">#** save user&#x27;</span>s context from cpu reg into dram(trapframe) **</span></span><br><span class="line">将当前cpu上运行的user process的上下文从cpu寄存器上存入dram的trapframe中</span><br><span class="line"><span class="meta"># swap a0 and sscratch so that a0 is TRAPFRAME</span></span><br><span class="line">  csrrw a0, sscratch, a0          </span><br><span class="line">  这条指令交换了寄存器a0和sscratch的内容</span><br><span class="line">  <span class="meta"># swap(ssrcatch , a0)</span></span><br><span class="line">      # a0 = trapframe</span><br><span class="line">      <span class="meta"># ssrcatch = user a0 </span></span><br><span class="line">  # SSCRATCH寄存器的作用就是保存另一个寄存器的值，并将自己的值加载给另一个寄存器</span><br><span class="line">  <span class="meta"># save the user registers in TRAPFRAME</span></span><br><span class="line">  sd ra, <span class="number">40</span>(a0)</span><br><span class="line">  sd sp, <span class="number">48</span>(a0)</span><br><span class="line">  sd gp, <span class="number">56</span>(a0)</span><br><span class="line">  sd tp, <span class="number">64</span>(a0)</span><br><span class="line">  ...</span><br><span class="line">  sd a1, <span class="number">120</span>(a0)</span><br><span class="line">  sd a2, <span class="number">128</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">  csrr t0, sscratch       # t0 = a0</span><br><span class="line">  sd t0, <span class="number">112</span>(a0)          <span class="meta"># p-&gt;trapframe-&gt;a0 = a0</span></span><br><span class="line"></span><br><span class="line"># **ld user process context from <span class="built_in">dram</span>(trapframe) to cpu reg**</span><br><span class="line">  <span class="meta"># restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span></span><br><span class="line">  ld sp, <span class="number">8</span>(a0)</span><br><span class="line">  <span class="meta"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span><br><span class="line">  ld tp, <span class="number">32</span>(a0)</span><br><span class="line">  <span class="meta"># load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span></span><br><span class="line">  ld t0, <span class="number">16</span>(a0)</span><br><span class="line">  <span class="meta"># restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span><br><span class="line">  ld t1, <span class="number">0</span>(a0)</span><br><span class="line">  csrw satp, t1 # 切换页表</span><br><span class="line">  sfence.vma zero, zero</span><br><span class="line">  # a0 is no longer valid, since the kernel page</span><br><span class="line">  <span class="meta"># table does not specially map p-&gt;tf.</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># jump to usertrap(), which does not return</span></span><br><span class="line">  jr t0</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a><strong>usertrap</strong></h4><ul>
<li><p>有很多原因都可以让程序运行进入到usertrap函数中来，比如系统调用，运算时除以0，使用了一个未被映射的虚拟地址，或者是设备中断。usertrap某种程度上存储并恢复硬件状态，但是它也需要检查触发trap的原因，以确定相应的处理方式，我们在接下来执行usertrap的过程中会同时看到这两个行为</p>
</li>
<li><p>usertrap行为：做些前置处理，然后根据发生trap的原因(scause)进行相应动作如系统调用，然后准备返回user态.(usertrapret)</p>
</li>
<li><p>usertrap</p>
<ul>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-22-08-00.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-22-09-35.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>syscall</p>
<ul>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-22-15-01.png"></p>
</blockquote>
</li>
<li>向trapframe中的a0赋值的原因是：所有的系统调用都有一个返回值，比如write会返回实际写入的字节数，而RISC-V上的C代码的习惯是函数的返回值存储于寄存器a0，所以为了模拟函数的返回，我们将返回值存储在trapframe的a0中**。之后，当我们返回到用户空间，trapframe中的a0槽位的数值会写到实际的a0寄存器，Shell会认为a0寄存器中的数值是write系统调用的返回值。</li>
</ul>
</li>
<li><p>获取trapframe中的参数</p>
<ul>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-22-11-51.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>内存trapframe里存储的值，有一部分是user process进入kernel需要用的上下文（就是前几个，内核栈指针啥的）。<br>有一部分是从process从kernel恢复到user需要使用的寄存器(上下文)。</p>
</li>
</ul>
<h4 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a><strong>usertrapret</strong></h4><ul>
<li>usertrapret.c<ul>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-22-45-47.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/10/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2022-11-03-22-41-02.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>uint64 satp = MAKE_SATP(p-&gt;pagetable)<ul>
<li>我们根据user page table地址生成相应的SATP值，这样我们在返回到用户空间的时候才能完成page table的切换。实际上，<strong>我们会在汇编代码trampoline中完成page table的切换，并且也只能在trampoline中完成切换，因为只有trampoline中代码是同时在用户和内核空间中映射</strong> </li>
</ul>
</li>
</ul>
<h4 id="trampoline-userret-kernel"><a href="#trampoline-userret-kernel" class="headerlink" title="trampoline userret (kernel)"></a><strong>trampoline userret (kernel)</strong></h4><p>流程如下</p>
<ul>
<li><strong>1. 切换page table</strong><ul>
<li>由kernel page table 变成user page table 。由于trampoline page是两页表映射的相同部分，因此代码可以正常运行。</li>
</ul>
</li>
<li><strong>2. 将trapframe中保存的对user process有用的上下文加载进cpu的reg中; 将trapframe的地址存回sscratch中</strong></li>
<li><strong>3. sret是我们在kernel中的最后一条指令</strong><ul>
<li><strong>程序会切换回user mode</strong></li>
<li><strong>$sepc会被拷贝到PC寄存器（程序计数器）</strong><ul>
<li>trapframe-&gt;epc 是在进入内核后/返回user前 内核设置好的，应当返回到user的哪个指令。</li>
</ul>
</li>
<li><strong>重新打开中断</strong></li>
</ul>
</li>
<li><strong>之后我们回到了用户空间。</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        <span class="meta"># sret 时 ，先将trapframe交给a0寄存器，然后加载完user process的上下文之后，</span></span><br><span class="line">        # 就将trapframe的地址再存入sscratch</span><br><span class="line">        <span class="meta"># userret(TRAPFRAME, pagetable)</span></span><br><span class="line">        <span class="meta"># switch from kernel to user.</span></span><br><span class="line">        <span class="meta"># usertrapret() calls here.</span></span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, <span class="keyword">for</span> satp.</span><br><span class="line"># 将user process的上下文从<span class="built_in">dram</span>(trapframe)中加载进cpu的reg</span><br><span class="line">      # <span class="number">1.</span> 切换成用户页表</span><br><span class="line">        <span class="meta"># switch to the user page table.</span></span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">      # <span class="number">2.</span> 将trapframe中保存的对user process有用的上下文加载进cpu的reg中; 将trapframe的地址存回sscratch中</span><br><span class="line">        # a0是trapframe地址 临时保存user的a0到sscratch中 </span><br><span class="line">        <span class="meta"># put the saved user a0 in sscratch, so we</span></span><br><span class="line">        <span class="meta"># can swap it with our a0 (TRAPFRAME) in the last step.</span></span><br><span class="line">        ld t0, <span class="number">112</span>(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld sp, <span class="number">48</span>(a0)</span><br><span class="line">        ld gp, <span class="number">56</span>(a0)</span><br><span class="line">        ld tp, <span class="number">64</span>(a0)</span><br><span class="line">        ld t0, <span class="number">72</span>(a0)</span><br><span class="line">        ....</span><br><span class="line">        ld s1, <span class="number">104</span>(a0)</span><br><span class="line">        ld a1, <span class="number">120</span>(a0)</span><br><span class="line">        # 将user的trapframe放回sscratch</span><br><span class="line">        <span class="meta"># restore user a0, and save TRAPFRAME in sscratch</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">      # <span class="number">3.</span>   </span><br><span class="line">        <span class="meta"># return to user mode and user pc.</span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        sret</span><br><span class="line">        程序会切换回user mode</span><br><span class="line">        SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器）</span><br><span class="line">        重新打开中断</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>系统调用被刻意设计的看起来像是函数调用，但是背后的user/kernel转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持user/kernel之间的隔离性，内核不能信任来自用户空间的任何内容.</li>
</ul>
<ul>
<li>通过trap机制从用户态进入内核态的开销为什么大，大在哪里？<ul>
<li>trampoline.S中，就有很多很多（离开和进入总共100多条）指令来存储当前寄存器</li>
<li>cpu $satp 扔掉user pagetable , 重新加载 kernel pagetable。清空当前TLB。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span><br><span class="line">ld t1, <span class="number">0</span>(a0)</span><br><span class="line">csrw satp, t1       <span class="meta"># cpu $satp 扔掉user pagetable , 重新加载 kernel pagetable</span></span><br><span class="line">sfence.vma zero, zero   # 清空当前TLB。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>xv6</category>
      </categories>
      <tags>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU调度策略</title>
    <url>/2022/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>线程是CPU基本调度单位（如果os支持线程的话）.<br>CPU调度没有对错，只有好坏，即作出的选择是否合适 .<br>cpu调度策略 : 先来先服务,最短作业优先,最短剩余时间优先调度,最短剩余时间优先调度,轮转调度,多级队列调度,最高优先级调度,多级反馈队列调度 . </p>
<span id="more"></span>


<h2 id="因素-及-准则"><a href="#因素-及-准则" class="headerlink" title="因素 及 准则"></a>因素 及 准则</h2><ul>
<li><p><strong>任务周转时间</strong>：即任务从新建进入os到该任务完成离开os所经历的全部时间</p>
<ul>
<li><strong>后台（非交互式）任务关注周转时间</strong></li>
</ul>
</li>
<li><p><strong>任务响应时间</strong>：即从用户向程序发起一个交互操作到该任务响应这个操作之间经历的时间。例如单机菜单到弹出菜单这段时间。</p>
<ul>
<li><strong>前台（交互式）任务关注响应时间</strong></li>
</ul>
</li>
<li><p><strong>系统吞吐量</strong>：即一段时间内计算机系统能完成的任务总数。（系统内耗时间少）</p>
</li>
<li><p>吞吐量和响应时间之间有矛盾</p>
<ul>
<li>响应时间小 =》切换次数多 =》 系统内耗大 =》吞吐量小</li>
</ul>
</li>
<li><p>IO密集型和CPU密集型任务<br><img src="/2022/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/2022-09-07-09-52-16.png"></p>
<ul>
<li>CPU密集型，也即CPU约束型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|--------CPU-------|--IO--|--------CPU-------|--IO--|</span><br></pre></td></tr></table></figure></li>
<li>IO密集型，也即IO约束型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|--CPU--|--------IO--------|--CPU--|--------IO--------|</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="先来先服务-First-Come-First-Severd-FCFS"><a href="#先来先服务-First-Come-First-Severd-FCFS" class="headerlink" title="先来先服务 First Come First Severd, FCFS"></a>先来先服务 First Come First Severd, FCFS</h3><ul>
<li><p><strong>特点：公平</strong></p>
</li>
<li><p>先来后到，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行</p>
<ul>
<li>这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，不利于短作业。<br><img src="/2022/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/2022-09-07-09-57-58.png"></li>
</ul>
</li>
</ul>
<h3 id="最短作业优先-Shortest-Job-First-SJF"><a href="#最短作业优先-Shortest-Job-First-SJF" class="headerlink" title="最短作业优先 Shortest Job First, SJF"></a>最短作业优先 Shortest Job First, SJF</h3><ul>
<li><strong>短作业优点：周转时间最小</strong><br><img src="/2022/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/2022-09-06-09-06-57.png"></li>
</ul>
<ul>
<li>优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。</li>
</ul>
<h3 id="最短剩余时间优先调度-Shortest-Remaining-Time-First-SRTF"><a href="#最短剩余时间优先调度-Shortest-Remaining-Time-First-SRTF" class="headerlink" title="最短剩余时间优先调度 Shortest Remaining Time First , SRTF"></a>最短剩余时间优先调度 Shortest Remaining Time First , SRTF</h3><ul>
<li><p>实际上，任务不可能一下子同时出现在0时刻，os无法在0时刻决定出那个先调度那进程，因此实际上是 <strong>最短剩余时间优先调度</strong></p>
<ul>
<li>每次新任务到达时，选择剩余执行时间最短的进行运行。</li>
<li><img src="/2022/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/2022-09-07-10-03-06.png"></li>
<li>是一种<strong>可抢占调度</strong></li>
</ul>
</li>
<li><p>对于旨在缩小平均周转时间的非交互式任务，SRTF看起来是个可以解决问题的调度算法。</p>
<ul>
<li>不过存在一个问题：需要<strong>预测任务执行时间</strong><ul>
<li>任务得到CPU之后将会执行的时间长度，只有任务完成以后</li>
</ul>
</li>
<li>并且实际上也并不是只有非交互式任务，还存在交互式任务<ul>
<li>SRTF中，任何任务要等到前面的任务全部执行完成以后才被调度，所以最差的用户响应时间可能很大</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="轮转调度-Round-Robin-RR"><a href="#轮转调度-Round-Robin-RR" class="headerlink" title="轮转调度 Round Robin, RR"></a>轮转调度 Round Robin, RR</h3><ul>
<li><strong>RR特点：可以保证用户响应时间，是交互式任务调度的解决方法</strong></li>
<li>概念<ul>
<li>每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。</li>
</ul>
</li>
<li>流程<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则CPU立即进行切换；另外，时间片的长度就是一个很关键的点：</li>
</ul>
</li>
<li>时间片长度<ul>
<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率，吞吐量变小。</li>
<li>如果设得太长又可能引起对短作业进程的响应时间变长。</li>
<li>时间片10-100ms,切换时间0.1-1ms(1%)</li>
</ul>
</li>
</ul>
<h3 id="多级队列调度-Multilevel-Queue-Schedule"><a href="#多级队列调度-Multilevel-Queue-Schedule" class="headerlink" title="多级队列调度 Multilevel Queue Schedule"></a>多级队列调度 Multilevel Queue Schedule</h3><p><img src="/2022/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/2022-09-07-10-46-41.png"></p>
<h3 id="最高优先级调度-Highest-Priority-First，HPF"><a href="#最高优先级调度-Highest-Priority-First，HPF" class="headerlink" title="最高优先级调度 Highest Priority First，HPF"></a>最高优先级调度 Highest Priority First，HPF</h3><ul>
<li><p>时间片轮转算法做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。</p>
</li>
<li><p>但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。</p>
</li>
<li><p>进程的优先级可以分为，<strong>静态优先级</strong>或<strong>动态优先级</strong>：</p>
<ul>
<li><strong>静态优先级</strong>：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
<li><strong>动态优先级</strong>：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。</li>
</ul>
</li>
<li><p>该算法也有两种处理优先级高的方法，<strong>非抢占式和抢占式</strong>：</p>
<ul>
<li><strong>非抢占式</strong>：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li><strong>抢占式</strong>：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
</li>
<li><p>但是依然有缺点，可能会导致低优先级的进程永远不会运行。</p>
</li>
</ul>
<h3 id="多级反馈队列调度-Multilevel-Feedback-Queue"><a href="#多级反馈队列调度-Multilevel-Feedback-Queue" class="headerlink" title="多级反馈队列调度 Multilevel Feedback Queue"></a>多级反馈队列调度 Multilevel Feedback Queue</h3><p><img src="/2022/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_CPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/2022-09-07-11-18-21.png"></p>
<ul>
<li><strong>多级反馈队列</strong>（<strong>Multilevel Feedback Queue</strong>）<ul>
<li><strong>多级</strong>：<ul>
<li>不是单纯分成前台队列，后台队列，分成队列1，队列2，队列3。</li>
<li>每个队列优先级从高到低，同时优先级越高时间片越短。</li>
</ul>
</li>
<li><strong>反馈</strong><ul>
<li>任务应该在哪个队列是在执行过程中<strong>动态调整</strong>，不似乎一开始就确定的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h4><ul>
<li><p>问题1：对于多级队列调度</p>
<ul>
<li>采用非抢占式调用，<ul>
<li>最差响应时间可能变长<ul>
<li>一旦后台任务得到CPU，就只能等到执行完之后再释放CPU，前台任务的响应时间可能变长</li>
</ul>
</li>
</ul>
</li>
<li>采用抢占调度<ul>
<li>后台任务饥饿</li>
<li>如果有前台任务，就必须切换到前台队列。</li>
</ul>
</li>
</ul>
</li>
<li><p>问题2：os如何知道哪些是前台任务，哪些是后台任务？</p>
<ul>
<li>任务类型不是在一开始就确定下来，而是根据任务执行的具体表现来<strong>动态调整</strong></li>
<li>这就是 <strong>多级反馈队列调度</strong> 中的<strong>反馈</strong>的含义</li>
<li>IO动态调整。<ul>
<li>总是进行IO的，提高优先级，减小时间片。</li>
</ul>
</li>
<li>按执行时长进行动态调整<ul>
<li>随着一个任务执行时间变长，降低其优先级，并增大其时间片。</li>
<li>近似实现了SRTF，且不需要对执行时长进行预测。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>多级反馈队列<ul>
<li>多级反馈队列之间的动态调整（反馈）近似实现了SRTF，降低周转时间，且不用预测时间</li>
<li>核心基础是RR，保证了任务响应时间</li>
<li>多级反馈队列之间的动态调整（反馈）可以综合交互式和非交互式任务调度</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>并发-互斥算法-Peterson算法</title>
    <url>/2022/10/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9101-%E4%BA%92%E6%96%A5%E7%AE%97%E6%B3%95-Peterson%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>不借助硬件支持，在【纯软件】层面实现 【共享内存的互斥】：【Peterson算法】</li>
</ul>
<span id="more"></span>

<h1 id="在共享内存上实现互斥"><a href="#在共享内存上实现互斥" class="headerlink" title="在共享内存上实现互斥"></a>在共享内存上实现互斥</h1><p>thread: 人<br>共享内存：物理世界</p>
<h2 id="失败的尝试"><a href="#失败的尝试" class="headerlink" title="失败的尝试"></a>失败的尝试</h2><ul>
<li>最开始 没做任何努力</li>
<li>发现可能同时进入Alipay_withdraw的if</li>
<li><strong>失败：处理器没有办法使得balance的load和store这两条指令原子的执行！</strong>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> balance = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOAD(x) x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STORE(x, y) (x) = (y)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  fail 原因</span></span><br><span class="line">    <span class="comment">//  balance 的 load 和 store 没有办法原子的完成！！！！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Alipay_withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if(balance &gt;= amt)      //  load</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">LOAD</span>(balance) &gt;= amt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  可能两个thread都进入这里。unsigned -到&lt;0后就会最大。</span></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">microseconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// balance -= amt;     //  store</span></span><br><span class="line">        <span class="built_in">STORE</span>(balance, balance - amt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Talipay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Alipay_withdraw</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(Talipay)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(Talipay)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;balance = %lu\n&quot;</span>, balance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line">balance = <span class="number">18446744073709551516</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>尝试用一个flag来标志，我们命名为lock<ul>
<li>lock = LOCKED / lock = UNLOCKED</li>
<li>我们为什么要尝试lock？<ul>
<li>因为 load , ++ , and store 原本不是原子的。<ul>
<li>我们企图通过加入lock 来令这段code互斥，同一时刻只能有一个thread的pc在执行这段代码。使得处理器只能一次把他们执行完。即我们人为的把这些指令搞成原子的。</li>
<li>结果失败，失败原因</li>
<li><strong>lock的load和store这两条指令没有办法原子的完成！！！</strong>，实际上和上面code的失败原因本质是一样的。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNLOCK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK 1</span></span><br><span class="line"><span class="keyword">int</span> locked = UNLOCK;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> check = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  失败 原因</span></span><br><span class="line">    <span class="comment">//  lock的load和store这两条指令没有办法原子的完成！！！处理器办不到！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">critical_section</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(locked!=UNLOCK);      <span class="comment">//  load lock</span></span><br><span class="line"><span class="comment">// retry:</span></span><br><span class="line"><span class="comment">//     if(locked!=UNLOCK)</span></span><br><span class="line"><span class="comment">//         goto retry;</span></span><br><span class="line"></span><br><span class="line">    locked = LOCK;              <span class="comment">//  store lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  thread a 和 thread b可能同时进入这里</span></span><br><span class="line">    <span class="comment">//  load , ++ , and store 原本不是原子的。</span></span><br><span class="line">    <span class="comment">//  我们企图通过加入lock 来使得处理器只能一次把他们执行完、人为的把他们搞成原子的。</span></span><br><span class="line">    <span class="comment">//  结果失败</span></span><br><span class="line">        <span class="comment">//  失败原因</span></span><br><span class="line">        <span class="comment">//  lock的load和store这两条指令没有办法原子的完成！！！处理器办不到！</span></span><br><span class="line">    ++check;</span><br><span class="line"></span><br><span class="line">    locked = UNLOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thead_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">critical_section</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thead_func)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thead_func)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;check = %lu\n&quot;</span>,check);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// shc@DESKTOP-TVUERHD:~/Code/try/lock$ ./execute_try02.sh | head -2000 | uniq -c</span></span><br><span class="line"><span class="comment">//    1199 check = 2</span></span><br><span class="line"><span class="comment">//       1 check = 1</span></span><br><span class="line"><span class="comment">//     800 check = 2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Peterson"><a href="#Peterson" class="headerlink" title="Peterson"></a>Peterson</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>Petetson算法本质上还是个<strong>自私</strong>的算法，</p>
<ul>
<li>即便A/B在自己想进入临界区的时候都会先邀请对方上厕所。</li>
<li>但是这只是一种<strong>假客气</strong></li>
<li>即便我们邀请了对方，一旦对方邀请了我们，那么我们就不客气，直接进入临界区。<ul>
<li>那么对方什么时候进入临界区？当我们离开临界区之后，对方检查到我们不想进入临界区（即离开了临界区），那么对方就会进入临界区）</li>
</ul>
</li>
</ul>
</li>
<li><p>Peterson 是 不依赖硬件原子指令, 完全 由软件实现的算法</p>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><blockquote>
<p>摘</p>
</blockquote>
<ul>
<li><p>A 和 B 争用[厕所的包厢] : 即[临界区]</p>
</li>
<li><p>想进入包厢之前，A/B 都要先举起自己的旗子 : x = 1 / y = 1(举旗子代表己方想要进入临界区)</p>
<ul>
<li>A 确认旗子举好以后，往厕所门上贴上 “B 正在使用” 的标签 : turn = B(贴对方的标签代表邀请对方先进入临界区(假客气))</li>
<li>B 确认旗子举好以后，往厕所门上贴上 “A 正在使用” 的标签 : turn = A</li>
</ul>
</li>
<li><p>然后，如果对方的旗子举起来 &amp;&amp; 门上的名字不是自己，等待 : while(y == 1 &amp;&amp; turn != A)</p>
<ul>
<li>否则可以进入包厢<ul>
<li>如果对方的旗子没举起来,意味着对方不需要上厕所，我们可以直接进入临界区</li>
<li>如果门上的名字是自己,意味着对方已经将我们的名字贴上去，我们的假客气被对方覆盖了，那么我们直接进入临界区。</li>
</ul>
</li>
</ul>
</li>
<li><p>出包厢后，放下自己的旗子 : x = 0 / y = 0</p>
</li>
<li><p>以下为总结</p>
</li>
</ul>
<hr>
<ul>
<li><p>A和B有临界区func</p>
</li>
<li><p><strong>0. :</strong> A想要进入func </p>
<ul>
<li><strong>0.1 :</strong> 先<strong>举起自己的旗子</strong>(举旗子代表己方想要进入临界区) : x = 1</li>
<li><strong>0.2 :</strong> 并且在临界区上<strong>贴上对方B的标签</strong>。(贴对方的标签代表邀请对方先进入临界区(<strong>假客气</strong>)) : turn = B</li>
</ul>
</li>
<li><p><strong>1. :</strong> <strong>A在进入func之前, : while(y == 1 &amp;&amp; turn != A)</strong></p>
<ul>
<li><strong>1.1 检查对方是否想要进入临界区 : y == 1 ?</strong> <ul>
<li>(对方的旗子是否举了起来) (对方的旗子举起来的话就代表对方会跟我们客气一下)</li>
</ul>
</li>
<li><strong>1.2 若 y != 1 , 则进入临界区</strong><ul>
<li>y!=1 ，即对方的旗子没举起来. 意味着对方不需要进临界区，我们可以直接进入临界区</li>
</ul>
</li>
<li><strong>1.3 若 y == 1 , 则观察临界区的标签是否是己方A : turn != A ?</strong> . <ul>
<li>y==1 ，即对方想要进入临界区</li>
<li><strong>turn != A 如果不是A的话</strong>，那么我们<strong>等待</strong><ul>
<li>等待对方跟我们客气一下 , 即对方将我们的标签贴上去.（此时对方还没进入临界区,还没客气)。</li>
<li>或者等待对方离开临界区, 放下旗子. (对方的假客气已经被我们的假客气覆盖了,对方会进入临界区,我们只能等待对方结束临界区使用)</li>
</ul>
</li>
<li><strong>turn == A 如果是A的话</strong>，那么我们可以<strong>直接进入</strong>临界区。<ul>
<li>如果门上的名字是己方,意味着对方已经将我们的名字贴上去，我们的假客气被对方覆盖了，那么我们直接进入临界区。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>2. :</strong> 1中条件不满足时，进入临界区。</p>
</li>
<li><p><strong>3. :</strong> 从临界区中出来之后，放下自己的旗 : x = 0。（自己不想进入临界区了） </p>
</li>
</ul>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><ul>
<li>Peterson算法</li>
<li>最后仍会出现错误是因为编译器会进行重排，处理器也会执行重排。不过我们的算法是没有错误的，正确的。经历了足足121778757次才发生错误  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; check;     <span class="comment">//  check设置成atomic 是因为我们要验证peterson算法。验证这个算法实现了互斥。那么就要保证目标的互斥代码段内没有破坏互斥的因素。</span></span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">volatile</span> x = <span class="number">0</span>, y = <span class="number">0</span>, turn = A;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">critical_section</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    ++check;</span><br><span class="line">    <span class="keyword">if</span>(check!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cnt = %d\n&quot;</span>,cnt.<span class="built_in">load</span>());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);           <span class="comment">//  never reach</span></span><br><span class="line">    &#125;</span><br><span class="line">    --check;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func_A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* PC1 */</span> x = <span class="number">1</span>;          <span class="comment">//  A 举旗子</span></span><br><span class="line">        <span class="comment">/* PC2 */</span> turn = B;       <span class="comment">//  贴 nameB （假客气一下hhh）</span></span><br><span class="line">        <span class="comment">/* PC3 */</span> <span class="keyword">while</span>(y == <span class="number">1</span> &amp;&amp; turn != A);     <span class="comment">//  此时B也要上厕所(y==1)，且B还没贴name--厕所的name不是A 那么A等等。因为A知道 B已经把旗子举了起来 B之后会将nameA贴上去。会覆盖掉A贴的nameB。所以A其实只是假客气一下 先把nameB贴上去 假意邀请B先上厕所，但如果B也客气一下（B如果要上厕所的话会先将nameA贴上去），那么A就不客气了，直接进入厕所。</span></span><br><span class="line">        <span class="comment">/* PC4 */</span> <span class="built_in">critical_section</span>();             <span class="comment">//  进入厕所</span></span><br><span class="line">        <span class="comment">/* PC5 */</span> x = <span class="number">0</span>;          <span class="comment">//  A 放下旗子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_fund_B</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* PC1 */</span> y = <span class="number">1</span>;          <span class="comment">//  B举旗子</span></span><br><span class="line">        <span class="comment">/* PC2 */</span> turn = A;       <span class="comment">//  贴nameA</span></span><br><span class="line">        <span class="comment">/* PC3 */</span> <span class="keyword">while</span>(x == <span class="number">1</span> &amp;&amp; turn != B);     <span class="comment">//  此时A要上厕所 且厕所的name不是B 那么B等等</span></span><br><span class="line">        <span class="comment">/* PC4 */</span> <span class="built_in">critical_section</span>();</span><br><span class="line">        <span class="comment">/* PC5 */</span> y = <span class="number">0</span>;          <span class="comment">//  B放旗子 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thread_func_A)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(thread_fund_B)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ ./execute_peterson.sh</span><br><span class="line">cnt = <span class="number">121778757</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="model-checker-工具"><a href="#model-checker-工具" class="headerlink" title="model checker 工具"></a>model checker 工具</h2><ul>
<li>model checker的基本假设：每一行源代码的执行是原子的</li>
<li>列出所有状态及转移关系。</li>
<li>如图中红色区域：即为t1 t2都进入了临界区！<img src="/2022/10/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9101-%E4%BA%92%E6%96%A5%E7%AE%97%E6%B3%95-Peterson%E7%AE%97%E6%B3%95/2022-10-12-16-16-53.png"></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统_并发-真实世界的并发编程</title>
    <url>/2022/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9104-%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<ul>
<li>摘自jyy课件以及自己笔记<ul>
<li>对 goroutine介绍 : 线程和协程的结合. 然而我没用过，没啥体会.</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="如何用好一台计算机？"><a href="#如何用好一台计算机？" class="headerlink" title="如何用好一台计算机？"></a>如何用好一台计算机？</h1><ul>
<li>如何用一台 (可靠的) 计算机尽可能多地服务并行的请求<ul>
<li>关键指标：QPS, tail latency , …</li>
</ul>
</li>
<li>我们有的工具<ul>
<li>线程 (threads)</li>
<li>协程 (coroutines)<ul>
<li>多个可以保存/恢复的执行流 (M2 - libco)</li>
<li>比线程更轻量 (完全没有系统调用，也就没有操作系统状态)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数据中心：协程和线程"><a href="#数据中心：协程和线程" class="headerlink" title="数据中心：协程和线程"></a>数据中心：协程和线程</h2><ul>
<li><img src="/2022/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9104-%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2022-10-16-15-16-31.png"></li>
<li><img src="/2022/10/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9104-%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2022-10-16-13-37-24.png"></li>
<li>协程：<ul>
<li>优点：协程间切换开销小。</li>
<li>缺点：不受os调度，会有blocking问题；无法利用多处理器<ul>
<li>一个thread的协程block后，该thread的所有协程都block了。</li>
<li>一个thread上即便有多个协程，同一时刻只有一个协程在运行。即 如果只有一个thread，该thread有多个协程，那么只能使用一个cpu核。没做到并行。</li>
</ul>
</li>
</ul>
</li>
<li>thread：<ul>
<li>优点：擅长并行，可以利用多处理器。<ul>
<li>有多少个thread 就能运行在多少核上。(thread number &lt; core number)</li>
</ul>
</li>
<li>缺点：占用资源多，thread切换开销大。</li>
</ul>
</li>
</ul>
<h2 id="Go-和-Goroutine"><a href="#Go-和-Goroutine" class="headerlink" title="Go 和 Goroutine"></a>Go 和 Goroutine</h2><ul>
<li>Go: 小孩子才做选择，多处理器并行和轻量级并发我全都要！</li>
<li>Goroutine: 概念上是线程，实际是线程和协程的混合体！</li>
<li>每个 CPU 上有一个 Go Worker，自由调度 goroutines<ul>
<li><strong>执行到 blocking API 时</strong> (例如 sleep, read)<ul>
<li><strong>Go Worker 偷偷改成 non-blocking 的版本</strong><ul>
<li><strong>成功 → 立即继续执行</strong></li>
<li><strong>失败 → 立即 yield 到另一个需要 CPU 的 goroutine</strong><ul>
<li>太巧妙了！<strong>CPU 和操作系统全部用到 100%</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>go中可以创建几百万个goroutine 完全没问题</li>
<li>如上图 再多的协程 实际上最多并行的也只有T1 T2 T3三个thread</li>
<li>go 几乎已经把程序运行的开销降到最低了。将CPU切换的时间都省掉了（一个CPU一个thread）</li>
</ul>
<h2 id="现代编程语言上的系统编程"><a href="#现代编程语言上的系统编程" class="headerlink" title="现代编程语言上的系统编程"></a>现代编程语言上的系统编程</h2><blockquote>
<p>要理解一点 os课上会讲很多并发算法peterson 生产者-消费者 哲学家 但是实际真正编程时 我们几乎不需要用他们。<br>那为什么还要学？为了理解。<br>有原子操作 就可以实现条件变量 有条件变量 就可以实现任何并发算法<br>正如我们需要学汇编，但实际并不需要写汇编。<br>Do not communicate by sharing memory; instead, share memory by communicating. ——Effective Go</p>
</blockquote>
<ul>
<li><strong>不要用共享内存 也即：不要去设计peterson算法那种并发的协议</strong></li>
<li>共享内存 = 万恶之源</li>
<li>在奇怪调度下发生的各种并发 bugs<ul>
<li>条件变量：broadcast 性能低，不 broadcast 容易错</li>
<li>信号量：在管理多种资源时就没那么好用了</li>
</ul>
</li>
</ul>
<p><strong>既然生产者-消费者能解决绝大部分问题，提供一个 API 不就好了</strong>？</p>
<ul>
<li><p>producer-consumer.go</p>
<ul>
<li>缓存为 0 的 <strong>channel</strong> 可以用来同步 (先到者等待)，而不是用共享内存</li>
</ul>
</li>
<li><p>当然go里也有共享内存</p>
</li>
<li><p>go 解决的问题</p>
<ul>
<li>goroutine 在协程等待的时候切换到另一个协程。(数据中心的IO)</li>
<li>并发编程：不用共享内存 而用channel</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>希望每个同学都有一个 “主力现代编程语言”<ul>
<li>Modern C++, Rust, Javascript, …</li>
</ul>
</li>
</ul>
<ul>
<li>尽管对并发原语和并行性进行了多年的研究，但使用锁进行编程仍然具有挑战性。通常最好将锁隐藏在更高级别的结构中，如同步队列，尽管xv6没有这样做。如果您使用锁进行编程，明智的做法是使用试图识别竞争条件（race conditions）的工具，因为很容易错过需要锁的不变量。</li>
<li>大多数操作系统都支持POSIX线程（Pthread），它允许一个用户进程在不同的CPU上同时运行几个线程。Pthread支持用户级锁（user-level locks）、障碍（barriers）等。支持Pthread需要操作系统的支持。例如，应该是这样的情况，如果一个Pthread在系统调用中阻塞，同一进程的另一个Pthread应当能够在该CPU上运行。另一个例子是，如果一个线程改变了其进程的地址空间（例如，映射或取消映射内存），内核必须安排运行同一进程下的线程的其他CPU更新其硬件页表，以反映地址空间的变化。</li>
<li>没有原子指令实现锁是可能的，但是代价昂贵，并且大多数操作系统使用原子指令。</li>
<li>如果许多CPU试图同时获取相同的锁，可能会付出昂贵的开销。如果一个CPU在其本地cache中缓存了一个锁，而另一个CPU必须获取该锁，那么更新保存该锁的cache行的原子指令必须将该行从一个CPU的cache移动到另一个CPU的cache中，并且可能会使cache行的任何其他副本无效。从另一个CPU的cache中获取cache行可能比从本地cache中获取一行的代价要高几个数量级。</li>
<li>为了避免与锁相关的开销，许多操作系统使用无锁的数据结构和算法。例如，可以实现一个像本章开头那样的链表，在列表搜索期间不需要锁，并且使用一个原子指令在一个列表中插入一个条目。然而，无锁编程比有锁编程更复杂；例如，人们必须担心指令和内存重新排序。有锁编程已经很难了，所以xv6避免了无锁编程的额外复杂性。</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-并发-互斥</title>
    <url>/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/</url>
    <content><![CDATA[<ul>
<li><p>互斥困难的根本原因:load 和 store不原子</p>
</li>
<li><p>纯软件层面的互斥算法实现太复杂了，下面借助硬件提供的原子指令 实现比peterson简单的互斥协议。</p>
</li>
<li><p>硬件提供的原子指令如 : x86-64提供的lock ,xchg ; riscv提供的LR/SC(实现CAS)  </p>
</li>
<li><p>自旋锁spinlock : 基于xchg实现的spinlock 正确实现临界区互斥。</p>
<ul>
<li>spinlock 缺陷。<ul>
<li>除了进入临界区的线程，其他处理器上的线程都在空转</li>
<li>获得自旋锁的线程可能被操作系统切换出去</li>
</ul>
</li>
<li>spinlock 使用场景<ul>
<li>内核的并发数据结构</li>
</ul>
</li>
</ul>
</li>
<li><p>互斥锁mutex : 在spinlock的基础上实现mutex</p>
<ul>
<li>目的 : thread在没拿到锁时不自旋空转占用cpu，而是切换到内核并阻塞，然后内核切换到其他thread执行. 避免浪费cpu</li>
<li>由于其目的，故只能是一种syscall</li>
</ul>
</li>
<li><p>xv6 : when to lock :</p>
<ul>
<li>if (2 processes access a shared data structure &amp;&amp; at least on is writiter) , then lock the shared data structure</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h2><p>如何解决问题 -&gt; 问题的假设 -&gt; 假设的难点 -&gt; 改变假设</p>
<ul>
<li>找到你依赖的假设，并大胆的打破它</li>
<li>如何在多处理器系统上实现互斥?<ul>
<li>一开始 软件层面的 <strong>peterson算法</strong>。太难了。</li>
<li>那么 软件不够 硬件来凑（<strong>自旋锁</strong>）(利用硬件提供的原子指令实现)</li>
<li>用户不够 内核来凑（<strong>互斥锁</strong>）(为了让别的thread执行)</li>
<li>fast / slow path ：性能优化的重要途径 : futex</li>
</ul>
</li>
</ul>
<h2 id="互斥困难-根本原因"><a href="#互斥困难-根本原因" class="headerlink" title="互斥困难 根本原因"></a>互斥困难 根本原因</h2><ul>
<li><p>在共享内存上实现<strong>互斥的根本困难</strong>：<strong>不能同时读/写共享内存</strong></p>
<ul>
<li>我们看到的东西马上就过时了。不禁让人想起verilog。读的永远是上一时钟周期的值。</li>
<li><strong>load</strong> (环顾四周) 的时候<strong>不能写</strong>，只能 “看一眼就把眼睛闭上”<ul>
<li><strong>看到的东西马上就过时了</strong></li>
</ul>
</li>
<li><strong>store</strong> (改变物理世界状态) 的时候<strong>不能读</strong>，只能 “闭着眼睛动手”<ul>
<li><strong>也不知道把什么改成了什么</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>实现一个巧妙地互斥算法是很困难的。</p>
</li>
<li><p>我们在这里尽量用简单、粗暴 (稳定)、有效的方法实现互斥。</p>
</li>
<li><p>基于以上事实作为假设，我们之前实现一段临界区互斥的方法：软件层面的，如Peterson算法、deckker算法等。很困难</p>
</li>
<li><p>那么我们让硬件帮忙，更改一些假设呢？</p>
</li>
</ul>
<h2 id="硬件提供的原子操作"><a href="#硬件提供的原子操作" class="headerlink" title="硬件提供的原子操作"></a>硬件提供的原子操作</h2><ul>
<li><p>汇编中的几条指令可以使得硬件进行原子操作</p>
</li>
<li><p><strong>lock</strong></p>
<ul>
<li>原子的实现 load 和 store</li>
<li>汇编的lock前缀,是使用了在硬件层面实现的锁</li>
<li>lock是个指令前缀。处理器读到lock 先去上锁。也即，先去获得总线的锁 等到得到总线的锁之后 在执行后面的指令，执行完之后 释放总线上的锁。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lock add $1 , %0 &quot;</span>: <span class="string">&quot;+m&quot;</span>(sum))</span></span>;</span><br><span class="line">        <span class="comment">//  ++sum 需要先把sum从内存load到寄存器。然后++寄存器。然后将寄存器store到mem</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  sum = 200000000</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>汇编中的xchg</strong></p>
<ul>
<li>最小的 原子的 [load 和 store]：也就是 原子的可以先看一眼 然后改变。</li>
<li>于是，利用汇编中的xchg，实现另一个原子的将两个数值原子的交换的函数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  原子的交换</span></span><br><span class="line">  <span class="comment">//  将addr地址存储的值 和 newval的值 进行原子的交换</span></span><br><span class="line">  <span class="comment">//  并返回addr原本的值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *addr,<span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;xchg %0 , %1&quot;</span> : <span class="string">&quot;+m&quot;</span>(*addr),<span class="string">&quot;=a&quot;</span>(res) : <span class="string">&quot;1&quot;</span>(newval))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>原子指令的模型</strong></p>
<ul>
<li>保证之前的store都写入内存（处理器还保证，在一个lock之前发生的所有事情，都可以在后面的lock时被看见）<ul>
<li>保证了内存的可见性。 </li>
</ul>
</li>
<li>保证load/store不与原子指令乱序（处理器保证，所有带lock的指令 都可以排出一个先后的顺序。）<ul>
<li>也因此，就是消灭了并行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用原子操作-实现-锁-基于xchg-实现-spinlock自旋锁"><a href="#使用原子操作-实现-锁-基于xchg-实现-spinlock自旋锁" class="headerlink" title="使用原子操作 实现 锁 : 基于xchg 实现 spinlock自旋锁"></a>使用原子操作 实现 锁 : <strong>基于xchg 实现 spinlock自旋锁</strong></h3><ul>
<li>如何用xchg这样的原子指令实现互斥 ? </li>
</ul>
<h4 id="实现协议"><a href="#实现协议" class="headerlink" title="实现协议"></a>实现协议</h4><ul>
<li><p>人作为thread，物理世界作为 资源： local变量、共享变量、需要互斥进入的临界区。  </p>
<h5 id="人话版"><a href="#人话版" class="headerlink" title="人话版"></a>人话版</h5></li>
<li><p>还是举例上厕所，多个同学上WC，WC上有锁，钥匙放在桌子上，每个同学手里有一个厕所正在使用的牌子。</p>
</li>
<li><p>厕所门口上放一个桌子（共享变量）</p>
<ul>
<li>初始时 ，桌子上是钥匙</li>
</ul>
</li>
<li><p><strong>在原子操作xchg的基础上，去实现一个互斥的协议</strong>。（这就比之前毫无原子操作的假设上实现的Peterson算法简单很多很多）</p>
<ul>
<li>如果同学A想上厕所。那么lock()，lock如下<ul>
<li>A闭眼睛</li>
<li>那么 将手中的 NOPE牌子 和 table上的东西（钥匙或者NOPE） 进行交换。<ul>
<li>这个交换是基于xchg的原子操作。<ul>
<li>拿走table上的东西</li>
<li>将NOPE放在桌子上</li>
</ul>
</li>
</ul>
</li>
<li>A睁眼睛<ul>
<li>如果手中拿到的是钥匙，那么可以进入厕所。</li>
<li>如果不是钥匙，那么循环上述过程</li>
</ul>
</li>
</ul>
</li>
<li>A同学出厕所。那么unlock，unlock如下。<ul>
<li>那么 将手中的 钥匙 和 table上的NOPE 进行交换。</li>
</ul>
</li>
</ul>
</li>
<li><p>人 ：thread , NOPE ： local var , 桌子 ：共享变量table , 厕所 ：临界区</p>
</li>
</ul>
<h4 id="实现code"><a href="#实现code" class="headerlink" title="实现code"></a>实现code</h4><ul>
<li>如果xchg不是原子的话，那么就可以有多个同学同时拿到table上的YES，一起进入临界区</li>
</ul>
<ul>
<li>code版<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">xchg</span>(&amp;locked,<span class="number">1</span>));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">xchg</span>(&amp;locked,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>人话版<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于 int xchg(volatile int *addr,int newval);  //  实现见上</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOPE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YES 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> table = YES;</span><br><span class="line">由流程易知</span><br><span class="line">table 和 同学 手里 有且只有一个YES 多个NOPE</span><br><span class="line">  如果有&gt;<span class="number">1</span>个YES的话，那么就会有多个同学同时进入临界区</span><br><span class="line">  如果有<span class="number">0</span>个YES的话，那么不会有同学进入临界区</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">//  将table上的标志和我们手中的进行原子的交换(如果我们想要上厕所的话，那么手中最开始一定是个NOPE[禁] , 然后我们要去获得table上的(YES)[钥匙]，去获得进入临界区的机会[打开厕所的门])</span></span><br><span class="line"><span class="comment">//  如果此时table上是 YES [钥匙]    </span></span><br><span class="line">    <span class="comment">//  那么 xchg之后 我们拿到的就是钥匙 (因为交换的动作是原子的，所以有且只会有一个人拿到了钥匙 不存在重复拿到的情况)</span></span><br><span class="line">    <span class="comment">//  成功拿到 钥匙 ，可以打开WC。于是我们继续向下走（即进入临界区）</span></span><br><span class="line"><span class="comment">//  如果此时table上是 NOPE [禁止入内]</span></span><br><span class="line">    <span class="comment">//  那么 xchg之后 我们拿到的就是NOPE </span></span><br><span class="line">    <span class="comment">//  循环等待</span></span><br><span class="line">    <span class="keyword">int</span> got_old_table = <span class="built_in">xchg</span>(&amp;table,NOPE);</span><br><span class="line">    <span class="keyword">if</span>(got_old_table == NOPE)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(got_old_table == YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果有一个没有上锁的人 调用了unlock 那么就会导致这个临界区中可以同时出现两个user</span></span><br><span class="line"><span class="comment">//  因为table可以同时存在两个yes</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">xchg</span>(&amp;table,YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>testSpinLock<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">lock</span>();</span><br><span class="line">        ++sum;</span><br><span class="line">        <span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(testFunc)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(testFunc)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout&lt;&lt;sum&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./spinlock</span><br><span class="line"><span class="number">200000</span></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.018</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.032</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原子操作在cpu上怎么实现"><a href="#原子操作在cpu上怎么实现" class="headerlink" title="原子操作在cpu上怎么实现"></a>原子操作在cpu上怎么实现</h2><ul>
<li>介绍下前缀lock如何保证硬件的原子操作</li>
</ul>
<h3 id="原子操作的需求"><a href="#原子操作的需求" class="headerlink" title="原子操作的需求"></a><strong>原子操作的需求</strong></h3><ul>
<li><strong>atomic test and set</strong>  原子的比较、赋值<ul>
<li>regVal = load(x) ;                //  取出regsiter x的值 </li>
<li>if(regVal == XX) {store (x,YY)}   //  如果x存的是XX，那么将YY存入x</li>
</ul>
</li>
<li><strong>lock xchg</strong>             原子的交换值<ul>
<li>reg = load(x);</li>
<li>store(x,XX);</li>
</ul>
</li>
<li><strong>lock add</strong>              原子的++<ul>
<li>t = load(x)</li>
<li>++t</li>
<li>store(x,t)</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>其本质都是</strong></p>
<ul>
<li><strong>load</strong> 从内存中加载到reg</li>
<li><strong>exec</strong> 即处理本地reg运算</li>
<li><strong>store</strong> 从reg中存到内存</li>
</ul>
</li>
<li><p>实现原子操作就是要 保证 一个内存的状态 可以由 我知道的一个状态，变成我想要他变成的一个状态。</p>
</li>
</ul>
<h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3><h4 id="前缀lock的早期实现（无cache-只需要锁住主存即可）"><a href="#前缀lock的早期实现（无cache-只需要锁住主存即可）" class="headerlink" title="前缀lock的早期实现（无cache 只需要锁住主存即可）"></a>前缀lock的早期实现（无cache 只需要锁住主存即可）</h4><ul>
<li>执行时发现前缀有lock，那么先锁住内存，然后再执行后面的指令，执行完之后释放对内存的锁。<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-07-53-21.png"></li>
</ul>
<h4 id="前缀lock的现代实现（需要考虑缓存一致性）"><a href="#前缀lock的现代实现（需要考虑缓存一致性）" class="headerlink" title="前缀lock的现代实现（需要考虑缓存一致性）"></a>前缀lock的现代实现（需要考虑缓存一致性）</h4><ul>
<li><p>在 L1 cache 层保持一致性 (ring/mesh bus)</p>
<ul>
<li>相当于每个 cache line 有分别的锁</li>
<li>store(x) 进入 L1 缓存即保证对其他处理器可见<ul>
<li>但要小心 store buffer 和乱序执行</li>
</ul>
</li>
</ul>
</li>
<li><p>L1 cache line 根据状态进行协调</p>
<ul>
<li>M (Modified), 脏值</li>
<li>E ( Exclusive ), 独占访问</li>
<li>S (Shared), 只读共享</li>
<li>I (Invalid), 不拥有 cache line</li>
</ul>
</li>
</ul>
<h4 id="应用lock前缀实现上层的原子操作"><a href="#应用lock前缀实现上层的原子操作" class="headerlink" title="应用lock前缀实现上层的原子操作"></a>应用lock前缀实现上层的原子操作</h4><ul>
<li><strong>应用lock前缀实现原子的load和store</strong></li>
<li>如上的xchg函数 将（exchange操作）load和store作为打包为一个原子的指令。</li>
</ul>
<ul>
<li><strong>插一条小结</strong><ul>
<li>使用 cpu提供的原子指令 的开销就是锁总线的开销以及保持缓存一致性的开销</li>
<li>使用自旋锁的开销 既包括 原子指令的开销，又包括了空转的开销。</li>
<li>使用互斥锁的开销 就是 进入、离开kernel的开销 以及 使用原子指令的开销。</li>
<li>使用futex的开销 ：少量的进入、离开kernel的开销 以及 使用原子指令的开销。（没进入和进入都需要用原子指令）</li>
<li>所以常说的 CAS无锁无锁，这个锁到底说的是什么？<ul>
<li>是汇编层面的那个lock前缀？我之前认为是，不过现在看来显然不是，反汇编之后仍然可以看到lock</li>
<li>我现在认为应当指的是 如果不用atomic_int的话，那么对于int sum的++我们理应会使用POSIX库中的pthread_mutex_lock。这个实际上是futex锁，尽管是少量，不过也会有可能进入离开kernel。造成开销。那么如果我们直接用cpu提供的原子指令的话，就完全不必进入离开kernel，而是一直在用户态就可以。</li>
<li>所以我现在认为，所谓的”无锁无锁,<strong>无锁开销小</strong>“,指的是user无需使用os提供给user的syscall的锁接口.(如pthread_mutex_lock). , 进而<strong>无需进入和离开kernel切换上下文. 故开销小</strong>.<ul>
<li>我是这么认为的. 还没有求证. 不过感觉89不离10</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h3><ul>
<li><strong>基本思想</strong>:本地的local的计算不重要，重要的是我要写入的共享内存的状态(当我想要写入时 是否和我之前看到的一样)。本地的local的计算可以重做</li>
</ul>
<h4 id="CPU-通过-LR-and-SC-实现原子操作"><a href="#CPU-通过-LR-and-SC-实现原子操作" class="headerlink" title="CPU 通过 LR and SC 实现原子操作"></a>CPU 通过 LR and SC 实现原子操作</h4><ul>
<li><p>Load-Reserved(LR): 在内存上标记 reserved (盯上你了)，中断、其他处理器写入都会导致标记消除<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-08-55-51.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lr.w rd, (rs1) </span><br><span class="line">  含义如下</span><br><span class="line">  rd = M[rs1]</span><br><span class="line">  reserve M[rs1]</span><br></pre></td></tr></table></figure></li>
<li><p>Store-Conditional(SC): 如果我对于该内存的”盯上”(标记)未被解除，则写入;如果被解除了，那么放弃写入，丢弃本次local计算的结果，稍后重试。<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-08-56-29.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sc.w rd, rs2, (rs1)   </span><br><span class="line">  含义如下</span><br><span class="line">  <span class="keyword">if</span> still reserved:  如果内存地址rs1上存在加载保留</span><br><span class="line">    M[rs1] = rs2      写入</span><br><span class="line">    rd = <span class="number">0</span>            存入成功 向reg[rd]写入<span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    rd = nonzero      存入失败（即不存在加载保留，写入非<span class="number">0</span>的errno）</span><br></pre></td></tr></table></figure></li>
<li><p>通过LR和SC的搭配使用，可以实现对一块mem的原子的load和store</p>
</li>
</ul>
<h4 id="应用LR-SC实现原子操作-：-原子的Compare-and-Swap的LR-SC实现"><a href="#应用LR-SC实现原子操作-：-原子的Compare-and-Swap的LR-SC实现" class="headerlink" title="应用LR/SC实现原子操作 ： 原子的Compare and Swap的LR/SC实现"></a>应用LR/SC实现原子操作 ： 原子的Compare and Swap的LR/SC实现</h4><ul>
<li><p>可以看到 没有使用锁 就是先了load和store的原子操作</p>
</li>
<li><p>所谓的原子的Compare ans Swap的实现 </p>
<ul>
<li><strong>指的是在我们 [compare(load) , (exec) , swap(store)] ,mem没有被其他指令读取、改变</strong>。（也就是所谓的没被打断，原子性）</li>
</ul>
</li>
<li><p>RISC-V-Reader d的 Compare and Swap<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-09-41-43.png"></p>
</li>
</ul>
<ul>
<li><p>C</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cas</span><span class="params">(<span class="keyword">int</span> *addr, <span class="keyword">int</span> cmp_val, <span class="keyword">int</span> new_val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_val = *addr;</span><br><span class="line">  <span class="keyword">if</span> (old_val == cmp_val) &#123;</span><br><span class="line">    *addr = new_val; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对应的RISCV 汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cas:</span><br><span class="line">  lr.w  t0, (a0)       # Load original value.     </span><br><span class="line">    将mema0的内容加载进t0 并打上flag</span><br><span class="line">  bne   t0, a1, fail   # Doesn’t match, so fail.</span><br><span class="line">  sc.w  t0, a2, (a0)   # Try to update.           </span><br><span class="line">    尝试将a2写入mema0,</span><br><span class="line">      如果a0的flag仍存在，那么写入成功，将标志寄存器t0赋值<span class="number">0</span>代表成功   </span><br><span class="line">      如果a1的flag被改变，那么写入失败，将标志寄存器t0赋值nonzero代表写入失败</span><br><span class="line">  bnez  t0, cas        # Retry <span class="keyword">if</span> store-conditional failed.</span><br><span class="line">    t0!=<span class="number">0</span> 代表store失败（失败的根本原因是因为不能和load形成原子的操作 从头load开始重新尝试。）</span><br><span class="line">  li a0, <span class="number">0</span>             # Set <span class="keyword">return</span> to success.</span><br><span class="line">  jr ra                # Return.</span><br><span class="line">fail:</span><br><span class="line">  li a0, <span class="number">1</span>             # Set <span class="keyword">return</span> to failure.</span><br><span class="line">  jr ra                # Return</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="spinlock缺陷-性能问题"><a href="#spinlock缺陷-性能问题" class="headerlink" title="spinlock缺陷 性能问题"></a>spinlock缺陷 性能问题</h2><ul>
<li><p><strong>性能问题 1</strong></p>
<ul>
<li>自旋 (共享变量) 会触发处理器间的<strong>缓存同步</strong>，延迟增加</li>
</ul>
</li>
<li><p><strong>性能问题 2</strong></p>
<ul>
<li>除了进入临界区的线程，其他处理器上的<strong>线程都在空转</strong></li>
<li>争抢锁的处理器<strong>越多</strong>，<strong>cpu利用率越低</strong><ul>
<li>一核处理（进入临界区的thread的核），多核围观。（其他所有没进入临界区的thread）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>性能问题 3</strong> （比 12都严重）</p>
<ul>
<li>获得自旋锁的线程可能被操作系统<strong>切换出去</strong><ul>
<li>那么，这个拿到了spinlock的进入临界区的thread在睡觉，其他没拿到spinlock的thread在空转，并且等待一个 较长时间之后才会释放的锁。（因为拿到锁的thread在睡觉）</li>
<li>那么，0核处理，1核睡觉，多核围观。</li>
<li><strong>实现 100% 的资源浪费</strong></li>
<li>操作系统不 “感知” 线程在做什么</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>由于以上三点，同样的工作，线程数量越多，执行时间越长。对于spinlock尤其明显<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">1</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.135</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.132</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">2</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.825</span>s</span><br><span class="line">user    <span class="number">0</span>m1<span class="number">.641</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">3</span></span><br><span class="line">sum = <span class="number">9999999</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m1<span class="number">.162</span>s</span><br><span class="line">user    <span class="number">0</span>m3<span class="number">.445</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">4</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m1<span class="number">.688</span>s</span><br><span class="line">user    <span class="number">0</span>m6<span class="number">.670</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">5</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m2<span class="number">.493</span>s</span><br><span class="line">user    <span class="number">0</span>m12<span class="number">.278</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>对于futex（因为无法获取锁时会阻塞,调度到其他进程而非空转），时间不会随着thread数增大而极度增大<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">1</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.154</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.145</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">2</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.786</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.993</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.564</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">7</span></span><br><span class="line">sum = <span class="number">9999997</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.921</span>s</span><br><span class="line">user    <span class="number">0</span>m1<span class="number">.499</span>s</span><br><span class="line">sys     <span class="number">0</span>m4<span class="number">.003</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">15</span></span><br><span class="line">sum = <span class="number">9999990</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m1<span class="number">.002</span>s</span><br><span class="line">user    <span class="number">0</span>m1<span class="number">.685</span>s</span><br><span class="line">sys     <span class="number">0</span>m9<span class="number">.346</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">32</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.916</span>s</span><br><span class="line">user    <span class="number">0</span>m1<span class="number">.134</span>s</span><br><span class="line">sys     <span class="number">0</span>m9<span class="number">.653</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Scalability-性能的新维度"><a href="#Scalability-性能的新维度" class="headerlink" title="Scalability : 性能的新维度"></a>Scalability : 性能的新维度</h3><ul>
<li>同一份计算任务，时间 (CPU cycles) 和空间 ( mapped memory) 会随处理器数量的增长而变化<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-13-32-27.png"></li>
</ul>
<h2 id="spinlock的使用场景"><a href="#spinlock的使用场景" class="headerlink" title="spinlock的使用场景"></a>spinlock的使用场景</h2><ul>
<li><p><strong>临界区几乎不拥堵</strong></p>
<ul>
<li>几乎不会发生锁的争抢。</li>
<li>比如说 queue作为临界区，threadpool从queue中取任务。取一个任务用100ns，执行一个任务用100ms，不频繁的取队列，锁也就不会争抢，因此可以用spinlock</li>
</ul>
</li>
<li><p><strong>持有自旋锁时禁止执行流切换</strong></p>
<ul>
<li>但是，这对机器很危险。应用程序也不会有这个权限。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>真正使用场景：操作系统内核的并发数据结构（短临界区）</strong></li>
</ul>
<p>操作系统可以关闭中断和抢占</p>
<ul>
<li>spinlock的如何使用好是一个很困难的问题。（以前甚至可以发paper）</li>
</ul>
<h2 id="mutex-互斥锁-os实现的系统调用"><a href="#mutex-互斥锁-os实现的系统调用" class="headerlink" title="mutex 互斥锁(os实现的系统调用)"></a>mutex 互斥锁(os实现的系统调用)</h2><h3 id="为什么要有互斥锁"><a href="#为什么要有互斥锁" class="headerlink" title="为什么要有互斥锁"></a>为什么要有互斥锁</h3><ul>
<li><p>如果希望实现一个很长的临界区，比如要我在写一个文件的时候，不希望别的thread写。</p>
</li>
<li><p>又或者如果我想做一件事情，但是现在做不了，需要等待一个长临界区。我们让另一个任务开始执行。</p>
</li>
<li><p>所以，对于<strong>让</strong>这个动作。<strong>让</strong>别的thread执行。在<strong>用户态</strong>用C语言是<strong>无法实现</strong>的，<strong>因此，操作系统应当实现这个系统调用。</strong></p>
</li>
<li><p>把锁的实现放到操作系统里就好啦！</p>
<ul>
<li>syscall(SYSCALL_lock, &amp;lk);<ul>
<li>syscall 进入kernel，关中断，然后进行xchg锁</li>
<li>试图获得 锁，<ul>
<li>如果<strong>成功上锁</strong>，</li>
<li>但如果<strong>失败，就切换到其他</strong>线程。（切换到其他线程，即让别的thread执行，这个动作只能由os做，user是做不到的）</li>
</ul>
</li>
</ul>
</li>
<li>syscall(SYSCALL_unlock, &amp;lk);<ul>
<li>释放 锁，如果有等待锁的线程就唤醒</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="互斥锁实现思路"><a href="#互斥锁实现思路" class="headerlink" title="互斥锁实现思路"></a>互斥锁实现思路</h3><p>初始lock = unlocked<br>临界区 = 更衣室<br>os = 更衣室管理员<br>thread = 要进去的人</p>
<ul>
<li><p>先到的人 thread</p>
<ul>
<li>成功获得手环，进入更衣室</li>
<li>lock 状态 变为 locked</li>
</ul>
</li>
<li><p>后到的人 thread</p>
<ul>
<li>不能进入更衣室，排队等待</li>
<li>这个后到的thread放入等待队列 执行thread切换（yield）</li>
</ul>
</li>
<li><p>洗完澡出来的人 thread</p>
<ul>
<li>交还手环给管理员；</li>
<li>管理员把手环再交给排队的人<ul>
<li>如果waiting thread queue is not empty，从queue中取出一个thread允许执行</li>
<li>如果waiting thread queue is empty，lock置为 unlocked</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>管理员OS通过使用spin lock来确保 自己处理手环的过程是原子的</strong>。</p>
<ul>
<li>所以，我们站在用户层面看的时候，就可以看到，<strong>锁的获取</strong>（load看一眼有没有，有的话就拿store；）；和<strong>锁的释放</strong>是<strong>原子的</strong>。</li>
<li>到最底层都是用了cpu提供的原子指令如 xchg</li>
<li>我们就是利用的获得释放锁的原子性，来提供临界区互斥（只允许有n个thread）的功能。</li>
</ul>
</li>
</ul>
<h2 id="关于-spinlock-和-睡眠锁-的快慢分析"><a href="#关于-spinlock-和-睡眠锁-的快慢分析" class="headerlink" title="关于 spinlock 和 睡眠锁 的快慢分析"></a>关于 spinlock 和 睡眠锁 的快慢分析</h2><ul>
<li><strong>自旋锁（thread直接共享locked）</strong><ul>
<li>更快的fast path<ul>
<li>xchg成功 -&gt; 立即进入临界区，开销很小</li>
</ul>
</li>
<li>更慢的slow path<ul>
<li>xchg失败 -&gt; 浪费CPU自选等待</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>睡眠锁（就是上文中的互斥锁，mutex）</strong> (通过系统调用访问 locked)<ul>
<li>更慢的 fast path<ul>
<li>即便上锁成功也需要进出内核 (syscall)</li>
</ul>
</li>
<li>更快的 slow path<ul>
<li>上锁失败线程不再占用 CPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>今天OS上的锁如何实现</li>
<li>小孩子才做选择。我当然是全都要啦！</li>
</ul>
<h2 id="Futex-Fast-Userspace-Mutexes"><a href="#Futex-Fast-Userspace-Mutexes" class="headerlink" title="Futex: Fast Userspace Mutexes"></a>Futex: Fast Userspace Mutexes</h2><ul>
<li><p><strong>Fast path: 一条原子指令，上锁成功立即返回。无需进入kernel</strong></p>
</li>
<li><p><strong>Slow path: 上锁失败，执行系统调用睡眠。需要进入kenrel（系统调用）</strong></p>
<ul>
<li>性能优化的最常见技巧<ul>
<li>看 average (frequent) case 而不是 worst case</li>
</ul>
</li>
<li>绝大多数的时候 都上锁成功 没进入kernel</li>
</ul>
</li>
<li><p>POSIX 线程库中的互斥锁 (pthread_mutex)</p>
<ul>
<li>futuex调用的数量远远小于lock和unlock的数量</li>
</ul>
</li>
<li><p>线程库中的锁，在绝大多数情况下都不会触发系统调用，直接用原子指令就解决了。只有在少部分情况下，有争抢的情况下，才会触发系统调用。</p>
</li>
<li><p>所以目前我认为 ：futex的好处就是尽量少的触发系统调用？绝大部分情况都不进入内核</p>
</li>
</ul>
<hr>
<h2 id="XV6-6-S801"><a href="#XV6-6-S801" class="headerlink" title="XV6 6.S801"></a>XV6 6.S801</h2><h3 id="When-to-lock"><a href="#When-to-lock" class="headerlink" title="When to lock"></a><strong>When to lock</strong></h3><ul>
<li><strong>Constructive rule:</strong><ul>
<li>if (2 processes access a shared data structure &amp;&amp; at least on is writiter) -&gt;</li>
<li>lock data structure </li>
<li><strong>too strict</strong>,相较于lock free programming。但是用锁来实现共享已经足够难了。</li>
</ul>
</li>
</ul>
<h3 id="Perspective"><a href="#Perspective" class="headerlink" title="Perspective"></a>Perspective</h3><ul>
<li><strong>Lock perspective</strong><ul>
<li>lock help avoid last update<ul>
<li>防止更新的数据/页/节点被覆盖/丢失。</li>
<li>如防止 list = l 被覆盖</li>
</ul>
</li>
<li>lock help amke multi-step to be atomic<ul>
<li>使得多步操作原子。</li>
<li>如 l-&gt; next 和 liast = l原子。 </li>
</ul>
</li>
<li>lock help maintain 不变量<ul>
<li>保持list是指向链表首元素的属性。</li>
<li>不变量是跨操作维护的数据结构的属性。通常，操作的正确行为取决于操作开始时不变量是否为真。操作可能暂时违反不变量，但必须在完成之前重新建立它们。例如，在链表的例子中，不变量是list指向列表中的第一个元素，以及每个元素的next字段指向下一个元素。push的实现暂时违反了这个不变量：在第17行，l-&gt;next指向list（注：则此时list不再指向列表中的第一个元素，即违反了不变量），但是list还没有指向l（在第18行重新建立）。我们上面检查的竞态条件发生了，因为第二个CPU执行了依赖于列表不变量的代码，而这些代码（暂时）被违反了。正确使用锁可以确保每次只有一个CPU可以对临界区域中的数据结构进行操作，因此当数据结构的不变量不成立时，将没有其他CPU对数据结构执行操作。</li>
</ul>
</li>
</ul>
</li>
<li>list例子<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">listlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    acquire(&amp;listlock);</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span> = l; </span><br><span class="line">    release(&amp;listlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>如何lock并且尽量做到较好的performance性能<ul>
<li>need to split up data structure</li>
<li>best split is a challenge</li>
<li>方法<ul>
<li>start with 粗粒度的lock</li>
<li>measure performance，是否出现争用</li>
<li>重新设计</li>
<li>是否值得更细粒度，因为越细逻辑越复杂。可能不值得</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul>
<li>人们很自然地会想到程序是按照源代码语句出现的顺序执行的。然而，许多编译器和中央处理器为了获得更高的性能而不按顺序执行代码。如果一条指令需要许多周期才能完成，中央处理器可能会提前发出指令，这样它就可以与其他指令重叠，避免中央处理器停顿。例如，中央处理器可能会注意到在顺序指令序列A和B中彼此不存在依赖。CPU也许首先启动指令B，或者是因为它的输入先于A的输入准备就绪，或者是为了重叠执行A和B。编译器可以执行类似的重新排序，方法是在源代码中一条语句的指令发出之前，先发出另一条语句的指令。</li>
<li>编译器和CPU在重新排序时需要遵循一定规则，以确保它们不会改变正确编写的串行代码的结果。然而，规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的排序规则称为内存模型（memory model）。</li>
<li>例如，在push的代码中，如果编译器或CPU将对应于第4行的存储指令移动到第6行release后的某个地方，那将是一场灾难：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release(&amp;listlock);</span><br></pre></td></tr></table></figure></li>
<li>如果发生这样的重新排序，将会有一个窗口期，另一个CPU可以获取锁并查看更新后的list，但却看到一个未初始化的list-&gt;next。</li>
<li>为了告诉硬件和编译器不要执行这样的重新排序，xv6在acquire(kernel/spinlock.c:22) 和release(kernel/spinlock.c:47)中都使用了__sync_synchronize()。__sync_synchronize()是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序load或store指令。因为xv6在访问共享数据时使用了锁，xv6的acquire和release中的障碍在几乎所有重要的情况下都会强制顺序执行。第9章讨论了一些例外。</li>
</ul>
<h3 id="Wrap-Up"><a href="#Wrap-Up" class="headerlink" title="Wrap Up"></a>Wrap Up</h3><ul>
<li>locks good for correctness , can be bad  for perf</li>
<li>locks complicate programming</li>
<li>don’t share data structre if you don’t have to</li>
<li>start with 粗粒度锁 , 在需要时转向细粒度锁</li>
<li>使用工具 检测性能和 race</li>
</ul>
<p><a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_concurrency.html">https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_concurrency.html</a></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统_并发05-死锁</title>
    <url>/2022/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9105-bug-%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<ul>
<li>死锁<ul>
<li>理论以及学校考试上<ul>
<li>四个条件:互斥 不可剥夺 请求与保持 循环等待</li>
<li>措施:预防,避免,检测/恢复,忽略</li>
<li>死锁避免中的 银行家算法实现</li>
</ul>
</li>
<li>实际<ul>
<li>AA-Deadlock <ul>
<li>Thread自己等待自己释放锁 : funcA持有lock , funcA调用funcB , funcB也需要lock</li>
</ul>
</li>
<li>AB-BA-Deadlock<ul>
<li>T1先拿A后等B，T2先拿B后等A</li>
<li>应当严格按照固定的顺序获得所有锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul>
<li>A deadlock is a state in which each member of a group is waiting for another member, including itself, to take action.</li>
</ul>
<p><img src="/2022/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9105-bug-%E6%AD%BB%E9%94%81/2022-10-17-09-21-38.png"></p>
<h2 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h2><ul>
<li>互斥（mutual exclusion）: 资源不能被共享，一个资源每次只能被一个进程使用</li>
<li>不可剥夺（no preemption）：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>请求与保持（hold and wait）：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>循环等待（circular wait）：若干进程之间形成一种头尾相接的循环性资源等待关系</li>
<li>破坏其中一个，就不会形成死锁.</li>
</ul>
<blockquote>
<p>“理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。” ——Bullshit.</p>
</blockquote>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><ul>
<li>互斥和不可剥夺一般很难破坏,死锁预防主要是破坏请求与保持和循环等待这两个必要条件.</li>
<li>方法一 : 破坏请求与保持<ul>
<li>(要么不请求,要么不保持)</li>
<li><strong>一次性申请所有资源</strong><ul>
<li>缺点</li>
<li>需要预先计算程序所需资源,这很难做到</li>
<li>在很远的未来会用到的资源需要早早地预留下来,这会造成资源的极大浪费.</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>方法二 : 破坏循环等待<ul>
<li>存在环路–&gt;死锁<img src="/2022/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9105-bug-%E6%AD%BB%E9%94%81/2022-09-13-11-30-55.png"></li>
<li>不让资源等待形成环路.</li>
<li><strong>资源按序申请</strong><ul>
<li>资源按序申请就一定不会出现环路,因此也就一定不会出现死锁.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><ul>
<li>死锁预防:对进程申请资源做出限制,不能随意的发出申请.</li>
<li>死锁避免:<ul>
<li>进程可以随意申请资源,但是需要有一个<strong>机制</strong>来<ul>
<li><strong>判断这次请求是否可能造成死锁</strong>.</li>
<li>存在这种死锁危险就拒绝此次申请.</li>
<li>(死锁危险实际上不一定会造成死锁)</li>
</ul>
</li>
<li>这样,就能保证进程对资源的占用和申请总处于安全状态.</li>
</ul>
</li>
</ul>
<h3 id="银行家算法-bank’s-algorithm"><a href="#银行家算法-bank’s-algorithm" class="headerlink" title="银行家算法 bank’s algorithm"></a>银行家算法 bank’s algorithm</h3><ul>
<li><p>思路: 遇到一个资源请求时,首先假设允许此次资源请求,</p>
<ul>
<li>如果发现允许该请求以后os上仍能找到安全序列,说明此次请求安全.可以分配资源</li>
<li>如果找不到,虽然不是一定会发生死锁,但还是拒绝请求</li>
<li>银行家算法是一个充分性算法(满足算法就必定安全),对资源的访问控制保守.</li>
<li>例子<br><img src="/2022/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9105-bug-%E6%AD%BB%E9%94%81/2022-09-13-12-05-37.png"></li>
</ul>
</li>
<li><p>时间复杂度:O(m * n^2). m:资源数量 n:进程数量</p>
</li>
<li><p><a href="https://sunnysab.cn/2020/04/29/Banker-Algorithm/">代码地址</a></p>
</li>
<li><p>缺点</p>
<ul>
<li>保守:本来不会导致死锁的请求不被允许.资源浪费,用户进程拖延.因为进程所占用的资源不是在进程结束之后一起释放的,而是使用完立即释放.</li>
<li>效率不高 : 首先时间复杂度O(m * n^2),其次在进程的每一次请求时都需要执行一次银行家算法.<ul>
<li>对于P12..N各个进程的申请释放动作,判定系统执行状态S是否会引起死锁,这是个NPC问题.只能容忍bank的时间复杂度</li>
</ul>
</li>
<li>参数难以获得:需要知道进程执行完毕所需要的资源总量</li>
</ul>
</li>
</ul>
<h2 id="死锁检测-死锁恢复"><a href="#死锁检测-死锁恢复" class="headerlink" title="死锁检测 + 死锁恢复"></a>死锁检测 + 死锁恢复</h2><ul>
<li>死锁检测算法 + 死锁恢复机制</li>
<li>思路:通过一种算法检测哪些进程死锁,并通过机制将陷入死锁的进程恢复.</li>
</ul>
<h3 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h3><ul>
<li><p>死锁检测算法(银行家算法变形: </p>
<ul>
<li>遍历n个进程,check每个进程拿到其所请求的资源后(不是所需的全部资源,只是该进程此时请求的资源)是否可以运行,</li>
<li>如果此时的系统状态下,不能满足任何一个等待运行的进程的请求<ul>
<li>那么,此时即发生了死锁.即这些不能运行,等待资源的进程就陷入了死锁.记录下这些陷入死锁的进程.之后将这些进程恢复</li>
</ul>
</li>
</ul>
</li>
<li><p>时间复杂度: O(m * n^2)</p>
</li>
<li><p>死锁检测算法 vs 银行家算法</p>
<ul>
<li>死锁检测算法: 定时调用 或是 需要检查死锁时才调用. (调用频率低)</li>
<li>银行家算法: 每次进程申请资源都要调用 (为了避免死锁发生)</li>
</ul>
</li>
<li><p>缺点:死锁恢复机制不好实现</p>
<ul>
<li>死锁检测算法的系统开销可以接收,但是 死锁恢复 不好实现.例如如何回滚</li>
<li>因此死锁检测/恢复 对 资源的访问没有限制,但是不好处理出现的死锁.</li>
</ul>
</li>
</ul>
<h2 id="死锁忽略"><a href="#死锁忽略" class="headerlink" title="死锁忽略"></a>死锁忽略</h2><ul>
<li>对死锁不做任何处理</li>
<li>PC机上的Linux Window都这样.<ul>
<li>死锁概率低 + 重启代价小 </li>
</ul>
</li>
</ul>
<h1 id="排查死锁-线程池"><a href="#排查死锁-线程池" class="headerlink" title="排查死锁 线程池"></a>排查死锁 线程池</h1><h1 id="死锁实际"><a href="#死锁实际" class="headerlink" title="死锁实际"></a>死锁实际</h1><h2 id="AA-DeadLock"><a href="#AA-DeadLock" class="headerlink" title="AA-DeadLock"></a>AA-DeadLock</h2><ul>
<li><p>Thread自己等待自己</p>
<ul>
<li>如：funcA 获得lockA , 在unlockA之前调用funcB , funcB需要lockA。</li>
</ul>
</li>
<li><p>假设你的 spinlock 不小心发生了中断</p>
<ul>
<li>在不该打开中断的时候开了中断</li>
<li>在不该切换的时候执行了 yield()<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">os_run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  spin_lock(&amp;list_lock);</span><br><span class="line">  spin_lock(&amp;xxx);</span><br><span class="line">  spin_unlock(&amp;xxx); <span class="comment">// ---------+</span></span><br><span class="line">&#125;                          <span class="comment">//    |</span></span><br><span class="line">                          <span class="comment">//    |</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">on_interrupt</span><span class="params">()</span> </span>&#123;      <span class="comment">//    |</span></span><br><span class="line">  spin_lock(&amp;list_lock);   <span class="comment">// &lt;--+</span></span><br><span class="line">  spin_unlock(&amp;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>死锁避免</strong></p>
<ul>
<li>AA 型的死锁容易检测，及早报告，及早修复</li>
<li>spinlock-xv6.c 中的各种防御性编程<ul>
<li>if (holding(lk)) panic(); 检查，如果已经获得A锁了，此时还想获得，那么直接报错。而不是让死锁发生。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="AB-BA-DeadLock"><a href="#AB-BA-DeadLock" class="headerlink" title="AB-BA-DeadLock"></a>AB-BA-DeadLock</h2><ul>
<li><p>T1先拿A后等B，T2先拿B后等A</p>
<ul>
<li>T1 拿到A。T2拿到B。T1等待B。T2等待A<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  spin_lock(&amp;lock[i]);</span><br><span class="line">  spin_lock(&amp;lock[j]);</span><br><span class="line">  arr[i] = <span class="literal">NULL</span>;</span><br><span class="line">  arr[j] = arr[i];</span><br><span class="line">  spin_unlock(&amp;lock[j]);</span><br><span class="line">  spin_unlock(&amp;lock[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>上锁的顺序很重要……</p>
</li>
<li><p>swap 本身看起来没有问题</p>
<ul>
<li>swap(1, 2); swap(2, 3), swap(3, 1) → 死锁。<ul>
<li>swap(1,2) lock 1</li>
<li>swap(2,3) lock 2</li>
<li>swap(3,1) lock 3 (该thread应当调用swap(1,3) , 来先获取lock 1 而不是lock 3. 这样才做到和swap(1,2) , swap(2,3)保持上锁顺序一致)</li>
<li>swap(1,2) wait for 2</li>
<li>swap(2,3) wait for 3</li>
<li>swap(3,1) wait for 1</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>死锁避免</strong></p>
<ul>
<li>任意时刻系统中的锁都是有限的</li>
<li>严格按照固定的顺序获得所有锁 (lock ordering; 消除 “循环等待”)<ul>
<li>“在任意时刻总是有获得 “最靠后” 锁的可以继续执行”</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-并发03-同步控制</title>
    <url>/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9103-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>互斥锁 + 条件变量<br>信号量<br>哲学家吃饭</p>
<span id="more"></span>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li><p>同步 (Synchronization)</p>
<ul>
<li>两个或两个以上随时间变化的量在变化过程中保持一定的相对关系</li>
<li>iPhone/iCloud 同步 (手机 vs 电脑 vs 云端)</li>
<li>变速箱同步器 (合并快慢速齿轮)</li>
<li>同步电机 (转子与磁场速度一致)</li>
<li>同步电路 (所有触发器在边沿同时触发)</li>
</ul>
</li>
<li><p>异步 (Asynchronous) = 不同步</p>
<ul>
<li>上述很多例子都有异步版本 (异步电机、异步电路、异步线程)</li>
</ul>
</li>
<li><p>并发程序中的同步:并发程序的步调很难保持 “完全一致”</p>
<ul>
<li><strong>线程同步：在某个时间点共同达到互相已知的状态</strong></li>
</ul>
</li>
</ul>
<h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><blockquote>
<p>99% 的实际并发问题都可以用生产者-消费者解决。</p>
</blockquote>
<h3 id="一种题目描述-问题"><a href="#一种题目描述-问题" class="headerlink" title="一种题目描述 ()问题"></a>一种题目描述 ()问题</h3><ul>
<li><p>在 printf 前后增加代码，使得打印的括号序列满足</p>
<ul>
<li>一定是某个合法括号序列的前缀</li>
<li>括号嵌套的深度不超过 n</li>
<li>n=3, ((())())((( 合法</li>
<li>n=3, (((()))), (())) （右括号多了一个） 不合法</li>
</ul>
</li>
<li><p><strong>同步</strong></p>
<ul>
<li>等到有空位再打印左括号</li>
<li>等到能配对时再打印右括号</li>
</ul>
</li>
<li><p><strong>分析</strong>  </p>
<ul>
<li>共享的缓冲区：终端（包）</li>
<li>将’(‘ 放入”包”中。’)’是取出资源。</li>
<li>资源数量即 ‘(‘的数量</li>
</ul>
</li>
</ul>
<h3 id="互斥锁实现"><a href="#互斥锁实现" class="headerlink" title="互斥锁实现"></a>互斥锁实现</h3><ul>
<li>能否<strong>用互斥锁实现括号问题</strong>？<ul>
<li>左括号：嵌套深度 (队列) 不足 n 时才能打印</li>
<li>右括号：嵌套深度 (队列) &gt;1 时才能打印<ul>
<li>当然是等到满足条件时再打印了：pc.c<ul>
<li>用互斥锁保持条件成立</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>wrong code :应当用while代替if ,防止消费者唤醒消费者，生产者唤醒生产者。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span>                <span class="comment">//  仅仅是为了用c++11的thread类 更方便</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread-sync.h&quot;</span>        <span class="comment">//  实现了spinlock , 封装了 POSIX的mutex（futex）,封装了条件变量还</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;                    <span class="comment">//  资源数量</span></span><br><span class="line"><span class="keyword">mutex_t</span> lk = <span class="built_in">MUTEX_INIT</span>();      <span class="comment">//  futex锁 即 封装的POSIX的pthread_mutex_t 在thread_sync中</span></span><br><span class="line"><span class="keyword">int</span> capacity = N;               <span class="comment">//  资源区大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tproduce</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="comment">//  lock</span></span><br><span class="line">        <span class="built_in">mutex_lock</span>(&amp;lk);        <span class="comment">//  futex 获得锁失败：进入kernel 调度到其他thread。获得锁成功：不进入kernel</span></span><br><span class="line">        <span class="comment">//  资源区满了 不再加入资源</span></span><br><span class="line">        <span class="keyword">if</span>(cnt == capacity)     </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  unlock </span></span><br><span class="line">            <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  放入资源</span></span><br><span class="line">        ++cnt;                  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="comment">//  在printf的时候不需要上锁 因为printf本身就会获得终端的锁 不必担心会打印乱码</span></span><br><span class="line">        <span class="comment">//  unlock</span></span><br><span class="line">        <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tconsume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    retry:</span><br><span class="line">        <span class="built_in">mutex_lock</span>(&amp;lk);</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  取出资源</span></span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        <span class="comment">//  unlock</span></span><br><span class="line">        <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  main</span></span><br><span class="line">    vector&lt;thread&gt; produces;</span><br><span class="line">    vector&lt;thread&gt; consumers;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        produces.<span class="built_in">emplace_back</span>(Tproduce);</span><br><span class="line">        consumers.<span class="built_in">emplace_back</span>(Tconsume);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="互斥锁-条件变量实现"><a href="#互斥锁-条件变量实现" class="headerlink" title="互斥锁 + 条件变量实现"></a>互斥锁 + 条件变量实现</h3><ul>
<li>使用条件变量比起只用互斥量的<strong>好处</strong>：<ul>
<li><strong>cond不满足时，用阻塞代替while空转</strong>。</li>
</ul>
</li>
</ul>
<h3 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h3><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ul>
<li>引入：while空转太浪费cpu了，不如阻塞，直到cond满足。<br><img src="/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9103-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/2022-10-14-20-56-13.png"></li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li>wait(cv, mutex) 💤<ul>
<li>调用时必须保证已经获得 mutex</li>
<li>释放 mutex、进入睡眠状态</li>
</ul>
</li>
<li>signal/notify(cv) 💬 私信：走起<ul>
<li>如果有线程正在等待 cv，则唤醒其中一个线程</li>
</ul>
</li>
<li>broadcast/notifyAll(cv) 📣 所有人：走起<ul>
<li>唤醒全部正在等待 cv 的线程</li>
</ul>
</li>
</ul>
<h3 id="wrong-code"><a href="#wrong-code" class="headerlink" title="wrong code"></a>wrong code</h3><ul>
<li><p>c</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tproduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">mutex_lock</span>(&amp;lk);</span><br><span class="line">  <span class="keyword">if</span> (count == n) <span class="built_in">cond_wait</span>(&amp;cv, &amp;lk);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); count++; <span class="built_in">cond_signal</span>(&amp;cv);</span><br><span class="line">  <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tconsume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">mutex_lock</span>(&amp;lk);</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="built_in">cond_wait</span>(&amp;cv, &amp;lk);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>); count--; <span class="built_in">cond_signal</span>(&amp;cv);</span><br><span class="line">  <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当producer 或者 consumer的thread数量大于1时，就会发生错误。</p>
<ul>
<li>因为生产者可能会唤醒生产者 / 消费者可能会唤醒消费者<br><img src="/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9103-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/2022-10-14-22-25-12.png"></li>
<li>```c<pre><code>shc@DESKTOP-TVUERHD:~/Code/try/lock$ ./pc2 2 | head -c 100
</code></pre>
(())(()()()())((()))()(())(()(())))))()())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))shc@DESKTOP-TVUERHD:~/Code/try/lock$ <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 解决：if改成while</span><br><span class="line"></span><br><span class="line">### 万能的正确使用姿势</span><br><span class="line"></span><br><span class="line">- **需要等待条件满足时**</span><br><span class="line">    ```c</span><br><span class="line">    mutex_lock(&amp;mutex);</span><br><span class="line">    while (!cond) &#123;</span><br><span class="line">        wait(&amp;cv, &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    //  无论thread如何并发 while都保证了出循环时一定满足cond</span><br><span class="line">    assert(cond);</span><br><span class="line">    // ...</span><br><span class="line">    // 互斥锁保证了在此期间条件 cond 总是成立</span><br><span class="line">    // ...</span><br><span class="line">    mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>其他线程条件可能被满足时</strong></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">broadcast(&amp;cv);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>观点：为了防止生产者唤醒生产者 ; 消费者唤醒消费者. 可以使用两个条件变量 ?<ul>
<li>一个是notFullCond 一个是notEmptyCond<ul>
<li>生产者等待notFullCond , 唤醒notEmptyCond</li>
<li>消费者等待NotEmptyCond , 唤醒notFullCond</li>
</ul>
</li>
<li>不过这个也算不了什么优化吧 ? 生产者唤醒生产者又能怎样。顶多是多生产一些资源燃火再让消费者消费呗</li>
</ul>
</li>
</ul>
<h4 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h4><ul>
<li>()问题正确源代码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread-sync.h&quot;</span>        <span class="comment">//  实现了spinlock , 封装了 POSIX的mutex（futex）,封装了条件变量还</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;                    <span class="comment">//  资源数量</span></span><br><span class="line"><span class="keyword">mutex_t</span> lk = <span class="built_in">MUTEX_INIT</span>();       <span class="comment">//  futex锁</span></span><br><span class="line"><span class="keyword">cond_t</span> cv = <span class="built_in">COND_INIT</span>();     <span class="comment">//  条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> capacity = N;               <span class="comment">//  资源区大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tproduce</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  lock</span></span><br><span class="line">        <span class="built_in">mutex_lock</span>(&amp;lk);        </span><br><span class="line">        <span class="keyword">while</span>( ! (cnt != capacity) )        <span class="comment">//  !cond</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  unblock and sleep</span></span><br><span class="line">            <span class="built_in">cond_wait</span>(&amp;cv,&amp;lk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  出循环时一定满足cond</span></span><br><span class="line">        <span class="built_in">assert</span>(cnt!=capacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  放入资源</span></span><br><span class="line">        ++cnt;                  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  unlock</span></span><br><span class="line">        <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  全部wakeup。防止 一些情况下生产者唤醒生产者 或者 consunmer唤醒consumer产生的bug。</span></span><br><span class="line">        <span class="built_in">cond_broadcast</span>(&amp;cv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tconsume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">mutex_lock</span>(&amp;lk);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!(cnt!=<span class="number">0</span>))    </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cond_wait</span>(&amp;cv,&amp;lk);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(cnt != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        --cnt;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">mutex_unlock</span>(&amp;lk);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cond_broadcast</span>(&amp;cv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实现并行计算"><a href="#实现并行计算" class="headerlink" title="实现并行计算"></a>实现并行计算</h4><ul>
<li>利用条件变量的万能姿势实现并行计算  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*run)(<span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">void</span> *arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> *<span class="title">job</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="keyword">while</span> (! (job = <span class="built_in">get_job</span>()) ) &#123;        <span class="comment">//  cond :job不为空</span></span><br><span class="line">    <span class="built_in">wait</span>(&amp;cv, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">job-&gt;<span class="built_in">run</span>(job-&gt;arg); <span class="comment">// 不需要持有锁</span></span><br><span class="line">                    <span class="comment">// 可以生成新的 job</span></span><br><span class="line">                    <span class="comment">// 注意回收分配的资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="lt-gt-例题"><a href="#lt-gt-例题" class="headerlink" title="&lt;&gt;_ (例题)"></a>&lt;&gt;_ (例题)</h4><ul>
<li><p>所以有了这个万能算法就很简单了阿，可以简单的解决奇怪的并发问题</p>
<ul>
<li>用条件变量解决问题只要回答一个问题：<strong>while循环的条件</strong>是什么，也即，我们的<strong>cond是什么</strong>？</li>
<li>还需要画出状态机，在什么情况下可以做出什么动作 然后转移到什么状态。</li>
</ul>
</li>
<li><p>例题如下 使用<strong>锁 + 条件变量 + 状态机</strong>。</p>
</li>
</ul>
<ul>
<li><p><strong>题目：打印出&lt;&gt;_ 或者 &gt;&lt;&gt;_</strong></p>
</li>
<li><p><strong>状态机</strong><br><img src="/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9103-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/2022-10-15-16-29-32.png"></p>
</li>
<li><p>fish.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> A = <span class="number">1</span>, B, C, D, E, F, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> from, ch, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span> <span class="title">rules</span>[] =</span> &#123;</span><br><span class="line">  &#123; A, <span class="string">&#x27;&lt;&#x27;</span>, B &#125;,</span><br><span class="line">  &#123; B, <span class="string">&#x27;&gt;&#x27;</span>, C &#125;,</span><br><span class="line">  &#123; C, <span class="string">&#x27;&lt;&#x27;</span>, D &#125;,</span><br><span class="line">  &#123; A, <span class="string">&#x27;&gt;&#x27;</span>, E &#125;,</span><br><span class="line">  &#123; E, <span class="string">&#x27;&lt;&#x27;</span>, F &#125;,</span><br><span class="line">  &#123; F, <span class="string">&#x27;&gt;&#x27;</span>, D &#125;,</span><br><span class="line">  &#123; D, <span class="string">&#x27;_&#x27;</span>, A &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   state        quota是为了保证打印完之后可以原子的改变状态 再切换到其他thread上、可以优化掉。</span></span><br><span class="line"><span class="keyword">int</span> current = A, quota = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lk   = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>  cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  根据current 和 ch 获取下一state</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH(rules); i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> *<span class="title">rule</span> =</span> &amp;rules[i];</span><br><span class="line">    <span class="keyword">if</span> (rule-&gt;from == current &amp;&amp; rule-&gt;ch == ch) &#123;</span><br><span class="line">      <span class="keyword">return</span> rule-&gt;to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_before</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lk);</span><br><span class="line">  <span class="keyword">while</span> (!(next(ch) &amp;&amp; quota)) &#123;     <span class="comment">//  next(ch) 是保证下一状态是状态机中存在的状态 非法的话就返回0，但不一定符合逻辑。所以还应当加一个计数的cnt，防止打印 &lt; 的thread 执行完before之后切换到另一个打印&lt;的thread。加上的cnt 保证了执行完after之后 才会切换到其他thread</span></span><br><span class="line">    <span class="comment">// can proceed only if (next(ch) &amp;&amp; quota)</span></span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;lk);</span><br><span class="line">  &#125;</span><br><span class="line">  quota--;                            <span class="comment">//  这是为了保证 state 改变之后 再切换到下一个 thread 。如果没有这个保证的话，可能putchar打印完&lt;之后,CPU可能切换到另一个thread（比如另一个打印&gt;的thread的before函数）但是，我们打印完之后并没有改变current（state），因此就会发生逻辑错误导致死锁。  其实可以优化掉</span></span><br><span class="line">  pthread_mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_after</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lk);</span><br><span class="line">  quota++;</span><br><span class="line">  current = next(ch);                 <span class="comment">//  state转化</span></span><br><span class="line">  assert(current);                    <span class="comment">//  确保state合法性。否则逻辑错误 终止程序</span></span><br><span class="line">  pthread_cond_broadcast(&amp;cond);      <span class="comment">//  唤醒所有等待在cond的thread</span></span><br><span class="line">  pthread_mutex_unlock(&amp;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> roles[] = <span class="string">&quot;.&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;___&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_thread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> role = roles[id];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    fish_before(role);                <span class="comment">//  根据state和本thread要打印的ch，阻塞到 一定时刻 再进行打印。</span></span><br><span class="line">    <span class="built_in">putchar</span>(role); <span class="comment">// can be long; no lock protection   //  在putchar的时候不需要上锁 因为putchar本身就会获得终端的锁 不必担心多个thread同时打印时 会打印乱码</span></span><br><span class="line">    <span class="comment">// printf(&quot;%c current = %d\n&quot;,ch,current);</span></span><br><span class="line">    fish_after(role);                 <span class="comment">//  唤醒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(roles); i++)</span><br><span class="line">    create(fish_thread);</span><br><span class="line">&#125;</span><br><span class="line">  shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ gcc fish.c -o fish -Wall -lpthread &amp;&amp; ./fish</span><br><span class="line">&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&gt;&lt;&gt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&gt;&lt;&gt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&gt;&lt;&gt;_...</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>简化：myFish.c<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;thread.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> A = <span class="number">1</span>, B, C, D, E, F, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> from, ch, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rule</span> <span class="title">rules</span>[] =</span> &#123;</span><br><span class="line">  &#123; A, <span class="string">&#x27;&lt;&#x27;</span>, B &#125;,</span><br><span class="line">  &#123; B, <span class="string">&#x27;&gt;&#x27;</span>, C &#125;,</span><br><span class="line">  &#123; C, <span class="string">&#x27;&lt;&#x27;</span>, D &#125;,</span><br><span class="line">  &#123; A, <span class="string">&#x27;&gt;&#x27;</span>, E &#125;,</span><br><span class="line">  &#123; E, <span class="string">&#x27;&lt;&#x27;</span>, F &#125;,</span><br><span class="line">  &#123; F, <span class="string">&#x27;&gt;&#x27;</span>, D &#125;,</span><br><span class="line">  &#123; D, <span class="string">&#x27;_&#x27;</span>, A &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> current = A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lk   = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>  cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LENGTH(rules); i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rule</span> *<span class="title">rule</span> =</span> &amp;rules[i];</span><br><span class="line">    <span class="keyword">if</span> (rule-&gt;from == current &amp;&amp; rule-&gt;ch == ch) &#123;</span><br><span class="line">      <span class="keyword">return</span> rule-&gt;to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  while(!cond)&#123;&#125;</span></span><br><span class="line">  <span class="keyword">while</span> (!next(ch)) &#123;                 <span class="comment">//  next(ch) 是保证下一状态是状态机中存在的状态 仅仅保证非0，而不一定符合逻辑。所以还应当加一个计数的cnt，防止打印 &lt; 的thread 执行完before之后切换到另一个打印&lt;的thread。加上的cnt 保证了执行完after之后 才会切换到其他thread</span></span><br><span class="line">    pthread_cond_wait(&amp;cond, &amp;lk);    <span class="comment">//  wait</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">putchar</span>(ch);          </span><br><span class="line">  current = next(ch);                 <span class="comment">//  state前进</span></span><br><span class="line">  assert(current);                    <span class="comment">//  check 确保state合法性。否则逻辑错误 终止程序</span></span><br><span class="line"></span><br><span class="line">  pthread_cond_broadcast(&amp;cond);      <span class="comment">//  wakeup</span></span><br><span class="line">  pthread_mutex_unlock(&amp;lk);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> roles[] = <span class="string">&quot;.&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;___&quot;</span>;</span><br><span class="line"><span class="comment">// const char roles[] = &quot;.&lt;&gt;_&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fish_thread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> role = roles[id];</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    fish(role);    <span class="comment">//  根据state和本thread要打印的ch，阻塞到什么时候再进行打印。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(roles); i++)</span><br><span class="line">    create(fish_thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ gcc myFish.c -o myFish -Wall -lpthread &amp;&amp; ./myFish | head -c <span class="number">10000</span></span><br><span class="line">&lt;&gt;&lt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&gt;&lt;&gt;_&gt;&lt;&gt;_&gt;&lt;&gt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_&lt;&gt;&lt;_...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="H2O"><a href="#H2O" class="headerlink" title="H2O"></a>H2O</h4><ul>
<li>同上。提交记录中有cpp。照着jyy教的写就行了。</li>
<li><a href="https://leetcode.cn/problems/building-h2o/description/">lc H2O</a><ul>
<li>用了两种。一种比较简化。不过都是锁 + 条件变量 + 状态机 </li>
</ul>
</li>
</ul>
<h2 id="信号量-带计数器的锁-扩展的锁"><a href="#信号量-带计数器的锁-扩展的锁" class="headerlink" title="信号量 - 带计数器的锁(扩展的锁)"></a>信号量 - 带计数器的锁(扩展的锁)</h2><ul>
<li>封装<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Semaphore</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P sem_wait</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V sem_post</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEM_INIT(sem, val) sem_init(sem, 0, val)</span></span><br></pre></td></tr></table></figure>
<h3 id="锁与信号量"><a href="#锁与信号量" class="headerlink" title="锁与信号量"></a>锁与信号量</h3></li>
</ul>
<blockquote>
<p><img src="/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9103-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/2022-10-15-08-14-10.png"><br><img src="/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9103-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/2022-10-15-08-14-24.png"><br><img src="/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9103-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/2022-10-15-08-14-49.png"></p>
</blockquote>
<h3 id="生产者-消费者-1"><a href="#生产者-消费者-1" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h3><ul>
<li><strong>信号量设计的重点</strong><ul>
<li>考虑 <strong>“手环”</strong> (每一单位的 “资源”) 是什么，谁<strong>创造</strong>？谁<strong>获取</strong>？</li>
</ul>
</li>
<li>code : 比使用条件变量更加简洁<ul>
<li>使用两个信号量</li>
<li>在 “一单位资源” 明确的问题上更好用</li>
<li>还是推荐用条件变量。信号量需要更加小心<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P(&amp;empty);   <span class="comment">// P()返回 -&gt; 得到手环</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>); <span class="comment">// 假设线程安全</span></span><br><span class="line">  V(&amp;fill);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  P(&amp;fill);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">  V(&amp;empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  assert(argc == <span class="number">2</span>);</span><br><span class="line">  SEM_INIT(&amp;fill, <span class="number">0</span>);</span><br><span class="line">  SEM_INIT(&amp;empty, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">      create(producer);</span><br><span class="line">      create(consumer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="哲学家吃饭"><a href="#哲学家吃饭" class="headerlink" title="哲学家吃饭"></a>哲学家吃饭</h2><ul>
<li>哲学家 (线程) 有时思考，有时吃饭<ul>
<li>吃饭需要同时得到左手和右手的叉子</li>
<li>当叉子被其他人占有时，必须等待，如何完成同步？<ul>
<li>如何用互斥锁/信号量实现？</li>
<li>套用生产者消费者模型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul>
<li>写不好的话可能会出现 同时所有哲学家都拿起左手边的叉子，而陷入dead lock</li>
<li>fail code <ul>
<li>有可能一个thread P1之后 又切到另一个thread P2 … 最后每个thread只有一个叉子。循环等待。故死锁。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tphilosopher</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lhs = (N + id - <span class="number">1</span>) % N;</span><br><span class="line">  <span class="keyword">int</span> rhs = id % N;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    P(&amp;locks[lhs]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T%d Got %d\n&quot;</span>, id, lhs + <span class="number">1</span>);</span><br><span class="line">    P(&amp;locks[rhs]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;T%d Got %d\n&quot;</span>, id, rhs + <span class="number">1</span>);</span><br><span class="line">    V(&amp;locks[lhs]);</span><br><span class="line">    V(&amp;locks[rhs]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">top</span><br><span class="line">   <span class="number">1613</span> shc       <span class="number">20</span>   <span class="number">0</span>   <span class="number">92768</span>    <span class="number">556</span>    <span class="number">472</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> philosopher</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="万能的条件变量"><a href="#万能的条件变量" class="headerlink" title="万能的条件变量"></a>万能的条件变量</h3><ul>
<li>资源是叉子</li>
<li>临界区是叉子。</li>
<li>各个线程互斥的处理叉子资源（即在处理资源时各个thread是串行的）</li>
<li>拿到资源后的thread 在吃饭的时候是并行的。</li>
<li>code<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  资源：叉子 avail</span></span><br><span class="line"><span class="comment">//  通过互斥锁的原子性保证了处理资源时的互斥性。</span></span><br><span class="line">  <span class="comment">//  同一时刻拿到锁的thread只有一个</span></span><br><span class="line">  <span class="comment">//  同一时刻load、store资源的thread只有一个</span></span><br><span class="line">    <span class="comment">//  也即保证了load和store的原子性</span></span><br><span class="line"><span class="built_in">mutex_lock</span>(&amp;mutex);     <span class="comment">//  atomic</span></span><br><span class="line"><span class="keyword">while</span> (!(avail[lhs] &amp;&amp; avail[rhs])) &#123;</span><br><span class="line">  <span class="built_in">wait</span>(&amp;cv, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  同一时刻 只有一个thread 会在这里</span></span><br><span class="line">  <span class="comment">//  取资源</span></span><br><span class="line">avail[lhs] = avail[rhs] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  eat</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mutex_lock</span>(&amp;mutex);</span><br><span class="line"><span class="comment">//  同一时刻 只有一个thread 会在这里</span></span><br><span class="line"><span class="comment">//  放回资源</span></span><br><span class="line">avail[lhs] = avail[rhs] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">broadcast</span>(&amp;cv);   <span class="comment">//  唤醒别人，条件满足</span></span><br><span class="line"><span class="built_in">mutex_unlock</span>(&amp;mutex);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Leader-Follower-生产者-消费者"><a href="#Leader-Follower-生产者-消费者" class="headerlink" title="Leader/Follower - 生产者/消费者"></a>Leader/Follower - 生产者/消费者</h3><ul>
<li>分布式常见的解决思路（HDFS）</li>
<li>Leader : 服务员</li>
<li>Follower : 哲学家</li>
<li>让一个人（服务员）<strong>集中</strong>的管理资源（叉子）<ul>
<li>这个人可以知道资源（叉子）的情况，比如谁霸占了叉子，谁用叉子用了多长时间</li>
<li>而非使用信号量（分布的，让每个人自己去争抢）</li>
</ul>
</li>
<li>Twaiter可能成为瓶颈：一大桌人吃饭，每个人都叫服务员的感觉</li>
<li>抛开 workload 谈优化就是耍流氓<ul>
<li>吃饭的时间通常远远大于请求服务员的时间</li>
<li>如果一个 manager 搞不定，可以分多个 (fast/slow path)<ul>
<li>把系统设计好，使集中管理不成为瓶颈</li>
</ul>
</li>
</ul>
</li>
<li>code<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  follower</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tphilosopher</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  send_request(id, EAT);      <span class="comment">//  请求资源</span></span><br><span class="line">  P(allowed[id]); <span class="comment">// waiter 会把叉子递给哲学家</span></span><br><span class="line">  philosopher_eat();</span><br><span class="line">  send_request(id, DONE);     <span class="comment">//  回收资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  leader 处理follower发来的请求 -分配资源/回收资源</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Twaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    (id, status) = receive_request();</span><br><span class="line">    <span class="keyword">if</span> (status == EAT) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">if</span> (status == DONE) &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-进程状态机模型</title>
    <url>/2022/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li>操作系统就是一个中断处理程序<ul>
<li>负责将第一个进程加载完后 第一个进程通过fork execve exit一系列系统调用创建其他的</li>
<li>创建状态机 : fork</li>
<li>替换 : execve</li>
<li>终止 : _exit<ul>
<li><strong>请问main退出后的detached thread的行为 ?</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>




<hr>
<ul>
<li><p>Linux 操作系统启动流程</p>
<ul>
<li>CPU Reset → Firmware → Loader → Kernel _start() → 第一个程序 /bin/init → 程序 (状态机) 执行 + 系统调用</li>
</ul>
</li>
<li><p>操作系统为 (所有) 程序提供 API</p>
<ul>
<li>进程 (状态机) 管理<ul>
<li>fork, execve, exit - 状态机的创建/改变/删除 ← 今天的主题</li>
</ul>
</li>
<li>存储 (地址空间) 管理<ul>
<li>mmap - 虚拟地址空间管理</li>
</ul>
</li>
<li>文件 (数据对象) 管理<ul>
<li>open, close, read, write - 文件访问管理</li>
<li>mkdir, link, unlink - 目录管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="创建状态机"><a href="#创建状态机" class="headerlink" title="创建状态机"></a>创建状态机</h1><ul>
<li>如果要创建状态机，我们应该提供什么样的 API？</li>
<li>UNIX 的答案: fork<ul>
<li>做一份状态机完整的复制 (内存、寄存器现场)</li>
</ul>
</li>
</ul>
<h1 id="替换状态机"><a href="#替换状态机" class="headerlink" title="替换状态机"></a>替换状态机</h1><ul>
<li>UNIX 的答案: execve<ul>
<li>将当前运行的状态机重置成成另一个程序的初始状态</li>
</ul>
</li>
<li>int execve(const char *filename, char * const argv, char * const envp);<ul>
<li>执行名为 filename 的程序</li>
<li>允许对新状态机设置参数 argv (v) 和环境变量 envp (e)</li>
<li>刚好对应了 main() 的参数！</li>
</ul>
</li>
</ul>
<h1 id="终止状态机"><a href="#终止状态机" class="headerlink" title="终止状态机"></a>终止状态机</h1><ul>
<li>有了 fork, execve 我们就能自由执行任何程序了，最后只缺一个销毁状态机的函数！</li>
<li>UNIX 的答案: _exit<ul>
<li>void _exit(int status)</li>
<li>立即摧毁状态机 <ul>
<li>销毁当前状态机，并允许有一个返回值</li>
<li>子进程终止会通知父进程 (后续课程解释)</li>
<li>这个简单……</li>
</ul>
</li>
</ul>
</li>
<li>但问题来了：多线程程序怎么办？</li>
</ul>
<h2 id="exit-的几种写法-它们是不同"><a href="#exit-的几种写法-它们是不同" class="headerlink" title="exit 的几种写法 (它们是不同)"></a>exit 的几种写法 (它们是不同)</h2><ul>
<li><p><strong>exit(0)</strong> - stdlib.h 中声明的 libc 函数</p>
<ul>
<li>因为是libc的库函数，所以会帮助我们做libc的clean up。比如将libc缓冲区中的数据写出去<ul>
<li>会调用 atexit 注册的函数</li>
</ul>
</li>
<li>return 也会将没flush的缓冲区清空。main种调用return就是相当于调用了exit(0)</li>
<li>执行 “<strong>exit_group</strong>” 系统调用<strong>终止整个进程</strong> (所有线程)<ul>
<li>那么操作系统会把当前进程所有的资源，包括地址空间、io、线程、管道、fd等等等等全部终止使用并且回收</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>_exit(0)</strong> - glibc 的 syscall wrapper</p>
<ul>
<li>是系统调用，不会帮助我们做libc的clean up（因为他根本就不知道libc）。直接就终止了整个进程。<ul>
<li>不会调用 atexit注册的函数</li>
</ul>
</li>
<li>执行 “<strong>exit_group</strong>” 系统调用<strong>终止整个进程</strong> (所有线程)</li>
</ul>
</li>
<li><p><strong>syscall(SYS_exit, 0)</strong></p>
<ul>
<li>执行 “<strong>exit</strong>” 系统调用终止<strong>当前线程</strong></li>
<li>不会调用 atexit注册的函数</li>
</ul>
</li>
<li><p><strong>pthread_exit(0)</strong></p>
<ul>
<li>libc的函数 , 所以会帮助我们做libc的clean up。比如将libc缓冲区中的数据写出去<ul>
<li>会调用atexit注册的函数</li>
</ul>
</li>
<li>当有多个thread时，执行”<strong>exit</strong>“系统调用<strong>终止当前thread</strong></li>
<li>当只有一个thread时，执行<strong>exit_group终止process</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Goodbye, Cruel OS World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  atexit(func);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) <span class="keyword">return</span> EXIT_FAILURE;        <span class="comment">//  exit_group</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);                                <span class="comment">//  exit_group</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;_exit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    _exit(<span class="number">0</span>);                               <span class="comment">//  exit_group</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;__exit&quot;</span>) == <span class="number">0</span>)   </span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);                   <span class="comment">//  exit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ strace ./<span class="built_in">exit</span>-<span class="function">demo </span></span><br><span class="line"><span class="function"><span class="title">execve</span><span class="params">(<span class="string">&quot;./exit-demo&quot;</span>, [<span class="string">&quot;./exit-demo&quot;</span>], <span class="number">0x7fffbed4f890</span> <span class="comment">/* 36 vars */</span>)</span> </span>= <span class="number">0</span></span><br><span class="line">arch_prctl(<span class="number">0x3001</span> <span class="comment">/* ARCH_??? */</span>, <span class="number">0x7fffd8ed0c70</span>) = <span class="number">-1</span> EINVAL (Invalid argument)</span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0x68c000</span></span><br><span class="line">brk(<span class="number">0x68d1c0</span>)                           = <span class="number">0x68d1c0</span></span><br><span class="line">arch_prctl(ARCH_SET_FS, <span class="number">0x68c880</span>)       = <span class="number">0</span></span><br><span class="line">uname(&#123;sysname=<span class="string">&quot;Linux&quot;</span>, nodename=<span class="string">&quot;DESKTOP-TVUERHD&quot;</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">readlink(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="string">&quot;/home/shc/Code/try/lock/jyy/exit&quot;</span>..., <span class="number">4096</span>) = <span class="number">37</span></span><br><span class="line">brk(<span class="number">0x6ae1c0</span>)                           = <span class="number">0x6ae1c0</span></span><br><span class="line">brk(<span class="number">0x6af000</span>)                           = <span class="number">0x6af000</span></span><br><span class="line">mprotect(<span class="number">0x4bd000</span>, <span class="number">12288</span>, PROT_READ)    = <span class="number">0</span></span><br><span class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=makedev(<span class="number">0x88</span>, <span class="number">0x4</span>), ...&#125;) = <span class="number">0</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;Goodbye, Cruel OS World!\n&quot;</span>, <span class="number">25</span>Goodbye, Cruel OS World!</span><br><span class="line">) = <span class="number">25</span></span><br><span class="line">exit_group(<span class="number">1</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">1</span> +++</span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ strace ./<span class="built_in">exit</span>-demo <span class="built_in">exit</span></span><br><span class="line">execve(<span class="string">&quot;./exit-demo&quot;</span>, [<span class="string">&quot;./exit-demo&quot;</span>, <span class="string">&quot;exit&quot;</span>], <span class="number">0x7fff0898d428</span> <span class="comment">/* 36 vars */</span>) = <span class="number">0</span></span><br><span class="line">arch_prctl(<span class="number">0x3001</span> <span class="comment">/* ARCH_??? */</span>, <span class="number">0x7ffe206995b0</span>) = <span class="number">-1</span> EINVAL (Invalid argument)</span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0xa47000</span></span><br><span class="line">brk(<span class="number">0xa481c0</span>)                           = <span class="number">0xa481c0</span></span><br><span class="line">arch_prctl(ARCH_SET_FS, <span class="number">0xa47880</span>)       = <span class="number">0</span></span><br><span class="line">uname(&#123;sysname=<span class="string">&quot;Linux&quot;</span>, nodename=<span class="string">&quot;DESKTOP-TVUERHD&quot;</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">readlink(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="string">&quot;/home/shc/Code/try/lock/jyy/exit&quot;</span>..., <span class="number">4096</span>) = <span class="number">37</span></span><br><span class="line">brk(<span class="number">0xa691c0</span>)                           = <span class="number">0xa691c0</span></span><br><span class="line">brk(<span class="number">0xa6a000</span>)                           = <span class="number">0xa6a000</span></span><br><span class="line">mprotect(<span class="number">0x4bd000</span>, <span class="number">12288</span>, PROT_READ)    = <span class="number">0</span></span><br><span class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=makedev(<span class="number">0x88</span>, <span class="number">0x4</span>), ...&#125;) = <span class="number">0</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;Goodbye, Cruel OS World!\n&quot;</span>, <span class="number">25</span>Goodbye, Cruel OS World!</span><br><span class="line">) = <span class="number">25</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ strace ./<span class="built_in">exit</span>-demo _exit</span><br><span class="line">execve(<span class="string">&quot;./exit-demo&quot;</span>, [<span class="string">&quot;./exit-demo&quot;</span>, <span class="string">&quot;_exit&quot;</span>], <span class="number">0x7ffd7e64a328</span> <span class="comment">/* 36 vars */</span>) = <span class="number">0</span></span><br><span class="line">arch_prctl(<span class="number">0x3001</span> <span class="comment">/* ARCH_??? */</span>, <span class="number">0x7ffd0457b610</span>) = <span class="number">-1</span> EINVAL (Invalid argument)</span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0xcb3000</span></span><br><span class="line">brk(<span class="number">0xcb41c0</span>)                           = <span class="number">0xcb41c0</span></span><br><span class="line">arch_prctl(ARCH_SET_FS, <span class="number">0xcb3880</span>)       = <span class="number">0</span></span><br><span class="line">uname(&#123;sysname=<span class="string">&quot;Linux&quot;</span>, nodename=<span class="string">&quot;DESKTOP-TVUERHD&quot;</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">readlink(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="string">&quot;/home/shc/Code/try/lock/jyy/exit&quot;</span>..., <span class="number">4096</span>) = <span class="number">37</span></span><br><span class="line">brk(<span class="number">0xcd51c0</span>)                           = <span class="number">0xcd51c0</span></span><br><span class="line">brk(<span class="number">0xcd6000</span>)                           = <span class="number">0xcd6000</span></span><br><span class="line">mprotect(<span class="number">0x4bd000</span>, <span class="number">12288</span>, PROT_READ)    = <span class="number">0</span></span><br><span class="line">exit_group(<span class="number">0</span>)                           = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ strace ./<span class="built_in">exit</span>-demo __exit</span><br><span class="line">execve(<span class="string">&quot;./exit-demo&quot;</span>, [<span class="string">&quot;./exit-demo&quot;</span>, <span class="string">&quot;__exit&quot;</span>], <span class="number">0x7ffcb7669508</span> <span class="comment">/* 36 vars */</span>) = <span class="number">0</span></span><br><span class="line">arch_prctl(<span class="number">0x3001</span> <span class="comment">/* ARCH_??? */</span>, <span class="number">0x7ffd2fb8ad30</span>) = <span class="number">-1</span> EINVAL (Invalid argument)</span><br><span class="line">brk(<span class="literal">NULL</span>)                               = <span class="number">0xf1b000</span></span><br><span class="line">brk(<span class="number">0xf1c1c0</span>)                           = <span class="number">0xf1c1c0</span></span><br><span class="line">arch_prctl(ARCH_SET_FS, <span class="number">0xf1b880</span>)       = <span class="number">0</span></span><br><span class="line">uname(&#123;sysname=<span class="string">&quot;Linux&quot;</span>, nodename=<span class="string">&quot;DESKTOP-TVUERHD&quot;</span>, ...&#125;) = <span class="number">0</span></span><br><span class="line">readlink(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="string">&quot;/home/shc/Code/try/lock/jyy/exit&quot;</span>..., <span class="number">4096</span>) = <span class="number">37</span></span><br><span class="line">brk(<span class="number">0xf3d1c0</span>)                           = <span class="number">0xf3d1c0</span></span><br><span class="line">brk(<span class="number">0xf3e000</span>)                           = <span class="number">0xf3e000</span></span><br><span class="line">mprotect(<span class="number">0x4bd000</span>, <span class="number">12288</span>, PROT_READ)    = <span class="number">0</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>)                                 = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br></pre></td></tr></table></figure>






<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><p>（1）<strong>请问main退出后的detached thread的行为 ?解答如下</strong></p>
</li>
<li><p><strong>关键在于 main 如何退出。</strong></p>
<ul>
<li>exit(0) / return 0 : 整个process被终止<ul>
<li>mutli-thread程序中，任意thread调用exit(0)(最后会到系统调用exit_group)，整个进程被终止，所有thread（包括detached thread）都被销毁。（进程的地址空间都没了，线程当然活不了）</li>
<li>main中调用return 0就相当于调用了exit(0)。</li>
</ul>
</li>
<li>pthread_exit : 只是终止当前main thread。<ul>
<li>只退出当前thread。（最后会调用到系统调用exit）</li>
<li>detached thread 仍运行</li>
</ul>
</li>
</ul>
</li>
<li><p>（2）编程时是否应该保证在main线程结束前join thread？或者说保证一个detached的thread在main exit之前就结束？</p>
<ul>
<li>解答：普通thread在main线程结束前，一定要join thread，保证业务执行的完整性（像C++，你没有设置子线程detach，也不join它，main函数运行完，还有子线程没执行完，它都给你直接报core dump了，你直接都能看出来）； detach thread不需要，一般detach thread设计的目的，就是在后台做一些非关键性任务，是否正常结束并没有要求，也不会出什么错误，如果要求任务的执行必须是完整的，不能设计成detach thread</li>
</ul>
</li>
</ul>
<p>atexit科普 : atexit (func)用来设置一个程序正常结束前调用的函数. 当程序通过调用exit ()或从main中return 时, func 会先被调用, 然后再结束程序.</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-并发06-bug-数据竞争</title>
    <url>/2022/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9106-bug-%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/</url>
    <content><![CDATA[<ul>
<li><p>并发bug 之 数据竞争 <strong>Data Race</strong></p>
<ul>
<li><strong>不同的线程同时访问同一段内存，且至少有一个是写</strong></li>
<li>为处理Data Race,我们需要一个互斥的协议，而peterson这种纯软的算法，太难了。故 我们应当使用(互斥)锁 消灭datarace</li>
</ul>
</li>
<li><p><strong>ThreadSanitizer原理</strong></p>
<ul>
<li><strong>不同线程对一块共享内存操作 且至少有一个是写。对这些动作的执行顺序进行排序，若检验出无法排序的（即排序结果不唯一），则error</strong></li>
</ul>
</li>
</ul>
<ul>
<li>学习自jyy</li>
</ul>
<span id="more"></span>

<h1 id="Data-Race"><a href="#Data-Race" class="headerlink" title="Data Race"></a>Data Race</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>起因：不上锁不就没有死锁了吗？</p>
</li>
<li><p>概念：<strong>不同的线程同时访问同一段内存，且至少有一个是写</strong>。</p>
</li>
<li><p>两个内存访问在 “赛跑”，“跑赢” 的操作先执行。</p>
<ul>
<li>因此我们不知道执行后的状态到底是什么，是否是我们想要的状态。</li>
</ul>
</li>
</ul>
<ul>
<li>如peterson-barrier.c: 内存访问都在赛跑<ul>
<li>对于peterson算法，我们回想，如何留下最少的 fence，依然保证算法正确？很难的。</li>
</ul>
</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul>
<li>Peterson 算法告诉大家：<ul>
<li>你们写不对无锁的并发程序</li>
<li>所以事情反而简单了</li>
</ul>
</li>
<li>解决：<ul>
<li><strong>用互斥锁保护好共享数据，消灭一切数据竞争</strong></li>
</ul>
</li>
<li>以下代码概括了你们遇到数据竞争的大部分情况<ul>
<li>bug 几乎都是这两种情况的变种<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Case #1: 上错了锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk1); sum++; spin_unlock(&amp;lk1); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk2); sum++; spin_unlock(&amp;lk2); &#125;</span><br><span class="line"><span class="comment">// Case #2: 忘记上锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123; spin_lock(&amp;lk1); sum++; spin_unlock(&amp;lk1); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123; sum++; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="其他类型的并发bug"><a href="#其他类型的并发bug" class="headerlink" title="其他类型的并发bug"></a>其他类型的并发bug</h1><ul>
<li><p>回顾我们实现并发控制的工具</p>
<ul>
<li>互斥锁 (lock/unlock) - 原子性</li>
<li>条件变量 (wait/signal) - 同步</li>
</ul>
</li>
<li><p>忘记上锁——原子性违反 (Atomicity Violation, AV)</p>
</li>
<li><p>忘记同步——顺序违反 (Order Violation, OV)</p>
</li>
<li><p>Empirical study: 在 105 个并发 bug 中 (non-deadlock/deadlock)</p>
<ul>
<li>MySQL (14/9), Apache (13/4), Mozilla (41/16), OpenOffice (6/2)</li>
<li>97% 的非死锁并发 bug 都是 AV 或 OV。</li>
</ul>
</li>
</ul>
<h2 id="原子性违反-AV"><a href="#原子性违反-AV" class="headerlink" title="原子性违反(AV)"></a>原子性违反(AV)</h2><ul>
<li>ABA<ul>
<li>我以为一段代码没啥事呢，但被人强势插入了<br><img src="/2022/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9106-bug-%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/2022-10-17-10-35-59.png"></li>
</ul>
</li>
</ul>
<h2 id="顺序违反-OV"><a href="#顺序违反-OV" class="headerlink" title="顺序违反 (OV)"></a>顺序违反 (OV)</h2><ul>
<li>BA<ul>
<li>怎么就没按我预想的顺序来呢？<ul>
<li>例子： concurrent use after free<br><img src="/2022/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9106-bug-%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/2022-10-17-10-37-23.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="bug排查"><a href="#bug排查" class="headerlink" title="bug排查"></a>bug排查</h1><h2 id="Lockdep-运行时死锁检查"><a href="#Lockdep-运行时死锁检查" class="headerlink" title="Lockdep 运行时死锁检查"></a>Lockdep 运行时死锁检查</h2><p><img src="/2022/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9106-bug-%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/2022-10-17-12-47-55.png"></p>
<h2 id="ThreadSanitizer-运行时的数据竞争检查"><a href="#ThreadSanitizer-运行时的数据竞争检查" class="headerlink" title="ThreadSanitizer: 运行时的数据竞争检查"></a>ThreadSanitizer: 运行时的数据竞争检查</h2><ul>
<li>检验dataRace ; 为所有事件建立 happens-before 关系图<ul>
<li>对于发生在不同线程且至少有一个是写的 x,y检查</li>
<li><strong>会有不能排队的事件 检验出来</strong><br><img src="/2022/10/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9106-bug-%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89/2022-10-17-12-09-05.png"></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>网络_socket流程</title>
    <url>/2022/09/01/%E7%BD%91%E7%BB%9C_socket%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/2022/09/01/%E7%BD%91%E7%BB%9C_socket%E6%B5%81%E7%A8%8B/2022-09-25-16-37-53.png"></p>
<p>只记录API关键信息方便快速回忆。API的具体信息还请man。以前初学的时候记录的信息太冗杂了。现在看也不方便看，这回力求精简，痛苦的重写一遍概要。</p>
<span id="more"></span>

<h1 id="socket-API"><a href="#socket-API" class="headerlink" title="socket API"></a>socket API</h1><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><ul>
<li>最基本API使用流程  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1. create socket</span></span><br><span class="line"><span class="keyword">int</span> lfd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//  2. bind socket with addr</span></span><br><span class="line">    <span class="comment">//  之前要先将protocol、ip、port以网络字节序存储入server_addr</span></span><br><span class="line"><span class="built_in">bind</span>(lfd,(sockaddr*)&amp;server_addr,<span class="keyword">sizeof</span> server_addr);</span><br><span class="line"><span class="comment">//  3. listen</span></span><br><span class="line"><span class="built_in">listen</span>(lfd,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//  4. accept</span></span><br><span class="line"><span class="keyword">int</span> connfd = <span class="built_in">accept</span>(fd,(sockaddr*)&amp;cliet_addr,&amp;len);</span><br><span class="line"><span class="comment">//  5. read/write</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">read</span>(fd,buf,BUFFER_SIZE<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//  6. close</span></span><br><span class="line"><span class="built_in">close</span>(fd);</span><br></pre></td></tr></table></figure>
<h3 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h3></li>
<li>sockaddr_in :   <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    sa_family sin_family;       <span class="comment">//  protocol   :AF_INET</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;         <span class="comment">//  port       :网络字节序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">//  ip         :IPv4结构体</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> s_addr;           <span class="comment">//  ip address : 网络字节序 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将 port(short) 和 ip(点分十进制字符串) 以网络字节序保存，供给socket使用。<ul>
<li>程序员看到的 port 是 : 本地字节序 &amp;&amp; short。看到的ip是 本地字节序 &amp;&amp; 点分十进制字符串。</li>
<li>将他们以网络字节序存入sockaddr_in<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  将protocol、ip、port以网络字节序存储入server_addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr,<span class="number">0</span>,<span class="keyword">sizeof</span> server_addr);</span><br><span class="line">    server_addr.sin_family = AF_INET;                   <span class="comment">//  protocol    network</span></span><br><span class="line">    inet_pton(AF_INET,ip,&amp;server_addr.sin_addr.s_addr); <span class="comment">//  ip          str-&gt;network</span></span><br><span class="line">    server_addr.sin_port = htons(port);                 <span class="comment">//  port        network   </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><ul>
<li>原型<ul>
<li>int socket(int domain,int type,int protocol);</li>
<li>return fd;</li>
</ul>
</li>
<li>使用<ul>
<li>int listening_fd = socket(PF_INET,SOCK_STREAM,0);</li>
</ul>
</li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul>
<li>原型：<ul>
<li>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</li>
<li>将socket地址addr结构体，绑定给sockfd。</li>
</ul>
</li>
<li>使用：<ul>
<li>bind(listening_fd,(sockaddr*)&amp;server_addr,sizeof server_addr);</li>
</ul>
</li>
</ul>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><ul>
<li><p>原型</p>
<ul>
<li>int listen(int sockfd, int backlog);</li>
<li>创建监听队列以存放待处理客户连接</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>listen(listening_fd,5);</li>
</ul>
</li>
<li><p>在listen之后listening_fd即变为监听socket，可以接受连接/epoll了。</p>
</li>
</ul>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><ul>
<li>原型<ul>
<li>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</li>
<li>success : return connection fd;</li>
<li>fail    : return -1 and set errno</li>
</ul>
</li>
<li>使用<ul>
<li>int connfd = accept(lfd,(sockaddr*)&amp;cliet_addr,&amp;cliet_len);</li>
<li>accept之后即可对connfd进行读写操作</li>
<li>即便client建立连接之后又断开网络或者退出程序，server也可连接<ul>
<li>accept只是从监听队列中取出连接，而不论连接处于何种状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><ul>
<li><p>client socketAPI流程</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1.  创建socket</span></span><br><span class="line"><span class="keyword">int</span> client_conn_fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//  2.  发起连接 </span></span><br><span class="line">    <span class="comment">//  之前要将要连接的server的protocol、ip、port以网络字节序存储入server_addr</span></span><br><span class="line"><span class="built_in">connect</span>(client_conn_fd, (sockaddr *)&amp;server_address, <span class="keyword">sizeof</span> server_address);</span><br><span class="line"><span class="comment">//  3.   read/write</span></span><br><span class="line"><span class="built_in">send</span>(client_conn_fd, request.<span class="built_in">c_str</span>(), request.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="comment">//  4.   close</span></span><br><span class="line"><span class="built_in">close</span>(client_conn_fd);</span><br></pre></td></tr></table></figure>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3></li>
<li><p>原型</p>
<ul>
<li>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</li>
<li>success : return 0</li>
<li>fail : return -1 and set errno</li>
</ul>
</li>
<li><p>使用</p>
<ul>
<li>connect(client_fd, (sockaddr *)&amp;server_address, sizeof server_address);</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-Socket及Lab总结</title>
    <url>/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/</url>
    <content><![CDATA[<ul>
<li>CS144lab1-7 自顶向下 实现了HTTP(GET) , TCP , IP(util) ,ARP(NetworkInterface) , Ethernet(util)(NetworkInterface use) , 最后在用户态组成了一个可靠数据传输的socket<ul>
<li>FullStackSocket概述<ul>
<li>2 thread (main thread , tcp thread)</li>
<li>3 fd(user socket , 内置的_thread_data(与协议栈交互) , tap fd)</li>
<li>eventloop注册事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li>看完FullStackSocket之后 重新体会到socket是站在用户层和传输层之间的这句话了</li>
<li>FullStackSocket通过一个socketpair 将user看到的Socket和实际与协议栈交互的Socket(_thread_data)分开. main thread 使用 _socket , tcp_thread使用_thread_data</li>
<li>user只需要站在user层拿着_socket就好 等待数据到来 , 交付数据即可。背后协议栈的处理以及网卡数据的读写以及_thread_data交付数据都不需要管,都由tcp_thread的eventloop负责监听和处理了。user甚至可以认为 他就是直接通过这个_socket去和外界交互的.</li>
</ul>
<h1 id="FullStackSocket"><a href="#FullStackSocket" class="headerlink" title="FullStackSocket"></a>FullStackSocket</h1><ul>
<li>镇楼<br><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-33-37.png"><br>outbound buffer和inbound buffer就是俩bytestream</li>
</ul>
<h2 id="3Fd"><a href="#3Fd" class="headerlink" title="3Fd"></a>3Fd</h2><ul>
<li>FullStackSocket中总共有<strong>3</strong>个Fd<ul>
<li><strong>_socket fd</strong> : user see . (main thread)<ul>
<li>user认为就是这个fd和internet交互，实际上是在和_thread_data进行交互 , 最终和internet交互的是网卡TAP fd</li>
</ul>
</li>
<li><strong>_thread_data fd</strong> : 和_socket交互 (TCP thread)</li>
<li><strong>TAP fd</strong> : 和外界交互,接收发送frame (TCP thread)</li>
</ul>
</li>
</ul>
<h3 id="pipe-socketpair"><a href="#pipe-socketpair" class="headerlink" title="pipe(socketpair)"></a>pipe(socketpair)</h3><ul>
<li><p><strong>_socket和_thread_data是socketpair. 通过pipe通信</strong></p>
<ul>
<li>tcp_thread对_thread_data进行操作 </li>
<li>main thread 对_socket进行操作. </li>
<li>避免了对同一socket复杂的线程通信操作.</li>
<li>感觉这就是所谓的”通过通信共享内存，而不是通过共享内存通信.”; </li>
<li>通过pipe , tcp_thread和main_thread“共享”(通信）了user要发送和下层读取到的data</li>
</ul>
</li>
<li><p><strong>main thread对_socket的操作</strong></p>
<ul>
<li>main thread对_socket进行write , 将data送入pipe之后即可返回</li>
<li>main thread对_socket进行read(block) , 从pipe中读到数据后即可返回</li>
</ul>
</li>
<li><p><strong>tcp thread对_thread_data的操作</strong></p>
<ul>
<li>TCP thread负责监听_thread_data读事件，并读出_thread_data数据并送入TCP/IP协议栈处理</li>
<li>TCP thread负责监听_thread_data写事件，并将data从_thread_data写入,送给pipe的另一端_socket</li>
</ul>
</li>
</ul>
<h3 id="TAP-Fd"><a href="#TAP-Fd" class="headerlink" title="TAP Fd"></a>TAP Fd</h3><ul>
<li>除此之外，<strong>tcp thread还需要对TAP Fd进行操作</strong><ul>
<li>监听TAP Fd写事件,并处理</li>
<li>监听TAP Fd读事件,并处理</li>
</ul>
</li>
<li>TAP device接收上层构造好的链路层帧(link-layer frames)并直接发送出去</li>
</ul>
<h2 id="2-thread"><a href="#2-thread" class="headerlink" title="2 thread"></a>2 thread</h2><ul>
<li>FullStackSocket中总共有2个thread<ul>
<li><strong>main thread</strong> (user)<ul>
<li>main thread对_socket进行write , 将data送入pipe之后即可返回</li>
<li>main thread对_socket进行read(block) , 从pipe中读到数据后即可返回</li>
</ul>
</li>
<li><strong>TCP thread</strong><ul>
<li><strong>一言以蔽之</strong>：<ul>
<li>负责 和上层main thread的_socket交互.</li>
<li>TCP/IP协议栈处理数据  </li>
<li>以及读写网卡  </li>
</ul>
</li>
<li>有个很重要的组件 : <strong>eventloop</strong>. 下文介绍.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="eventloop-tcp-thread"><a href="#eventloop-tcp-thread" class="headerlink" title="eventloop (tcp thread)"></a>eventloop (tcp thread)</h3><p><strong>eventloop</strong></p>
<ul>
<li><p>好像到处都有eventloop哈，libsponge有，muduo有，redis有。是个reactor就有。</p>
</li>
<li><p>大概来说如下</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">    poll();</span><br><span class="line">    handleEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不过只能说类似,因为我们没有listenfd.只有connfd<blockquote>
<p><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-07-47.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>eventloop监听事件如下</p>
<ul>
<li><strong>EventA</strong> : adapter的读事件. 即TAP Fd 接收到frame<ul>
<li>Handler : network interface 读取frame并交付给上层协议栈</li>
<li>注册条件 : 只有local tcp存活时 才监听并处理该事件</li>
</ul>
</li>
<li><strong>EventB</strong> : _thread_data的读事件. 即_thread_data接收到了_socket写入pipe的数据<ul>
<li>Handler : tcp sender 读取_thread_data的数据并发送</li>
<li>注册条件 : 在local tcp存活 &amp;&amp; 写不关闭 &amp;&amp; local tcp outbound_buffer仍有空闲空间时 可监听并处理此事件</li>
</ul>
</li>
<li><strong>EventC</strong> : _thread_data的写事件.<ul>
<li>Handler : _thread_data从inbound buffer中读出数据，写入pipe</li>
<li>注册条件 : tcp inbound buffer有数据可读出写入_thread_data</li>
</ul>
</li>
<li><strong>EventD</strong> : TAP Fd可写. <ul>
<li>Handler : datagram adapter读取TCPsender发送的segment。层层封装成frame 写给TAP Fd</li>
<li>注册条件 : tcp outbound buffer有数据可读出送入协议栈</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="关于写事件的注册"><a href="#关于写事件的注册" class="headerlink" title="关于写事件的注册"></a>关于写事件的注册</h4><ul>
<li><p>背景: 如何正确的在epoll/poll LT模式下正确的执行写操作.</p>
<ul>
<li>易知poll为水平触发 , 在LT模式下如果注册了某fd的写事件到epoll上，那么只要fd背后的pipe亦或者kernel buffer没被填满，就会触发该事件,基本上一定会陷入死循环（busy wait)(loop刚刚回到poll就再次触发事件)。</li>
</ul>
</li>
<li><p>如何正确执行写操作 -&gt; 如何正确的在poll上注册写事件,使得写事件可以在有数据写的时候发生,没有的时候就不发生？而不会频繁的触发写事件陷入busy wait ?</p>
<ul>
<li>解决方案很简单如下：<ul>
<li><strong>设置一个 注册写事件的先决条件</strong>(code中的interest).</li>
<li>如先决条件为有数据可写,那么如下 </li>
<li>也即 只有在<strong>有数据时才注册写事件</strong>到poll</li>
<li>并且 在<strong>不满足该条件时，就立刻将该写事件从poll上拿下来</strong>.</li>
</ul>
</li>
<li>如<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Event C interest</span><br><span class="line">    <span class="comment">//  interest : 如果tcp的outbound buffer有数据要可发 才注册 ; 不符合该条件时立刻移除</span></span><br><span class="line">    [&amp;] &#123; <span class="keyword">return</span> <span class="keyword">not</span> _tcp-&gt;segments_out().empty(); &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Event D interest</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">    <span class="comment">//  tcp的inbound buffer不空(有数据可交付给上层app) || tcp的inbound buffer读到eof亦或者出错error (那就可以返回给上层eof或是error) </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">not</span> _tcp-&gt;inbound_stream().buffer_empty()) <span class="keyword">or</span></span><br><span class="line">            ((_tcp-&gt;inbound_stream().eof() <span class="keyword">or</span> _tcp-&gt;inbound_stream().error()) <span class="keyword">and</span> <span class="keyword">not</span> _inbound_shutdown);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="之前的一些问题"><a href="#之前的一些问题" class="headerlink" title="之前的一些问题"></a>之前的一些问题</h2><ul>
<li><p>使用</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  des addr :  ip and port</span></span><br><span class="line"><span class="function">Address <span class="title">addr</span><span class="params">(host,<span class="string">&quot;http&quot;</span>)</span></span>;    <span class="comment">//  getaddrinfo : host -&gt; ip ; http -&gt; port </span></span><br><span class="line"><span class="comment">//  connect</span></span><br><span class="line">FullStackSocket tcp_socket;</span><br><span class="line">tcp_socket.connect(addr);   </span><br><span class="line"><span class="comment">//  send req</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\n&quot;</span> + <span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;\r\n&quot;</span> + <span class="string">&quot;Connection: close\r\n&quot;</span> + <span class="string">&quot;\r\n&quot;</span>)</span></span>;</span><br><span class="line">tcp_socket.write(request);</span><br><span class="line"><span class="keyword">while</span>(!tcp_socket.eof())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;tcp_socket.read();</span><br><span class="line">&#125;</span><br><span class="line">tcp_socket.wait_until_closed();</span><br></pre></td></tr></table></figure></li>
<li><p>wait_until_closed()</p>
<ul>
<li>此时peer已经停止写(receiver 接收fin)</li>
<li>于是我们 _socket 关闭读写, 致使 _thread_data关闭读 , 通过之前注册的回调 , 致使tcpconnection关闭写 , 于是local tcp sender发送fin给peer. 完成四次挥手. clean shutdown<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="keyword">void</span> TCPSpongeSocket&lt;AdaptT&gt;::wait_until_closed() &#123;</span><br><span class="line">    <span class="comment">//  关闭user看到的_socketfd的读写   </span></span><br><span class="line">    shutdown(SHUT_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (_tcp_thread.joinable()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;DEBUG: Waiting for clean shutdown... &quot;</span>;    <span class="comment">//  </span></span><br><span class="line">        _tcp_thread.join();     <span class="comment">//  等待tcp thread结束</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;done.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><ul>
<li>port是传输层的，可是我们没在lab4的tcpconnection中填充，他在什么时候填充的 ?<ul>
<li>tcpConnection 填充了 seq num , ack num , window , data , ack , rst , syn , fin. urg和psh没用到</li>
<li>tcpsegment自己计算了dataoffset , checksum</li>
<li><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-11-03-04.png"></li>
<li>在wrap_tcp_in_ip中填充的<br><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-38-22.png"></li>
</ul>
</li>
</ul>
<ul>
<li><p>本地IP和本地Port在什么时候告知Socket？: connect时随机生成port ; peer的IP和Port呢？: user传入. 见connect.<br>  <img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-43-58.png"></p>
</li>
<li><p>port在什么时候起到作用 ? 怎么用于区分segment是不是给我们的socket的？<br>  <img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-47-59.png"></p>
</li>
</ul>
<ul>
<li>tcp协议的端口只是逻辑上的端口，并没有实际物理意义，没有对应设备 只是个逻辑上的 用于区分socket罢了. 其范围0到65535是受报文中给port的空间限制的 .<ul>
<li>在网络技术中，端口(Port)大致有两种意思：一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用于连接其他网络设备的接口，如RJ-45端口、SC端口等等；二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</li>
</ul>
</li>
</ul>
<h3 id="关于IP分片"><a href="#关于IP分片" class="headerlink" title="关于IP分片"></a>关于IP分片</h3><p><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-27-13-18-56.png"></p>
<ul>
<li>可以看到 util以及libsonge中并没有IP分片的代码. 为什么 ?<ul>
<li>因为我们只实现了TCP/IP协议栈. 并没有实现UDP/IP . </li>
<li>UDP才会在IP分片，TCP不会在IP分片. 原因如下</li>
</ul>
</li>
<li><strong>TCP</strong>会进行<strong>分段</strong>,临界为称为(Max Segment Size). <strong>MSS</strong><ul>
<li>放入TCP Segment的最大应用层报文段大小.</li>
<li>MSS的大小一般都是参考了MTU. 如MTU = 1500bytes , 则 MSS = 1500 - IP Header - TCP Header = 1460 Bytes</li>
</ul>
</li>
<li><strong>IP</strong>层<strong>分片</strong>的临界是(Max Transimssion Unit)<strong>MTU</strong>. <ul>
<li>MTU是由数据链路层决定的. 如Ethernet II的MTU就是1500 bytes</li>
<li>MTU = IP Header + TCP Header + MSS</li>
</ul>
</li>
<li>易知一个IP datagram里面封装一个 TCP Segment. 又由于 MSS &lt; MTU , 故<strong>TCP分段避免了IP分片</strong>.</li>
<li>TCP MSS目的 : 为了让IP层少分包或是不分包 ,因为<strong>IP分片丢失会导致TCP重传所有分片组成的那个Segment.</strong></li>
<li>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。<ul>
<li>当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」(该TCPSegment大于MTU)。</li>
<li>因此，IP 层进行分片，如果丢失某个分片，则重传效率很低</li>
</ul>
</li>
</ul>
<h3 id="listening-fd"><a href="#listening-fd" class="headerlink" title="listening fd"></a>listening fd</h3><ul>
<li>与kernel实现不同. Kernel里面，对于server，会有一个listening socket（与peer进行三次握手建立连接)。然后为到来的建立连接请求创建connection socket. 去和client的connfd进行通信.</li>
<li>libsponge的实现没有listening socket,仅仅就是一个connection socket。这个connection去和client的connfd进行三次握手、通信以及四次挥手.</li>
</ul>
<h2 id="PS-eventloop相关code"><a href="#PS-eventloop相关code" class="headerlink" title="PS :  eventloop相关code"></a>PS :  eventloop相关code</h2><ul>
<li>tcp_spong_socket.cc</li>
</ul>
<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul>
<li>通过CS144 lab0-7 <ul>
<li>掌握了如何实现基本的TCP协议(TCPSender TCPReceiver) , 更加理解了TCP协议是如何应对 对于两军问题导致的双方难以达成clean shutdown的情况 , 并对TCP/IP协议栈(TCP IP ARP Ethernet)以及路由(Router)有了更深刻的理解.</li>
<li>学会了c++14的一些新特性,如optional , string_view </li>
<li>学习FullStackSocket的设计 : 事件交给worker thread的eventloop来做 , user 在另一个thread等待 , 二者通过pipe传输.</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab0</title>
    <url>/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/</url>
    <content><![CDATA[<p>实现流量有限的bytestream,支持读写.<br>是TCPSender和TCPReceiver与用户层的接口.<br>app通过bytestream向下TCPSender写入<br>TCPReceiver通过bytestream向上app交付数据</p>
<span id="more"></span>

<h2 id="part0"><a href="#part0" class="headerlink" title="part0"></a>part0</h2><ul>
<li>telnet : a client program that makes outgoing connections<br>to programs running on other computers</li>
<li>telnet cs144.keithw.org http<ul>
<li>打开 本主机和主机cs144.keithw.org之间的 可靠字节流（即建立一条TCP连接）</li>
<li>且 双方采用的 应用层协议为 HTTP协议</li>
</ul>
</li>
<li>telnet之后<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GET /hello HTTP/<span class="number">1.1</span>     # 告知server the path part of the url</span><br><span class="line">Host: cs144.keithw.org  # 告诉server the host part of the url</span><br><span class="line">Connection: close       # 告知server我已经描述完自己的请求，且 server应当立刻关闭这条tcp连接当响应了用户的请求</span><br><span class="line">empty line 回车         # 告知server我已完成HTTP请求</span><br><span class="line">接下来等待server响应即可</span><br></pre></td></tr></table></figure></li>
<li><blockquote>
<p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-25-17-02-52.png"></p>
</blockquote>
</li>
<li>Assignment<blockquote>
<p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-25-15-39-04.png"></p>
</blockquote>
</li>
</ul>
<h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><ul>
<li>netcat : 建立一个server</li>
<li>netcat -v -l -p 9090：创建一个可提供telnet服务的tcpserver<br><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-25-16-30-11.png">  </li>
</ul>
<h2 id="webget"><a href="#webget" class="headerlink" title="webget"></a>webget</h2><ul>
<li><p>get_URL</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_URL</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;host, <span class="keyword">const</span> <span class="built_in">string</span> &amp;path)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//  get ip and port</span></span><br><span class="line">  <span class="function">Address <span class="title">addr</span><span class="params">(host,<span class="string">&quot;http&quot;</span>)</span></span>;    <span class="comment">//  getaddrinfo : host -&gt; ip ; http -&gt; port </span></span><br><span class="line">  <span class="comment">//  connect</span></span><br><span class="line">  TCPSocket tcp_socket;</span><br><span class="line">  tcp_socket.connect(addr);   </span><br><span class="line">  <span class="comment">//  send req</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\n&quot;</span> + <span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;\r\n&quot;</span> + <span class="string">&quot;Connection: close\r\n&quot;</span> + <span class="string">&quot;\r\n&quot;</span>)</span></span>;</span><br><span class="line">  tcp_socket.write(request);</span><br><span class="line">  <span class="keyword">while</span>(!tcp_socket.eof())</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;tcp_socket.read();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>class Address如何解析出要连接的ip和port</p>
<ul>
<li>核心API : getaddrinfo</li>
<li>解析hostname 如 cs144.keithw.org 获取IP</li>
<li>解析servicename 如 /hello 获取port (/etc/service中记录了servicename和port之间的对应关系)</li>
</ul>
</li>
<li><p>getaddrinfo</p>
<ul>
<li>通过主机名获取ip：gethostbyname</li>
<li>通过服务名获取port：getservbyname</li>
<li><blockquote>
<p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-29-16-39-01.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>getaddrinfo</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *node, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">const</span> struct addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">                 struct addrinfo **res)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *res)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">         <span class="keyword">int</span>              ai_flags;</span><br><span class="line">         <span class="keyword">int</span>              ai_family;</span><br><span class="line">         <span class="keyword">int</span>              ai_socktype;</span><br><span class="line">         <span class="keyword">int</span>              ai_protocol;</span><br><span class="line">         <span class="keyword">socklen_t</span>        ai_addrlen;</span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span>    <span class="comment">//  (关键) 即 IP地址</span></span><br><span class="line">         <span class="keyword">char</span>            *ai_canonname;</span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">关于hints参数，可以设置其ai_flags,ai_family,ai-socktype,ai_protocol。其余字段须设置为<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-29-16-46-59.png"><br><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-29-16-47-19.png"></p>
</li>
</ul>
<h2 id="ByteStream"><a href="#ByteStream" class="headerlink" title="ByteStream"></a>ByteStream</h2><p>一言以蔽之: 实现一个容量有限的管道 , 一端为读端一端为写端</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>An in-memory reliable byte stream : 在内存中的可靠字节流<ul>
<li>就是实现个管道pipe，且无需考虑多线程</li>
</ul>
</li>
<li>该字节流特性如下<ul>
<li>The byte stream is finite: (the writer can end the input, and then no more bytes can be written).  but it can be almost arbitrarily long before the writer ends the input and finishes the stream. <ul>
<li>有限：写者可以关闭写端，关闭写端后，就不能再向管道中写入字节了。</li>
</ul>
</li>
<li><strong>EOF：写端已经关闭，且管道中没有未弹出的字节</strong>。（这就是所谓的，读到末尾了，即 <strong>reach the end of the stream</strong>）<ul>
<li>When the reader has read to the end of the stream, it will reach “EOF” (end of file) and no more bytes can be read</li>
</ul>
</li>
<li><strong>Flow Control</strong><ul>
<li>tcp通过该bytestream向上层app传输字节. 故该bytestream需要具有的flow control流量控制功能：确保发送端不在接收端缓冲区（这里就是stream）已满的情况下发送数据。</li>
<li>设定stream的capacity：stream在任意时刻最多有capacity个字节，当字节数量达到capacity时，写端不可继续写入；需要等待读端将字节从stream中读出。读出后写端即可继续写入。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我所做的工作如下</p>
<ul>
<li><p>bytestream功能如图<br><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-29-15-07-06.png"></p>
</li>
<li><p>由于需要使用迭代器，且需要快速的pop_front。则<strong>byte stream底层数据结构：deque</strong><br><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-29-16-07-24.png"><br>主要接口如下</p>
</li>
<li><p>size_t write(const std::string &amp;data);</p>
<ul>
<li>写data，写入顺序data[0][1][2]… 。Write a string of bytes into the stream. Write as many as will fit, and return the number of bytes written.<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_to_write = min(data.size(), _capacity - _stream.size());   <span class="comment">//  最多写多少bytes</span></span><br><span class="line">    _bytes_pushed += bytes_to_write;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; bytes_to_write; ++i) &#123;</span><br><span class="line">        _stream.push_back(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes_to_write;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>std::string peek_output(const size_t len) const</p>
<ul>
<li>读取len bytes，但不弹出。bytes will be copied from the output side of the buffer<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ByteStream::peek_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    assert(_stream.size() &lt;= _capacity);</span><br><span class="line">    <span class="keyword">size_t</span> bytes_to_read = min(len, _stream.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(_stream.begin(),_stream.begin()+bytes_to_read);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>void pop_output(const size_t len);</p>
<ul>
<li>从读端弹出len bytes。len bytes will be removed from the output side of the buffer<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    assert(_stream.size() &lt;= _capacity);</span><br><span class="line">    <span class="keyword">size_t</span> bytes_to_pop = min(len, _stream.size());  <span class="comment">//  最多全部弹出</span></span><br><span class="line">    _bytes_popped += bytes_to_pop;</span><br><span class="line">    <span class="keyword">while</span> (bytes_to_pop--) &#123;</span><br><span class="line">        _stream.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>eof</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _end &amp;&amp; _stream.empty(); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>pass<br><img src="/2022/12/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab0/2022-12-29-11-51-11.png"></li>
</ul>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab2</title>
    <url>/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/</url>
    <content><![CDATA[<p><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-16-17-59.png"></p>
<p>一言以蔽之</p>
<ul>
<li><p>lab2实现的tcp receiver</p>
<ul>
<li>（0） 转换stream_idx ，abs_seq ，seq（属于内部功能)  </li>
<li>（1） 利用 StreamReassembler对 接收到的segment进行重组 并压入bytestream</li>
<li>（2） 填充receive_window的相关信息：ackno , window_size， 从而实现flow-control流量控制</li>
<li>（3） 根据 接收到的报文 对tcp receiver进行状态划分. listen syn_recv fin_recv</li>
</ul>
</li>
<li><p>我们的receiver只实现了234</p>
<ul>
<li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-02-27-22-58-04.png"></li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="背景-amp-Receiver功能-amp-分析"><a href="#背景-amp-Receiver功能-amp-分析" class="headerlink" title="背景 &amp; Receiver功能 &amp; 分析"></a>背景 &amp; Receiver功能 &amp; 分析</h2><p><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-16-17-59.png"></p>
<ul>
<li><p>lab0实现了ByteStream，lab1实现了StreamReassembler，lab2要求我们实现TCPReceiver</p>
</li>
<li><p>TCP是一个在不可靠数据报之上 可靠地传输 可控制的字节流。TCP连接有两方参与，每一方都同时扮演着sender和receiver的角色。这两方被称为TCP连接的端点endpoint或者对等方peers</p>
</li>
<li><p><strong>TCP receiver</strong></p>
<ul>
<li><strong>(1) 接收对端发来的segment</strong></li>
<li><strong>(2) 使用我们之前实现的StreamReassembler将segment重组进ByteStream</strong></li>
<li><strong>(3) 计算出receive_window的相关信息：ackno以及receive_window size</strong>. 随output segment被传输给对端<ul>
<li><strong>receive_window</strong>：<ul>
<li>含义：receiver感兴趣的、愿意接受的字节的下标范围，也是允许 tcp sender 发送的字节范围。</li>
<li>作用：tcp receiver使用该receive window，可以进行流量控制，使得sender限制自己的发送量，直到receiver可以接收更多data。（Using the window, the receiver can control the flow of incoming data, making the sender limit how much it sends until the receiver is ready for more.）</li>
<li><strong>ackno</strong> : 即tcp header中的acknowledgement number字段。<ul>
<li>即 lab1中所实现的receive_window [first_unassembled,first_unacceptable)的左边界</li>
<li>即 ackno = first_unassembled</li>
<li>含义如下<ul>
<li>receiver期望从另一方收到的下一个字节的序号，（接收该字节可以使得receiver重组更多的字节流）</li>
<li><strong>累计确认</strong></li>
<li>ack number：已经收到了[begin,ack-1]的所有bytes，期待收到的下一个byte是ack 。 即期待收到的下一个TCP报文段的body的起始字节的序号是ack</li>
</ul>
</li>
</ul>
</li>
<li><strong>window_size</strong> : 即TCP Header中的window size字段 <ul>
<li>即lab1中所实现的receiving_window的大小</li>
<li>receive_window size + stream size = capacity</li>
<li>receive_window size = first_unacceptable - first_unassembled</li>
<li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-16-36-11.png"></li>
</ul>
</li>
<li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-18-54-16.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么要实现这些？</p>
<ul>
<li>这些信号对实现TCP的功能至关重要，为了TCP能够在不可靠的数据报网络之上提供流量控制、可靠的字节流。</li>
<li>TCP中，<strong>ack</strong>意味着，接收方所期待的下一个字节，使其能够重组更多的bytestream。它告诉sender应该发送什么字节</li>
<li><strong>Flow Control</strong>流量控制意味着 receiver感兴趣的、愿意接受的字节的下标范围。这告知了sender其被允许发送多少字节。</li>
</ul>
</li>
</ul>
<h2 id="index-关系"><a href="#index-关系" class="headerlink" title="index 关系"></a>index 关系</h2><p><strong>seqno , absolute seqno , stream idx</strong></p>
<ul>
<li><p>A 64-bit index is big enough that we can treat it as never overflowing.</p>
<ul>
<li>Transmitting at 100 gigabits/sec, it would take almost 50 years to reach 2^64 bytes. By contrast, it takes only a third of a second to reach 2^32 bytes</li>
</ul>
</li>
<li><p><strong>seqno</strong></p>
<ul>
<li>32bits , wrapping<ul>
<li>tcp 的 stream 可以任意长</li>
</ul>
</li>
<li>start from isn(Initial Sequence Number)<ul>
<li>TCP sequence numbers start at a random value.</li>
<li>To improve security and avoid getting confused by old segments belonging to earlier connections between the same endpoints, TCP tries to make sure sequence numbers can’t be guessed and are unlikely to repeat. So the sequence numbers for a stream don’t start at zero.</li>
</ul>
</li>
<li>Include SYN/FIN<ul>
<li>The logical beginning and ending each occupy one sequence number</li>
<li>SYN报文 代表 beginning of the stream , 占据ISN seq，</li>
<li>FIN报文 代表 end of the stream , 占据最后一个seq</li>
<li>SYN和FIN之间的每个byte都占据一个seq</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>absolute seq</strong> : </p>
<ul>
<li>不考虑(isn)initial seq num，即seq - isn。(即start at 0)</li>
<li>64bit , non-wrapping。</li>
<li>包含SYN/FIN。</li>
</ul>
</li>
<li><p><strong>stream idx</strong> : </p>
<ul>
<li>StreamReassembler中，stream中每个字节的idx。</li>
<li>start at 0</li>
<li>64bit , non-wrapping。</li>
<li>不包含SYN/FIN</li>
</ul>
</li>
<li><p><strong>seqno , absolute seqno , stream idx之间的关系 关键图</strong><br><strong><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-11-51-52.png"></strong><br><strong><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-18-46-55.png"></strong></p>
</li>
<li><p>转换：stream_idx &lt;-&gt; abs_seq &lt;-&gt; seq</p>
</li>
<li><p>易知stream_idx和abs_seq之间的转换</p>
<ul>
<li>assert(absolute seq &gt; 0) : stream_idx = absolute seq - 1 </li>
</ul>
</li>
<li><p>abs_seq和seq之间的转换见下。</p>
</li>
</ul>
<h3 id="WrappingInt32-seq-lt-gt-abs-seq"><a href="#WrappingInt32-seq-lt-gt-abs-seq" class="headerlink" title="WrappingInt32 seq &lt;-&gt; abs_seq"></a>WrappingInt32 seq &lt;-&gt; abs_seq</h3><ul>
<li><p>WrappingInt32 </p>
<ul>
<li>实现absolute sequence number和sequence nunmber的转换</li>
</ul>
</li>
<li><p>absolute sequence number -&gt; sequence number</p>
<ul>
<li>WrappingInt32 wrap(uint64_t abs_seq, WrappingInt32 isn)</li>
<li>abs_seq : seq = (abs_seq + isn) % 2^32<ul>
<li><code>[63,32][31,0]</code>,舍去<code>[63,32]</code>，转化成seq只需要其低32bit加上isn即可。</li>
<li>因为seq的域是<code>[0,2^32-1]</code>，abs_seq每增加<code>2^32</code>，其对应的seq就回到起点的isn</li>
<li><code>对于任意isn，abs_seq : 0 / 2^32 / k * 2^32 + x  ---&gt;  seq : isn + x</code></li>
<li><code>如 abs_seq = 2^32 + 3 ---&gt; seq = isn + 3 = 1 ，当isn = 2^32-2时，seq = 1</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="keyword">uint64_t</span> abs_seq, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isn + <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(abs_seq);  </span><br><span class="line">    <span class="comment">//  该加法（底层就是uint32位加法)会自动对2^32取模  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>sequence number -&gt; absolute sequence number</p>
<ul>
<li>uint64_t unwrap(WrappingInt32 seq, WrappingInt32 isn, uint64_t checkpoint)<ul>
<li>Given a sequence number (n), the Initial Sequence Number (isn), and an absolute checkpoint sequence number, compute the absolute sequence number that corresponds to n that is closest to the checkpoint</li>
<li>closet : 没有向上取最接近还是向下取最接近之分，无论上下，只要求最接近即可。</li>
</ul>
</li>
<li>易知对于任意seq，其在<code>[0,2^64-1]</code>的每个2^32大小的域上，都有一个abs_seq_num，wrap函数的目标就是返回其中最接近checkpoint的abs_seq_num</li>
<li>思路：<ul>
<li><ol>
<li>先求出abs no 在域<code>[0,2^32-1]</code>上的值为abs_base，易知目标abs_seq_num = abs_base + k * 2^32。</li>
</ol>
<ul>
<li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-13-11-45.png"></li>
</ul>
</li>
<li><ol start="2">
<li>求出最接近的abs_seq_num ? </li>
</ol>
<ul>
<li>找到abs_base和checkpoint的距离offset：令checkpoint在[0,2^32-1|域上对应的值 和 [0,2^32-1]域上的abs_base求差。|checkpoint(low 32bit) - abs_base|。</li>
<li>a. 先假设checkpoint lowbit &gt; abs_base。<ul>
<li>然后讨论abs_seq的两种情况：<ul>
<li>落在checkpoint左侧，abs_seq1 = check_point - offset ；落在checkpoint右侧，abs_seq2 = check_point + 2^32 - offset。如下图1</li>
<li>等价为 offset的两种情况。<ul>
<li>offset &lt; 2^31 , then abs_seq1; offset &gt;= 2^31 , then abs_seq2。</li>
</ul>
</li>
<li>（对于左右abs_seq和check_point距离相等时，我选择了右侧的check_point，因为我觉着从定义来讲，我们传入的check_point是接收窗口最左端，也即_first_unassembled，也即ackno，_first_unassembled左侧的字节都已经读完了进入bytestream，我们期待的，以及理论上应该接接收的是位于滑动窗口最左端往右的字节，故选择右侧而非左侧。</li>
</ul>
</li>
</ul>
</li>
<li>b. 同理，当checkpoint lowbit &lt; abs_base，情况如下图2。<ul>
<li>offset &lt;= 2^31 , then abs_seq1 ; offset &gt; 2^31 , them abs_seq2。</li>
</ul>
</li>
<li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-13-12-10.png"></li>
</ul>
</li>
</ul>
</li>
<li>seq -&gt; abs_seq举例<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Unwrap the first byte after ISN</span></span><br><span class="line">seq = <span class="number">1</span> , isn = <span class="number">0</span> , check_point = <span class="number">0</span> -&gt; closet abs_seq = <span class="number">1</span> = seq - isn（逻辑）</span><br><span class="line">test_should_be(unwrap(WrappingInt32(<span class="number">1</span>), WrappingInt32(<span class="number">0</span>), <span class="number">0</span>), <span class="number">1ul</span>);</span><br><span class="line"><span class="comment">// 2. Unwrap the last byte before the third wrap</span></span><br><span class="line">seq = <span class="number">2</span>^<span class="number">32</span> - <span class="number">2</span> , isn = <span class="number">0</span> , check_point = <span class="number">3</span> * <span class="number">2</span>^<span class="number">32</span> -&gt; closet abs_seq = <span class="number">3</span> * <span class="number">2</span>^<span class="number">32</span> - <span class="number">2</span> = check_point - <span class="number">2</span></span><br><span class="line">test_should_be(unwrap(WrappingInt32(UINT32_MAX - <span class="number">1</span>), WrappingInt32(<span class="number">0</span>), <span class="number">3</span> * (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>)), <span class="number">3</span> * (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>) - <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3. Non-zero ISN</span></span><br><span class="line">seq = <span class="number">2</span>^<span class="number">32</span> - <span class="number">1</span> , isn = <span class="number">10</span> , check_point = <span class="number">2</span> * <span class="number">2</span>^<span class="number">32</span> -&gt; closet abs_seq = <span class="number">3</span> * <span class="number">2</span>^<span class="number">32</span> - <span class="number">1</span> - <span class="number">10</span></span><br><span class="line">test_should_be(unwrap(WrappingInt32(UINT32_MAX), WrappingInt32(<span class="number">10</span>), <span class="number">3</span> * (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>)), <span class="number">3</span> * (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>) - <span class="number">11</span>);</span><br><span class="line"><span class="comment">// 4. Unwrap a non-zero ISN</span></span><br><span class="line">seq = <span class="number">16</span> , isn = <span class="number">16</span> , check_point = <span class="number">0</span> -&gt; closet <span class="built_in">abs</span> seq = seq - isn = <span class="number">0</span></span><br><span class="line">test_should_be(unwrap(WrappingInt32(<span class="number">16</span>), WrappingInt32(<span class="number">16</span>), <span class="number">0</span>), <span class="number">0ul</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>corner case : 对于下溢情况，选择非下溢的一侧</strong> <ul>
<li>seq = 2^32 - 1 , isn = 0 , check_point = 0 -&gt; closet seq = 2 ^ 32 - 1<ul>
<li>按照closet的逻辑，closet seq 有两个选择</li>
<li>位于check_point左侧，即 abs_seq = checkpoint(0) - 1 = 18446744073709551615 </li>
<li>位于check_point右侧，即 abs_seq = checkpoint(0) + 2^32 - 1 = 2^32 - 1</li>
<li>若仅仅按照closet，则应当选择check_point左侧的abs_seq(18446744073709551615)，但实际上，应当选择check_point右侧的abs_seq</li>
<li>原因如下：unwrap的意义<ul>
<li>目的是将字节流中的seq，依据checkpoint，转化成正确的对应的abs_seq。</li>
<li>易知按照100 GB/sec的传输速度，要发送五十多年，才能发送到2^64bytes，可以看作abs_seq是不可能到达2^64级别的byte。</li>
<li>故本case中check_point(0)左侧的下溢情况应当为非法情况。应选择 abs_seq = 2^32 - 1</li>
</ul>
</li>
</ul>
</li>
<li>故：<ul>
<li>当abs_seq位于check_point左侧 且 发生 下溢(到2^64bytes) 时，选择check_point右侧的abs_seq。</li>
<li>当abs_seq位于check_point右侧 且 发生 上溢（重新到0）时，正常计算、上溢取模即可。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// corner case : 4. Big unwrap</span></span><br><span class="line">test_should_be(unwrap(WrappingInt32(UINT32_MAX), WrappingInt32(<span class="number">0</span>), <span class="number">0</span>), <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(UINT32_MAX));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>实现  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 seq, WrappingInt32 isn, <span class="keyword">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line"><span class="comment">//  seqno -&gt; absolute seq no</span></span><br><span class="line">    <span class="keyword">uint32_t</span> base_abs = seq - isn;</span><br><span class="line">    <span class="keyword">if</span>( base_abs &gt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(checkpoint))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">uint32_t</span> offset = base_abs - <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(checkpoint);</span><br><span class="line">          <span class="keyword">if</span>(offset &lt;= (<span class="number">1ul</span>&lt;&lt;<span class="number">31</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> checkpoint + offset;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//  corner case : 当下溢时 选择右侧 而不是左侧溢出到2^64</span></span><br><span class="line">              <span class="keyword">if</span>(checkpoint &lt; (WrappingInt32::_MOD - offset))</span><br><span class="line">                  <span class="keyword">return</span> checkpoint + offset;</span><br><span class="line">              <span class="keyword">return</span> checkpoint - (WrappingInt32::_MOD - offset);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">uint32_t</span> offset = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(checkpoint) - base_abs;</span><br><span class="line">          <span class="keyword">if</span>(offset &gt; (<span class="number">1ul</span>&lt;&lt;<span class="number">31</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> checkpoint + (WrappingInt32::_MOD - offset);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(checkpoint &lt; offset)</span><br><span class="line">                  <span class="keyword">return</span> checkpoint + (WrappingInt32::_MOD - offset);</span><br><span class="line">              <span class="keyword">return</span> checkpoint - offset;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="TCP-Receiver实现"><a href="#TCP-Receiver实现" class="headerlink" title="TCP Receiver实现"></a>TCP Receiver实现</h2><h3 id="报文信息-amp-阶段"><a href="#报文信息-amp-阶段" class="headerlink" title="报文信息 &amp; 阶段"></a>报文信息 &amp; 阶段</h3><ul>
<li>关于报文<br><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-18-59-44.png"><ul>
<li>蓝色：receiver需要读取、关注的<ul>
<li>seq , syn flag , fin flag , playload</li>
</ul>
</li>
<li>红色：receiver需要填充的<ul>
<li>ackno , window_size</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>复习一下三次握手四次挥手的图<blockquote>
<p><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-19-17-34.png"><br><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-19-17-45.png"></p>
</blockquote>
</li>
</ul>
<ul>
<li>将receiver划分为如下阶段。<br><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-19-27-00.png"><ul>
<li>LISTENING : 还没接收到初始化ISN的SYN报文.(the begining of the stream)</li>
<li>SYN_RECV : 已经接收SYN报文 &amp;&amp; 还没接收FIN报文</li>
<li>FIN_RECV : 已经接收到FIN报文且已经传入给bytestream。（即bytestream已经关闭）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listening</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> !_isn.has_value(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">syn_recv</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _isn.has_value() &amp;&amp; !_reassembler.stream_out().input_ended(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fin_recv</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _reassembler.stream_out().input_ended(); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>再看一眼receive_window图<br><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-22-14-58.png"></li>
</ul>
<h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><h4 id="ackno"><a href="#ackno" class="headerlink" title="ackno"></a>ackno</h4><ul>
<li><strong>std::optional<WrappingInt32> ackno() const;</WrappingInt32></strong><ul>
<li><strong>注意：实现的ackno 是 累计确认 ackno</strong></li>
<li>如分析中所述，seqno = receive window left edge = reciver第一个没被写入bytestream的字节。</li>
<li>注意以seqno的形式获取，而非stream_idx：stream_idx –&gt; abs_seq –&gt; seq</li>
<li>注意receiver在不同阶段，所获取的abs_seq不同，自然得出seq不同。<ul>
<li>LISTENING : 还没接收到第一个SYN报文，也即还没建立连接，即还没初始化isn。返回空即可。</li>
<li>SYN_RECV : abs_seq = stream_idx + 1。因为SYN报文会占据abs_seq的起始索引.</li>
<li>FIN_RECV : abs_seq = stream_idx + 2。因为SYN、FIN报文均会占据abs_seq索引位置。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  还没初始化isn，也即还没建立连接，还没接收到第一个SYN报文 </span></span><br><span class="line">    <span class="keyword">if</span>(_state == LISTENING)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::nullopt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  +1 是为了第一个初始化syn报文 规定其占据一个字节的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(_state == SYN_RECV)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> wrap(_reassembler.first_unassembled() + <span class="number">1</span>,_isn.value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  +2 : syn + fin</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(_state == FIN_RECV)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> wrap(_reassembler.first_unassembled() + <span class="number">2</span>,_isn.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="segment-received"><a href="#segment-received" class="headerlink" title="segment_received"></a>segment_received</h4><ul>
<li><strong>void TCPReceiver::segment_received(const TCPSegment &amp;seg)</strong><ul>
<li>每次接收到对端发送的segment时，都会调用该segment_received</li>
<li>主要工作<ul>
<li>接收第一个具有syn flag的报文时 , 初始化isn = seq.</li>
<li>对于data,push_substring(data).</li>
<li>接收fin报文(end-of-stream marker)，代表该fin是该stream的最后一个字节.</li>
</ul>
</li>
<li>注意<ul>
<li>同一个报文中可能同时有syn flag和fin flag.</li>
<li>state什么时候变成fin_recv , 是segment_received刚收到fin flag ,state就改变吗 ?<ul>
<li>不是，此时可能fin flag只是位于receive_window中 ;当fin -&gt; eof被加入到reassembler中的bytestream时(bytestream.end_input())，state才变成fin_recv</li>
</ul>
</li>
<li>对于第一个建立连接,初始化isn的syn报文，其也有可能携带应用层报文数据，即（这和我之前学的三次握手不一样啊。我记着第一次握手的syn报文是连接初始化isn，没有携带应用层数据。  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">test.execute(ExpectState&#123;TCPReceiverStateSummary::LISTEN&#125;);</span><br><span class="line">test.execute(SegmentArrives&#123;&#125;.with_syn().with_seqno(isn).with_data(<span class="string">&quot;Hello, CS144!&quot;</span>).with_result(SegmentArrives::Result::OK));</span><br></pre></td></tr></table></figure></li>
<li>对于invalid segment seq: ignore<ul>
<li>如segment的seq == isn<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCPReceiverTestHarness test&#123;<span class="number">4</span>&#125;;</span><br><span class="line">test.execute(SegmentArrives&#123;&#125;.with_syn().with_seqno(isn).with_result(SegmentArrives::Result::OK));</span><br><span class="line">test.execute(SegmentArrives&#123;&#125;.**with_seqno(isn)**.with_data(<span class="string">&quot;a&quot;</span>).with_result(SegmentArrives::Result::OK));  <span class="comment">//  WRONG INDEX isn ! </span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>核心逻辑  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  0.  corner case such as invalid idx</span></span><br><span class="line">    <span class="keyword">if</span>(corner(seg))</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//  1.  首次确立isn</span></span><br><span class="line">    <span class="keyword">if</span>(_state == LISTENING &amp;&amp; seg.header().syn)</span><br><span class="line">    &#123;</span><br><span class="line">        _isn = seg.header().seqno;</span><br><span class="line">        update_state();     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  2.  如果还没初始化isn，且该报文不是syn报文</span></span><br><span class="line">    <span class="keyword">if</span>(_state == LISTENING)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//  3.  seq -&gt; abs_seq -&gt; stream_idx</span></span><br><span class="line">    <span class="keyword">size_t</span> abs_seq = unwrap(seg.header().seqno,_isn.value(),_reassembler.first_unassembled());   </span><br><span class="line">    <span class="keyword">size_t</span> stream_idx = abs_seq_to_stream_idx(abs_seq);</span><br><span class="line">    <span class="comment">//  4.  push_substring(segment)</span></span><br><span class="line">    _reassembler.push_substring(<span class="built_in">string</span>(seg.payload().str()),stream_idx,seg.header().fin);   </span><br><span class="line"></span><br><span class="line">    update_state();         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="window-size"><a href="#window-size" class="headerlink" title="window_size"></a>window_size</h4><ul>
<li>window_size() : [_first_unassembled , first_unacceptable())<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">window_size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">  <span class="comment">// _first_unassembled = _output.bytes_written(); </span></span><br><span class="line">  <span class="comment">//  first_unacceptable() =  _capacity + _output.bytes_read()</span></span><br><span class="line">  <span class="comment">// return first_unacceptable() - _first_unassembled;</span></span><br><span class="line">  <span class="keyword">return</span> _capacity + _output.bytes_read() - _output.bytes_written();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>值得后续 注意 &amp; 疑问 <ul>
<li>可以看到 对于 receiver 只有第一个syn报文 的syn 可以被receiver识别到，后来的报文，即使syn为true，receiver也识别不到</li>
<li>可以看到，本lab中并没有要求做出ESTABLISHED状态，也并没有FIN_WAIT状态。留待观察，日后应该会实现。</li>
<li><strong>流量控制 – 拥塞控制区别</strong><ul>
<li>已知流量控制 是 flow-controled ，是通过receiver的 receive_window 的ackno以及 window_size实现的。</li>
<li>那么拥塞控制呢？？？<ul>
<li>并没有实现拥塞控制. 见lab3 以及 计网-拥塞控制 blog</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><ul>
<li>添加示例case1<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  ===============my test3==============</span><br><span class="line">  capacity <span class="number">4000</span></span><br><span class="line">  <span class="number">1000</span> <span class="number">0</span> <span class="number">0</span> shc</span><br><span class="line">  shc</span><br><span class="line">        <span class="comment">/* segment with SYN + data + FIN */</span></span><br><span class="line">        &#123;</span><br><span class="line">            TCPReceiver receiver(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> isn = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//  now LISTEN</span></span><br><span class="line">            Assert(<span class="keyword">not</span> receiver.ackno().has_value());</span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;shc&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">true</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">true</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(isn);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(seg);</span><br><span class="line">            <span class="comment">//  already has received syn</span></span><br><span class="line">            Assert(receiver.ackno().has_value());</span><br><span class="line">            <span class="comment">//  now FIN_RECV</span></span><br><span class="line">            Assert(receiver.stream_out().input_ended());</span><br><span class="line">            Assert(receiver.ackno().value() == WrappingInt32(<span class="number">0</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> + isn));  <span class="comment">//  syn(0) + &quot;shc&quot;[123] + fin(4) -&gt; 5 + isn = 1005;</span></span><br><span class="line">            Assert(receiver.unassembled_bytes() == <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;receiver.stream_out().read(receiver.stream_out().buffer_size())&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//  shc</span></span><br><span class="line">            <span class="comment">//  stream empty &amp;&amp; closed</span></span><br><span class="line">            Assert(receiver.stream_out().eof());</span><br><span class="line">                <span class="comment">//////// bytestream   //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////syn shc         //////////   ////// fin empty       //////</span></span><br><span class="line"><span class="comment">// abs_seq      //////0   123         //////////   ////// 4  5          //////</span></span><br><span class="line"><span class="comment">// seq = abs_seq + isn</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li>添加示例case0 : 普通通信<ul>
<li>syn报文 , data报文 , fin报文<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">======================my test <span class="number">02</span>==============</span><br><span class="line">capacity <span class="number">200</span></span><br><span class="line"><span class="number">5</span> <span class="number">0</span> <span class="number">0</span> abcdefg</span><br><span class="line"><span class="number">14</span> <span class="number">9</span> <span class="number">8</span> abc</span><br><span class="line"><span class="number">13</span> <span class="number">8</span> <span class="number">7</span> a</span><br><span class="line">abcdefgaabc</span><br><span class="line"><span class="number">17</span> <span class="number">12</span> <span class="number">11</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;======================my test 02==============&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="function">TCPReceiver <span class="title">receiver</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line">            <span class="comment">//  window size</span></span><br><span class="line">            Assert(receiver.window_size() == <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  tcp segment abcdefg , syn isn = 5</span></span><br><span class="line">            &#123;</span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">false</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">true</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(<span class="number">5</span>);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(<span class="built_in">std</span>::move(seg));</span><br><span class="line">                Assert(receiver.ackno().has_value() == <span class="literal">true</span>);</span><br><span class="line">                Assert(receiver.stream_out().bytes_written() == <span class="number">7</span>);</span><br><span class="line">                Assert(receiver.ackno() == WrappingInt32(<span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//////// bytestream //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////// abcdefg    //////////   ////// empty       ////// </span></span><br><span class="line"><span class="comment">// abs_seq      ////////01234567    //////////   ////// 8           //////</span></span><br><span class="line"><span class="comment">// seq = abs_seq + 5</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  abc , seqno = 14</span></span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">false</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">false</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(<span class="number">14</span>);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(<span class="built_in">std</span>::move(seg));</span><br><span class="line">                Assert(receiver.stream_out().bytes_written() == <span class="number">7</span>);</span><br><span class="line">                Assert(receiver.unassembled_bytes() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//////// bytestream //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////// abcdefg    //////////   ////// abc       //////</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  a , seqno = 13</span></span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">false</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">false</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(<span class="number">13</span>);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(<span class="built_in">std</span>::move(seg));</span><br><span class="line">                Assert(receiver.stream_out().bytes_written() == <span class="number">11</span>);    <span class="comment">//  abcdefgaabc</span></span><br><span class="line">                Assert(receiver.unassembled_bytes() == <span class="number">0</span>);</span><br><span class="line">                Assert(receiver.ackno() == WrappingInt32(<span class="number">17</span>));          <span class="comment">//  syn(0) + abcdefgaabc[1,11] -&gt; 12 +  isn(5) </span></span><br><span class="line">                ByteStream stream = receiver.stream_out();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;stream.read(stream.buffer_size())&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//////// bytestream  //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////// abcdefgaabc //////////   ////// empty       //////</span></span><br><span class="line"><span class="comment">// abs_seq      //////0 1234567891011//////////   ////// 12          //////</span></span><br><span class="line"><span class="comment">// seq = abs_seq + 5</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  &quot;&quot; , fin , seqno = 17</span></span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">true</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">false</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(<span class="number">17</span>);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(<span class="built_in">std</span>::move(seg));</span><br><span class="line">                Assert(receiver.stream_out().bytes_written() == <span class="number">11</span>);    <span class="comment">//  abcdefgaabc</span></span><br><span class="line">                Assert(receiver.unassembled_bytes() == <span class="number">0</span>);</span><br><span class="line">                Assert(receiver.ackno().value() == WrappingInt32(<span class="number">18</span>));          <span class="comment">//  syn(0) + abcdefgaabc[1,11] + fin[12] -&gt; 13 + isn(5) </span></span><br><span class="line">                <span class="comment">//////// bytestream  //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////// abcdefgaabc //////////   ////// fin empty       //////</span></span><br><span class="line"><span class="comment">// abs_seq      //////0 1234567891011//////////   ////// 12  13          //////</span></span><br><span class="line"><span class="comment">// seq = abs_seq + 5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>(未完成)计算机网络-CS144-lab4-优化</title>
    <url>/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>心血来潮，给lab4来个性能优化. <del>失败</del><br>成功了<br>结果如图<br><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-03-05-20-57-50.png"></p>
<p>方式：改进StreamReassembler + ByteStream</p>
<span id="more"></span>



<h2 id="分析-amp-优化"><a href="#分析-amp-优化" class="headerlink" title="分析 &amp; 优化"></a>分析 &amp; 优化</h2><ul>
<li>You may need to profile your code or reason about where it is slow, and you may have to improve your implementation of some of the critical modules (e.g., ByteStream or StreamReassembler) to get to this point.</li>
</ul>
<h3 id="尝试优化-ByteStream-失败"><a href="#尝试优化-ByteStream-失败" class="headerlink" title="尝试优化 ByteStream (失败)"></a>尝试优化 ByteStream (失败)</h3><ul>
<li>根据同学支招 , 尝试将ByteStream中的deque&lt; char&gt;替换为BufferList，不过效果不太明显甚至导致性能更差.<ul>
<li>分析之后我认为原因如下几点<ul>
<li>a. bytestream由StreamReassembler调用 , 我实现的策略是StreamReassembler逐个字节的扫描并write进bytestream. 那么如果在stream.write()为一个字节造了个Buffer , 还要再填入BufferList , 得不偿失.</li>
<li>b. 并且由于StreamReassembler策略(逐byte写入)会导致频繁的调用output_bytestream.write(),导致BufferList里面的buffer数量急剧增多，在求取BufferList.size()时会极耗费时间.<blockquote>
<p><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-22-02-53.png"></p>
</blockquote>
</li>
<li>c. 更何况，即便使用了Buffer(shared_ptr管理data) ,每个字节<strong>进入bytestream必然要1次拷贝</strong>(因为传入的是const &amp;) , 从bytestream<strong>离开也必然需要1次拷贝</strong>. 这点来讲这实际上和我的 deque&lt; char &gt; 并无差别.</li>
<li>gropf验证一下 , 可以看到BufferList造成的开销更大(归咎于StreamReassembler策略)<ul>
<li><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-22-19-00.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>总结: <strong>我的性能热点不在这里。即不在于str进出bytestream的拷贝次数过多. md浪费时间了</strong></li>
</ul>
<h3 id="性能热点确定-StreamReassembler"><a href="#性能热点确定-StreamReassembler" class="headerlink" title="性能热点确定 : StreamReassembler"></a>性能热点确定 : StreamReassembler</h3><p>完全未优化图</p>
<ul>
<li>使用gropf得到<img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-17-31.png"></li>
<li>从图中可以看到，<strong>性能消耗的大头在于unordered_map和move_receiving_window , 也即性能热点都在StreamReassembler</strong>. 有点麻烦啊靠。 </li>
<li>unordered_map应该没啥优化空间了(也有，避免重复缓存），复杂度平摊下来O(1) ; 那么就是优化move_receiving_window. 我的代码没有时刻记录能移动到的位置，只能最后遍历一次. 所以应该尝试在重组字节的时候就记录下最大的顺序字节的位置. 日后有时间再尝试吧. 这一下午就当打游戏了…… 悲</li>
<li>突然想起来当时写StreamReassembler时，写到这部分时考虑过是否性能会较低,不过当时偷懒先只追求正确性了，可恶.</li>
<li>有时间再继续优化吧. 不赶趟了不赶趟了 快点复习数据库考试吧.</li>
</ul>
<h3 id="优化成功"><a href="#优化成功" class="headerlink" title="优化成功"></a>优化成功</h3><h4 id="优化StreamReassembler"><a href="#优化StreamReassembler" class="headerlink" title="优化StreamReassembler"></a>优化StreamReassembler</h4><ul>
<li>优化成果<br><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-03-05-22-03-24.png"><br><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-03-05-21-17-44.png"><ul>
<li>请和上图未优化对比</li>
</ul>
</li>
</ul>
<p>优化前后原理对比.改进StreamReassembler使得性能变高原因123</p>
<ul>
<li><strong>优化之前</strong> 底层容器 : unordered_map&lt;size_t , char&gt;<ul>
<li>原先的策略，仅仅是为了保证正确性，以单个字符的形式维护char，无法维护字节连续的信息，只能每次通过遍历获取<ul>
<li>向bytestreampush的时候，每次只能write1个字节，边遍历边write。</li>
<li>对于到来的char，哪怕这些char之前已经缓存过，还是重新缓存一遍(也即，每个char会加入到receive_window中多次），对于重复的大量字符串，效率极差.<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamReassembler</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span> , <span class="keyword">char</span>&gt; _receving_window;      <span class="comment">//  乱序到达的，还没加入bytestream的bytes</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><strong>优化之后</strong> 底层容器 ：map&lt;size_t , string&gt;<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamReassembler</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  map : 为支持二分查找. 找到新来串的上一个分组（称为前串）和下一个分组（称为后串）</span></span><br><span class="line">      <span class="comment">//  前串 ：prev_idx &lt;= now_idx</span></span><br><span class="line">      <span class="comment">//  后串 ：ne_idx &gt; now_idx</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">size_t</span> , <span class="built_in">string</span>&gt; _receving_window;      <span class="comment">//  起始下标为key的string</span></span><br><span class="line">    <span class="comment">//  维护receive_window中字节个数</span></span><br><span class="line">    <span class="keyword">size_t</span> _receiving_window_size&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li>相比之下，通过<strong>map&lt;size_t,string&gt;可以以块的形式（因为底层用的是string）维护字节，即可以维护哪些块是连续的，以及其连续范围</strong></li>
<li>故现在的策略，对于缓存的char，可以维护哪些字符是连在一起的。<ul>
<li><strong>原因之1.</strong> : 这样不会重复缓存已经缓存过的char! 每个char只会缓存一次. 也即 每个char只会加到 receive_window中一次!。<ul>
<li>可以看到两张性能分析图中，对于StreamReassembler::底层容器unordered_map的查询、插入不再是性能热点</li>
</ul>
</li>
<li><strong>原因之2.</strong> : 且这样调用write的时候不必1个char1个char的遍历、write。直接write一个string即可。<ul>
<li>原先StreamReassembler(unordered_map&lt;size_t,char&gt;)调用write时只能传递char，故每个char在传参的时候都会拷贝一次，这个const &amp;就跟直接传值一样。那么对于一个大字符串，每个字符都要拷贝一次。<ul>
<li>为什么原先只能传递char 不能传递string呢? 因为原先是以char为单元来对窗口进行维护的，也没有维护哪些字符连续，只能边遍历边传unordered_map里的字符char拷贝给write</li>
</ul>
</li>
<li>而我们将StreamReassembler 底层容器改为 map&lt;size_t,string&gt;时,可以以块(string)的形式维护字节连续的信息，这样当我们调用write的时候，直接传入给write const string &amp;的就是map里的string，所以是以引用的方式传递的，故减少了拷贝的时间和内存上的消耗</li>
<li>这就是改变StreamReassembler提升性能的原因之<strong>2</strong></li>
<li>可以看到两张性能分析图中，moving_receive_window，即原先一个一个给bytestream write char，在这里也不是热点了。整个push_substring里都没有性能消耗过大的.</li>
</ul>
</li>
<li><strong>原因之3.</strong> : 原先StreamReassembler(unordered_map&lt;size_t,char&gt;)调用write时只能传递1个1个char，对于大量字符串，调用write的次数会极多，write开辟和回退栈帧的消耗会变得很大。<ul>
<li>可以看到两张性能分析图中，moving_receive_window，即原先一个一个给bytestream write char，在这里也不是热点了。整个push_substring里都没有性能消耗过大的,</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>StreamReassembler改进后的思路: <a href="https://kiprey.github.io/">参考</a><ul>
<li><ol>
<li>根据idx，寻找data的(1.1)前串和((1.2)后串，去除data和前串和后串重叠(覆盖)的部分，得到一个独立的data</li>
</ol>
</li>
<li><ol start="2">
<li>然后判断能否将该独立的（不和其他串重叠）data压入bytestream中，若能，则写入，且写入之后要查询后续串是否能够写入，因为当前串的写入可能导致后续串被写入.<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  1. 寻找前串,确定data_start_offset</span></span><br><span class="line">    prev_iter = _receving_window.upper_bound(index); <span class="comment">//  &gt;</span></span><br><span class="line">    --prev_iter;</span><br><span class="line">    </span><br><span class="line">    data_new_index = data非重叠的起始</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  去除重叠的data前缀. </span></span><br><span class="line">      <span class="comment">//  去除前缀后的起始idx : data_new_index.</span></span><br><span class="line">      <span class="comment">//  相对offset : data_start_offset</span></span><br><span class="line">      <span class="comment">//  data大小 : data_size</span></span><br><span class="line">    data_start_offset = new_idx - index</span><br><span class="line">    data_size = data.size() - (new_idx - index)     <span class="comment">//  还得处理下eof</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  寻找后串 : 确定data_size. (去掉全部覆盖的以及重叠后缀)</span></span><br><span class="line">    ne_iter = _receving_window.lower_bound(new_idx);      </span><br><span class="line">    <span class="comment">//  如果和后面的重叠</span></span><br><span class="line">    <span class="keyword">while</span>(如果当前data和后串ne重叠)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> data 全部覆盖 ne_iter)</span><br><span class="line">          覆盖. erase 掉ne_iter</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="keyword">new</span> data 部分覆盖 ne_iter，去除后缀,确定data长度</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ！！！阶段<span class="number">1</span>完成</span><br><span class="line">    至此，我们得到的 data.substr(data_start_offset,data_size) </span><br><span class="line">    是一个不和receive_window中其他字段重叠的data</span><br><span class="line"></span><br><span class="line">    开始阶段<span class="number">2</span> </span><br><span class="line">    接下来只开始将data写入bytestream</span><br><span class="line"></span><br><span class="line">    isolated_data = data.substr(data_start_offset,data_size);</span><br><span class="line">    <span class="keyword">if</span>(新串不可写)</span><br><span class="line">        存入receive_window.insert(isolated_data)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(新串可写)</span><br><span class="line">        写入</span><br><span class="line">        将没写完的存入receive_window</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  本次来的新串写入bytestream之后 , 有可能造成别的串也可以压入bytestream了。</span></span><br><span class="line">    <span class="keyword">for</span>(iter = 遍历receive_window中的串;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  维护 receive_window_size</span></span><br><span class="line">        <span class="comment">//  全部写入</span></span><br><span class="line">        _receving_window.insert(&#123;nidx,<span class="built_in">std</span>::move(str.substr(written))&#125;); </span><br><span class="line">        iter = _receving_window.erase(iter);</span><br><span class="line">    &#125;</span><br><span class="line">    处理eof</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="优化ByteStream"><a href="#优化ByteStream" class="headerlink" title="优化ByteStream"></a>优化ByteStream</h4><ul>
<li>上面优化完重排器后，性能已经从0.1Gbit/s达到了1.1Gbit/s</li>
<li>继续优化，我们将ByteStream内部的底层容器改成BufferList.(deque<string>)</string></li>
<li>先看优化成果<br><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-03-05-20-57-50.png"><br><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-03-05-21-00-26.png"></li>
</ul>
<p>实现如下</p>
<ul>
<li><p>原先：deque<char>；现在：deque<string></string></char></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteStream</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  原先：</span></span><br><span class="line">    <span class="comment">//  deque&lt;char&gt; _stream;    </span></span><br><span class="line">    <span class="comment">//  现在：</span></span><br><span class="line">    BufferList _stream;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data)</span> </span>&#123;</span><br><span class="line">    get bytes_to_write;</span><br><span class="line">    <span class="comment">//  原先：一个一个char的copy</span></span><br><span class="line">    <span class="comment">// for (size_t i = 0; i &lt; bytes_to_write; ++i) &#123;</span></span><br><span class="line">        <span class="comment">// _stream.push_back(data[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//  现在：substr copy 一次 ; 然后一次move到_stream中</span></span><br><span class="line">    _stream.append(<span class="built_in">std</span>::move(data.substr(<span class="number">0</span>,bytes_to_write)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>性能变高原因：调用push_back次数</strong>。<ul>
<li>在write里面，使用vector<char>时，每次只能push_back一个char，对于大string，会push很多很多次，push_back开辟和回退栈帧的开销也会很大.</char></li>
<li>使用deque<string> 时，只需要一次push_back，就能得到所有char. 开辟回退栈帧开销小.</string></li>
<li>两张性能分析图对比，明显看到，现在write不再是性能热点.</li>
</ul>
</li>
</ul>
</li>
<li><p>注意：实际上在ByteStream类内，write函数中，对字符的拷贝次数并无差别。push到队列，每个字符要拷贝一次；pop出去，还要拷贝一次。</p>
<ul>
<li>可以看到，在ByteStream内部，底层容器采用BufferList还是deque<char>，对于在write中，拷贝char次数是相同的.</char></li>
<li>采用deque<char>,每次push_back(char)的时候会有拷贝一个字符，最终会拷贝data的所有字符，将其放入deque中</char></li>
<li>采用BufferList(deque<Buffer>, Buffer即shared_ptr拥有着一个string;可以看作是个deque<string>)<ul>
<li>则虽然string不同于char，是个内部有移动构造函数的对象</li>
<li>但是，由于data是个const &amp; , 我们为了获取它的字符，还是需要substr一次。而substr是一个拷贝. 故 还是会拷贝一次string里所有的char</li>
</ul>
</string></Buffer></li>
</ul>
</li>
</ul>
<h2 id="分析-amp-gprof-和-gprof2dot-py-使用"><a href="#分析-amp-gprof-和-gprof2dot-py-使用" class="headerlink" title="分析 &amp; gprof 和 gprof2dot.py 使用"></a>分析 &amp; gprof 和 gprof2dot.py 使用</h2><ul>
<li><p>gprof使用</p>
<ul>
<li><ol>
<li>编译选项 -g更改为 -pg</li>
</ol>
</li>
<li><ol start="2">
<li>./apps/tcp_benchmark 运行一下生成gmon.out</li>
</ol>
</li>
<li><ol start="3">
<li>分析生成的gmon.out : <code>gprof ./apps/tcp_benchmark</code></li>
</ol>
<ul>
<li>函数消耗时间分析. 依据self seconds进行排序<br>  <img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-17-31.png"><br>  <img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-26-53.png"></li>
<li>call graph段. 描述函数调用关系<br><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-23-16.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>图形化 : gprof2dot.py使用</p>
<ul>
<li><ol>
<li>还是先生成gmon.out</li>
</ol>
</li>
<li><ol start="2">
<li>分析生成的gmon.out , 并将输出传递给gprof2dot.py , 处理完之后传给dot. 生成png</li>
</ol>
<ul>
<li> <code>sudo gprof ./apps/tcp_benchmark | gprof2dot.py | dot -Tpng -o report.png</code></li>
<li><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-17-55.png"></li>
<li><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-18-17.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>gprof 缺陷：只能分析应用程序在运行过程中所消耗掉的用户时间，无法得到程序内核空间的运行时间。</p>
</li>
<li><p>这类工具还有valgrind, google perftools , perf , systemtap , oprofile , dtrace 有时间再研究.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab4-补充</title>
    <url>/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>补充八股</p>
<span id="more"></span>

<h2 id="挥手丢失-发生什么"><a href="#挥手丢失-发生什么" class="headerlink" title="挥手丢失 发生什么"></a>挥手丢失 发生什么</h2><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86">https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86</a></p>
<h2 id="两军问题"><a href="#两军问题" class="headerlink" title="两军问题"></a>两军问题</h2><p>A1 B A2<br>背景: 只有A1 和 A2同时向B发起进攻，才能成功。注：A1 和 A2的通信只能通过B，且是不可靠的通信。</p>
<p>前提：A1发送给A2 的消息 ，可能被B截获<br>目标：A1 和 A2达成一致… 到底什么叫一致 ? 我要学raft啊啊啊。春节之前学啊啊啊。<br>困难：A1 和 A2无法达成一致<br>A1无法确定A2是否收到A1发送的消息，A2为使得A1知道A2收到消息，则A2向A1发送确认报文；然而，A2无法确认A1是否收到该确认报文，则A1为使得A2知道A1收到确认，A1需要向A2发送确认报文（用于确认A2发送的确认报文）；那么同理，A2又需要向A1发送确认报文（用于确认A1发送的，用于确认A2发送的确认报文 的报文）; …. 如此，无穷无尽。<br>一言以蔽之 : 由于信道B不可靠，A1和A2无法确定对方是否收到本端发送的消息，因此会造成无穷多的ack.</p>
<h2 id="TCP-Keepalive"><a href="#TCP-Keepalive" class="headerlink" title="TCP Keepalive"></a>TCP Keepalive</h2><ul>
<li>TCP Keepalive是TCP的保活机制，为了及时知道对方的TCP是否还存活，以判断该连接是否已经死亡.</li>
<li>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。<ul>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。</li>
</ul>
</li>
<li>TCPConnection实现：segment_received()的special case<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.ackno().has_value() <span class="keyword">and</span> (seg.length_in_sequence_space() == <span class="number">0</span>) <span class="keyword">and</span> seg.header().seqno == _receiver.ackno().value() - <span class="number">1</span>) &#123;    <span class="comment">//  local TCP expect the seqno to be _receiver.ackno().value()</span></span><br><span class="line">   _sender.send_empty_segment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h2><ul>
<li>HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；</li>
<li>HTTP协议 : 请求-应答模式<ul>
<li><strong>HTTP短连接</strong><ul>
<li>一次http请求 就要发起一条tcpconnection</li>
<li>每次请求都会经历 : 三次握手 -&gt; 请求 -&gt; 响应 -&gt; 四次挥手</li>
</ul>
</li>
<li><strong>HTTP长连接</strong><ul>
<li>使用同一条tcpconnection 来传送多条http请求/响应 , (1)从而避免连接建立和释放的开销</li>
<li>http层的双方通过在请求/响应的包头中添加 <code>Connection: Keep-Alive</code>来达成协议.</li>
<li>http长连接不仅减少了多次连接/释放的开销，(2)也是http流水线技术的基础<ul>
<li>http流水线 : 客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应，服务器按照顺序响应请求<blockquote>
<p><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E8%A1%A5%E5%85%85/2023-01-16-16-01-24.png"></p>
</blockquote>
</li>
<li>归功于多个请求使用同一条tcp连接，server的多条响应才能按序到达client</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab1</title>
    <url>/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/</url>
    <content><![CDATA[<ul>
<li><img src="/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/2022-12-31-20-50-45.png"></li>
<li>lab1 : 实现一个接收端的重排器<ul>
<li>lab2实现的 TCP receiver 的重要功能：处理乱序到达的数据包 ，该功能即lab1 所谓的 重排器 reassembler</li>
<li>就是让我们实现一个tcp的滑动窗口协议的接收端。</li>
<li>TCP协议中的滑动窗口协议是SR协议和GBN协议的结合<ul>
<li>发送窗口 &gt; 1</li>
<li>ack代表 : 接收方接收到的顺序到来的最后一个字节 + 1</li>
<li>像GBN协议的部分 : <ul>
<li><ol>
<li>发送窗口内只有一个定时器（窗口内最老的分组的定时器）</li>
</ol>
</li>
<li><ol start="2">
<li>发送ack累计确认</li>
</ol>
</li>
</ul>
</li>
<li>像SR协议的部分 : <ul>
<li><ol>
<li>可以乱序接收 </li>
</ol>
</li>
<li><ol start="2">
<li>sender重传超时分组（最老的），receiver给sender发送新的ackno , sender可以发送新的数据. 是否重传发送窗口中的其他分组，取决于ackno的大小. 若大于send window中的所有segment , 则清空send window,不必重传所有分组. 若小于send window中的某些segment , 则会重传这某些分组.</li>
</ol>
<ul>
<li>我目前认为网上有些人说的 重传 所有分组 是不对的。又不是GBN协议. receve window是 &gt; 0的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>receiving_window 接收窗口 [the first unassembled , the first unaccepted)<br>capacity = bytestream.buffer_size() + receiving_window.size()<br><img src="/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/2023-01-01-11-49-14.png"></p>
</li>
<li><p>从某种意义上来说，receive_window就是就是从bytestream中划出了一部分用作乱序缓存<br>bytestream(顺序字节) + receive_window(乱序字节) = capacity</p>
</li>
</ul>
<span id="more"></span>


<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p><img src="/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/2022-12-31-20-50-45.png"></p>
<ul>
<li>上图：我们将实现的TCP的 每一个模块的安排 以及 数据的流向。<ul>
<li>TCP的工作是在不可靠的datagram网络之上 传输两个方向的ByteStream，因此写入socket的字节(outbound)会在连接的对端作为可读字节(inbound)出现，反之亦然。</li>
<li>Lab0实现了图中的ByteStream。</li>
<li>Lab1实现的是流重组器(StreamReassembler)</li>
<li>Lab2是TCP接收器(TCPReceiver)</li>
<li>Lab3是TCP发送器(TCPSender)</li>
<li>Lab4是TCP连接（TCPConnection) 将他们组合在一起</li>
</ul>
</li>
</ul>
</li>
<li><p>我为什么要实现TCP ? </p>
<ul>
<li><img src="/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/2023-01-01-08-41-21.png"></li>
<li>在不可靠的服务之上 提高服务或者抽象 可以解释网络中的许多有趣的问题。<ul>
<li>在过去四十年中，调查者和实践者已经解决了如何通过互联网传输各种各样的信息 如邮件、超链接、搜索引擎、声音、视频、写作文件共享、数字货币。</li>
</ul>
</li>
<li>TCP自己的角色是：使用不可靠的数据报 提供可靠的字节流。就是上述所说的在不可靠服务之上提供服务的经典案例。一个合理的观点是：TCP是地球上使用的最广泛的非凡的计算机程序。</li>
</ul>
</li>
<li><p>实验会要求你以模块化的方式构造一种TCP的实现。在接下来的四个实验中，你将会实现</p>
<ul>
<li>通过网络传输lab0中实现的bytestream：<ul>
<li>outbound bytestream，用于本地的数据写入socket然后发送给TCP连接的对端；</li>
<li>inbound bytestream，用于接收来自对端的数据，这些数据会被本地的app读取。</li>
</ul>
</li>
<li>lab1中，我们将实现一个流重组器（stream reassembler）<ul>
<li>该模块用于将字节流中的片段（被称为substrings / segments）重组为顺序的字节流。</li>
</ul>
</li>
<li>lab2中 我们将实现TCPReceiver : <ul>
<li>负责处理inbound bytestream。</li>
<li>这包括了思考TCP是如何将字节流中的每个字节的位置标记为序列号；TCPReceiver负责告知发送方inbound bytestrean有能力组装多少字节；并且发送方被允许再发送多少bytes.(这就是所谓的流量控制)</li>
</ul>
</li>
<li>lab3中 我们将实现TCPSender : <ul>
<li>负责处理outbound bytestream.</li>
<li>TCPSender需要如何反应 当它认为一个传输了的segment在路上丢失了；它在什么时候需要重传丢失的segment</li>
</ul>
</li>
<li>lab4中 我们将组合之前的lab，来创建构建一个TCP实现：一个TCP包含了TCPSender和TCPReceiver的连接。你将使用该TCP实现去和全世界的server通信。 </li>
</ul>
</li>
</ul>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul>
<li><strong>背景</strong>：<ul>
<li>在lab1和lab2，你将要<strong>实现TCP receiver</strong>。这个模块接收datagrams，并且将他们转化成将要被user从socket中读取的可靠字节流（就像lab0中 从webserver读取字节流的webget一样）<ul>
<li>TCP Sender会将字节流切割成short segment（每片不大于1460bytes的substring），因此每个short segment都可以放入一个datagram中。</li>
<li>但是网络可能会打乱datagram的顺序，或者丢弃他们，或者重复投递他们。</li>
<li><strong>TCP receiver需要 重新组合这些segments，将其重组进顺序连续的字节流（就像发送方刚开始发送的字节流一样）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>约定：segment/substring/bytes not reassembled<br>还没重组的字节：我们将 还没有 形成 顺序的 连续的 segment/byte，称为乱序的byte，也即需要reassemble重组的byte，这些byte被缓存在receving_window中，由于和bytestream中的byte还没连续起来，故不加入bytestream，等待所需字节的到来，也即等待reassemble。<br>重组完成的字节：已经形成了顺序的、连续的byte，这些byte已经从receving_window被压入bytestream中.<br>老数据：已经从bytestream中读走的字节 以及 已经压入到bytestream中的字节<br>新数据：下标范围落在receiving_window中的字节。这些字节可能之前已经被缓存在receive_window中。</p>
<p>StreamReassembler要求如下</p>
<ul>
<li><p><strong>本实验实现目标：StreamReassembler 流重组器</strong>。</p>
<ul>
<li>所谓的流重组器StreamReassembler，也就是我们常说的 滑<strong>动窗口协议中 接收窗口大小大于1时（Selective Repeat协议） 的 接收端</strong>。只不过这里接收窗口的大小不是固定的，是和bytestream的大小加在一起=capacity）</li>
<li>StreamReassembler接收segment(substring)<ul>
<li>segment结构：string data , index(data[0])</li>
</ul>
</li>
<li>整个字节流的起始byte下标为0.</li>
<li>output bytestream : StreamReassembler 的输出接口。<ul>
<li>其中装载的是已经顺序的连续的字节。</li>
<li>output.write(msg) : 一旦StreamReassembler确认流中顺序的下一个字节，就将其写入ByteStream.</li>
<li>output.read() : user可以使用该output bytestream，并在任何时候从其中读取字节。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>接口</strong></p>
<ul>
<li>void push_segment(const string &amp;data, const uint64_t index, const bool eof);<ul>
<li>data : the segment</li>
<li>index : data[0]在整个字节流中的下标</li>
<li>eof : 该data segment的最后一个字节将成为整个流的最后一个字节<ul>
<li>可以看出，eof本身并不占据字节流中的位置，不消耗下标。（也即stream_idx不记录eof）</li>
</ul>
</li>
<li>接收segment data , 将相应的部分落入 recving_window , 并将连续的bytes写入output bytestream。超出capactiy部分的字节将自动被舍弃。</li>
</ul>
</li>
<li>size_t unassembled_bytes() const;<ul>
<li>被缓存 但还没被重组的 segment的字节数量。（segment stored but not yet reassembled）</li>
</ul>
</li>
<li>bool empty() const<ul>
<li>我认为是 outputstream和recving_window均为empty（Is the internal state empty (other than the output stream)?）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>关于capacity</strong></p>
<ul>
<li>一言以蔽之: <strong>capacity = bytestream.buffer_size() + receving_window.size()</strong></li>
<li><strong>也即，capacity = reassembled bytes (in bytestream)+ unreassembled bytes (in segment)</strong></li>
<li><strong>也可以看作是 从 bytestream的capacity中，划走一部分作为接收窗口（即缓存）</strong></li>
<li><strong>capacity</strong>作用：流量控制的一部分，防止己方接受过多bytes<ul>
<li>push_substring()会忽略任何超出capacity的字节，这防止了StreamReassembler没有限制的使用内存，不管TCP Sender打算做什么。</li>
</ul>
</li>
</ul>
</li>
<li><p>整个字节流图。整个字节流从左向右增长，从右向左流动。<br>  <img src="/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/2023-01-01-10-21-26.png"></p>
</li>
</ul>
<p><img src="/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/2023-01-01-11-48-56.png"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>class StreamReassembler</strong><br>由上述分析可知，<strong>我们所要实现的，就是一个接受窗口大小&gt;1的滑动窗口协议接收端</strong></p>
<ul>
<li><p><strong>图</strong><img src="/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/2023-01-01-11-49-14.png"></p>
</li>
<li><p>一些关系</p>
<ul>
<li><strong>capacity = bytestream.size() + receving_window.size()</strong></li>
<li>从某种意义上来说<ul>
<li><strong>receive_window就是就是从bytestream中划出了一部分用作乱序缓存</strong> </li>
<li><strong>bytestream(顺序字节) + receive_window(乱序字节) = capacity</strong></li>
</ul>
</li>
<li>bytestream中 存储的是 StreamReassembler已经重组完成的顺序连续字节。上层user可通过调用bytestream.read()将其读走</li>
<li><strong>receiving_window : [first_unassembled,first_unacceptable)</strong><ul>
<li><strong>作用：缓存乱序字节</strong><ul>
<li>receiving_window 中存储的是 没能和bytestream形成连续的字节，当其能和bytestream连起来时，就将连起来的字节压入bytestream。</li>
</ul>
</li>
<li>大小变化，受capacity限制。</li>
<li>实现：unordered_map&lt;size_t , char&gt; _receving_window;</li>
</ul>
</li>
</ul>
</li>
<li><p>成员</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream  有序的bytes</span></span><br><span class="line">    <span class="keyword">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes   </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  receiving_window</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">size_t</span> , <span class="keyword">char</span>&gt; _receving_window;      <span class="comment">//  乱序到达的，还没加入bytestream的bytes</span></span><br><span class="line">    <span class="keyword">size_t</span> _first_unread;         <span class="comment">//  第一个没被读的byte的索引。其大小等于上层已经从bytestream读走了多少bytess</span></span><br><span class="line">    <span class="keyword">size_t</span> _first_unassembled;    <span class="comment">//  第一个没加入bytestream的byte的索引（第一个乱序的byte索引）</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">first_unacceptable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _first_unread + _capacity;&#125;   <span class="comment">//  the first_unacceptable</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  eof</span></span><br><span class="line">    <span class="keyword">size_t</span> _eof_idx;</span><br><span class="line">    <span class="keyword">bool</span> _eof;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>push_segment实现</strong> </p>
<ul>
<li>void StreamReassembler::push_substring(const string &amp;data, const size_t index, const bool eof)</li>
<li>主要分为<strong>两步</strong><ul>
<li><strong>1. 将segment data的相应部分，正确的缓存在receiving_window中</strong>（1.）<ul>
<li>这也就是 所谓的 StreamReassembler 所做的重组工作，即将字节正确的排列在receiving_window中，当形成连续的顺序字节时，就输出出去(即送入bytestream中)</li>
<li>对于segment data，可分为如下情况讨论。</li>
<li>segment data全部是老数据，那么不必缓存在receiving_window中</li>
<li>segment data全部是新数据，那么则将其全部缓存在receiving_window中（当然超出capacity的要截断）<ul>
<li>这里我的实现可能会造成重复缓存的问题，可以优化，比如用一个数组记录下接收窗口中连续字节的起始位置，不过目前还没做优化，只是保证正确性，反正没超0.5s。</li>
</ul>
</li>
<li>segment data一部分是老数据，一部分是新数据，那么截断新数据，缓存进receiving_window中.</li>
</ul>
</li>
<li><strong>2. 将receiving_window中 已经重组好的字节 压入 output bytestream中</strong>（3.）<ul>
<li>就是 根据规则<strong>移动receiving_window接收窗口</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>核心代码逻辑如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! \details This function accepts a substring (aka a segment) of bytes,</span></span><br><span class="line"><span class="comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span></span><br><span class="line"><span class="comment">//! contiguous substrings and writes them into the output stream in order.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  0. corner case</span></span><br><span class="line">    <span class="keyword">if</span>(corner(data,index,eof))</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    _first_unread = _output.bytes_read();</span><br><span class="line">    _first_unassembled = _output.bytes_written();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1. 将data的相应部分cached into receiving_window</span></span><br><span class="line">    <span class="keyword">size_t</span> last_idx = cached_into_receiving_window(data,index,non);</span><br><span class="line">    <span class="comment">//  2. 计算eof下标</span></span><br><span class="line">    whether_eof(data,index,eof,last_idx);</span><br><span class="line">    <span class="comment">//  3. 将receiving_window中的顺序字节加入bytestream，宏观来看就是移动接收窗口</span></span><br><span class="line">    move_receiving_window();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>test passed</p>
<blockquote>
<p><img src="/2022/12/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab1/2023-01-01-14-47-51.png"></p>
</blockquote>
</li>
</ul>
<ul>
<li>几个小问题<ul>
<li>2个小bug<ul>
<li>eof本身并不占据字节流中的索引位置（即不消耗stream_idx），故即使其位于first_unacceptable(recving_window的右开边界)，也可以将eof加入到bytestream中。</li>
<li><strong>如果push_segment之前已经有了eof，那么接下来的push_segment该怎么办？</strong><ul>
<li>首先bytestream 的eof标志后面，就不应当再加入任何字节到bytestream中。（即外界禁止调用bytestream.write(data)）</li>
<li>其次关于这个问题，我们应当看eof位于哪里。</li>
<li>如果eof已经加入了bytestream，则接下来的push_segment直接返回。因为此时bytestream已经关闭了，再往receive_window中加也没有意义，并且逻辑上来讲就不该再有字节。</li>
<li>如果eof只是在receive_window中，也即还并没有加入bytestream，则正常push_segment。(因为此时receive_window中eof之前 还并没有形成连续的字节。)直到接收窗口中字节重组完毕 连带着eof加入bytestream。</li>
</ul>
</li>
</ul>
</li>
<li>对于字节流中的同一下标位置，是否会出现不同的字节？也即对于同一index，是否会出现不同的data？该如何处理？<ul>
<li>本实验中认为不会出现这种不一致的情况，也即外界调用push_segment 传给reassembler的字节流是一个唯一的字节流，且所有的segment 是字节流的正确的一个个切片。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>感觉大部分时间都画在搞懂实验要求上了。。<br>明确我们要实现的是个接收窗口之后 就好办很多了</p>
<ul>
<li>代码拆开见下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! \details This function accepts a substring (aka a segment) of bytes,</span></span><br><span class="line"><span class="comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span></span><br><span class="line"><span class="comment">//! contiguous substrings and writes them into the output stream in order.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">bool</span> eof)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  corner case 1 : data empty </span></span><br><span class="line">    <span class="keyword">if</span>(data.empty() &amp;&amp; (!eof))</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//  corner case 2 : data empty and eof</span></span><br><span class="line">    <span class="keyword">if</span>(data.empty() &amp;&amp; eof)</span><br><span class="line">    &#123;</span><br><span class="line">        _output.end_input();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _first_unread = _output.bytes_read();</span><br><span class="line">    _first_unassembled = _output.bytes_written();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1. 将data的相应部分 正确的放入receving window   O(n)</span></span><br><span class="line">    <span class="comment">//  (1). data全部是已经排好序的老数据，即data全部是已经加入bytestream _output的数据,</span></span><br><span class="line">    <span class="comment">//  则不必加入bytestream，也不必有其他操作</span></span><br><span class="line">    <span class="keyword">if</span> (index + data.size() &lt; _first_unassembled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//  nothiing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  (2). data全部是还没加入bytestream output的数据</span></span><br><span class="line">    <span class="comment">//  则将其加入_receving_window、这里可能会重复加入，效率低，不过先无所谓了，保证正确性再说别的。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= _first_unassembled &amp;&amp; index &lt; first_unacceptable()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            _receving_window[index + i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        last_idx = index + len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  (3).  data全部位于receving_window范围之外</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &gt;= first_unacceptable()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">//  nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  (4). data一部分加入 一部分没加入bytestream</span></span><br><span class="line">    <span class="comment">//  则截取相应部分落入recv_window</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; _first_unassembled &amp;&amp; index + data.size() &gt;= _first_unassembled) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            _receving_window[_first_unassembled + i] = data[i + start_idx];</span><br><span class="line">        &#125;</span><br><span class="line">        last_idx = _first_unassembled + len;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sth unknown happened!!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eof &amp;&amp; index + data.size() &lt;= first_unacceptable()) &#123;      <span class="comment">//  注意是 &lt;= 。eof本身并不占据字节流中的位置(stream_idx)，只是标记结束。</span></span><br><span class="line">        _eof = <span class="literal">true</span>;</span><br><span class="line">        _eof_idx = last_idx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;============receving window to bytestream=============&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> old_first_unacceptable = first_unacceptable();</span><br><span class="line">    <span class="comment">//  2.  将recv_window中已经顺序的加入bytestream</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = _first_unassembled; i &lt;= old_first_unacceptable; ++i) &#123;     <span class="comment">//  == first_unacceptable 仅仅是为了eof可能出现在first_unacceptable处。</span></span><br><span class="line">        <span class="keyword">if</span>(i == _eof_idx &amp;&amp; _eof)</span><br><span class="line">        &#123;</span><br><span class="line">            _output.end_input();</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == old_first_unacceptable)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_receving_window.find(i) == _receving_window.end())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  从recving_window进入bytestream</span></span><br><span class="line">        _output.write(<span class="built_in">string</span>(<span class="number">1</span>,_receving_window[i]));</span><br><span class="line">        <span class="comment">//  从recving_window中移除</span></span><br><span class="line">        _receving_window.erase(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab5</title>
    <url>/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/</url>
    <content><![CDATA[<ul>
<li><p>关于如何发送TCP segment</p>
<ul>
<li>user负责 TCP</li>
<li>user负责 TCP,IP</li>
<li>user负责 TCP IP Ethernet</li>
<li>CS144目标实现的就是从TCP到Ethernet全部在用户态实现.</li>
<li>Ethernet报文的封装和解封装就由NetWorkInterface来做</li>
</ul>
</li>
<li><p>实现一个NetWorkInterface</p>
<ul>
<li>发送IP datagram –封装–&gt; <strong>linker-layer frame</strong></li>
<li>接收 linker-layer frame —解封–&gt; IP datagram</li>
<li>在执行封装IP datagram成linker-layer frame时 , 需要ip-&gt;mac地址,这时就需要用到<strong>arp协议</strong><ul>
<li>涉及处理 arp table , 缓存未知mac的ipdatagram等</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>本实验，我们将到达协议栈的最底层 并实现一个 InetWork Interface : 一个将Internet Datagram 送入世界的桥梁 ; 并且实现在每一跳之间传送的链路层Ethernet以太网帧(frame).</p>
<ul>
<li>这个InetWork Interface组件适用于你之前实现的TCP/IP的底层 , 并且可以以另一种不同的上下文使用 : 当你在lab6中建立了路由器router,其将在network interface之间路由datagrams. Figure 1 展示了network interface在主机和路由器两种上下文下的层次位置<br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-08-09-26-11.png"></li>
</ul>
</li>
<li><p>在过去的实验中 你实现了一个可以成功和其他主机交流TCP segment . 这些segment 实际上到底是如何传送到对端的tcp呢 ? 有以下几个选项</p>
</li>
<li><p>How are these segments actually conveyed to the peer’s TCP implementation?</p>
</li>
</ul>
<h2 id="如何封装并发送TCP-segment"><a href="#如何封装并发送TCP-segment" class="headerlink" title="如何封装并发送TCP segment"></a>如何封装并发送TCP segment</h2><h3 id="TCP-in-UDP-in-IP"><a href="#TCP-in-UDP-in-IP" class="headerlink" title="TCP-in-UDP-in-IP"></a>TCP-in-UDP-in-IP</h3><p><strong>TCP-in-UDP-in-IP</strong></p>
<ul>
<li><p>TCP segment 可以作为 user datagram 的 payload. 当tcp运行在用户态 , 这是一种最简单的实现.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Ethernet Header # IP Header # UDP Header # [ TCPSegment (TCP Header # Http # payload) ]  </span><br></pre></td></tr></table></figure></li>
<li><p>Linux提供了一个udp socket的接口 </p>
<ul>
<li>code : class UDPSocket -&gt; socket(AF_INET, SOCK_DGRAM , 0)</li>
<li>udp socket的user只需提供user datagram(udp datagram)的payload 和 目标 address(ip and port). kernel的send接口如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msghdr message&#123;&#125;;</span><br><span class="line">message.msg_name = <span class="keyword">const_cast</span>&lt;sockaddr *&gt;(destination_address);</span><br><span class="line">message.msg_namelen = destination_address_len;</span><br><span class="line">message.msg_iov = iovecs.data();</span><br><span class="line">message.msg_iovlen = iovecs.size();</span><br><span class="line">sendmsg(fd_num, &amp;message, <span class="number">0</span>);   </span><br><span class="line"><span class="comment">//  msghr message : 目标ip和port(sockaddr*) + 要发送数据payload</span></span><br><span class="line"><span class="comment">//  本lab中 该sendmsg 用于通过udp socket fd 发送 udp segment</span></span><br><span class="line"><span class="comment">//  udp 的 payload 为 tcp segment. 存入 msghdr</span></span><br></pre></td></tr></table></figure></li>
<li>kernel 负责构造UDP header , IP header 和 Ethernet header , 然后将packet发送到正确的下一跳(next hop)</li>
<li>kernel 负责确保 每个socket都由独占的 本地和远端的端口组合(exclusive combination of local and remote addresses and port numbers).</li>
<li>由于kernel 负责构造 UDP 和 IP header , 他会保证不同应用之间的独立 </li>
</ul>
</li>
<li><p>听起来很神奇是吧，居然udp的负载是tcp segment. code见下<br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-20-09-15-12.png"></p>
</li>
</ul>
<h3 id="TCP-In-IP"><a href="#TCP-In-IP" class="headerlink" title="TCP-In-IP"></a>TCP-In-IP</h3><p><strong>TCP-in-IP</strong></p>
<ul>
<li><p>普遍情况下 , TCP Segment 是直接放入 Internet datagram中的 , 没有udp header夹在 ip header和tcp header之间</p>
<ul>
<li>这就是人们所说的 <strong>“TCP/IP”</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Ethernet Header # IP Header # [ TCPSegment (TCP Header # Http Header # payload) ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>比上一个难实现一点. Linux 提供接口 : <strong>TUN device</strong></p>
<ul>
<li>让应用提供完整的Internet datagram. 也即应用需要提供IP Header 而不仅仅是payload</li>
<li>kernel 负责剩余部分 <ul>
<li>writing the Ethernet header 构造 Ethernet Header </li>
<li>actually sending via the physical Ethernet card 实际通过网卡发送帧 </li>
</ul>
</li>
</ul>
</li>
<li><p>我们已经完整这个了.</p>
<ul>
<li>在lab4中, 我们有一个object 代表 Inernet datagrams 并且 其知道如何解析和序列化自身. (tcp helpers/ipv4_datagram)</li>
<li>The CS144TCPSocket uses these tools to connect your TCPConnection to a TUN device</li>
<li>实验都做完之后 先分析fullstack 然后分析cs144tcp<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! \class TCPSpongeSocket</span></span><br><span class="line"><span class="comment">//! This class involves the simultaneous operation of two threads.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! One, the &quot;owner&quot; or foreground thread, interacts with this class in much the</span></span><br><span class="line"><span class="comment">//! same way as one would interact with a TCPSocket: it connects or listens, writes to</span></span><br><span class="line"><span class="comment">//! and reads from a reliable data stream, etc. Only the owner thread calls public</span></span><br><span class="line"><span class="comment">//! methods of this class.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! The other, the &quot;TCPConnection&quot; thread, takes care of the back-end tasks that the kernel would</span></span><br><span class="line"><span class="comment">//! perform for a TCPSocket: reading and parsing datagrams from the wire, filtering out</span></span><br><span class="line"><span class="comment">//! segments unrelated to the connection, etc.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! There are a few notable differences between the TCPSpongeSocket and TCPSocket interfaces:</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! - a TCPSpongeSocket can only accept a single connection</span></span><br><span class="line"><span class="comment">//! - listen_and_accept() is a blocking function call that acts as both [listen(2)](\ref man2::listen)</span></span><br><span class="line"><span class="comment">//!   and [accept(2)](\ref man2::accept)</span></span><br><span class="line"><span class="comment">//! - if TCPSpongeSocket is destructed while a TCP connection is open, the connection is</span></span><br><span class="line"><span class="comment">//!   immediately terminated with a RST (call `wait_until_closed` to avoid this)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! Helper class that makes a TCPOverIPv4SpongeSocket behave more like a (kernel) TCPSocket</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CS144TCPSocket</span> :</span> <span class="keyword">public</span> TCPOverIPv4SpongeSocket &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CS144TCPSocket();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">const</span> Address &amp;address)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="TCP-in-IP-in-Ethernet"><a href="#TCP-in-IP-in-Ethernet" class="headerlink" title="TCP-in-IP-in-Ethernet"></a>TCP-in-IP-in-Ethernet</h3><p><strong>TCP-in-IP-in-Ethernet</strong></p>
<ul>
<li>在TCP-in-IP方法中 , 我们依然依赖于Linux kernel 去实现部分networking stack.<ul>
<li>每次我们的code write一个IP datagram到TUN device , Linux kernel需要负责创建一个正确的链路层frame(如Ethernet frame). 将我们的IPdatagram作为帧的payload.</li>
<li>这就意味着Linux kernel需要负责依据给定的IP addr , 来找出下一跳的正确Mac addr ; 如果 kernel还不知道该&lt; ip-mac &gt; , 其需要广播一个ARP查询分组 (asks, “Who claims the following IP address? What’s your Ethernet address?” and waits for a response.)</li>
<li>这些函数由network interface负责执行<ul>
<li><strong>network interface 功能 :  转换 IP datagram和 linker-layer frame(Ethernet)</strong> </li>
<li><strong>在真实系统中 , network interface 的经典命名是(eth0, eth1, wlan0, etc.)</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>lab5</strong> , 实现<strong>network interface</strong> , 并将其插入到我们TCP/IP协议栈的最底层. <ul>
<li>我们的代码将生成未经加工的 Ethernet frame. </li>
<li>该frame会被传递给Linux的<strong>TAP device</strong>(比 TUN device更底层). TAP device传输未经加工的我们生成的linker-layer frames.</li>
<li>下图中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Ethernet Header # IP Header # UDP Header # [ TCPSegment (TCP Header # Http # payload) ]  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/293658778">TAP device介绍</a><ul>
<li>tap是链路层的虚拟网络设备，等同于一个以太网设备，它可以收发第二层数据报文包，如以太网数据帧。Tap最常见的用途就是做为虚拟机的网卡，因为它和普通的物理网卡更加相近，也经常用作普通机器的虚拟网卡。</li>
<li><strong>TAP device接收上层构造好的链路层帧(link-layer frames)并直接发送出去 ;</strong> </li>
<li><strong>TUN device接收上层的IP数据报(IP datagrams) , TUN负责构造链路层帧(link-layer frames) 再发送出去</strong></li>
<li><blockquote>
<p><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-08-11-00-35.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>network interface的主要工作都在于ARP协议 : 获取IP addr对应的 Ethernet addr.</li>
</ul>
<h2 id="地址解析协议-Address-Resolution-Protocol"><a href="#地址解析协议-Address-Resolution-Protocol" class="headerlink" title="地址解析协议 Address Resolution Protocol"></a>地址解析协议 Address Resolution Protocol</h2><ul>
<li><p><strong>ARP : Address Resolution Protocol</strong></p>
<ul>
<li><strong>负责网络层地址(IP地址)和链路层地址(MAC地址)的转换</strong><br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-07-11-51-58.png"> </li>
</ul>
</li>
<li><p>在LAN上的每个IP节点都有一个ARP表</p>
</li>
<li><p>ARP表：包括一些LAN节点IP/MAC地址的映射</p>
<ul>
<li>&lt; IP address; MAC address; TTL&gt; </li>
<li>TTL时间是指MAC地址映射失效的时间 ,典型是20min<br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-07-11-57-06.png"></li>
</ul>
</li>
<li><p>A要发送帧给B(B的IP地址已知),A需要根据ipB解析出macB.</p>
<ul>
<li>如果arp table中有该ipB的entry，那么易得mac地址</li>
<li>如果arp table中没有该ipB的entry(如222.222.222.222)，那么如何 ?<ul>
<li><strong>A广播包含B的IP地址的ARP查询包</strong><ul>
<li>ARP查询分组</li>
<li>目的地址使用MAC广播地址，子网LAN上的所有节点都会收到该查询包<ul>
<li>Dest MAC address = FF-FF-FF-FF-FF-FF </li>
</ul>
</li>
<li>子网中的其他适配器接收到该用于arp查询的帧，将该帧中的ARP分组向上传递给arp模块，arp模块检验该arp分组要查询的ip地址是否是本机的ip地址. <ul>
<li>无论是否匹配 , 都缓存下收到的该查询分组&lt; sender_ip - sender_mac_addr &gt; </li>
<li>若匹配, B给A发送回一个响应ARP分组，告知其B的MAC地址 ; 该响应分组的目的地址为A的MAC地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>ARP报文结构</strong><br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-07-17-21-02.png"></p>
</li>
<li><p>ARP是即插即用的 : 节点自己创建ARP的表项  ; 无需网络管理员干预</p>
</li>
<li><p>ARP协议是网络层协议还是链路层协议.</p>
<ul>
<li>ARP分组既包含链路层地址，又包含网络层地址.</li>
<li>将ARP看成是跨越链路层和网络层边界的协议<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">===================</span><br><span class="line">    传输层 </span><br><span class="line">    TCP/UDP</span><br><span class="line">===================</span><br><span class="line">    网络层</span><br><span class="line">    ICMP</span><br><span class="line">    IP</span><br><span class="line">======# ARP #=======</span><br><span class="line">    链路层</span><br><span class="line">    Ethernet 以太网帧</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>A发出的ARP查询报文 , B响应arp分组<ul>
<li>dst_mac src_mac type 是 Ethernet报文字段. 只有mac addr 而没有ip addr</li>
<li>opcode开始 是 arp报文. arp message中既有ip addr又有mac addr. </li>
<li>arp查询分组的目的mac地址是广播地址 , 该BROADCAST地址填入链路层linker-layer(Ethernet)的dst mac addr , 而非 arp 报文字段中的dst mac addr. arp 报文字段中的dst mac addr应该填0<table>
<thead>
<tr>
<th>dst_mac</th>
<th>src_mac</th>
<th>type</th>
<th>opcode</th>
<th>sender_mac</th>
<th>sender_ip</th>
<th>target_mac</th>
<th>target_ip</th>
</tr>
</thead>
<tbody><tr>
<td>FF-FF-FF-FF-FF-FF</td>
<td>mac_A</td>
<td>ARP</td>
<td>REQUET</td>
<td>mac_A</td>
<td>ip_A</td>
<td>00-00-00-00-00-00</td>
<td>ip_B</td>
</tr>
<tr>
<td>mac_A</td>
<td>mac_B</td>
<td>ARP</td>
<td>REPLY</td>
<td>mac_B</td>
<td>ip_B</td>
<td>mac_A</td>
<td>ip_A</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h2 id="接口及实现"><a href="#接口及实现" class="headerlink" title="接口及实现"></a>接口及实现</h2><p><a href="https://github.com/Cstardust/CS144_LAB/blob/master/libsponge/network_interface.cc">code</a> </p>
<p>简单 按照逻辑实现就好 比lab0-4简单多了去了</p>
<ul>
<li><p><strong>class NetworkInterface 重要成员</strong></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">本network interface mac addr</span><br><span class="line"><span class="comment">//! Ethernet (known as hardware, network-access-layer, or link-layer) address of the interface</span></span><br><span class="line">EthernetAddress _ethernet_address;</span><br><span class="line"></span><br><span class="line">本network interface ip addr</span><br><span class="line"><span class="comment">//! IP (known as internet-layer or network-layer) address of the interface</span></span><br><span class="line">Address _ip_address;</span><br><span class="line"></span><br><span class="line">frames to send</span><br><span class="line"><span class="comment">//! outbound queue of Ethernet frames that the NetworkInterface wants sent</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;EthernetFrame&gt; _frames_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arp_table: &lt;mac addr , ttl&gt;</span><br><span class="line"><span class="keyword">using</span> MacAddrInfo = <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;EthernetAddress,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> TTL = <span class="number">30</span> * <span class="number">1000</span>;    <span class="comment">//  keep each &lt;ip-mac&gt; for 30s</span></span><br><span class="line"><span class="comment">//  ARP table : &lt;IP addr , MAC addr&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">uint32_t</span>,MacAddrInfo&gt; _arp_table&#123;&#125;;</span><br><span class="line"></span><br><span class="line">由于不知道ip对应的mac , 等待被发送的datagrams</span><br><span class="line"><span class="comment">//  data buffer : &lt;IP addr , datagrams&gt; </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">uint32_t</span>,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InternetDatagram&gt; &gt; _data_buffer&#123;&#125;;</span><br><span class="line"><span class="comment">//  ip - time_since_last_req</span></span><br><span class="line"></span><br><span class="line">对于每个ip的请求过去的时间</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">uint32_t</span>,<span class="keyword">int</span>&gt; _wait_for_req&#123;&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WAITING_TIME = <span class="number">5</span> * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>network interface 功能 :  在 IP datagram 和 linker-layer frame(Ethernet) 之间转换</strong></p>
<ul>
<li>发送IP datagram -&gt; linker-layer frame</li>
<li>接收 linker-layer frame -&gt; IP datagram</li>
<li>在执行封装ipdatagram成linker-layer frame时 , 需要ip-&gt;mac地址,这时就需要用到<strong>arp协议</strong></li>
</ul>
</li>
<li><p>void NetworkInterface::send_datagram(const InternetDatagram &amp;dgram,const Address &amp;next_hop)</p>
<ul>
<li>This method is called when the caller (e.g., your TCPConnection or a router) wants to send an outbound Internet (IP) datagram to the next hop.1</li>
<li>将 IP datagram 封装成 Ethernet frame , 发送到下一跳next_hop<ul>
<li>需要获取next_hop对应的mac addr<ul>
<li>send TYPE_IPv4 : 已知mac , 则直接使用mac addr,填入ethernet字段,封装成帧,发送</li>
<li>send TYPE_ARP : 未知mac , 广播arp request分组(查询分组封装成帧并发送),将该IP datagram缓存起来 收到arp reply后发送. <ul>
<li>对于同一ip对应的mac 的arp request分组 , 每5s至多发送一个<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (find &lt;ip-mac&gt; <span class="keyword">and</span> <span class="keyword">not</span> expired) &#123;</span><br><span class="line">    <span class="comment">// Encapsulate the IP datagram into Ethernet frame and send it</span></span><br><span class="line">    ethernet_frame = buildEthernetFrame(TYPE_IPv4,<span class="built_in">string</span>(datagram));</span><br><span class="line">    send ipv4 frame</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//   If the network interface already sent an ARP request about the same IP address in the last five seconds, don’t send a second request—just wait for a reply to the first one</span></span><br><span class="line">    <span class="keyword">if</span>(pass <span class="number">5</span>s since last req)</span><br><span class="line">    &#123;</span><br><span class="line">        arp = buildArpRequest(next_hop_ip);</span><br><span class="line">        ethernet_frame = buildEthernetFrame(EthernetHeader::TYPE_ARP,<span class="built_in">string</span>(arp));</span><br><span class="line">        send arp req</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  queue the dgram</span></span><br><span class="line">    _data_buffer[next_hop_ip].push_back(dgram);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>optional<InternetDatagram> NetworkInterface::recv_frame(const EthernetFrame &amp;frame)</InternetDatagram></p>
<ul>
<li>This method is called when an Ethernet frame arrives from the network. The code should ignore any frames not destined for the network interface (meaning, the Ethernet destination is either the broadcast address or the interface’s own Ethernet address stored in the ethernet address member variable).</li>
<li>接收从network中发来的linker-layer frame. </li>
<li>对于不是本网卡需要接收的frame，丢弃<ul>
<li>本网卡接收的frame : frame.dst_mac = local_mac || frame.dst_mac = ff-ff-ff-ff-ff-ff</li>
</ul>
</li>
<li>对于frame的payload<ul>
<li>IPv4 : return the resulting InternetDatagram to the caller.</li>
<li>ARP : <ul>
<li>无论是reply还是request,记录下该分组的&lt; sender_ip - sender_mac &gt; . 每个entry的ttl为30s。<ul>
<li>及时发送之前由于mac未知而缓存的frame</li>
</ul>
</li>
<li>对于arp request , 发送一个arp reply. 封装成帧, 发送.</li>
</ul>
</li>
<li>丢弃<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (checkInValidFrame(frame)) &#123; <span class="comment">//  dst is local mac addr or broad cast</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (recv IPv4) &#123;</span><br><span class="line">    <span class="keyword">return</span> ipv4_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (recv ARP)&#123;</span><br><span class="line">    record &lt;ip-mac&gt; in arp table</span><br><span class="line"></span><br><span class="line">    clear waiting buffer of ip : send waiting datagrams</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arp is REQUEST <span class="keyword">and</span> arp.dst_ip is to us) &#123;</span><br><span class="line">        arp_reply = buildArpReply;</span><br><span class="line">        ethernet_frame = buildEthernetFrame(</span><br><span class="line">            TYPE_ARP, arp_reply.serialize());</span><br><span class="line">        send an ARP reply</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>void NetworkInterface::tick(const size_t ms_since_last_tick)</p>
<ul>
<li>处理ARP table(即IP mac表)中的entry过期(TTL)</li>
<li>处理等待ARP reply的ip</li>
</ul>
</li>
</ul>
<h2 id="over"><a href="#over" class="headerlink" title="over"></a>over</h2>]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab7</title>
    <url>/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/</url>
    <content><![CDATA[<p>使用我们lab0-5实现的协议栈(Host) 以及 lab6实现的router , 来和远端server实现通信</p>
<span id="more"></span>

<ul>
<li>使用我们lab0-5实现的协议栈(Host) 以及 lab6实现的router , 来实现通信.<ul>
<li>原理 : 自己画了一遍也确实是这样<br><img src="/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/2023-02-12-09-37-28.png"></li>
<li>exchange data<br><img src="/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/2023-02-12-08-40-29.png"></li>
<li>sending and recving file over network<br><img src="/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/2023-02-12-09-54-55.png"></li>
</ul>
</li>
</ul>
<p>简单理解relay server : 中继服务器 由于距离过远 , Host不直接将信号发送给彼此，而是通过中继节点，经过信号放大或再生处理进行转发。</p>
<ul>
<li>over!<br><img src="/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/2023-02-12-10-06-40.png"></li>
</ul>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab3</title>
    <url>/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/</url>
    <content><![CDATA[<ul>
<li>实现 TCPSender<ul>
<li>发送新segment : fill_window() when 上层有数据 &amp;&amp; receive_window有空间<ul>
<li>fill_window 负责一直向后走 发送新数据. 更新send_window</li>
<li>重传的部分交由tick()来做</li>
</ul>
</li>
<li>定时器超时重传 : tick()<ul>
<li>更新send_window ; 重启定时器 ; 超时重传 , RTO加倍</li>
<li><a href="https://datatracker.ietf.org/doc/rfc6298/?include_text=1">Retransmission Timer [RFC]</a></li>
</ul>
</li>
<li>收到ACK报文 : ack_received()<ul>
<li>更新rwnd , sender自动继续发送fill_window.(因为rwnd可能变大)</li>
</ul>
</li>
</ul>
</li>
<li>我们Sender并没有实现快速重传(可以不实现，易知不影响其正确性，仍然可以可靠传输)</li>
<li>有趣的是我们Sender并没有实现拥塞控制，但TCP仍然可以正常运行.<ul>
<li>原因如下 : 拥塞控制只是为了TCP的公平性，使得其不会无节制的占用带宽. 如我们的信道中有两条TCP连接，若都实现了拥塞控制，那么最终二者所占带宽会向y=x收敛.</li>
<li>而为了保证己方Sender可以和对端Receiver正常交互，我们只需要保证：<ul>
<li>每个字节都令对方接受到并返回ACK : 重传保证</li>
<li>对端receiver不会由于己方发送过快而导致receiver buf缓存溢出<ul>
<li>这通过流量控制就解决了.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-06-15-35-14.png"></p>
<ul>
<li>lab0中, 我们实现了bytestream</li>
<li>lab1 和 lab2中, 我们实现了StreamReassembler 和 TCPReceiver : 将通过不可靠的datagrams传送来的segment 重组到 bytestream中</li>
<li>lab3中, 我们将实现tcp connection的另一端 : TCPSender：TCPSender 将 outbound bytestream 转化成 不可靠datagrams的负载内容</li>
<li>lab4中，我们将组装lab0123 来实现tcp：一个包含 TCPSender 和 TCPReceiver 的 tcp connection。我们将使用lab4实现的tcp 去和互联网上真实的server进行通信</li>
</ul>
<h2 id="TCP-Sender-概述"><a href="#TCP-Sender-概述" class="headerlink" title="TCP Sender 概述"></a>TCP Sender 概述</h2><ul>
<li>TCP 协议 是一个 在不可靠的 datagram之上 传输可靠 的 流量控制的 字节流 的协议。<br>参与TCP连接的双方 都同时扮演了sender和 receiver的角色。</li>
<li>本周，我们将实现 TCP Sender。TCPSender 负责读取 outbound bytestream ，并将 stream转化成将要发出的一系列 tcp segment。（在对端，TCP receiver 将这些 segment(those that arrive—they might not all make it)重组为原先的字节流，并发送ack 和 window size 给sender。）</li>
<li>TCP sender 和 receiver 各自负责 TCP segment的一部分. <ul>
<li>TCP Sender 添写 lab2 中 TCP receiver 相关的 所有字段 sequence number , syn , fin , payload (其他的在wrap in ip , unwrap in ip)</li>
<li>TCP Sender 只读取 receiver 填写的字段 : ackno , window size<br><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-06-16-53-45.png"></li>
</ul>
</li>
</ul>
<h2 id="TCPSender-责任"><a href="#TCPSender-责任" class="headerlink" title="TCPSender 责任"></a>TCPSender 责任</h2><ul>
<li><p>TCP Sender 负责</p>
</li>
<li><p>关注 receiver window , 处理传入的 ackno 和 window size</p>
</li>
<li><p>填充receiver window : 在可能的时候 通过 读取outbound bytestream ，创建 tcp segment(include syn , fin) 并发送。TCP Sender应当持续发送segment 直到 receiver window满了 或者 bytestream 空了。（没有可发送的segment，即 no data payload(bytestream.eof()) &amp;&amp; no flags)</p>
</li>
<li><p>outstanding segment : 关注sent but not acked 的segment，我们称之为 outstanding segment（未完成的segment，就是之前学的send window).</p>
</li>
<li><p>重传 outstanding segment 当超时（从发送之后开始计时）</p>
</li>
<li><p>我为什么要做这个 ？</p>
<ul>
<li>基本原理是 automatic repeat request(ARQ) : (fill window)sender发送任何receiver允许发送的segment，并且持续重传segment，直到receiver ack了每个segment。</li>
<li>TCP sender 将流切分成segment，并在receiver允许的范围内尽可能地发送他们。</li>
<li>由之前实现易知, tcp receiver 可以重组至少接收到一次的byte；那么Sender需要保证receiver对于每个byte都至少接收到了一次</li>
</ul>
</li>
</ul>
<h2 id="TCPSender如何知道-segment-lost"><a href="#TCPSender如何知道-segment-lost" class="headerlink" title="TCPSender如何知道 segment lost"></a>TCPSender如何知道 segment lost</h2><ul>
<li><p>TCPSender 如何知道一个segment丢失了 ? (即发送方没有接收到 接收方 发送的 对该segment的ack)</p>
</li>
<li><p>TCPSender 将会持续发送一堆segment,每个segment都包含了来自outbound bytestream的substring，每个segment都有一个seqno作为下标来代表其在字节流中的位置,并且用SYN flagstream的开始,FIN flag标记stream的结束。</p>
</li>
<li><p>除了发送segment，TCPSender还需要关注 outstanding segment 直到 其被 ack。</p>
</li>
<li><p>TCP Sender也会周期性的调用tick方法，标记着时间的流逝。</p>
</li>
<li><p>TCP Sender负责 查询所有outstanding segment 然后决定 最老的outstanding segment是否已经超时（长时间没被ack,outstanding for too long）。（这句话就是说在tick的时候 如果定时器超时（全局只有一个最老的outstanding segment的定时器））</p>
<ul>
<li>如果是，则重传该分组</li>
</ul>
</li>
<li><p>Here are outstanding for too long的含义 </p>
<ul>
<li>These are based on a simplified version of the “real” rules for TCP: RFC 6298, recommendations 5.1 through 5.6. The version here is a bit simplified, but your TCP implementation will still be able to talk with real servers on the Internet</li>
<li>你将要实现如下逻辑，有一点详细，但我们不希望你过于教条或者面向case编程。（感觉就是这意思）。lab3将给你一些合理的测试。lab4会给全部测试</li>
</ul>
</li>
<li><p>我为什么要做这个 ?</p>
<ul>
<li>总体目标是 让sender及时检测到segment丢失 并 需要重新发送。</li>
<li>超时时间很重要：你不会希望发送方在重传segment之前等待过长时间（因为这样延迟了字节流向发送方），但是你也不会想重传一个即将收到ack的segment，因为这样会浪费宝贵的网络流量。（重传出去的这个segment就相当于没用了，因为之前发送的该segment的ack马上就收到，而之后再收到的重传的segment的ack就没用了，因为segment已经被ack了，已经不在send_window中了）</li>
</ul>
</li>
<li><ol>
<li>每隔一些微秒，TCPSender 就会调用 tick(elapsed_milliseconds)，来告知tcp sender 举例上次调用tick已经过去了多长时间(elapsed_milliseconds)。</li>
</ol>
<ul>
<li>使用tick来维护TCPSender处于活跃状态的总微秒数。不要调用syscall 如 time,clock function. tick 是我们操作时间流逝的唯一途径。这使得事情具有确定性和可测试性。</li>
</ul>
</li>
<li><ol start="2">
<li>TCPSender 在构建是就会初始化 retransmission timeout (RTO) 的初始值(initial retransmission timeout)</li>
</ol>
<ul>
<li>RTO是超时时间。RTO的值 会随着超时次数变化，但是初始值不变。</li>
</ul>
</li>
<li><ol start="3">
<li>你将实现 重传定时器retransmission timer : 一个可以计时 RTO时间 时钟。当RTO过去之后，alarm goes off 报警。我们强调通过tick method来获取时间流逝的概念 而非通过获取真实的时间。</li>
</ol>
</li>
<li><ol start="4">
<li>每次发送segment时（nonzero length in sequence space），不管是第一次发送该报文还是重传该报文，如果timer没有启动，那么启动timer，这样RTO之后，timer就会expire过期(感觉可以理解成报警）。</li>
</ol>
</li>
<li><ol start="5">
<li>当所有的outstanding data都被ack了，那么停止 retransmission timer</li>
</ol>
</li>
<li><ol start="6">
<li>调用tick , timer过期</li>
</ol>
<ul>
<li>a. 重传outstanding segment中 最早发送的segment(lowest sequence number)。<pre><code>为实现此功能，你需要用一个数据结构来存储这些outstanding segment
</code></pre>
</li>
<li>b. if receiver window size != 0 <ul>
<li>i. 关注consecutive retransmissions，当重传sth时 ++cnt。<ul>
<li>你的TCP连接将使用该信息，来决定一条连接是否已经没有希望，需要被放弃.(当重传次数cnt过多时)</li>
</ul>
</li>
<li>ii. RTO *= 2 , 减缓了我们在糟糕的网络上进行重传，以免进一步把事情搞糟(拥塞控制这就是 ?)</li>
</ul>
</li>
<li>c.  重置timer 并启动timer，使其在RTO之后过期（注意RTO可能翻倍） </li>
<li>可以看到，在tick函数的具体实现里，基本就是完全照着这abc三步做的</li>
</ul>
</li>
</ul>
<ul>
<li><ol start="7">
<li>当发送端接收了接收方发送的确认新数据的ackno时（ackno比之前接收到的ackno都要大）（就是说ackno确认了outstanding的segment(即send window中的segment)）</li>
</ol>
<ul>
<li>a. 重置RTO = initial(我的实现是将RTO交给timer保管)</li>
<li>b. 如果TCP Sender有任何outstanding segment，那么重启timer</li>
<li>c. 重置consecutive retransmissions = 0</li>
</ul>
</li>
</ul>
<h2 id="Retransmission-Timer-RFC"><a href="#Retransmission-Timer-RFC" class="headerlink" title="Retransmission Timer [RFC]"></a>Retransmission Timer [RFC]</h2><p><a href="https://datatracker.ietf.org/doc/rfc6298/?include_text=1">RFC 中 共识的 TCP retransmission timer 实现</a></p>
<ul>
<li><ol start="5">
<li> Managing the RTO Timer</li>
</ol>
<ul>
<li>An implementation MUST manage the retransmission timer(s) in such a<br>way that a segment is never retransmitted too early, i.e., less than<br>one RTO after the previous transmission of that segment.</li>
<li>The following is the RECOMMENDED algorithm for managing the<br>retransmission timer:</li>
<li>(5.1) Every time a packet containing data is sent (including a<pre><code> retransmission), if the timer is not running, start it running
 so that it will expire after RTO seconds (for the current value
 of RTO).
</code></pre>
</li>
<li>(5.2) When all outstanding data has been acknowledged, turn off the<pre><code> retransmission timer.
</code></pre>
</li>
<li>(5.3) When an ACK is received that acknowledges new data, restart the<pre><code> retransmission timer so that it will expire after RTO seconds
 (for the current value of RTO).
</code></pre>
</li>
<li>When the retransmission timer expires, do the following:<ul>
<li>(5.4) Retransmit the earliest segment that has not been acknowledged<br>   by the TCP receiver.</li>
<li>(5.5) The host MUST set RTO &lt;- RTO * 2 (“back off the timer”).  The<br>   maximum value discussed in (2.5) above may be used to provide<br>   an upper bound to this doubling operation.</li>
<li>(5.6) Start the retransmission timer, such that it expires after RTO<br>   seconds (for the value of RTO after the doubling operation<br>   outlined in 5.5).</li>
<li>(5.7) If the timer expires awaiting the ACK of a SYN segment and the<br>   TCP implementation is using an RTO less than 3 seconds, the RTO<br>   MUST be re-initialized to 3 seconds when data transmission<br>   begins (i.e., after the three-way handshake completes).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>next_seqno_abs : sender要发送的下一个字节的绝对索引，syn和fin也会占据一个字节。<br>bytes_in_flight : bytes sent but not acked</p>
<p><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-07-00-17-39.png"></p>
<ul>
<li><p><strong>State</strong></p>
<ul>
<li>为了测试你的代码，test会期待你的sender经历一系列状态：从发送第一个syn报文，到发送所有数据，到发送fin报文，以及最终获得fin的ack。我们不认为你需要设计更多的变量来追踪这些状态。这些状态被简单的定义在tcp sender的接口中。但是为了让你理解test的输出，这里有一个tcpsender在stream的生命中的演化图。你不必要担心error state 或者 rst flag 直到lab4</li>
</ul>
</li>
<li><p><strong>CLOSED</strong> : waiting for stream to begin</p>
<ul>
<li>next_seqno_absolute() = 0</li>
<li>字节流中还没有任何字节，连最一开始的syn segment也没有发送</li>
</ul>
</li>
<li><p><strong>SYN_SENT</strong> : stream started but nothing acked</p>
<ul>
<li>sender发送了第一个syn报文(可能携带数据)(可能也接着发送了其他带data得segment)，但是sender还没有收到receiver对该syn报文的ack</li>
<li>next_seqno_absolute() == bytes_in_flight() &amp;&amp; next_seqno_absolute() &gt; 0<ul>
<li>next_seqno_absolute() == bytes_in_flight() : syn 和 data segment 都在 send_window中</li>
<li>next_seqno_absolute() &gt; 0 : 至少有一个syn了 </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SYN_ACKED</strong> : stream outgoing</p>
<ul>
<li>sender已经接收到了 syn 的 ack，那么syn就不会在bytes_in_flight中占据字节了（即不会在send window中占据字节了），但是syn仍然一直占据着abs_seqno空间里的0号位置。故会next_seqno_abs &gt; bytes_in_flight）</li>
<li>next_seqno_absolute() &gt; bytes_in_flight() &amp;&amp; not stream_in().eof()<ul>
<li>next_seqno_absolute() &gt; bytes_in_flight() : syn 不在 send_window中 (即syn已经acked)</li>
<li>not stream.eof() : stream还没到结尾</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>SYN_ACKED (also)</strong> ： stream outgoing (stream has reached EOF , but FIN flag hasn’t been sent yet)</p>
<ul>
<li>sender的stream已经到eof了，但是sender还没有发送FIN seg</li>
<li>outbound_stream.eof() &amp;&amp; next_seqno_absolute() &lt; outbound_stream.bytes_written() + 2;</li>
<li>那么sender应该何时发送fin seg : <ul>
<li>在sender 处于syn_acked(also)状态时，且此时接受窗口的大小 还能装下 当前seg(syn + data)附带上一个fin flag,那么，发送fin segment</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>FIN_SENT</strong> : stream finished(FIN sent) but not fully acked</p>
<ul>
<li>sender 已经 发送了 fin segment 但是还没有接收到 fin segment的ack</li>
<li>也即 sender 已经 将outbound stream的 字节全部发送出去，并发送了代表关闭的fin seg ， 但是sender还没有收到receiver对outbound stream中的所有字节的确认（因为fin还没被确认）</li>
<li>bytes_in_flight() &gt; 0 &amp;&amp; outbound_stream.eof() &amp;&amp; next_seqno_abs() == outbound_stream.bytes_written() + 2 &amp;&amp; bytes_in_flight() &gt; 0<ul>
<li>bytes_in_flight() &gt; 0 : 至少有一个fin segment sent but not acked</li>
<li>outbound_stream.eof() : 好理解，outbound已经走到了eof</li>
<li>next_seqno_abs() == outbound_stream.bytes_written() + 2 : 已经发送了fin<ul>
<li>next_seqno_abs = fin seq + 1。</li>
<li>好比outbound_stream发送了abcdef,那么下标为<ul>
<li>////   0  1 2 3 4 5 6 7   8///</li>
<li>////  syn a b c d e f fin ////</li>
<li>易知 next_abs_seq = 8</li>
<li>同时，outbound_stream.bytes_written() = 6 , 因为bytestream 并不会将 syn fin 作为占据stream_idx的字节。故+2 = next_seqno_abs</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>FIN_ACKED</strong> : stream finished fully acked<ul>
<li>outbound_stream的字节已经全部被acked</li>
<li>outbound_stream.eof() &amp;&amp; next_seq_abs = outbound_stream.bytes_written() + 2 &amp;&amp; bytes_in_flight() == 0<ul>
<li>outbound_stream.eof() : outbound_stream已经走到of</li>
<li>next_seq_abs = outbound_stream.bytes_written() + 2 : sender已经发送fin</li>
<li>bytes_in_flight() == 0 : sender没有sent but not acked 的segment（ -&gt; fin segment已经被acked）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="TCPSender-实现"><a href="#TCPSender-实现" class="headerlink" title="TCPSender 实现"></a>TCPSender 实现</h2><ul>
<li>We’ve discussed the basic idea of what the TCP sender does (given an outgoing ByteStream, split it up into segments, send them to the receiver, and if they don’t get acknowledged soon enough, keep resending them). And we’ve discussed when to conclude that an outstanding segment was lost and needs to be resend.</li>
</ul>
<ul>
<li><p>TCPsender 主要关注以下几类事件</p>
<ul>
<li>发送新segment : fill_window() when 上层有数据 &amp;&amp; receive_window有空间</li>
<li>定时器超时重传 : tick()</li>
<li>收到ACK报文 : ack_received()<ul>
<li>维护receive_window</li>
<li>新ackno : 更新recv_window</li>
<li>老ackno : 我的实现是忽略·<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">event: <span class="function">data received from application above </span></span><br><span class="line"><span class="function">  create TCP segment with sequence number NextSeqNum </span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(timer currently <span class="keyword">not</span> running)</span> </span></span><br><span class="line"><span class="function">    start timer pass segment to IP </span></span><br><span class="line"><span class="function">  NextSeqNum </span>= NextSeqNum + length(data) </span><br><span class="line"></span><br><span class="line">event: timer timeout </span><br><span class="line">  retransmit <span class="keyword">not</span>-yet-acknowledged segment with smallest sequence number </span><br><span class="line">  start timer </span><br><span class="line"></span><br><span class="line">event: ACK received, <span class="function">with ACK field value of y </span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(y &gt; SendBase)</span> </span>&#123; </span><br><span class="line">    SendBase = y</span><br><span class="line">    <span class="keyword">if</span> (there are currently <span class="keyword">not</span>-yet-acknowledged segments) </span><br><span class="line">      start timer </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>接口如下。这四个接口每个都可能以发送tcp segment作为结尾</p>
</li>
</ul>
<h3 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h3><ul>
<li>图<br><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-09-22-03-33.png"></li>
</ul>
<p>约定outstanding segment : segment sent but not acked<br>约定超时时间：在重传一个outstanding segment之前所等待的时间。（从该segment被发送出去之后开始计时）<br>约定rwnd :  receive_window_size<br>约定 earliest outstanding segment : 最早发送的outstanding segment，即 send_window的左边界的segment的timer。<br>约定：携带数据的segment：即占据了sequence num的分组，即syn + payload + fin 不为空</p>
<ul>
<li><p><strong>_next_seqno{0}</strong></p>
<ul>
<li>含义：sender将要发送的下一个byte 在 字节流中的 abs_seqno</li>
<li>_next_seqno 是 单增的，只从stream中读取新数据来发送，而不管需要超时重传的数据。</li>
</ul>
</li>
<li><p><strong>约定 : send_window</strong>(中科大郑老师这么叫的，不过书上和rfc似乎没有这种叫法hhh)</p>
<ul>
<li>即将 bytes_in_flight 的 bytes 都称为落在 send_window中的bytes</li>
<li>即将 outstanding segment 都称为落在send_window中的segment</li>
<li><strong>[last_ackno , _next_seqno)</strong></li>
<li><strong>bytes sent but not acked : sebder已经发送但还没被接收到ack确认的字节</strong></li>
<li>随着sender接收到的ack_no的增大，send_window的左端也随之增大</li>
<li>随着sender发送新segment(_next_seqno增大)，send_window的右端也随之增大</li>
<li>实现<ul>
<li><strong><code>deque&lt;TCPSegment&gt; _send_window&#123;&#125;</code></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>std::queue<TCPSegment> _segments_out{};</TCPSegment></strong></p>
<ul>
<li>sender发送segment：将 segment 压入queue </li>
</ul>
</li>
<li><p><strong>size_t _receive_window_size{1}</strong></p>
<ul>
<li>sender认为receive_window_size</li>
<li><strong>rwnd初始化为1</strong>（在还没有接收到接收方的任何ack报文时）<ul>
<li><strong>原因 ？</strong>：我觉得为了使得sender可以发送出第一个SYN报文？不然会一直等待</li>
<li><strong>或许rfc中有</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>unsigned int _initial_retransmission_timeout</strong></p>
<ul>
<li>retransmission timer for the connection</li>
</ul>
</li>
<li><p><strong>Timer _timer</strong></p>
<ul>
<li>TCPSender全局只有一个定时器</li>
<li>该timer监测：earliest outstanding segment</li>
<li>该timer超时，重传earliest outstanding segment</li>
<li>sender的使用者通过tick()来使用_timer</li>
</ul>
</li>
<li><p>ByteStream _stream</p>
<ul>
<li>outgoing stream of bytes that have not yet been sent</li>
</ul>
</li>
<li><p><strong>uint64_t _consecutive_retransmissions_cnt;</strong></p>
<ul>
<li>对于同一分组的 重传次数</li>
</ul>
</li>
<li><p>enum <strong>State</strong> { ERROR = 0, CLOSED , SYN_SENT, SYN_ACKED_1,SYN_ACKED_2,FIN_SENT,FIN_ACKED,};</p>
<ul>
<li>见State</li>
</ul>
</li>
</ul>
<h3 id="fill-window"><a href="#fill-window" class="headerlink" title="fill_window"></a>fill_window</h3><ul>
<li><p><strong>fill_window含义: 从outbound_stream中读取新数据（还没发送过的数据），依据receive_window大小，尽可能多的发送出去。该方法并不负责重传segment，重传segment由tick方法负责。</strong></p>
</li>
<li><p><strong>fill_window 到什么时候停止发送 segment ?</strong></p>
<ul>
<li>只要同时满足AB两个条件，就一直发送segment<ul>
<li>(as long as there are new bytes to be read and space available in the window.) </li>
<li>A. 还有segment可以发送 <ul>
<li>payload!=0 (outbound_bytestream 中还有可读字节) + 需要发送 syn / fin flag </li>
</ul>
</li>
<li>B. receive_window还有空间</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>在正确的时刻发送syn和fin flag</strong></p>
<ul>
<li>发送syn flag<ul>
<li>TCP Sender 处于 CLOSED 状态 : 字节流中还没有任何字节，连最一开始的syn segment也没有发送</li>
</ul>
</li>
<li>发送fin flag<ul>
<li>TCP Sender 处于 SYN_ACKED_2 状态 : TCP Sender的stream已经到eof了，但是TCP Sender还没有发送FIN seg</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>发送segment</strong> : _segment_out.push(seg)</p>
</li>
<li><p><strong>start timer</strong> : 如果没有开启定时器（send_window empty之后 第一次发送数据），那么重新开启定时器 </p>
</li>
<li><p>更新_next_seqno</p>
<ul>
<li>_next_seqno含义：将要发送的下一个byte 在 字节流中的 abs_seqno</li>
<li>_next_seqno 是 单增的，只从stream中读取新数据来发送，而不管需要超时重传的数据。</li>
<li>代表sender将要发送到第几个字节了。</li>
</ul>
</li>
<li><p><strong>当sender收到receiver声明的rwnd = 0时，sender应当保持发送1byte的segment给receiver</strong></p>
<ul>
<li><strong>代码体现</strong>：调用fill_window时，若<strong>receive_window_size = 0</strong> , 则 fill_window() 先将其<strong>视为1</strong>。</li>
<li><strong>为什么sender要发送1 byte的segment？</strong><ul>
<li>其实感觉就是一个<strong>探测报文</strong>的作用，<strong>sender为了及时获知receiver的receive_window是否有了空闲空间。</strong><ul>
<li>如果receiver没有空闲空间，那么sender发送的这个segment就被receiver丢弃，且sender也不会收到任何报文</li>
<li>如果receiver有空闲空间，那么就会接收该探测segment到receive_window中，且发送一个携带了receive_window_size的ack segment给sender。sender得知rwnd之后，会fill_window。</li>
</ul>
</li>
<li>既然是为了起到探测报文的作用，自然发送的大小越小越好，所以其payload = 1byte。</li>
</ul>
</li>
<li><blockquote>
<p>如《自顶向下》中所说</p>
</blockquote>
<ul>
<li><blockquote>
<p>假设receiver 的 receive_window_size = 0, 在将rwnd告知sender后，还要假设receiver没有任何数据要发送给sender。此时，考虑发生什么情况：</p>
</blockquote>
</li>
<li><blockquote>
<p>因为TCP中，receiver只在有数据或者有确认要发送时，才会给sender发送segment，因此在receiver将接收缓存清空的过程中以及清空后，receiver不会给sender发送任何带有rwnd新值的报文。</p>
</blockquote>
</li>
<li><blockquote>
<p>那么 sender就永远也无法得知  receiver的 receive_window中有空闲空间了(rwnd!=0)，那么sender就被阻塞而永远也不会发送新数据。（如fill_window中，如果按照receive_window_size = 0来运行，那么不会发送数据）。</p>
</blockquote>
</li>
<li><blockquote>
<p>为解决该问题，TCP规范中要求：当sender认为receiver的receive_window_size = 0时，sender继续发送只有1个byte数据的报文段，这些segment最终会被receiver确认（因为receiver的receve_window迟早会出现空闲空间），receiver会向sender发送对该1byte的segment的ack segment（其中会有新的receive_window_size）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>fill_window核心逻辑</strong>: </p>
<ul>
<li><ol>
<li>计算 remaining_recv_window，然后开始发送segment，直到消耗完recv_window_space</li>
</ol>
</li>
<li><ol start="2">
<li>创建tcp segment</li>
</ol>
<ul>
<li>syn + payload from bytestream + fin</li>
</ul>
</li>
<li>3.1 发送tcp segment<ul>
<li>_segments_out.push(seg);</li>
</ul>
</li>
<li>3.2 存入send_window<ul>
<li>_send_window.push_back(seg);</li>
</ul>
</li>
<li><ol start="4">
<li>start timer if need</li>
</ol>
</li>
<li><ol start="5">
<li>update vars such as_next_seqno<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  try to send segment to fill the receive window</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. 计算 remaining_recv_window</span></span><br><span class="line">    <span class="keyword">size_t</span> remaining_recv_window_sz = _receive_window_size == <span class="number">0</span> ? <span class="number">1</span> : _receive_window_size;</span><br><span class="line">    <span class="keyword">if</span>(bytes_in_flight() &gt; remaining_recv_window_sz)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    remaining_recv_window_sz -= bytes_in_flight();</span><br><span class="line">    <span class="comment">//  开始发送segment</span></span><br><span class="line">    <span class="keyword">while</span>(remaining_recv_window_sz &gt; <span class="number">0</span>)     <span class="comment">//  check B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  2. build tcpsegment</span></span><br><span class="line">        TCPSegment seg;</span><br><span class="line">            seg.header().seqno = next_seqno();</span><br><span class="line">            <span class="comment">//  syn flag</span></span><br><span class="line">            <span class="keyword">if</span>(state() == State::CLOSED)    <span class="comment">//  remain_recv_window_sz &gt;= 1 （肯定的）</span></span><br><span class="line">                seg.header().syn = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  payload</span></span><br><span class="line">            <span class="keyword">size_t</span> payload_sz = min(&#123;TCPConfig::MAX_PAYLOAD_SIZE,remaining_recv_window_sz - seg.header().syn,_stream.buffer_size()&#125;);</span><br><span class="line">            seg.payload() = _stream.read(payload_sz);       </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//  fin flag</span></span><br><span class="line">            <span class="comment">//  疑问a</span></span><br><span class="line">            <span class="keyword">if</span>(state() == SYN_ACKED_2 &amp;&amp; remaining_recv_window_sz &gt; payload_sz + seg.header().syn)</span><br><span class="line">                seg.header().fin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  check A : 如果这个segment 既没有 flag 如 syn fin；又没有 payload 则 不必发送该seg</span></span><br><span class="line">        <span class="keyword">if</span>(seg.length_in_sequence_space() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.1 send seg !</span></span><br><span class="line">        _segments_out.push(seg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  3.2 update send_window</span></span><br><span class="line">        _send_window.push_back(seg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  4. 如果这是 send_window empty之后 第一次发送数据（装入数据到_send_window）。</span></span><br><span class="line">        <span class="keyword">if</span>(!_timer.active())</span><br><span class="line">        &#123;</span><br><span class="line">            _timer.reset();</span><br><span class="line">            _timer.start(_initial_retransmission_timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  5.  update</span></span><br><span class="line">        <span class="comment">//  update _next_seq</span></span><br><span class="line">        _next_seqno += seg.length_in_sequence_space();</span><br><span class="line">        <span class="comment">//  update receive_window_size</span></span><br><span class="line">        remaining_recv_window_sz -= seg.length_in_sequence_space();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- remaining_recv_window_sz -= bytes_in_flight() : </span><br><span class="line">- 如sender给receiver分别发送a b c <span class="number">3</span>个segment(已知receive_window = <span class="number">3</span>).receiver接收到了a之后，给sender发送ack segment，（abs_ackno = <span class="number">1</span> , rwnd = <span class="number">2</span>),那么ack_received会更新rwnd，并且调用fill_window。易知fill_window会依照rwnd的大小，继续从bytestream读取新数据发送,那么实际上，虽然sender收到的rwnd=<span class="number">2</span>，但是sender不能直接使用，还要减去bytes_in_flight，这些byte，sent but <span class="keyword">not</span> acked，receiver稍后就会对他们ack，存入receive_window. sender发送新segment时，这些新segment在recv_window所占的空间应当在bc之后，故应当将recv_window - bytes_in_flight。获取当sender继续发送数据时，应当认为recv_window是多大。</span><br><span class="line">- <span class="keyword">if</span>(bytes_in_flight() &gt; remaining_recv_window_sz) <span class="keyword">return</span> ;</span><br><span class="line">- 此时receive_window没有空闲空间，无法发送，返回即可。</span><br><span class="line">- 由于我们ack_received 没有实现将segment拆开了acked，也即更新了recv_window（减小），但是send_window中的字节并没有移除，故可能会出现recv_window &lt; bytes_in_flight的情况，无法成功的remaining_recv_window_sz -= bytes_in_flight() = <span class="number">0</span>(溢出)，所以需要特判返回。</span><br><span class="line">- 如果实现了则应当不需要。</span><br><span class="line">- In fact , the receive_window is full now , but because of our sender implementation , we can<span class="number">&#x27;</span>t acked part of the segment , so we can<span class="number">&#x27;</span>t bascially remaining_recv_window_sz -= bytes_in_flight() to get <span class="number">0</span> . Instead, we should <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="ack-received"><a href="#ack-received" class="headerlink" title="ack_received"></a>ack_received</h3><ul>
<li>void ack received( const WrappingInt32 ackno, const uint16 t window size)<ul>
<li>含义:(何时调用) sender收到了包含 ackno 和 rwnd 的 segment</li>
<li>更新sender看到的receive_window_sz</li>
<li>sender 查询send_window中所有segment，并移除其中被ackno确认的segment<ul>
<li>什么样的segment才是被ackno确认的segment？<ul>
<li>segment.abs_seqno + seg.length &lt;= abc_ackno</li>
<li><strong>我们的实现中，sender 认为 segment只能被完整的确认，而不能部分确认</strong>。也即如下，sender发送了”abc”segment，receiver分别返回了ack_for_a , ack_for_b , ack_for_c，那么对于我们实现的sender,收到的ack_for_a 和 ack_for_b 都是无用的，只有收到了ack_for_c时，sender会知道receiver确认了”abc”segment，将其从send_window中移除。</li>
<li>以下摘自指导书<ul>
<li><blockquote>
<p>我应该怎么做，如果有一个ack报文只确认了某个outstanding segment的一部分?我应该将该segment进行切割吗？将确认的字节切割出去？</p>
</blockquote>
</li>
<li><blockquote>
<p>一个TCP Sender 可以做到这点，不过就这个类的目的而言，没有必要这么花哨。</p>
</blockquote>
</li>
<li><blockquote>
<p>将每个segment视为一个整体都outstanding,直到她完全被一个ack确认（直到它每个字节的seqno都小于收到的ack）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>TCP Sender 需要 查询outstanding segment的集合，并且移除其中 seqno &lt; ack的 segment</p>
</li>
<li><p>TCP Sender 需要 再次fill window 如果receive window中有新的空间</p>
</li>
<li><p><strong>核心逻辑：核心代码见下</strong></p>
<ul>
<li><strong>0.</strong> update window_size</li>
<li><ol>
<li>检验ackno是否合法</li>
</ol>
</li>
<li><strong>2.</strong> 从send_window中移除被acked的segment</li>
<li><strong>3.1</strong> 为send_window中的 新的 earliest outstanding segment 计数 _consecutive_retransmissions_cnt = 0;</li>
<li><strong>3.2</strong> 为send_window中的 新的 earliest outstanding segment 开启 timer</li>
<li><strong>4. fill_window(起到自动响应receiver，sender继续发送的作用)</strong> : 因为更新了rwnd 且 bytes_in_flight可能也减少了。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//  0. </span></span><br><span class="line">    _receive_window_size = window_size;</span><br><span class="line">    <span class="keyword">uint64_t</span> abs_ackno = unwrap(ackno,_isn,_next_seqno);</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">//  1. some check for ackno</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. remove acked seg from window</span></span><br><span class="line">    <span class="comment">//  remove acked seg from the send_window  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">deque</span>&lt;TCPSegment&gt;::iterator iter = _send_window.begin();iter!=_send_window.end();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> abs_idx = unwrap(iter-&gt;header().seqno,_isn,_next_seqno);</span><br><span class="line">        <span class="keyword">uint64_t</span> len = iter-&gt;length_in_sequence_space();</span><br><span class="line">        <span class="keyword">if</span>(abs_idx + len &lt;=  abs_ackno)     <span class="comment">//  如果对于abs_idx &lt; abs_ackno , abs_idx + len &gt; abs_ackno的情况呢 ? 该如何处理 ?</span></span><br><span class="line">        &#123;</span><br><span class="line">            seg_acked = <span class="literal">true</span>;</span><br><span class="line">            iter = _send_window.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">//  3.1 上一个计时重传的分组被移除 故 下一个重新计数</span></span><br><span class="line">    _consecutive_retransmissions_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  3.2 如果send_window中还有未发送的分组 则 为send_window新的最左侧分组开启timer</span></span><br><span class="line">    <span class="keyword">if</span>(!_send_window.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        _timer.reset();</span><br><span class="line">        _timer.start(_initial_retransmission_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  否则关闭老timer</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _timer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4. 因为更新了rwnd 且 bytes_in_flight可能也减少了。 故 接着从next_seqno发送新分组  </span></span><br><span class="line">    fill_window();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h3><ul>
<li><p><strong>void TCPSender::tick(const size_t milli_secs)</strong></p>
<ul>
<li>sender 每过milli_secs 就调用一次tick，代表时间流逝. </li>
<li><strong>核心逻辑：</strong><ul>
<li>如果超时<ul>
<li>a. 重传earliest outstanding segment。</li>
<li>b. <strong>if receive_window_size != 0 (我目前也不知道为什么必须rwnd!=0)</strong><ul>
<li>对于rwnd == 0时 不double rwnd 可能是为了</li>
<li>i. 关注consecutive retransmissions，当重传sth时 ++cnt。<ul>
<li>你的TCP连接将使用该信息，来决定一条连接是否已经没有希望，需要被放弃.(当重传次数cnt过多时)</li>
</ul>
</li>
<li>ii. RTO *= 2 , 减缓了我们在糟糕的网络上进行重传，以免进一步把事情搞糟</li>
</ul>
</li>
<li>c.  重置timer 并启动timer，使其在RTO之后过期（注意RTO可能翻倍） </li>
<li>可以看到，在tick函数的具体实现里，基本就是完全照着这abc三步做的<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!_timer.active())        </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(_timer.elapse(ms_since_last_tick))</span><br><span class="line">    &#123;</span><br><span class="line">        TCPSegment &amp; oldest_seg = _send_window.front();</span><br><span class="line">        <span class="keyword">uint64_t</span> timeout = _timer.initial_alarm();</span><br><span class="line">        <span class="comment">//  b. </span></span><br><span class="line">        <span class="keyword">if</span>(_receive_window_size &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeout &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            ++_consecutive_retransmissions_cnt;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  c. </span></span><br><span class="line">        _timer.reset();</span><br><span class="line">        _timer.start(timeout);</span><br><span class="line">        <span class="comment">//  a. 超时重传</span></span><br><span class="line">        _segments_out.push(oldest_seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>超时重传相关FAQ</p>
<ul>
<li>如果我发送了三个独立的segment，其payload分别为”a”, “b”, “c”,并且他们还都没被acked，那么稍后当我重传a的时候，我需要将abc三个segment拼接成一个大的segment吗？还是说我需要分别的独立的传输每个segment？<ul>
<li>TCP Sender可以做到这点，但是就这个类的目的而言，没有必要这么花哨</li>
<li>只需要独立的关注每个segment即可，并且当timer到期的时候，重传最早的outstanding segment。</li>
</ul>
</li>
<li>我需要在数据结构中存储empty segment，然后在必要的时候重传他们吗 ？ <ul>
<li>不需要。只有携带了数据(consume some length in sequence space)的segment需要被关注是否重传的</li>
<li>一个没有占据seqno的segment(no payload, SYN, or FIN),不需要被记录或者重传。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流量控制-flow-control"><a href="#流量控制-flow-control" class="headerlink" title="流量控制 flow-control"></a>流量控制 flow-control</h3><ul>
<li><p><strong>一言以蔽之：receiver 通过 将 recv_window （ackno + recv_window_size)发送给 sender , 来告知sender自己可接收的字节下标范围,sender通过receive_window,来获知自己还能发送多少字节</strong>.</p>
</li>
<li><p><strong>背景</strong>: 当TCP连接的 receiver 接收到 正确的、按序的字节后，就将数据放入接收缓存（receiver 的 bytestream）。相关联的应用进程会从该缓存中读取数据，但不必是数据刚一到达就立即读取。事实上，接收方应用也许正忙于其他服务，甚至要过很长时间之后才读取该数据。如果某应用程序读取数据时相对缓慢。而sender发送的太快太多，发送的数据会从接受缓存溢出。</p>
<ul>
<li>我所实现的<strong>receiver接收缓存溢出</strong> 情况.<ul>
<li><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-09-20-52-20.png"></li>
<li>约定接收缓存 : bytestream(顺序) + recv_window(乱序)</li>
<li><strong>receiver接收缓存溢出</strong>实现 : bytestream_size + recv_window_size == capacity —&gt; 最终会变成bytestream_size == capacity,(接收缓存中只有bytestream而没有recv_window的空间了)，那么再来的data就会全部落入接收缓存之外(first_unacceptable之外),也即被discarded.<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">receiver_code</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">StreamReassembler::cached_into_receiving_window</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index,<span class="keyword">bool</span> &amp;non)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(index &gt;= first_unacceptable())</span> </span>&#123;</span><br><span class="line">        non = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//  nothing</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>flow-control 流量控制</strong></p>
<ul>
<li>TCP为其应用程序提供了流量控制服务，目的：避免Receiver的接收缓存溢出</li>
<li>也即流量控制 是一个 速度匹配服务 , 通过遏制sender，来让sender和发送速率和receiver的接收速率相匹配</li>
</ul>
</li>
<li><p><strong>流量控制实现途径 : receive_window</strong></p>
<ul>
<li>ackno + recv_window_size</li>
<li>sender通过ack报文维护 (recv_window) recv_window_size</li>
<li><strong>实现核心：sender 在 整个 TCPConnection 中，始终保证send_window_size &lt;= recv_window_size。</strong> <ul>
<li><strong>recv_window(recv_window_size + ackno) 即 receiver 可以接收的 字节的 范围</strong></li>
<li><strong>sender 所能发送的 字节范围 被限制在recv_window中</strong>. </li>
</ul>
</li>
<li><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-09-22-03-33.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fill_window()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(recv_window_size &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//  send segment from _next_seqno</span></span><br><span class="line">    <span class="comment">//  update recv_window_size</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>关于receive_window具体含义 可见 lab2 blog</p>
</li>
</ul>
<h3 id="拥塞控制-Congestion-Control"><a href="#拥塞控制-Congestion-Control" class="headerlink" title="拥塞控制 Congestion Control"></a>拥塞控制 Congestion Control</h3><ul>
<li><p>可以看到，TCPSender并没有实现TCP拥塞控制算法</p>
<ul>
<li>根本就没维护拥塞窗口cwnd变量，只有一个接收窗口rwnd</li>
<li>那就更没有慢启动,拥塞避免,拥塞控制,快速恢复</li>
</ul>
</li>
<li><p>我们只实现了一种形式受限的拥塞控制</p>
<ul>
<li>对于同一报文段 , 每次Timer超时之后 , RTO翻倍</li>
</ul>
</li>
</ul>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><ul>
<li><ol>
<li>fin 占据 receive_window seqno空间</li>
</ol>
<ul>
<li>发送syn</li>
<li>发送abc</li>
<li>发送fin<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    TCPConfig cfg;</span><br><span class="line">    <span class="function">WrappingInt32 <span class="title">isn</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> rto = uniform_int_distribution&lt;<span class="keyword">uint16_t</span>&gt;&#123;<span class="number">30</span>, <span class="number">10000</span>&#125;(rd);</span><br><span class="line">    cfg.fixed_isn = isn;</span><br><span class="line">    cfg.rt_timeout = rto;</span><br><span class="line"></span><br><span class="line">    TCPSenderTestHarness test&#123;<span class="string">&quot;Don&#x27;t add FIN if this would make the segment exceed the receiver&#x27;s window&quot;</span>, cfg&#125;;        </span><br><span class="line">        <span class="comment">//  sender.fill_window(); 发送syn报文 </span></span><br><span class="line">    test.execute(ExpectSegment&#123;&#125;.with_no_flags().with_syn(<span class="literal">true</span>).with_payload_size(<span class="number">0</span>).with_seqno(isn));</span><br><span class="line">        <span class="comment">//  check 刚才发送的报文 : seq(isn) + syn + payload(0)</span></span><br><span class="line">        <span class="comment">//  [0](isn)  1  2  3  4</span></span><br><span class="line">        <span class="comment">//  syn </span></span><br><span class="line">    test.execute(WriteBytes(<span class="string">&quot;abc&quot;</span>).with_end_input(<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//  sender.stream_in().write(std::move(_bytes));    sender.stream_in().end_input();     sender.fill_window();     </span></span><br><span class="line">        <span class="comment">//  [0]  1  2  3  4</span></span><br><span class="line">        <span class="comment">//  syn  </span></span><br><span class="line">        <span class="comment">//  in stream wait for send : a b c fin   </span></span><br><span class="line">    test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">1</span>&#125;&#125;.with_win(<span class="number">3</span>));</span><br><span class="line">    test.execute(ExpectState&#123;TCPSenderStateSummary::SYN_ACKED&#125;);</span><br><span class="line">    test.execute(ExpectSegment&#123;&#125;.with_payload_size(<span class="number">3</span>).with_data(<span class="string">&quot;abc&quot;</span>).with_seqno(isn + <span class="number">1</span>).with_no_flags());</span><br><span class="line">        <span class="comment">// sender.ack_received(_ackno, _window_advertisement.value_or(DEFAULT_TEST_WINDOW));</span></span><br><span class="line">        <span class="comment">//  0   [1  2  3]  4</span></span><br><span class="line">        <span class="comment">//  syn  a  b  c</span></span><br><span class="line">        <span class="comment">//  in stream wait for send : fin   </span></span><br><span class="line">    <span class="comment">//  ack for a</span></span><br><span class="line">    test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">2</span>&#125;&#125;.with_win(<span class="number">2</span>));</span><br><span class="line">    test.execute(ExpectNoSegment&#123;&#125;);</span><br><span class="line">    <span class="comment">//  ack for b</span></span><br><span class="line">    test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">3</span>&#125;&#125;.with_win(<span class="number">1</span>));</span><br><span class="line">    test.execute(ExpectNoSegment&#123;&#125;);</span><br><span class="line">    <span class="comment">//  ack for c</span></span><br><span class="line">    test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">4</span>&#125;&#125;.with_win(<span class="number">1</span>));</span><br><span class="line">    test.execute(ExpectSegment&#123;&#125;.with_payload_size(<span class="number">0</span>).with_seqno(isn + <span class="number">4</span>).with_fin(<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">// sender.ack_received(_ackno, _window_advertisement.value_or(DEFAULT_TEST_WINDOW));</span></span><br><span class="line">        <span class="comment">//  0   1  2  3  [4]</span></span><br><span class="line">        <span class="comment">// syn  a  b  c  fin</span></span><br><span class="line">        <span class="comment">//  in stream wait for send</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul>
<li>FAQ and sepcial cases<ul>
<li>我该如何既发送segment，又追踪该segment作为outstanding segment，以便我知道稍后将要重传该segment ？ 我是否需要为每个segment做一份拷贝?可那样的话不会很浪费吗？<ul>
<li>不会。虽然TCPSegment在send_window和segments_out中会有两个副本，但是由TCPSegment实现可知，其payload的实现是Buffer，Buffer中保存的是对string payload的引用。（<code>std::shared_ptr&lt;std::string&gt; _storage&#123;&#125;;</code>）。故不必担心会真实的拷贝一份payload。代价不是太大。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>receiver reassembler 看来 SYN 和 FIN就不占据 recv_window 空间<br>在sender看来 SYN和FIN就占据 recv_window 空间<br>因为reassembler使用的是stream_idx 发送时sender使用的是seqno<br>他们之间通过wrap进行转化 见 lab2</p>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab6</title>
    <url>/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/</url>
    <content><![CDATA[<p>build a Router based on Network Interface</p>
<ul>
<li>在Network Interface的基础上实现一个Router<ul>
<li>功能 : 根据 forwarding table (&lt;ip_prefix - interface(port)&gt;). 将来自ip的分组从正确的网卡接口转发出去.</li>
<li>匹配规则 : 最长前缀匹配</li>
<li>注意entry中需要记录next_hop_ip</li>
</ul>
</li>
<li>我们的Router只实现了数据平面（转发），并没有实现控制平面（路由选择）<ul>
<li>控制平面的路由选择算法有 LS , DV , RIP , OSPF. 详情见《自顶向下》</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>本周在NetworkInterface之上实现一个IP Router. IP Router的任务是根据routing table转发. 对于收到的dgram,router有一系列规则</p>
<ul>
<li>转发到正确的interface</li>
<li>获知下一跳的IP地址(为了使得Router将其传递给NetWork Interface , NetWork Interface根据ip获取下一跳的mac地址)</li>
</ul>
</li>
<li><p>概述图<img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-08-11-25.png"></p>
</li>
</ul>
<p>我们的任务是 实现一个router. 去解决上述两个事情. </p>
<ul>
<li>我们只实现了router的数据平面 , 并没有实现router的控制平面.</li>
<li>也即我们只实现了根据router的forwarding table,并没有实现生成forwarding_table的routing algorithm路由选择算法<ul>
<li>You will not need to implement the algorithms that make the routing table, e.g. RIP, OSPF,BGP, or an SDN controller—just the algorithm that follows the routing table.</li>
</ul>
</li>
<li>IP router不必关系任何有关TCP,ARP,Ethernet协议字段的任何东西. 只关心IP协议字段即可.</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>Router class 应该负责<ul>
<li>维护forwarding table</li>
<li>Router负责处理收到的网络层的datagram. 对于每个datagram<ul>
<li>正确的发到下一跳</li>
<li>转发到正确的NetworkInterface</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>重要成员 forwarding_table的entry  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RouterEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> route_prefix;                <span class="comment">//  ip</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> prefix_length;                 <span class="comment">//  ip_perfix_len</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;Address&gt; next_hop;       <span class="comment">//  下一跳的ip地址 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> interface_num;             <span class="comment">//  从哪个网卡转发出去 编号 </span></span><br><span class="line">    RouterEntry(<span class="keyword">const</span> <span class="keyword">uint32_t</span> ip , <span class="keyword">const</span> <span class="keyword">uint8_t</span> prefix , <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;Address&gt; ne , <span class="keyword">const</span> <span class="keyword">size_t</span> interface_idx):</span><br><span class="line">        route_prefix(ip),prefix_length(prefix),next_hop(ne),interface_num(interface_idx)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RouterEntry&gt; _forwarding_table&#123;&#125;;</span><br><span class="line"></span><br><span class="line">一来开始以为 既然我们的router只需要维护forwarding table并转发到正确的Interface. 因此forwarding table的entry并不需要记录next_hop_ip。只需要记录 &lt;ip_perfix , interface&gt;. 但由于之后forwarding_table要调用interface接口进行发送.为了使得interface可以获取到mac地址,需要传递给下一跳的ip地址, 故forwarding table的entry中还需要记录next_hop_ip</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>void add_route(const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt; Address &gt; next_hop, const size_t interface_num);</strong><ul>
<li>保存一条 {ip_perfix,network_interface}到forwarding_table中</li>
</ul>
</li>
</ul>
<ul>
<li><strong>void route_one_datagram(InternetDatagram &amp;dgram);</strong><ul>
<li><strong>“match-action” rule</strong> : <ul>
<li>依据我们在《自顶向下》中所学，router应当对收到的dgram执行 匹配加动作 规则。而传统路由器的动作就是根据目的地转发. 也即本lab中实现的 匹配加转发</li>
<li><strong>匹配</strong> : 将dgram中的ip和forwarding_table中的ip进行 <strong>最长前缀匹配</strong></li>
<li><strong>动作 : 转发</strong><ul>
<li>如果router和dst ip<strong>在同一网络</strong>中(If the router is directly attached to the network in question) , 那么forwarding_table中的entry记录的next_hop_ip为empty, router传递给network_interface的next_hop_ip为dgram_dst_ip</li>
<li>如果router和dst ip<strong>不在同一网络</strong>中(But if the router is connected to the network in question through some other router) , 那么entry中会记录路径上的下一跳ip地址(应该是个router ip)</li>
</ul>
</li>
</ul>
</li>
<li>步骤如下 , 根据forwarding_table找到最长前缀匹配的entry<ul>
<li>没找到 , drop the dgram</li>
<li>找到 , dgram TTL –.<ul>
<li>如果TTL已经 &lt;= 0 则 drop the dgram</li>
<li>否则 , 将dgram转发给正确的interface , 由interface将其封装成frame发送出去.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>void Router::route()</strong></p>
<ul>
<li>(Linker) 从network interface取出dgrams , (Internet) 调用route_one_datagram(dgram) , (Linker) 进而转发到正确的network interface 发送出去</li>
<li><strong>Linker -&gt; Internet -&gt; Linker</strong></li>
</ul>
</li>
<li><p>网络协议巧妙设计 : 分层. router只关注网络层.</p>
<ul>
<li>Router不必关注frame中封装的TCP 还是ARP ,也不必关注link layer frame类型. </li>
<li>Router只需要关注 网络层的Internet datagram , 然后通过NetworkInterface 来和 链路层link layer进行交互</li>
<li>When it comes to questions like, “How are link-layer addresses resolved?” or “Does the link layer even have its own addressing scheme distinct from IP?” or “What’s the format of the link-layer frames?” or “What’s the meaning of the datagram’s payload?”, the router just doesn’t care.</li>
</ul>
</li>
<li><p>代码略 简单</p>
</li>
<li><p>ques : 如果router drop dgram : 没有找到对应entry , 或者ttl = 0 . 是否需要发送icmp 报文给源主机 ?</p>
<ul>
<li>在真实生活中 , router需要发哦是那个icmp给源主机 . 但lab中这不是必需的.即便在真实生活中 , 不是所有router都需要发送icmp报文给源地址的. </li>
</ul>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li>测试原理. test code中的NetWork 模拟的就是下图交互情况. NetWork中的_router就是图中中间的路由器<br>  <img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-11-26.png"></li>
</ul>
<ul>
<li><p>apleasure to cherry</p>
<blockquote>
<p><img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-12-23.png"></p>
</blockquote>
</li>
<li><p>app to internet</p>
<blockquote>
<p><img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-14-12.png"></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; green &lt;&lt; <span class="string">&quot;\n\nSuccess! Testing applesauce sending to the Internet.&quot;</span> &lt;&lt; normal &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> dgram_sent = network.host(<span class="string">&quot;applesauce&quot;</span>).send_to(&#123;<span class="string">&quot;1.2.3.4&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;default_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><blockquote>
<p><img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-19-56.png"></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; green &lt;&lt; <span class="string">&quot;\n\nSuccess! Testing sending to the HS network and Internet.&quot;</span> &lt;&lt; normal &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> dgram_sent = network.host(<span class="string">&quot;applesauce&quot;</span>).send_to(&#123;<span class="string">&quot;143.195.131.17&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;hs_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line"></span><br><span class="line">    dgram_sent = network.host(<span class="string">&quot;cherrypie&quot;</span>).send_to(&#123;<span class="string">&quot;143.195.193.52&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;hs_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line"></span><br><span class="line">    dgram_sent = network.host(<span class="string">&quot;cherrypie&quot;</span>).send_to(&#123;<span class="string">&quot;143.195.223.255&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;hs_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line"></span><br><span class="line">    dgram_sent = network.host(<span class="string">&quot;cherrypie&quot;</span>).send_to(&#123;<span class="string">&quot;143.195.224.0&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;default_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>同一LAN</p>
<blockquote>
<p><img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-15-20.png"></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dgram_sent = network.host(<span class="string">&quot;dm42&quot;</span>).send_to(network.host(<span class="string">&quot;dm43&quot;</span>).address());</span><br><span class="line">dgram_sent.header().ttl--;</span><br><span class="line">network.host(<span class="string">&quot;dm43&quot;</span>).expect(dgram_sent);</span><br><span class="line">network.simulate();</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-传输层-TCP</title>
    <url>/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/</url>
    <content><![CDATA[<p>TCP概述<br>报文格式、发送方接收方状态机模型、流量控制、拥塞控制、三次握手四次挥手</p>
<span id="more"></span>

<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul>
<li><p><strong>什么是TCP连接</strong>：</p>
<ul>
<li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</li>
</ul>
</li>
<li><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><strong>点对点</strong>：<ul>
<li>一个发送方，一个接收方</li>
<li>多播对于TCP来说是不可能的。（一个发送方传送给多个接收方）</li>
</ul>
</li>
<li><strong>可靠的、按顺序的字节流</strong>： <ul>
<li>没有报文边界</li>
</ul>
</li>
<li><strong>管道化（流水线）</strong>： <ul>
<li>TCP拥塞控制和流量控制设置窗口大小</li>
</ul>
</li>
<li><strong>发送和接收缓存</strong><blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-14-18-32.png"></p>
</blockquote>
<ul>
<li>MSS(MAX Segment Size)：放入TCP报文段的最大应用层报文段大小。（应用层报文段的最大大小）</li>
<li>MTU(Maximum Transmission Unit) = IP Header + TCP Header + MSS(应用层报文段)<blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-14-37-22.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>全双工数据</strong>：<ul>
<li>在同一连接中数据流双向流动</li>
</ul>
</li>
<li><strong>面向连接</strong>：<ul>
<li><strong>三次握手</strong>：在数据交换之前，通过握手（交换控制报文） 初始化发送方、接收方的状态变量</li>
<li>TCP连接是一条<strong>逻辑连接</strong>，其共同状态仅<strong>保存在</strong>两个通信<strong>端系统</strong>的TCP程序中。<ul>
<li>TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的socket，另一台主机上的另一组缓存、变量和与进程连接的socket</li>
</ul>
</li>
<li><strong>中间的</strong>网络元素如 路由器、交换机、中继器，没有为该连接分配任何缓存和变量。也即，<strong>不会维持TCP连接状态。</strong><ul>
<li>中间路由器对TCP连接完全视而不见，它们看到的是数据报，而不是连接。</li>
</ul>
</li>
</ul>
</li>
<li><strong>有流量控制：</strong><ul>
<li>发送方不会淹没接收方</li>
</ul>
</li>
</ul>
<h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-15-06-18.png"></p>
<ul>
<li><p>源port、目的port：</p>
<ul>
<li>多路复用/分解来自或送到上层的数据</li>
</ul>
</li>
<li><p>检验和check sum</p>
</li>
<li><p>序号sequence number (32bit) and 确认号acknowledgement number  (32bit)</p>
<ul>
<li><strong>用于实现可靠数据传输服务</strong></li>
</ul>
</li>
<li><p>首部长度header length </p>
<ul>
<li>TCP Header 长度</li>
</ul>
</li>
<li><p>标志</p>
<ul>
<li>RSF位的组合代表了是第几次握手</li>
<li>…</li>
</ul>
</li>
<li><p>接收窗口receive window </p>
<ul>
<li>用于<strong>流量控制</strong>，指示接收方愿意接受的字节数量</li>
</ul>
</li>
<li><p>选项options </p>
</li>
</ul>
<h3 id="序号、确认号"><a href="#序号、确认号" class="headerlink" title="序号、确认号"></a>序号、确认号</h3><ul>
<li><strong>好图</strong><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-15-32-13.png"></li>
<li><strong>序号：</strong><ul>
<li>报文段<strong>首字节</strong>的在<strong>字节流</strong>的编号</li>
<li>即 <strong>一个报文段的序号</strong> 是该TCP报文段的数据部分的首字节的字节流编号</li>
</ul>
</li>
<li><strong>确认号</strong>:<ul>
<li>期望从另一方收到的<strong>下一个字节</strong>的序号</li>
<li><strong>累计确认</strong>（与SR协议不同，SR协议是非累计确认）</li>
<li>ack number：已经收到了[begin,ack-1]的所有bytes，期待收到的下一个byte是ack 。 即期待收到的下一个TCP报文段的body的起始字节的序号是ack</li>
</ul>
</li>
<li>TCP没有规定 接收方如何处理乱序的报文段<ul>
<li>丢弃</li>
<li>缓存。（实际中使用的）</li>
</ul>
</li>
<li>对于一条TCP连接，双方<strong>随机选择初始序号</strong><ul>
<li>? </li>
</ul>
</li>
<li>telnet例子<br>  <img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-16-09-33.png"><ul>
<li><strong>捎带</strong>：B到A的数据的ack确认被 捎带(装载) 在一个B到A的数据包文段中。</li>
<li>顺带一句：初始序号随机 防止老连接的包造成影响。不过对方是如何知道自己的初始序号的？</li>
</ul>
</li>
</ul>
<h2 id="往返延时（RTT）和-TCP超时"><a href="#往返延时（RTT）和-TCP超时" class="headerlink" title="往返延时（RTT）和 TCP超时"></a>往返延时（RTT）和 TCP超时</h2><ul>
<li>怎样设置TCP超时？<ul>
<li>比RTT要长  <ul>
<li> 但RTT是变化的</li>
</ul>
</li>
<li>太短：太早超时<ul>
<li> 不必要的重传</li>
</ul>
</li>
<li>太长：对报文段丢失<ul>
<li> 反应太慢，消极</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="往返时间RTT预估"><a href="#往返时间RTT预估" class="headerlink" title="往返时间RTT预估"></a>往返时间RTT预估</h3><ul>
<li>怎样估计RTT？<ul>
<li>SampleRTT：测量从报文段发出到收到确认的时间 <ul>
<li>如果有重传，忽略此次测量</li>
</ul>
</li>
<li>SampleRTT会变化，因此估计的RTT应该比较平滑 <ul>
<li>对几个最近的测量值求平均，而不是仅用当前的SampleRTT</li>
</ul>
</li>
</ul>
</li>
<li><strong>EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT</strong> <ul>
<li>表示 当前最近一段时间的往返平均值</li>
<li>指数加权移动平均：越近的样本权重越大<blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-16-31-50.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="RTT变化-预估"><a href="#RTT变化-预估" class="headerlink" title="RTT变化 预估"></a>RTT变化 预估</h3><ul>
<li>DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT| <ul>
<li>表示 当前采样值SampleRTT 离 估算平均值EstimatedRTT 的偏差程度 的一个平均值</li>
<li>同样采用指数移动加权平均。</li>
</ul>
</li>
</ul>
<h3 id="设置和管理-重传超时间隔"><a href="#设置和管理-重传超时间隔" class="headerlink" title="设置和管理 重传超时间隔"></a>设置和管理 重传超时间隔</h3><ul>
<li>TimeoutInterval = EstimatedRTT + 4*DevRTT</li>
</ul>
<h2 id="TCP-如何rdt-可靠数据传输"><a href="#TCP-如何rdt-可靠数据传输" class="headerlink" title="TCP: 如何rdt?(可靠数据传输)"></a>TCP: 如何rdt?(可靠数据传输)</h2><ul>
<li>TCP在IP不可靠服务的基础上建立了rdt<ul>
<li>pipeline的报文段<ul>
<li>GBN + SR</li>
</ul>
</li>
<li><strong>累计确认：像GBN</strong></li>
<li><strong>单个定时器</strong>：发送方只设置一个定时器（GBN）,且该定时器只和最老的段关联.<strong>像GBN</strong></li>
<li>TCP没有规定 接收方如何处理乱序的报文段</li>
<li>通过以下事件触发<strong>重传</strong><ul>
<li><strong>超时</strong>：当超时的时候 只**重放一个段(SR)**，且是最老的段。</li>
<li><strong>冗余ACK</strong>：触发快速重传机制<ul>
<li>例如收到ACK50之后，又收到3个ACK50</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP发送方（简化）"><a href="#TCP发送方（简化）" class="headerlink" title="TCP发送方（简化）"></a>TCP发送方（简化）</h3><ul>
<li>接下来考虑简化的TCP发送方<ul>
<li>忽略重复的确认</li>
<li>忽略流量控制和拥塞控制</li>
</ul>
</li>
</ul>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><ul>
<li><p><strong>发送窗口</strong> : [base,next-1]</p>
<ul>
<li>发送窗口 size = next - base</li>
<li>next : 即将发送的报文段，也即紧挨着发送窗口的下一个报文段</li>
<li>next-1 : 最新的 已经发送 未确认的报文段</li>
<li>base : 最老的 已发送 未确认的报文段</li>
<li>base - 1 : 最新的被确认的分组</li>
</ul>
</li>
<li><p>ack number：</p>
<ul>
<li>接收方接收到的<strong>顺序</strong>到来的最后一个字节 + 1（期待）。</li>
<li>发送给发送方，ack告诉发送方[begin,ack-1]已经被确认。</li>
<li>发送方的base移动到ack，因此<strong>接收到的ack是发送窗口的base</strong></li>
</ul>
</li>
<li><p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-09-13-55.png"></p>
</li>
</ul>
<h4 id="文字版-Action-and-Event"><a href="#文字版-Action-and-Event" class="headerlink" title="文字版 Action and Event"></a>文字版 Action and Event</h4><ul>
<li><p><strong>data received from application : 从应用层接收数据</strong></p>
<ul>
<li>用nextseq创建报文段</li>
<li>序号nextseq为报文段首字节的字节流编号</li>
<li>如果还没有运行定时器，启动定时器<ul>
<li><strong>定时器与最老未确认的报文段关联（即 定时器与base分组关联）</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>timeout : 定时器超时</strong>：</p>
<ul>
<li>重传后沿最老的报文段（即 <strong>重传base</strong>）<ul>
<li><strong>只重传一个base分组</strong>（类似SR）</li>
</ul>
</li>
<li>重启timer</li>
</ul>
</li>
<li><p><strong>ACK received , with ACK field and value y收到确认</strong>：</p>
<ul>
<li>如果收到的是对尚未确认的报文段的确认（接收到的ACK &gt; 发送窗口的base）<ul>
<li>发送窗口的后沿向右侧移动，更新已被确认的报文序号。即 <strong>base 右移到ack的位置</strong></li>
<li><strong>base &lt; next</strong> : 如果当前还有已经发送但没被确认的报文段，重启timer。</li>
<li><strong>base = next</strong> : 如果当前没有已经发送但没被确认的报文段，无需启动timer。<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-22-56-20.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>如下就要启动对报文段7的timer<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-22-52-34.png"><br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-22-53-15.png"></p>
</li>
</ul>
<h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><ul>
<li>三件event 和 相应 action<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NextSeqNum = InitialSeqNum</span><br><span class="line">SendBase = InitialSeqNum</span><br><span class="line">loop (forever) &#123;</span><br><span class="line">  <span class="keyword">switch</span>(event) </span><br><span class="line">  event: data received from application above </span><br><span class="line">    create TCP segment with sequence number NextSeqNum </span><br><span class="line">    <span class="keyword">if</span> (timer currently <span class="keyword">not</span> running) </span><br><span class="line">      start timer pass segment to IP </span><br><span class="line">    NextSeqNum = NextSeqNum + length(data) </span><br><span class="line">  </span><br><span class="line">  event: timer timeout </span><br><span class="line">    retransmit <span class="keyword">not</span>-yet-acknowledged segment with smallest sequence number </span><br><span class="line">    start timer </span><br><span class="line">  </span><br><span class="line">  event: ACK received, with ACK field value of y </span><br><span class="line">    <span class="keyword">if</span> (y &gt; SendBase) &#123; </span><br><span class="line">      SendBase = y</span><br><span class="line">      <span class="keyword">if</span> (there are currently <span class="keyword">not</span>-yet-acknowledged segments) </span><br><span class="line">        start timer </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="comment">/* end of loop forever */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li><blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-10-39-08.png"></p>
</blockquote>
<ul>
<li><blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-10-42-49.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-10-42-39.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-10-39-21.png"></p>
</blockquote>
<ul>
<li><blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-10-44-43.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="TCP接收方"><a href="#TCP接收方" class="headerlink" title="TCP接收方"></a>TCP接收方</h3><ul>
<li>RCF对于接收方返回ACK的建议。</li>
<li><blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-11-10-46.png"></p>
</blockquote>
<ul>
<li><blockquote>
<p>(1)(2)<img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-11-03-04.png"></p>
</blockquote>
</li>
<li><blockquote>
<p>(3)<img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-11-05-59.png"></p>
</blockquote>
</li>
<li><blockquote>
<p>(4)<img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-18-11-09-24.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="补充-TCP发送方-之-快速重传机制"><a href="#补充-TCP发送方-之-快速重传机制" class="headerlink" title="补充 : TCP发送方 之 快速重传机制"></a>补充 : TCP发送方 之 快速重传机制</h3><ul>
<li>超时周期往往太长： <ul>
<li>在重传丢失报文段之前的延时太长</li>
</ul>
</li>
<li>通过<strong>重复的ACK</strong>来<strong>检测报文段丢失</strong> <ul>
<li>发送方通常连续发送大量报文段 </li>
<li>如果报文段丢失，通常会引起多个重复的ACK</li>
</ul>
</li>
<li>如果发送方收到同一数据的3个冗余ACK，重传最小序号的段： <ul>
<li><strong>快速重传</strong>：在定时器过时之前重发报文段 </li>
<li>它假设跟在被确认的数据后面的数据丢失了 </li>
<li>第一个ACK是正常的； </li>
<li>收到第二个该段的ACK，表示接收方收到一个该段后的乱序段； </li>
<li>收到第3，4个该段的ack，表示接收方收到该段之后的2个，3个乱序段，可能性非常大段丢失了</li>
</ul>
</li>
</ul>
<ul>
<li><p>例子</p>
<blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-19-18-32-22.png"><br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-19-18-43-07.png"></p>
</blockquote>
</li>
<li><p>补充上文中的发送方简化版状态机</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">event: ACK received, <span class="function">with ACK field value of y </span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(y &gt; SendBase)</span> </span>&#123; </span><br><span class="line">  SendBase = y</span><br><span class="line">  <span class="keyword">if</span> (there are currently <span class="keyword">not</span>-yet-acknowledged segments)</span><br><span class="line">    start timer </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    stop timer</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;       </span><br><span class="line">  <span class="comment">//  ACK = sendBase </span></span><br><span class="line">  increment count of dup ACKs received <span class="keyword">for</span> y</span><br><span class="line">  <span class="comment">//  ACK重传</span></span><br><span class="line">  <span class="keyword">if</span> (count of dup ACKs received <span class="keyword">for</span> y = <span class="number">3</span>) &#123;</span><br><span class="line">    resend segment with sequence number y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>流量控制</strong>：<strong>接收方控制发送方</strong>，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出。<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-19-19-26-23.png"></li>
<li><strong>TCP接收方 通过填写TCP段头部的receiving window field来告知 TCP发送方 自己的空闲buffer大小</strong>。<ul>
<li><strong>进而控制TCP发送方的发送速度</strong> </li>
</ul>
</li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li><p>TCP接收方 通过填写TCP段头部的receiving window field来告知 TCP发送方 自己接收Buffer的空闲大小.</p>
<ul>
<li>RcvBuffer大小通过socket选项设置 (典型默认大小为4096 字节)。 </li>
<li>很多操作系统自动调整RcvBuffer。</li>
</ul>
</li>
<li><p>TCP发送方知道接收方的receiving window之后，通过限制未确认(“inflight”)字节的个数≤接收方发送过来的rwnd值，来保证接收方不被淹没。（意图控制发送方新发送的（新要送入接收方Buffer的）data size &lt; free buffer space）</p>
</li>
<li><p>接收buffer , recvWindow(free空间) 以及 , data to read by app<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-19-19-55-50.png"></p>
</li>
</ul>
<h2 id="连接管理-（即-TCP三次握手-四次挥手）"><a href="#连接管理-（即-TCP三次握手-四次挥手）" class="headerlink" title="连接管理 （即 TCP三次握手 四次挥手）"></a>连接管理 （即 TCP三次握手 四次挥手）</h2><ul>
<li><strong>连接关闭的两军问题</strong></li>
</ul>
<h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><ul>
<li>TCP连接的建立会显著地增加人们感受到的时延。</li>
<li>连接建立的本质<ul>
<li>知道要和对方通信</li>
<li>双方准备通信资源 如 缓冲区</li>
<li>控制变量置位 如连接初始序号 和初始化的recvBuffer大小</li>
</ul>
</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul>
<li><p><strong>流程</strong>：client的进程向和server的进程建立TCP连接<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-21-13-57-17.png"></p>
</li>
<li><p><strong>1. client向server发送SYN报文段</strong></p>
<ul>
<li>请求发起连接，并告知对方自己的初始序列号。</li>
<li>不含应用层数据</li>
<li>SYN = 1</li>
<li>seq = client_isn。</li>
<li>client状态变化：CLOSE -&gt; SYN_SENT<blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-21-14-04-20.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>2. server向client发送SYNACK报文段(SYNACK segment)</strong></p>
<ul>
<li>收到了client的连接请求，收到了对方的初始化序列号，并同意建立连接，并告知对方自己的初始序列号。</li>
<li>不含应用层数据</li>
<li>SYN = 1 </li>
<li>seq num = server_isn</li>
<li>ACK = 1 , ack num = client_isn + 1</li>
<li>server状态变化：LISTEN -&gt; SYN_RCVD<blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-21-14-16-38.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>3. client向server发送发送ACK报文段</strong></p>
<ul>
<li>client告诉server，自己收到了对方对于连接建立的确认，以及收到了对方的初始化序列号。</li>
<li>可含应用层数据</li>
<li>ACK = 1 , ack num = server_isn + 1</li>
<li>client状态：SYN_SENT -&gt; ESTABLISHED</li>
<li>server收到client发送的这个ack报文段后:SYN_RCVD -&gt; ESTABLISHED<blockquote>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-21-14-18-15.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="三次握手问题"><a href="#三次握手问题" class="headerlink" title="三次握手问题"></a>三次握手问题</h4><ul>
<li>三次而非两次？见blog TCP2</li>
</ul>
<h3 id="TCP连接关闭"><a href="#TCP连接关闭" class="headerlink" title="TCP连接关闭"></a>TCP连接关闭</h3><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul>
<li>客户端，服务器分别关闭它自己这一侧的连接<ul>
<li>将TCP连接分为两个方向，每个方向单独拆除。 </li>
<li>发送FIN bit = 1的TCP段</li>
</ul>
</li>
<li>一旦接收到FIN，用ACK回应 <ul>
<li>接到FIN段，ACK可以和它自己发出的FIN段一起发<br>送</li>
</ul>
</li>
<li>可以处理同时的FIN交换</li>
<li><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-22-20-18-12.png"></li>
<li><strong>主动关闭连接的，才有 TIME_WAIT 状态</strong></li>
</ul>
<h4 id="TIME-WAIT问题"><a href="#TIME-WAIT问题" class="headerlink" title="TIME_WAIT问题"></a>TIME_WAIT问题</h4><p>…</p>
<h3 id="连接管理状态机"><a href="#连接管理状态机" class="headerlink" title="连接管理状态机"></a>连接管理状态机</h3><ul>
<li><p>client的状态机<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-22-20-20-38.png"></p>
</li>
<li><p>server的状态机<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-22-20-21-07.png"></p>
</li>
</ul>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>见blog 拥塞控制</p>
<p>没有准确定义<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-22-22-06-12.png"></p>
<p>网络拥塞特点<br>延时大<br>为了让网络达到有效的泵出 我的输入要泵入很多速率<br>拥塞时会重传没有必要重传的分组 从而让网络更慢<br>不加控制 马上不可控制 网络瘫痪</p>
<p>拥塞控制目的：<br>不是为了不发生拥塞，而是在不发生拥塞的情况下，尽可能地提高它的发送速率。</p>
<p>TCP采用端到端控制<br>（互联网架构将复杂性放在端上）</p>
<p>流量窗口 拥塞窗口</p>
<p>警戒值之后线性增长<br>警戒值之前指数增长<br>喝的大醉 滑动窗口变为1 警戒值变为发疯的一半<br>半倒不倒 3个冗余ack<br>喝的半醉 滑动窗口减为一半，进入拥塞避免，省了一个慢启动阶段。</p>
<p>慢启动阶段并不慢。很快 指数型增加</p>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-24-16-42-08.png"></p>
<p>慢启动 很快 时间忽略不计<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-24-16-47-16.png"></p>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-24-16-50-51.png"></p>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-24-16-52-42.png"><br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-24-16-53-01.png"><br>tcp公平<br>udp对tcp不友好 只顾着自己</p>
<hr>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-19-18-18-03.png"></p>
<p>返回的ack 是 最老的 未确认的字节的编号</p>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-22-30-37.png"></p>
<p><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-17-22-33-52.png"></p>
<p>滑动窗口协议GO BY N ,SR 窗口如何滚动 接收窗口作用 这部分内容很重要 对理解pipeline协议 提高效率的同时实现可靠传递 很重要</p>
<p>快速重传：在定时器到时之前 如果收到3个冗余的ack 就重传</p>
<p>快速重传的各种情况<br><img src="/2022/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP/2022-10-15-12-49-23.png"></p>
<p>捎带发送确认</p>
<p>流量控制目的：发送方发送的不至于太快，</p>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-传输层-TCP2</title>
    <url>/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/</url>
    <content><![CDATA[<p>TCP 八股补充</p>
<span id="more"></span>

<h2 id="TCP-三次握手问题"><a href="#TCP-三次握手问题" class="headerlink" title="TCP 三次握手问题"></a>TCP 三次握手问题</h2><ul>
<li>server方究竟什么时候为TCP连接分配资源？如缓冲区、变量？<ul>
<li>是established之后 还是SYN_RCVD之后</li>
</ul>
</li>
</ul>
<p>《TCP/IP详解 卷1：协议（原书第2版）》的第 13.6.1 节有讲到这个问题。</p>
<p>通常情况下，当一个连接请求到达本地却没有相关进程在目的端口侦听时就会产生一个重置报文段。</p>
<p>UDP 协议规定，当一个数据报到达一个不能使用的目的端口时就会产生一个 ICMP 目的地不可达（端口不可达）的消息。TCP 协议则使用重置报文段来代替完成相关工作。</p>
<h3 id="listen-connect-accept-以及-三次握手流程"><a href="#listen-connect-accept-以及-三次握手流程" class="headerlink" title="listen , connect , accept 以及 三次握手流程"></a>listen , connect , accept 以及 三次握手流程</h3><ul>
<li>问题：accept时是否已经完成三次握手？<ul>
<li>当然已经完成。</li>
</ul>
</li>
<li>在server调用<strong>listen之后</strong>，client就可以调用<strong>connect</strong>来和server<strong>完成三次握手</strong>建立连接。</li>
<li><strong>也即，在server调用accept之前，client就已经和server完成了三次握手，建立好了TCP连接。</strong></li>
<li>也即，accept所做的事情仅仅就是将已经建立好的TCP连接从Accept中取出，交给应用层。（即将connection socket交给应用层）</li>
<li>API以及三次握手流程如下<br><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-24-21-11-08.png"></li>
</ul>
<h3 id="close与四次挥手"><a href="#close与四次挥手" class="headerlink" title="close与四次挥手"></a>close与四次挥手</h3><ul>
<li>调用close，向对方发送FIN报文，代表自己这一端没有数据要发送了。</li>
<li>client与server都可通过调用close关闭自己这一方的连接。</li>
<li>server接收到了 FIN 报文，TCP 协议栈会插入EOF到recv buffer中，user 通过read 感知FIN报文（就是通过读取EOF来感知EOF报文的吧）。EOF 会被放在已排队等候的其他已接收的数据之后，因为 EOF 表示在该连接上再无额外数据到达。此时，server进入 CLOSE_WAIT 状态。</li>
<li>接着，当server处理完数据后，自然就会读到 EOF，于是也close socket，发出FIN 包，server进入LAST_ACK 状态；</li>
</ul>
<p><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-24-21-35-09.png"></p>
<h3 id="listen-的-backlog"><a href="#listen-的-backlog" class="headerlink" title="listen 的 backlog"></a>listen 的 backlog</h3><ul>
<li><strong>省流：backlog 即 Accept全连接队列大小</strong><blockquote>
<ul>
<li>Linux内核中会维护两个队列：</li>
<li>半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li>
<li>全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</li>
<li><blockquote>
<p><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-24-21-24-34.png"></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>int listen (int socketfd, int backlog)</li>
<li>socketfd : listeningfd<br>?- backlog，这参数在历史版本有一定的变化</li>
<li>在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。</li>
<li>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></li>
<li>但是accpt队列上限值是内核参数 somaxconn 的大小</li>
<li>也就说 **accpet 队列长度 = min(backlog, somaxconn)**。</li>
<li><a href="https://xiaolincoding.com/network/3_tcp/tcp_queue.html">SYN队列和Accept队列满了怎么办</a></li>
</ul>
</blockquote>
<h3 id="三次而非两次"><a href="#三次而非两次" class="headerlink" title="三次而非两次"></a>三次而非两次</h3><ul>
<li>为什么三次握手而非两次握手？<ul>
<li>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接 ？</li>
</ul>
</li>
</ul>
<ul>
<li>避免server维护大量半连接，浪费资源。也避免将老数据当作新数据接收。</li>
<li>同步双方的初始序列号。</li>
<li>阻止重复历史连接的初始化。</li>
</ul>
<h4 id="防止server维持多个半连接，浪费资源"><a href="#防止server维持多个半连接，浪费资源" class="headerlink" title="防止server维持多个半连接，浪费资源"></a>防止server维持多个半连接，浪费资源</h4><ul>
<li>情景：client的SYN报文段超时重传。</li>
<li><strong>两次握手</strong>，<ul>
<li>client根本不会对server返回的ack做出任何响应报文。</li>
<li><strong>server</strong>无需等待client返回ack就<strong>直接分配资源建立连接</strong>。</li>
<li>而<strong>client</strong>端却<strong>不</strong>会<strong>建立连接</strong>。</li>
<li><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-21-17-22-24.png"></li>
</ul>
</li>
<li>因此，<strong>两次握手，server端可能会维护大量的无用的半连接，浪费资源</strong>。</li>
</ul>
<h5 id="可能将老数据当作新数据接收"><a href="#可能将老数据当作新数据接收" class="headerlink" title="可能将老数据当作新数据接收"></a>可能将老数据当作新数据接收</h5><ul>
<li>更进一步，server不但维护了半连接，还将旧数据当做新数据接收。<br>  <img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-21-17-32-31.png"></li>
</ul>
<h4 id="同步双方的初始序列号-。-三次而非两次-四次"><a href="#同步双方的初始序列号-。-三次而非两次-四次" class="headerlink" title="同步双方的初始序列号 。(三次而非两次/四次)"></a>同步双方的初始序列号 。(三次而非两次/四次)</h4><ul>
<li><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，作用：</p>
<ul>
<li>保证双方正确的按序的接收(其实是按序的向上层交付)到对方的一个个报文段。</li>
<li>A -data-&gt; B。data报文段要携带A自己的seq number,和根据B的seq推断出的ack number。</li>
</ul>
</li>
<li><p>建立连接时同步序列号（就是告诉对方自己的序列号）步骤</p>
<ul>
<li>client 发送 SYN 报文 给server，server须回一个 ACK报文，</li>
<li>server 发送 SYN 报文 给client，clinet须回一个 ACK报文，</li>
</ul>
</li>
<li><p><strong>四次</strong>。但是server给client的<strong>ack可以被syn报文段捎带。故三次</strong></p>
</li>
<li><p>这也解释了为什么不是2次握手，</p>
<ul>
<li>如果只有<strong>2次</strong>的话，那么只能是client -SYN-&gt; server , client &lt;-SYNACK- server。<strong>只能保证server接收到了client的SYN，无法保证client接收到了server的SYN</strong>。</li>
</ul>
</li>
<li><p>如图</p>
<blockquote>
<p><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-21-16-36-51.png"></p>
</blockquote>
</li>
</ul>
<h4 id="防止建立错误（老的-过期的-废弃的）连接"><a href="#防止建立错误（老的-过期的-废弃的）连接" class="headerlink" title="防止建立错误（老的 / 过期的 / 废弃的）连接"></a>防止建立错误（老的 / 过期的 / 废弃的）连接</h4><ul>
<li><p><strong>一言以蔽之：防止 旧的连接(即所谓的历史连接) 被错误的建立(再断开?) 而造成混乱/浪费</strong></p>
<ul>
<li>其实根本原因就是 server(TCP的被动方)无法判断这个连接是否是正确的连接(即 非 历史连接)。只有client(TCP的主动)才能根据server返回的信息(ack)和自身的上下文(seq)来判断是否是正确的连接，然后告知server。</li>
<li>三次握手<ul>
<li>server端在接收SYN报文段，发送SYNACK报文后，并不立刻建立连接，而是进入一个SYN_RCVD状态。这是因为：<ul>
<li>在连接建立之前，<strong>server需要有一个中间状态(作为一个缓冲/隔离状态)，供给client端发送消息来确认</strong>，来<strong>告诉server</strong>端，server想要确认的连接，<strong>是否是一个正确的连接</strong>，是否是client端想要建立的连接。<ul>
<li>如果是正确的连接，client向server发送一个ACK</li>
<li>如果<strong>不是正确</strong>的连接，client向server发送一个<strong>RST</strong>。告诉<strong>server</strong>，<strong>不</strong>要<strong>建立这个连接</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>两次握手<ul>
<li>在两次握手的情况下，server 没有中间状态给 client 来阻止历史连接，而是直接建立连接。导致server可能建立一个历史连接，造成资源浪费。</li>
</ul>
</li>
</ul>
</li>
<li><p>例子：</p>
</li>
<li><p><strong>三次握手处理历史(废弃的)SYN报文段</strong></p>
<ul>
<li>server接收SYN报文段，进入SYN_RCVD状态。在server端处于SYN_RCVD状态时，client终止告知server该连接。阻止了server建立该连接</li>
<li><blockquote>
<p><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-21-15-56-36.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>两次握手处理</strong></p>
<ul>
<li>server接收SYN报文段，直接进入ESTABLISHED状态，没有给client端去告诉server这个连接正确与否的机会。（server进入established之后，即可向网络中send data）</li>
<li>然而client根据server发送的ack判断<ul>
<li>如果是<strong>错误的连接</strong>的话，那么发送RST报文段。server接收到RST报文段后，还要断开连接。白白的浪费了资源。send的data也不会被接收，<strong>白白浪费</strong>。</li>
<li>如果是正确的连接，一切好说。</li>
</ul>
</li>
<li><blockquote>
<p><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-21-16-08-03.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</li>
</ul>
<ul>
<li><a href="https://www.rfc-editor.org/rfc/rfc793.html">RFC 793</a></li>
<li>The principle reason for the three-way handshake is <strong>to prevent old duplicate connection initiations from causing confusion</strong>.  </li>
<li>To deal with this, a special control message, <strong>reset</strong>, has been devised.  <ul>
<li>If the receiving TCP is in a  non-synchronized state (i.e., SYN-SENT, SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.</li>
<li>If the TCP is in one of the synchronized states (ESTABLISHED,FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it aborts the connection and informs its user.  </li>
<li>We discuss this latter case under “half-open” connections below.</li>
</ul>
</li>
</ul>
<h1 id="TCP-四次挥手问题"><a href="#TCP-四次挥手问题" class="headerlink" title="TCP 四次挥手问题"></a>TCP 四次挥手问题</h1><h2 id="why-TIME-WAIT"><a href="#why-TIME-WAIT" class="headerlink" title="why TIME_WAIT"></a>why TIME_WAIT</h2><h3 id="保证server-被动方-的连接正常关闭-it’s-why-2MSL"><a href="#保证server-被动方-的连接正常关闭-it’s-why-2MSL" class="headerlink" title="保证server(被动方)的连接正常关闭 (it’s why 2MSL)"></a>保证server(被动方)的连接正常关闭 (it’s why 2MSL)</h3><ul>
<li><p><strong>这也解释了为什么是2MSL</strong></p>
</li>
<li><p><strong>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</strong></p>
</li>
<li><p><strong>等待足够的时间以确保最后的 ACK 能让server(被动关闭方)接收，从而帮助其正常关闭</strong></p>
</li>
<li><p>假设场景:client主动向server发起关闭连接</p>
<ul>
<li><strong>client用于确认server FIN的ACK报文丢失</strong>，server没有收到。于是server超时<strong>重传FIN报文</strong>。</li>
<li><strong>如果client没有TIME_WAIT状态</strong><ul>
<li>那么client在接收FIN，发送ACK之后，直接就进入了CLOSED状态。client收到server的FIN重传之后，回复RST报文，那么server将rst解释为错误（Connection reset by peer），server端的连接异常终止。（client的依旧是正常终止）</li>
<li><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-24-19-08-11.png"></li>
</ul>
</li>
<li><strong>如果client有TIME_WAIT状态。(ACK一去，重传的FIN一回，正好2MSL。)</strong><ul>
<li><strong>client收到FIN报文后 重新计时2MSL。</strong></li>
<li><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-24-19-04-58.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="防止历史连接中的数据，被新连接错误的接收-it’s-also-why-2MSL"><a href="#防止历史连接中的数据，被新连接错误的接收-it’s-also-why-2MSL" class="headerlink" title="防止历史连接中的数据，被新连接错误的接收 (it’s also why 2MSL)"></a>防止历史连接中的数据，被新连接错误的接收 (it’s also why 2MSL)</h3><ul>
<li><p>前提：</p>
<ul>
<li>新老连接的四元组相同。（源ip 源 port 目的IP 目的port）</li>
<li>初始序列号：32位的计数器，循环，因此可能重复或者接近。</li>
<li>序列号：32 位，循环。如下是初始序列号。<blockquote>
<p><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-24-19-33-32.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>如果TIME_WAIT过短或者没有TIME_WAIT，</p>
<ul>
<li>那么假设情景：一个老连接的报文段在网络中被延迟，并且由于没有TIME_WAIT，在新TCP连接建立之后，这个老的报文段仍然存活于网络中，在网络中传播。</li>
<li>那么，存在一种可能。<strong>这个老连接的包在死亡之前到达了client，且在此时正好落在新连接的receving window中。且该老连接包(如seq=301)的位置的报文段还没到</strong><ul>
<li><strong>那么，就会将这个老连接的报文缓存在receving window中</strong>。新连接的正常的301号报文就被丢弃。  <blockquote>
<p><img src="/2022/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-TCP2/2022-10-24-19-48-14.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>为了防止老报文被新连接接收</strong></p>
</li>
<li><p><strong>TCP 设计了 2MSL的 TIME_WAIT 状态</strong>，</p>
<ul>
<li><strong>2MSL 使得两个方向上的老的报文都在网络中死亡。再出现的报文一定都是新连接的报文</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="TIME-WAIT-why-2MSL-（不用看-看上面那个就行）"><a href="#TIME-WAIT-why-2MSL-（不用看-看上面那个就行）" class="headerlink" title="TIME_WAIT why 2MSL ?（不用看 看上面那个就行）"></a>TIME_WAIT why 2MSL ?（不用看 看上面那个就行）</h2><ul>
<li><p>前置</p>
<ul>
<li><strong>MSL : Maximum Segment Lifetime : 报文最大生存时间</strong>。<ul>
<li>单位是时间</li>
<li>一般 MSL = 30s</li>
</ul>
</li>
<li><strong>TTL</strong> : <strong>最大路由数</strong><ul>
<li>TCP 协议基于IP 协议，IP header 中有一个 TTL 字段，是 IP 报文段 可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则报文段将被丢弃，同时发送 ICMP 报文通知源主机。</li>
<li>单位是跳数</li>
<li>一般 TTL = 64</li>
</ul>
</li>
<li>MSL &gt;= TTL</li>
<li>认为报文段经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。</li>
</ul>
</li>
<li><p>假设是client向server发起关闭连接的四次挥手请求。</p>
<ul>
<li>即 <strong>client是 主动关闭方，server是被动关闭方。</strong></li>
<li>2MSL 的时间是从client接收到 FIN 后发送 ACK 开始计时的</li>
</ul>
</li>
<li><p>理由1</p>
</li>
<li><p><strong>client为了 接收到 [server] 对 [client之前（进入TIME_WAIT之前/接收server的FIN 发送给server ACK）发送给server的tcp报文段] 的 [响应报文段(server发送给client的)]。</strong></p>
<ul>
<li>这样的 responding packet是由 server 在进入LAST_ACK之前就发送给client的，但是由于延迟等原因，packet比server发送给client的FIN更晚到达client</li>
</ul>
</li>
<li><p><strong>我认为下面这个是2MSL主要理由</strong></p>
</li>
<li><p><strong>理由2</strong>：<strong>2MSL，至少允许(ACK)报文丢失一次，且 保证server可以正确关闭连接</strong>。</p>
</li>
<li><p><strong>client用于确认server FIN的ACK报文丢失</strong>，server没有收到。于是server超时<strong>重传FIN报文</strong>。这样ACK一去，FIN一回，正好2MSL。</p>
</li>
<li><p><strong>client收到FIN报文后 重新计时2MSL。</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-传输层-可靠数据传输-流水线</title>
    <url>/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<p>rdt3.0 性能问题 ：停止等待协议 信道利用率低<br>因此 需要流水线技术<br>解决流水线的差错恢复的两种基本方法：<br>    Go-Back-N(GBN 回退N步)<br>    Selective Repeat(SR 选择重传)</p>
<ul>
<li>Slide Window 滑动窗口协议<ul>
<li>Sending Window = 1 , Receive Window = 1</li>
</ul>
</li>
<li>Go BY N 回退N步协议<ul>
<li>Sending Window &gt; 1 , Receive Window = 1</li>
</ul>
</li>
<li>Selective Repeat   选择重传协议 <ul>
<li>Sending Window &gt; 1 , Receive Window &gt; 1</li>
</ul>
</li>
<li>Sending Window &gt; 1 的协议 称为流水线协议。</li>
</ul>
<span id="more"></span>

<h1 id="slide-window-滑动窗口协议"><a href="#slide-window-滑动窗口协议" class="headerlink" title="slide window 滑动窗口协议"></a>slide window 滑动窗口协议</h1><ul>
<li><p>发送窗口：[前沿,后沿]</p>
</li>
<li><p>发送窗口在发送缓冲区里面。是一段已经发送，但还没被确认的分组。</p>
</li>
<li><p>发送缓冲区中 除了发送窗口之外的，就是空闲的缓冲区，可以填入分组然后发送。</p>
</li>
<li><p>实际上 发送缓冲区不动，分组动。但为了便于观察，看成是缓冲区相对于分组移动。<br><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-16-01-17.png"></p>
</li>
<li><p>发送缓冲区什么时候向前移动？</p>
<ul>
<li>当发送窗口的后沿向前移动</li>
<li>发送窗口的后沿向前移动，意味着有已经发送的分组被确认了。那么，这个分组就没必要再缓存在缓冲区里了。（既然已经确认，发送方就没有再重发这个分组的可能。）</li>
<li>可以发现，发送窗口的最左端 一定 就是 发送缓冲区的最左端。因为发送窗口右移一定会导致发送缓冲区右移</li>
</ul>
</li>
<li><p>接收缓冲区什么时候向前移动</p>
<ul>
<li>当接收窗口的后沿向前移动</li>
</ul>
</li>
</ul>
<h2 id="发送缓冲区"><a href="#发送缓冲区" class="headerlink" title="发送缓冲区"></a>发送缓冲区</h2><p><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-14-29-48.png"></p>
<ul>
<li><strong>发送缓冲区</strong> <ul>
<li>形式：内存中的一个区域，落入缓冲区的分组可以发送 </li>
<li>功能：用于存放已发送，但是没有得到确认的分组 </li>
<li>必要性：需要重发时可用</li>
</ul>
</li>
<li><strong>发送缓冲区的大小：发送方在未经接收方确认的情况下，最多可以发送多少个分组。</strong><ul>
<li>停止等待协议 的发送缓冲区大小 = 1 </li>
<li>流水线协议 &gt; 1<ul>
<li>合理的值，不能很大，</li>
<li>因为链路利用率不能够超过100%</li>
</ul>
</li>
</ul>
</li>
<li><strong>发送缓冲区中的分组</strong><ul>
<li>未发送的：落入发送缓冲区的分组，可以连续发送出去</li>
<li>已经发送的、等待对方确认的分组：发送缓冲区的分组只有得到确认才能删除</li>
</ul>
</li>
</ul>
<h3 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h3><ul>
<li><strong>发送窗口：发送缓冲区内容的一个范围 那些已发送但是未经确认分组的序号构成的空间</strong></li>
<li><strong>发送窗口 &lt;= 发送缓冲区</strong></li>
<li>一开始：没有发送任何一个分组 <ul>
<li>后沿=前沿 </li>
<li>之间为发送窗口的尺寸=0</li>
</ul>
</li>
<li>每发送一个分组，前沿前移一个单位<br>  <img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-15-42-13.png"></li>
</ul>
<h4 id="前沿移动"><a href="#前沿移动" class="headerlink" title="前沿移动"></a>前沿移动</h4><ul>
<li>发送窗口前沿极限：[后沿,前沿] &lt;= 发送缓冲区<br>  <img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-15-43-02.png"></li>
</ul>
<h4 id="后沿移动"><a href="#后沿移动" class="headerlink" title="后沿移动"></a>后沿移动</h4><ul>
<li>条件：收到老分组的确认</li>
<li>效果：发送缓冲区罩住了新的分组，来了分组可以发送</li>
<li>极限：后沿&lt;=前沿<br>  <img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-15-57-30.png"></li>
</ul>
<h2 id="接收缓冲区"><a href="#接收缓冲区" class="headerlink" title="接收缓冲区"></a>接收缓冲区</h2><h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><ul>
<li>接收窗口 (receiving window)=接收缓冲区</li>
<li><strong>receive window 接收窗口 = 1</strong><ul>
<li><strong>receive window = 1 即为 GBN协议</strong></li>
<li><strong>返回ack 累计确认</strong>：接收方每次返回给发送方的就是最后接收到的正确的分组的ack。</li>
<li>对于<strong>不是顺序</strong>到达的分组，接收方<strong>丢弃</strong>，然后返回最后接收到的正确的分组的ack。</li>
<li>对于<strong>顺序</strong>到达的分组，接收方<strong>接收</strong>，返回该ack，并且移动接收窗口。</li>
<li>即，<strong>只能顺序接收</strong></li>
<li>例子：Wr＝1，<ul>
<li>在0的位置；只有0号分组可以接收；向前滑动一个，罩在1的位置，如果来了第2号分组，则丢弃；<br><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-16-49-55.png"></li>
</ul>
</li>
</ul>
</li>
<li><strong>receive window 接收窗口 &gt; 1</strong><ul>
<li><strong>receive window &gt; 1 即为 SR协议</strong></li>
<li><strong>返回ack 非累计确认</strong>：接收方返回给发送方 本次接收到的分组的 ack。（前提：分组要落在接收窗口内）</li>
<li><strong>对于不是顺序</strong>到达的分组（即高序号分组乱序到达），接收方<strong>可以接收</strong>。（只要该分组落在了接收窗口内）。<ul>
<li>即 <strong>缓存，但不交付</strong>（因为要实现rdt，不允许失序），窗口也不滑动。</li>
</ul>
</li>
<li><strong>对于顺序</strong>到达的分组（即低序号分组），接收方<strong>接收</strong>，并且<strong>移动</strong>接收窗口。</li>
<li>即，<strong>可以乱序接收</strong><br><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-17-10-13.png"></li>
</ul>
</li>
</ul>
<h2 id="GBN-and-SR-的窗口互动"><a href="#GBN-and-SR-的窗口互动" class="headerlink" title="GBN and SR 的窗口互动"></a>GBN and SR 的窗口互动</h2><h3 id="正常情况"><a href="#正常情况" class="headerlink" title="正常情况"></a>正常情况</h3><ul>
<li>无论是GBN还是SR，其正常情况下的窗口互动都相同，如下<ul>
<li>互动：即发送窗口和接收窗口如何推进</li>
<li>源动力：发送方向发送缓冲区内送入新分组</li>
<li><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-17-40-09.png"></li>
</ul>
</li>
</ul>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><ul>
<li>GBN和SR的区别在于receiving window的大小。</li>
<li>体现就是 异常情况下 GBN的接收方只能接收顺序、丢弃乱序，SR的接收方可以缓存乱序。</li>
</ul>
<h4 id="GBN"><a href="#GBN" class="headerlink" title="GBN"></a>GBN</h4><ul>
<li><p>发送窗口</p>
<ul>
<li>新分组落入发送缓冲区范围，发送。前沿向右滑动</li>
<li><strong>超时重发机制让发送端将发送窗口中的所有分组发送出去</strong></li>
<li>来了老分组的重复确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围</li>
</ul>
</li>
<li><p>接收窗口</p>
<ul>
<li>收到乱序分组，没有落入到接收窗口范围内，则抛弃。然后发送老分组的确认，累计确认；</li>
</ul>
</li>
<li><p><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-19-09-58.png"></p>
</li>
<li><p>为什么GBN的超时重发机制会将发送窗口中的所有分组发送出去？</p>
<ul>
<li>原因如下</li>
<li>GBN发送方是<strong>一个发送窗口用一个定时器（窗口内最老的分组的定时器）。一旦窗口中最早发送的分组超时，那么会把整个分组都重传。</strong></li>
<li>因为发送方知道 接收方如果有一个已发送的分组没接收到，那么这个已发送分组之后的已发送分组，必然也没有接收到。<ul>
<li>为什么接收方会这样？<ul>
<li>因为接收方的<strong>接收窗口</strong>的大小只有<strong>1个分组</strong>。不可接受乱序分组。</li>
</ul>
</li>
</ul>
</li>
<li>并且 发送方的<strong>发送窗口最左端</strong> 就是已被发送但还没被确认的<strong>第一个分组</strong>。因此，从滑动窗口最左端向右，即整个滑动窗口内的分组，都还没有被接收方接收。因此发送方要将滑动窗口内的所有分组全部重发。</li>
</ul>
</li>
</ul>
<h4 id="SR"><a href="#SR" class="headerlink" title="SR"></a>SR</h4><ul>
<li><p>发送窗口</p>
<ul>
<li>新分组落入发送缓冲区范围，发送-&gt;前沿滑动</li>
<li><strong>超时重发机制让发送端将超时的分组重新发送出去</strong></li>
<li>来了乱序分组的确认-&gt;后沿不向前滑动-&gt;新的分组无法落入发送缓冲区的范围</li>
</ul>
</li>
<li><p>接收窗口</p>
<ul>
<li>收到乱序分组，落入到接收窗口范围内，接收</li>
<li>发送该分组的确认，单独确认</li>
</ul>
</li>
<li><p><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-20-41-27.png"></p>
</li>
<li><p><strong>SR协议</strong>，发送方<strong>对于每一个分组都有一个定时器</strong>；而非整个窗口使用一个定时器（GBN协议就是）。</p>
<ul>
<li>如果接收方接收到乱序的分组（高序号分组），那么会缓存在缓冲区中（并不移动窗口），并且发送该分组的ACK给发送方。</li>
<li>发送方会接受返回的ACK，这些ACK使得发送方知道：发送窗口里的哪些分组已经被接收了。停止这些分组的定时器。这些分组没必要再重发，更没有必要继续缓存在窗口里，不过可惜，如果窗口后沿的分组没被确认，即使其他高序号被确认，窗口仍旧不能移动。</li>
<li>当发送方发生超时重传时，只需要重传发送窗口内没被确认的分组即可。不需要像GBN一样，全部重新发送。</li>
</ul>
</li>
</ul>
<h2 id="GBN-和-SR协议的内容异同"><a href="#GBN-和-SR协议的内容异同" class="headerlink" title="GBN 和 SR协议的内容异同"></a>GBN 和 SR协议的内容异同</h2><h3 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h3><ul>
<li><p>发送窗口&gt;1</p>
</li>
<li><p>一次能够可发送多个未经确认的分组</p>
</li>
<li><p>发送端最多在流水线中有N个未确认的分组</p>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3></li>
<li><p><strong>GBN : receiving window = 1</strong></p>
<ul>
<li>接收端：只能顺序接收</li>
<li>发送端：从表现来看，一旦一个分组没有发成功，如：发送窗口：0,1,2,3,4 ; 假如1未成功，234都发送出去了，<strong>要回退到1再发送；GO BACK TO 1</strong></li>
</ul>
</li>
<li><p><strong>SR: receiving window &gt; 1</strong></p>
<ul>
<li>接收端：可以乱序接收 </li>
<li>发送端：发送窗口：0,1,2,3,4，一旦1未成功，2,3,4,已发送，无需重发234，只<strong>选择性重发1 : SELECT 1</strong></li>
</ul>
</li>
<li><p>receiving window的差异 带来了是【回退、重传窗口内所有分组】；【还是选择性重传】的差异</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-22-36-21.png"></p>
<h2 id="GBN-1"><a href="#GBN-1" class="headerlink" title="GBN"></a>GBN</h2><ul>
<li><p>发送端最多在流水线中有N个未确认的分组</p>
<ul>
<li>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</li>
</ul>
</li>
<li><p>接收方发送<strong>累计型确认 cumulative ack</strong></p>
<ul>
<li>接收端如果发现乱序（高序号来了），不确认新到来的分组</li>
</ul>
</li>
<li><p>发送端拥有<strong>最老的未确认的分组的定时器</strong>。</p>
<ul>
<li>一个窗口只需设置<strong>一个定时器</strong></li>
<li>若定时器到时，<strong>重传所有未确认分组，GBN中即重传窗口内所有分组</strong>。</li>
</ul>
</li>
</ul>
<h3 id="发送方状态机"><a href="#发送方状态机" class="headerlink" title="发送方状态机"></a>发送方状态机</h3><p><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-21-39-21.png"><br>发送窗口[base,seqnum-1]<br>发送缓冲区[base,base+N-1]</p>
<h3 id="接收方状态机"><a href="#接收方状态机" class="headerlink" title="接收方状态机"></a>接收方状态机</h3><p><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-21-50-46.png"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-22-10-49.png"></p>
<h2 id="SR-1"><a href="#SR-1" class="headerlink" title="SR"></a>SR</h2><ul>
<li><p>发送端最多在流水线中有N个未确认的分组</p>
<ul>
<li>发送窗口的最大值（发送缓冲区）限制发送未确认分组的个数</li>
</ul>
</li>
<li><p><strong>发送方</strong>为<strong>每个未确认的分组保持一个定时器</strong></p>
<ul>
<li>每收到一个ack，就将相应的定时器关掉。</li>
</ul>
</li>
<li><p><strong>接收方</strong>对每个到来的分组单独确认<strong>individual ack</strong> <strong>非累计确认</strong></p>
<ul>
<li>接收窗口&gt;1<ul>
<li>可以<strong>缓存乱序的分组</strong></li>
</ul>
</li>
<li>最终将分组<strong>按顺序交付</strong>给上层</li>
</ul>
</li>
<li><p>如图<br><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-22-25-19.png"></p>
</li>
<li><p>例子<br><img src="/2022/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93-%E6%B5%81%E6%B0%B4%E7%BA%BF/2022-10-10-22-33-54.png"></p>
</li>
<li><p>状态机：略。有时间再搞。</p>
</li>
</ul>
<h1 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h1><ul>
<li><p>如果用nbits来代表分组序号</p>
<ul>
<li>那么序号空间为2^n  即[0,…2^n-1]</li>
</ul>
</li>
<li><p>那么 对于SR协议，窗口长度必须&lt;=序号空间大小的一半</p>
<ul>
<li>即 SR协议的 窗口长度 &lt;=2^(n-1)</li>
<li>原因：发送方和接收方之间的窗口缺乏同步，并不总是一致的。</li>
<li>见自顶向下P150</li>
</ul>
</li>
<li><p>那么 对于GBN协议，窗口长度必须 &lt;= 序号空间大小-1</p>
<ul>
<li>即 GBN协议的 窗口长度 &lt;=2^n - 1</li>
</ul>
</li>
<li><p>分析</p>
<ul>
<li>略。改天再搞。写密码学实验了该。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层2</title>
    <url>/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<p>记得不多，好多都略.<br>网络层-控制平面<br>路由选择算法（LS，DV，RIP，OSPF，BGP）<br>SDN控制平面简介<br>ICMP简介</p>
<span id="more"></span>

<p>第5章：网络层控制平面</p>
<ul>
<li>本章目标：理解网络层控制平面的工作原理 <ul>
<li>传统路由选择算法 </li>
<li>SDN 控制器 </li>
<li>ICMP:Internet Control Message Protocol </li>
<li>网络管理（略）</li>
<li>以及它们在互联网上的实例和实现: <ul>
<li>OSPF, BGP, OpenFlow, ODL 和ONOS控制器, ICMP, SNMP</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><ul>
<li>网络层功能 <ul>
<li>数据平面<ul>
<li>转发: 将分组从路由器的一个输入端口移到合适的输出端口</li>
</ul>
</li>
<li>控制平面<ul>
<li>路由：确定分组从源到目标的路径</li>
</ul>
</li>
</ul>
</li>
<li>2种构建网络控制平面功能的方法: <ul>
<li>每个路由器控制功能实现（传统） <ul>
<li>在每一个路由器中的单独路由器算法元件，在控制平面进行交互</li>
<li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-08-51-01.png"></li>
</ul>
</li>
<li>逻辑上集中的控制功能实现(software defined networking)<ul>
<li>一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互</li>
<li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-08-51-22.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="routing-algorithm-路由选择算法"><a href="#routing-algorithm-路由选择算法" class="headerlink" title="routing algorithm 路由选择算法"></a>routing algorithm 路由选择算法</h2><ul>
<li>路由选择算法(routing algorithm):网络层软件的一部分,完成路由功能</li>
</ul>
<h3 id="路由-route"><a href="#路由-route" class="headerlink" title="路由 route"></a>路由 route</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p>路由概念</p>
<ul>
<li>按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径 <ul>
<li>较好路径: 按照某种指标较小的路径 </li>
<li>指标:站数, 延迟,费用,队列长度等, 或者是一些单纯指标的加权平均 </li>
<li>采用什么样的指标,表示网络使用者希望网络在什么方面表现突出,什么指标网络使用者比较重视</li>
</ul>
</li>
</ul>
</li>
<li><p>以<strong>网络</strong>为单位进行路由（路由信息通告+路由计算） </p>
<ul>
<li>也即路由信息以子网为单位进行计算</li>
<li>前提条件是：一个网络所有节点地址前缀相同，且物理上聚集 </li>
<li>路由就是：找到一个子网到另一个子网最好的路径，也就是找到一个路由器到另一个路由器最好的路径，也就是找到了一个子网中的所有主机到另一个子网的所有主机的路径</li>
</ul>
</li>
<li><p>网络到网络的路由= 路由器-路由器之间路由</p>
<ul>
<li>网络对应的路由器到其他网络对应的路由器的路由</li>
<li>在一个网络中：路由器-主机之间的通信，由链路层负责解决</li>
<li>到了这个路由器就是到了这个网络</li>
<li>这里的网络应当就是一个子网。（子网里面没有其他路由器了，子网只有一个路由器和若干主机）</li>
</ul>
</li>
</ul>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><ul>
<li><p>网络图<br>  <img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-08-57-55.png"></p>
</li>
<li><p>路由的输入：拓扑、边的代价、源节点    </p>
</li>
<li><p>输出的输出：源节点的汇集树</p>
<ul>
<li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-08-58-45.png"></li>
</ul>
</li>
<li><p>sink tree 汇集树</p>
<ul>
<li>此节点到所有其它节点的最优路径形成的树</li>
<li>路由选择算法就是为所有路由器找到并使用汇集树<blockquote>
<p><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-00-47.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="路由原则"><a href="#路由原则" class="headerlink" title="路由原则"></a>路由原则</h4><ul>
<li>正确性(correctness):算法必须是正确的和完整的,使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应的表项；没有处理不了的目标站地址；</li>
<li>简单性(simplicity):算法在计算机上应简单：最优但复杂的算法，时间上延迟很大，不实用，不应为了获取路由信息增加很多的通信量；</li>
<li>健壮性(robustness):算法应能适应通信量和网络拓扑的变化：通信量变化，网络拓扑的变化算法能很快适应；不向很拥挤的链路发数据，不向断了的链路发送数据</li>
<li>稳定性(stability)：产生的路由不应该摇摆</li>
<li>公平性(fairness)：对每一个站点都公平</li>
<li>最优性(optimality)：某一个指标的最优，时间上，费用上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li>
</ul>
<h4 id="routing-algorithm"><a href="#routing-algorithm" class="headerlink" title="routing algorithm"></a>routing algorithm</h4><ul>
<li>按照集中式和分布式来区分<ul>
<li>centralized outing algorithm 集中式路由选择算法<ul>
<li>该算法以所有结点的连通性以及所有链路开销作为输入</li>
<li>这种具有全局状态信息的算法被称为 <strong>链路状态 (Link State , LS)算法</strong></li>
</ul>
</li>
<li>decentralized rouing algorithm 分散式路由选择算法<ul>
<li>每个节点仅有预期直接相连链路的开销 即可开启工作</li>
<li>迭代地与邻居交换路由信息、计算路由信息</li>
<li>没有节点拥有关于所有网络链路开销的完整信息</li>
<li>例子 : <strong>距离向量算法(Distance-Vector , DS)</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>按照静态或者动态的区分<ul>
<li>静态: 路由随时间变化缓慢<ul>
<li>非自适应算法(non-adaptive algorithm)：不能适应网络拓扑和通信量的变化,路由表是事先计算好的</li>
</ul>
</li>
<li>动态: 路由变化很快<ul>
<li>周期性更新 </li>
<li>根据链路代价的变化而变化</li>
<li>自适应路由选择(adaptive algorithm)：能适应网络拓扑和通信量的变化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="LS"><a href="#LS" class="headerlink" title="LS"></a>LS</h5><p>略<br>Dijkstra算法 – 链路状态算法<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-01-28-21-54-15.png"><br>链路状态分组 ：任何一个节点 其链路状态分组为 她到周边有哪些邻居，以及到这些邻居的代价。也就是邻接矩阵的出向边？<br>然后将链路状态分组泛红 我将我的链路状态告诉我的邻居 邻居们将我的链路状态告诉邻居的邻居</p>
<h5 id="DV"><a href="#DV" class="headerlink" title="DV"></a>DV</h5><p>略</p>
<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><h2 id="因特网中自治系统内部-AS-的路由选择"><a href="#因特网中自治系统内部-AS-的路由选择" class="headerlink" title="因特网中自治系统内部(AS)的路由选择"></a>因特网中自治系统内部(AS)的路由选择</h2><h3 id="RIP-Routing-Information-Protoco"><a href="#RIP-Routing-Information-Protoco" class="headerlink" title="RIP , Routing Information Protoco"></a>RIP , Routing Information Protoco</h3><p>略</p>
<h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>略</p>
<h2 id="ISP之间的路由选择-BGP"><a href="#ISP之间的路由选择-BGP" class="headerlink" title="ISP之间的路由选择 : BGP"></a>ISP之间的路由选择 : BGP</h2><p>略</p>
<h2 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h2><ul>
<li><p>SDN控制平面的工作室 计算、管理和安装所有网络交换机中的流表项</p>
</li>
<li><p>互联网络网络层：</p>
<ul>
<li>传统方式：历史上都是通过分布式、每个路由器的实现<ul>
<li>单个路由器包含了：交换设备硬件、私有路由器OS（如：思科IOS）和其上运行的互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现</li>
<li>需要不同的中间盒来实现不同网络层功能：防火墙，负载均衡设备和NAT…</li>
<li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-24-59.png"></li>
</ul>
</li>
<li>SDN : 一种集中式<ul>
<li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-25-41.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>为什么需要一个逻辑上集中的控制平面?</p>
<ul>
<li>网络管理更加容易<ul>
<li>避免路由器的错误配置，对于通信流的弹性更好</li>
</ul>
</li>
<li>基于流表的转发（回顾一下OpenFlow API)，允许“可编程”的路由器<ul>
<li>集中式“编程”更加容易：集中计算流表然后分发</li>
<li>传统方式分布式“编程”困难：在每个单独的路由器上分别运行分布式的算法，得到转发表（部署和升级代价低） <ul>
<li>而且要求各分布式计算出的转发表都得基本正确</li>
</ul>
</li>
<li>控制平面的开放实现（非私有）<ul>
<li>新的竞争生态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SDN特点"><a href="#SDN特点" class="headerlink" title="SDN特点"></a>SDN特点</h3><p>自顶向下P265</p>
<ul>
<li>基于流的转发<ul>
<li>SDN控制的交换机的分组转发工作，能供基于运输层、网络层和链路层的任意数量首部字段进行.(路由器传统转发仅仅依据网络层的目的IP地址进行)</li>
</ul>
</li>
<li>数据平面和控制平面分离<ul>
<li>数据平面由分组交换机组成,根据流表执行匹配加动作的规则</li>
<li>控制平面由SDN控制器和SDN网络控制应用程序</li>
<li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-45-57.png"></li>
</ul>
</li>
<li>网络控制功能：位于数据平面交换机外部</li>
<li>可编程的网络<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-30-08.png"></li>
</ul>
<h3 id="SDN架构"><a href="#SDN架构" class="headerlink" title="SDN架构"></a>SDN架构</h3><p>P266</p>
<p><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-45-40.png"></p>
<h4 id="数据平面的分组交换机"><a href="#数据平面的分组交换机" class="headerlink" title="数据平面的分组交换机"></a>数据平面的分组交换机</h4><ul>
<li>快速，简单，商业化交换设备,采用硬件实现通用转发功能</li>
<li>分组交换机的流表被控制器计算和安装</li>
<li>SDN控制器通过南向API（例如OpenFlow）访问基于流的交换机 </li>
</ul>
<h4 id="SDN控制器"><a href="#SDN控制器" class="headerlink" title="SDN控制器"></a>SDN控制器</h4><ul>
<li>维护网络状态信息</li>
<li>通过上面的北向API和网络控制应用交互</li>
<li>通过下面的南向API和网络交换机交互</li>
<li>逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法实现</li>
<li>SDN控制器组成<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-48-07.png"></li>
</ul>
<h4 id="SDN网络控制应用程序"><a href="#SDN网络控制应用程序" class="headerlink" title="SDN网络控制应用程序"></a>SDN网络控制应用程序</h4><ul>
<li>控制的大脑： 采用下层提供的服务（SDN控制器提供的API)，实现如下网络功能<ul>
<li>路由器 交换机</li>
<li>接入控制 防火墙</li>
<li>负载均衡</li>
<li>其他功能</li>
</ul>
</li>
<li>非绑定：SDN网络控制应用程序可以被第三方提供，与控制器厂商以通常上不同，与数据平面分组交换机厂商也可以不同</li>
</ul>
<h3 id="OpenFlow"><a href="#OpenFlow" class="headerlink" title="OpenFlow"></a>OpenFlow</h3><p>P268</p>
<ul>
<li>OpenFlow协议 <ul>
<li>是控制器和SDN交换机交互的协议</li>
<li>运行在SDN控制器和SDN控制的交换机或其他实现OpenFlowAPI的设备上</li>
<li>基于TCP</li>
</ul>
</li>
<li>控制器到交换机的重要报文如下<ul>
<li>特性：控制器查询交换机特性，交换机应答</li>
<li>配置：交换机查询/设置交换机的配置参数</li>
<li>修改状态：增加删除修改OpenFlow表中的流表</li>
<li>发送分组 packet-out：控制器可以将分组通过特定的端口发出<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-10-07-07.png"></li>
</ul>
</li>
<li>一些关键的交换机到控制器的报文<ul>
<li>分组进入: 将分组（和它的控制）传给控制器，见来自控制器的packet-out报文</li>
<li>流移除: 在交换机上删除流表项</li>
<li>端口状态: 通告控制器端口的变化<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-10-07-20.png"></li>
</ul>
</li>
</ul>
<h3 id="SDN控制平面-数据平面交互例子"><a href="#SDN控制平面-数据平面交互例子" class="headerlink" title="SDN控制平面-数据平面交互例子"></a>SDN控制平面-数据平面交互例子</h3><p>P269</p>
<ul>
<li><ol>
<li>交换机s1,经历了与s2的链路失效，采用OpenFlow”端口状态报文”通告控制器链路状态的更新</li>
</ol>
</li>
<li><ol start="2">
<li>SDN 控制器接收OpenFlow报文，更新链路状态信息</li>
</ol>
</li>
<li><ol start="3">
<li>Dijkstra路由算法应用被调用（前面注册过这个状态变化消息）</li>
</ol>
</li>
<li><ol start="4">
<li>Dijkstra路由算法访问控制器中的网络拓扑信息，链路状态信息计算新路由</li>
</ol>
</li>
<li><ol start="5">
<li>链路状态路由app和SDN控制器中流表计算元件交互，计算出新的所需流表</li>
</ol>
</li>
<li><ol start="6">
<li>控制器采用OpenFlow在交换机上安装新的需要更新的流表<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-10-07-59.png"></li>
</ol>
</li>
</ul>
<h2 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP : Internet Control Message Protocol"></a>ICMP : Internet Control Message Protocol</h2><ul>
<li>ICMP协议 , 用于主机、路由器、网关用于传达网络层控制信息 <ul>
<li>最典型用途 : <ul>
<li>错误报告 :</li>
<li>如运行http会话时，可能会遇到”目的网络不可达”之类的错误报文.</li>
<li>这种报文源于ICMP.</li>
<li>在某个位置，IP路由器不能找到一条通往和http请求种所指定的主机的路径，该路由器就会像你的主机生成并发送一个ICMP报文以指示该错误.</li>
</ul>
</li>
</ul>
</li>
<li>ICMP处在网络层，但是在IP协议的上面 <ul>
<li>ICMP消息由IP数据报承载</li>
</ul>
</li>
<li>ICMP 报文: 类型 + 编码 + (第一个导致该ICMP报文生成的)IP数据报的头8Byte<br>  <img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-11-03-38.png"></li>
</ul>
<h3 id="TraceRoute"><a href="#TraceRoute" class="headerlink" title="TraceRoute"></a>TraceRoute</h3><ul>
<li><p>Traceroute ： 通过udp(源主机) 和 ICMP(路由器) 实现</p>
<ul>
<li>源主机发送udp segment，接收 icmp 报文段.</li>
</ul>
</li>
<li><p>源主机运行Traceroute , 发送一系列具有不可达UDP端口号的UDP报文段给目标主机 , 并为每个数据报开启定时器. </p>
<ul>
<li>第一个：TTL =1 , 第二个： TTL=2, etc.</li>
<li>当nth数据报到达nth路由器<ul>
<li>路由器观察到该数据过期，根据IP协议，路由器抛弃数据报 ,然后发送一个给源的ICMP报文 (type 11, code 0) . 报文包括了路由器的名字和IP地址 . </li>
</ul>
</li>
<li>当ICMP报文返回给源主机，源主机通过定时器计算RTT（往返时延），并从icmp报文种获得第n台路由器的名字和ip</li>
</ul>
</li>
<li><p>源主机何时停止发送udp报文段</p>
<ul>
<li>最终有一个数据报沿着这条路到达目的主机</li>
<li>因为该数据报包含了一个具有不可达端口号 UDP 报文段，该目的主机会向源发送一个端口不可达的 ICMP 报文(type 3 code 3) </li>
<li>当源主机收到这个特别的 ICMP 报文时，就不再发送另外的探测分组</li>
</ul>
</li>
</ul>
<h2 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h2><p>略</p>
<hr>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-CS144-lab4</title>
    <url>/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/</url>
    <content><![CDATA[<ul>
<li>TCPConnection : 基于之前实现的 TCPReciver和TCPSender ; 作为完整的一端的TCP实现<ul>
<li>功能以及对应核心函数如下<ul>
<li>接收segment : segment_received<ul>
<li>本端接收seg 并根据自身receiver以及sender状态 发送相应seg给peer</li>
<li>注意在segment_receive中 会自动调用send_segments()</li>
</ul>
</li>
<li>发送segment : send_segment. (会捎带ack)</li>
<li>pass时间 : tick. 可能触发重传</li>
<li>shutdown关闭连接<ul>
<li>unclean_shutdown : 清空要发送的seg , 根据是否主动异常,发送rst , 设置_sender和receiver状态error , active_ = false<ul>
<li>active unclean_shutdown : send rst</li>
<li>passive unclean shut_down : not send rst</li>
</ul>
</li>
<li>clean_shutdown : active = false<ul>
<li>active clean_shutdown : 在tick时 判断是否经历完TIME_WAIT, 经历完，则clean_shutdown</li>
<li>passive clean_shutdown : 在segment_recieve接收完FIN的ACK后发现进入CLOSED状态，则clean_shutdown</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>最核心的一点 : <strong>如何确定结束连接</strong>. When TCPConnection is Done<ul>
<li>unclean shutdown : 接收或发送rst就立刻结束连接</li>
<li>clean shutdown<ul>
<li>需要满足#1#2#3#4</li>
<li>只有一端同时满足四个条件，该端才能认为TCPConnection is done. 结束连接.</li>
<li>对于#4有两种情况可以满足<ul>
<li>active close : A. 无法确定100%满足,只能通过TIME_WAIT接近100%<ul>
<li>这也就是由于两军问题,不可能去保证两端(主动关闭的无法一定达成clean shutdown)都能达成clean shutdown，但是TCP已经尽可能地接近了。</li>
</ul>
</li>
<li>passive close : B. 100%满足<ul>
<li>被动关闭的一端无需linger time，可以100%达成clean_shutdown</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="TCPConnection"><a href="#TCPConnection" class="headerlink" title="TCPConnection"></a>TCPConnection</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>为什么满足#1234 本端就能connection is donw ?</strong> </p>
<ul>
<li><p>因为首先明确clean_shutdown的目标是 双方都完全的可靠的接收到了对方的outbound stream.</p>
</li>
<li><p>其次这四个条件含义分别如下</p>
<ul>
<li>.#2是为了保证local的outbound_stream全部字节都已经被发送出去（其实按照我们所实现的，满足了#3就一定满足#2）(TCPSender.state = FIN_SENT)</li>
<li>.#3是为了保证local知道，local的outbound stream全部被peer接收(TCPSender.state = FIN_ACKED)</li>
<li>.#1是为了保证peer的outbound stream全部被local接收(TCPReceiver.state = FIN_RECV)</li>
<li>.#4是为了保证peer知道，其outbound stream 已经全部被local接收，不然根据重传机制，peer会不断重传outbound stream字节或如fin segment(remote TCPSender.state = FIN_ACKED)</li>
</ul>
</li>
<li><p><strong>为什么说TCP的字节流是双向的 ?</strong></p>
<ul>
<li>因为TCP有两条单向的字节流</li>
<li>每一端都有TCPSender 和 TCPReceiver</li>
<li><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-16-20-08-34.png"></li>
<li>从A到B的字节流 是 由 TCPSender A 向 TCPReceiver B 发起的 , 并由TCPSender A 和 TCPReceiver B维护.<ul>
<li>TCPSender A 给 TCPReceiver B发送的是 outbound_stream A的payload以及影响该连接的syn 和 fin。这三者都会占据seq空间. 这是sender A向 receiver B发送数据</li>
<li>TCPReceiver A给TCPSender B发送 ackno 以及 rwnd. 是receiver A向sender B反应接收情况.</li>
<li>TCPReceiver B给TCPSender A发送 ackno 以及 rwnd. 是receiver B向sender A反应接收情况.</li>
<li>TCPSender B 给 TCPReceiver A发送的是 outbound_stream B的payload以及影响该连接的syn 和 fin。这三者都会占据seq空间. 这是sender B向 receiver A发送数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>为什么(A发送的)ack不占据(A发送的)seqno空间 ? 也即为什么 empty ack segment的大小为0 ?</strong></p>
<ul>
<li>约定下A的seqno空间 : TCPSender A 发起 并 维护的 seqno空间. TCPReceiver B依据该seqno空间发送ackno报文向B进行确认(当然报文中的rwnd是依据TCPReceiver B自己的接收窗口空间)</li>
<li><strong>一言以蔽之</strong>：A发送给B的ack，并不是A要发送给B的数据，而仅仅是A为了使得B正常工作，所发送的交互辅助信息. 只有A要发送给B的数据(outbound_stream(payload))才会占据A的seqno空间,除此之外还有syn和fin（因为他们会对A到B的连接产生影响）</li>
<li><strong>复杂来说如下</strong>（已知每一端都可分为Receiver和Sender）<ul>
<li><ol>
<li>A端发送给B端的segment , 其中的seqno , 是A发送给B的字节 在 A的空间的下标.</li>
</ol>
</li>
<li><ol start="2">
<li><strong>只有TCPSender A 发送给 TCPReceiver B 的 报文内容才会占据seqno空间(syn + payload(outbound_stream) + fin)</strong></li>
</ol>
</li>
<li><ol start="3">
<li>而TCPReceiver A发送给TCPSender B的ackno 并不会占据TCPSender A的seqno空间</li>
</ol>
<ul>
<li>因为这是<strong>TCPReceiver A发送给TCPSender B的,ackno</strong>并不是来自TCPSender。况且<strong>ackno</strong>本身也并不是数据，而是一个辅助TCPSender B进行工作的<strong>辅助信息</strong>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>所有报文都有ack吗？所有报文都有seqno吗？</p>
<ul>
<li>任何报文都有seqno，发送的任何segment都需要有一个seqno,即便该segment本身可能并不占据/消耗seqno空间。</li>
<li>几乎所有报文都有ackno 以及 rwnd. (除了client发送给sender的第一个syn 报文)</li>
<li>如A给B发送了一个empty ack segment with seqno x, 那么A给B发送的下一个segment的seqno仍然是x</li>
</ul>
</li>
<li><p>How does the application read from the inbound stream?</p>
<ul>
<li>TCPConnection::inbound_stream() is implemented in the header file already. </li>
</ul>
</li>
</ul>
<ul>
<li>关于rst<ul>
<li>This flag (“reset”) means instant death to the connection</li>
<li>发送和接收到rst segment的后果是一样的：<ul>
<li>unclean shutdown :<ul>
<li>将outbound_stream和outbound_stream置为error</li>
<li>销毁连接 active = false</li>
</ul>
</li>
</ul>
</li>
<li>什么时候发送rst segment ?<ul>
<li>重传次数过多</li>
<li>当active = true时 调用了TCPConnection的析构函数</li>
<li><blockquote>
<p>There are two situations where you’ll want to <strong>abort the entire connection</strong>:</p>
<ol>
<li>If the sender has sent too many consecutive retransmissions without success (more than TCPConfig::MAX RETX ATTEMPTS, i.e., 8).</li>
<li>If the TCPConnection destructor is called while the connection is still active (active() returns true).</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>rst不占据seqno空间</li>
</ul>
</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-16-08-40-28.png"> </p>
<ul>
<li>You have reached the summit.</li>
<li>lab0 ，我们实现了一个 flow-controlled(流量控制) 的 bytestream</li>
<li>lab123 , 我们实现了一个 in-both-direction(双向的) 在bytestream和网络提供的unreliable datagrams之间进行通信的 工具（TCPSender和TCPReceiver）</li>
<li>lab4 , now , 我们将实现一个称为TCPConnection的整体模块 , 整合我们的TCPSender 和 TCPReceiver ，并处理connection的global housekeeping.</li>
<li>connection的TCPSegment 可以被封装进 uesr UDP segment(TCP-in-UDP) 或者 Internet IP datagrams(TCP/IP) -&gt; 使得你的代码可以和Internet上同样使用TCP/IP的主机进行交互.</li>
<li>需要注意的是 , TCPConnection只是将TCPSender和TCPReceiver进行组合. TCPConnection本身的实现只需要100行代码. TCPConnection依赖于TCPSender和TCPReceiver的鲁棒性</li>
</ul>
<ul>
<li><strong>Lab4 : the TCP Connection</strong><ul>
<li>本周 实现一个可工作的TCP, 我们已将做了大部分的工作 : 已经实现了TCPSender 和 TCPReceiver. lab4的工作是将他们组合在一起，组成一个class TCPConnection , 处理一些对于connection来说全局的事务</li>
<li>class TCPConnection就是一个peer. 负责接收和发送segment. 确保TCPSender和TCPReceiver 都可以在收到和发送的segment上 添写和读取相应的字段.</li>
<li>回忆 : <ul>
<li>TCP reliably conveys a pair of flow-controlled byte streams, one in each direction<ul>
<li>TCP可靠的 传输一对双向的流量控制的字节流.</li>
</ul>
</li>
<li>Two parties participate in the TCP connection, and each party acts as both “sender” (of its own outbound byte-stream) and “receiver” (of an inbound byte-stream) at the same time<ul>
<li>TCPConnection的两端，每一端都同时扮演者sender和receiver的角色.</li>
</ul>
</li>
</ul>
</li>
<li>AB两方被称为connection的endpoint / peer.<img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-16-20-08-14.png"></li>
</ul>
</li>
</ul>
<p>Here are the basic rules the TCPConnection has to follow</p>
<p>约定一下 将本端称为local … , 将对端称为 peer …</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="Receiving-segments"><a href="#Receiving-segments" class="headerlink" title="Receiving segments"></a>Receiving segments</h3><ul>
<li>TCPConnection收到segment : <strong>segment_received()</strong> called<br>In this method :  </li>
<li><strong>对于rst segment</strong><ul>
<li>如果local收到的segment 有 rst flag , 那么将 <ul>
<li>set inbound_stream and outbound_stream as error state , </li>
<li>并且不发送任何报文回复给peer , </li>
<li>并立刻杀死本连接. </li>
</ul>
</li>
</ul>
</li>
<li><strong>对于非rst segment</strong><ul>
<li>报文发送给 TCPReceiver : <strong>TCPReceiver</strong>接收<strong>segment中的seqno , syn , payload , fin</strong></li>
<li>如果ack flag , segment 告知 <strong>TCPSender</strong> 接收 <strong>ackno + window_size</strong>  </li>
<li>只要收到的segment占据了peer的seqno空间, 那么TCPConnection(本端的TCPReceiver)需要至少回复一个segment,来告知对端(的TCPSender) ackno 以及 window_size<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (seg.length_in_sequence_space() &gt; <span class="number">0</span>)  <span class="comment">//  receiver recv syn , payload , fin</span></span><br><span class="line">        ack_to_send = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>special case:<ul>
<li>TCP : Keepalive保活机制. 我们只实现回复keep-alive segment,不实现发送keep-alive segment <ul>
<li>对端会发送segment with invalid seqno 去检验本端的TCP是否还活着.</li>
<li>本端的TCPConnection需要回复该segment , 即便该segment不消耗任何 seqno.</li>
<li>如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.ackno().has_value() <span class="keyword">and</span> (seg.length_in_sequence_space() == <span class="number">0</span>) <span class="keyword">and</span> seg.header().seqno == _receiver.ackno().value() - <span class="number">1</span>) &#123;    <span class="comment">//  local TCP expect the seqno to be _receiver.ackno().value()</span></span><br><span class="line">  _sender.send_empty_segment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>从这里也可以看出，keep-alive segment只是检验对端的TCP层是否存活,而不是检验对端的应用层是否正常工作. 因为该keep-alive报文根本不会被送到应用层程序.</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Sending-segments"><a href="#Sending-segments" class="headerlink" title="Sending segments."></a>Sending segments.</h3><ul>
<li>The TCPConnection will send TCPSegments over the Internet:</li>
<li>TCPConnection将要发送的报文 其字段由两部分组成: TCPSender添写 + TCPReceiver添写<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-16-16-13-02.png"><ul>
<li>TCPSender负责 seqno + syn + payload + fin + rst</li>
<li>TCPReceiver负责ackno 以及receive window_size , 如果存在ackno 则 将ackno填入将要发送的segment（应该只有client主动发起连接的那一条syn segment中没有ackno）</li>
</ul>
</li>
<li>How does the TCPConnection actually send a segment?<ul>
<li>Similar to the TCPSender—push it on to the segments out queue. As far as your TCPConnection is concerned, consider it sent as soon as you push it on to this queue.</li>
<li>Soon the owner will come along and pop it (using the public segments_out() accessor method) and really send it.</li>
</ul>
</li>
</ul>
<h3 id="When-time-passes"><a href="#When-time-passes" class="headerlink" title="When time passes."></a>When time passes.</h3><ul>
<li>TCPConnection通过调用tick()代表时间流逝</li>
<li>TCPConnection::tick():<ul>
<li>tell the TCPSender about the passage of time : TCPSender::tick()</li>
<li>当重传次数过多, 放弃该连接 , 并发送an empty segment with the rst flag set给对端</li>
<li>end the connection cleanly if necessary  <ul>
<li>necessary : 满足#1234，TIME_WAIT阶段结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Decide-when-connection-is-done"><a href="#Decide-when-connection-is-done" class="headerlink" title="Decide when connection is done"></a><strong>Decide when connection is done</strong></h3><p><strong>One important function of the TCPConnection is to decide when the TCP connection is fully “done.”</strong></p>
<p>以下就是关于tcp何时结束的讨论</p>
<p><strong>The end of a TCP connection: consensus takes work</strong></p>
<h4 id="connection-is-down-的方式"><a href="#connection-is-down-的方式" class="headerlink" title="connection is down 的方式"></a>connection is down 的方式</h4><ul>
<li><p><strong>when tcpconnection is down</strong></p>
<ul>
<li><strong>释放其对本地端口号的独占声明</strong></li>
<li><strong>停止发送ack作为回复</strong></li>
<li><strong>将连接视为历史记录</strong></li>
<li><strong>active() return false</strong></li>
</ul>
</li>
<li><p><strong>connection有两种结束的方式</strong></p>
</li>
<li><p><strong>Unclean shutdown</strong></p>
<ul>
<li>情况: 本端发送或者收到一个rst segment<ul>
<li>关于rst segment : 接收和发送的作用都是一样的：导致unclean shutdown</li>
</ul>
</li>
<li>动作: <ul>
<li>outbound and inbound stream 置为 state error</li>
<li>active() return false from now on immediately</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>clean shutdown</strong></p>
<ul>
<li>the connection get to “done” without error</li>
<li>clean shutdown更复杂但是更优美，因为他尽可能地保证了双方的outbound bytestream被可靠的完全的交付给peer receiver.</li>
</ul>
</li>
</ul>
<h4 id="如何尽可能达成clean-shutdown"><a href="#如何尽可能达成clean-shutdown" class="headerlink" title="如何尽可能达成clean_shutdown"></a>如何尽可能达成clean_shutdown</h4><ul>
<li><strong>由于Two Generals Problem两军问题,不可能去保证两端都能达成clean shutdown，但是TCP已经尽可能地接近了。</strong>下面从一端的角度来看tcp如何做到这点 </li>
<li><strong>若要在一条连接中 和 remote peer 达成clean shutdown，需要先满足四个先决条件</strong><ul>
<li><strong>Prereq #1 The inbound_stream has been fully assembled and has ended.</strong><ul>
<li>TCPReceiver的inbound_stream已经顺序的存了所有字节，且 已经存了最后的那个fin.(TCPReciever receive fin —&gt; inbound_stream.end_input())</li>
<li><strong>即 TCPReceiver.state = FIN_RECV</strong></li>
</ul>
</li>
<li><strong>Prereq #2 The outbound_stream has been ended by the local application and fully sent (including the fact that it ended, i.e. a segment with fin ) to the remote peer.</strong><ul>
<li>local outbound_stream 已经关闭(上层app调用了outbound.end_input()),且outbound_stream的全部字节都已经发送，且TCPSender 已经发送了最后的fin segment.</li>
<li><strong>即TCPSender.state = FIN_SENT</strong></li>
</ul>
</li>
<li><strong>Prereq #3 The outbound stream has been fully acknowledged by the remote peer.</strong><ul>
<li>local outbound_stream 已经全部被remote peer 所确认.<ul>
<li>即 local收到了remote peer 为fin返回的一个ack。因为这代表local发送的fin及之前的全部都被确认；且fin代表这就是发送的全部字节。</li>
</ul>
</li>
<li><strong>即TCPSender.state = FIN_ACKED</strong></li>
<li>易知若达成#3 则#2必然已经达成 </li>
</ul>
</li>
<li><strong>Prereq #4 The local TCPConnection is confident that the remote peer can satisfy prerequisite #3</strong>. This is the brain-bending part. There are two alternative ways this can happen:<ul>
<li><strong>即local确认 remote peer满足TCPSender.state = FIN_ACKED</strong></li>
<li>即local确认 remote peer 接收到了自己回复fin的ack</li>
<li>这有点绕，有两种方式满足#4<ul>
<li><strong>option A</strong> : local 几乎可以认为 peer满足#3，但并不肯定。也即<strong>local几乎满足#4</strong></li>
<li><strong>option B</strong> : local 可以百分之分确定 peer满足#3，即<strong>local肯定满足#4</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>为什么满足了1234，local就可以销毁了？local就可以完全断开连接了？（关闭Sender和Receiver，不再与外界交互）</strong><ul>
<li>因为首先明确clean_shutdown的目标是 双方都完全的可靠的接收到了对方的outbound stream.</li>
<li>其次这四个条件含义分别如下<ul>
<li>.#2是为了保证local的outbound_stream全部字节都已经被发送出去（其实按照我们所实现的，满足了#3就一定满足#2）(TCPSender.state = FIN_SENT)</li>
<li>.#3是为了保证local知道，local的outbound stream全部被peer接收(TCPSender.state = FIN_ACKED)</li>
<li>.#1是为了保证peer的outbound stream全部被local接收(TCPReceiver.state = FIN_RECV)</li>
<li>.#4是为了保证peer知道，其outbound stream 已经全部被local接收，不然根据重传机制，peer会不断重传outbound stream字节或如fin segment(remote TCPSender.state = FIN_ACKED)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="条件4如何达成"><a href="#条件4如何达成" class="headerlink" title="条件4如何达成"></a>条件4如何达成</h5><h6 id="Option-A"><a href="#Option-A" class="headerlink" title="Option A"></a>Option A</h6><p><strong>Option A: lingering after both streams end.</strong><br>这种情况发生在local<strong>主动发起关闭</strong>，<strong>lingering</strong> 即 close前的最后一个状态的 <strong>TIME_WAIT</strong>。<br>等待linger time是为了local尽可能地满足#4</p>
<ul>
<li><p><strong>local满足#1 和 #3 ; 且peer似乎满足#3。(即local似乎满足#4.)</strong></p>
<ul>
<li><strong>local并不能准确的得知peer满足#3,因为TCP不可靠的传输ack（TCP不会为ack回复ack）</strong>，local发给对方的ack可能丢失.</li>
</ul>
</li>
<li><p><strong>local</strong>可以通过很<strong>自信的认为</strong>remote peer满足#3</p>
<ul>
<li><strong>local通过等待一段时间（linger time），且这段时间内remote peer没有重传任何报文</strong></li>
</ul>
</li>
<li><p>linger time = 10 * initial _retransmission_timeout; 在生产环境中 = 2 MSL(60~120s)</p>
<ul>
<li>具体的，当本端满足#1和#3，且距离上次收到ack已经至少过去了10倍的initial _retransmission_timeout 时 , the connection is done . 这种双方stream结束之后的等待 称为 lingering : 它的目的是确保远端不会尝试重传 [本端需要回复ack的] 报文.</li>
<li>这也就意味着local class TCPConnection需要再存活一会，仍旧占据着端口，并为收到的segment回复ack.即使本端的inbound,outbound stream已经关闭,并且TCPSender,TCPReceiver都已经正确的完成了所负责的工作。我的实现也做到了这一点</li>
</ul>
</li>
<li><p>TIME_WAIT作用例子如下</p>
<blockquote>
<p><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-17-00-20-17.png"><br>在TCP的生产环境中，linger timer (also known as the time-wait timer or twice the Maximum Segment Lifetime (MSL)) 一般来说是60～120秒。实际上这是一段相当长的时间占据着端口，没有人愿意等这么久，尤其是当你还想用这个端口号去启动本地的另一个服务的时候。Socket编程里，有一个选项是SO_REUSEADDR，可以让Linux忽视端口的占用，强制把一个Socket服务绑定到正在被使用中的端口号上。</p>
</blockquote>
</li>
<li><p>但是即便有lingering，也不能保证peer一定满足#3，因为peer重传的FIN可能在linger time之后才到达local 或者 根本就是丢失了. 故可能会造成peer的class tcpconnection一直存在，一直重传fin segment。即便此时local的outbound stream 和 inbound stream已经关闭；peer的outbound stream 和 inbound stream都已经关闭.</p>
</li>
</ul>
<ul>
<li><strong>综上，active close 时 , 若满足#1#3，则local不一定满足了#4，需通过linger time来尽可能地满足#4</strong></li>
</ul>
<h6 id="Option-B"><a href="#Option-B" class="headerlink" title="Option B"></a>Option B</h6><p><strong>Option B: passive close.</strong><br><strong>发生在local被动关闭连接，直接进入CLOSED状态，而不必进入TIME_WAIT</strong></p>
<ul>
<li><p><strong>满足 #1和#3，且local100%确认remote peer满足#3</strong>.(既local确定renmote收到了local的所发送的fin ack)</p>
<ul>
<li><strong>怎么做到100%确认的？由上所述TCP也不ack ack.</strong>  </li>
<li><strong>因为在这种passive close的情况下，remote peer首先关闭了其outbound_stream。</strong></li>
</ul>
</li>
<li><p>OptionB rule是如何工作的 ? <strong>为什么passive close的时候就可以100%确定remote peer满足#4 ?</strong></p>
<ul>
<li>这有一点烧脑，不过可以更深入的理解 两军问题 以及 在不可靠的网络上提供可靠服务的固有限制<ul>
<li>it’s fun to think about and gets to the deep reasons for the Two Generals Problem and the inherent constraints on reliability across an unreliable network.</li>
</ul>
</li>
<li><strong>原因如下</strong>: <ul>
<li>local在收到了remote peer的fin之后(#1)，发送ack报文（至少要发送<strong>FIN segment with ack and fin</strong>以满足 #2），易知该local发送的fin报文ack的是remote peer’s fin. </li>
<li>已知local满足#3 , 那么remote peer 一定已经ack了该local发送的fin+ack报文, 意味着remote peer已经看到了local peer发送的fin报文（上的ackno）, <strong>该ackno ack了remote之前发送的fin。那么，就可以保证 remote peer一定已经满足#3了</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>综上，passive close 时 , 若满足#1#3，则local一定满足了#4，无需通过linger time来尽可能地满足#4</strong></p>
</li>
</ul>
<ul>
<li>The bottom line is that if the TCPConnection’s inbound stream ends before the TCPConnection has ever sent a fin segment(local outbound_stream_end), （即如果local被动关闭连接）then the TCPConnection doesn’t need to linger after both streams finish</li>
</ul>
<h4 id="The-end-of-a-TCP-connection-practical-summary）"><a href="#The-end-of-a-TCP-connection-practical-summary）" class="headerlink" title="The end of a TCP connection (practical summary）"></a>The end of a TCP connection (practical summary）</h4><p>指导书给出的实践指导<br>我们可以根据local的state，来判断是active close(optionA) 还是 passive close(optionB)</p>
<ul>
<li><p>class TCPConnection 有一个变量linger_after_streams_finish 代表本端是否需要等待linger time再关闭连接</p>
<ul>
<li>一开始是true</li>
<li>如果inbound_stream在outbound_stream eof之前被对端end,那么置为false. (即如果是被动关闭连接)</li>
</ul>
</li>
<li><p><strong>在任何时候 #1 和 #3 被满足</strong>，</p>
<ul>
<li><strong>a.</strong> 如果linger_after_streams_finish = false ，则 connection is done(active() should return false)</li>
<li><strong>b.</strong> 如果linger_after_streams_finish = true , 则 本端等待足够长的时间(尽可能的满足#4），然后connection is done(active() should return false)</li>
</ul>
</li>
</ul>
<p>约定 TCPConnection的调用者称为owner<br>约定 A主动关闭连接 ：A先断开 A到B的字节流<br>约定 A主动被动连接 ：A后断开 A到B的字节流</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h3><ul>
<li>TCPConnection如何发送segment:<ul>
<li><strong>std::queue<TCPSegment> _segments_out{}</TCPSegment></strong>;</li>
<li><strong>void TCPConnection::send_segments()</strong><ul>
<li>将TCPSender的segment移动到TCPConnection的segment_queue中</li>
<li>而后owner会将该segment_queue发送出去</li>
<li>注意会捎带ack</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>关于_linger_after_streams_finish</strong></p>
<ul>
<li><strong>只有在clean_shutdown的情况下 , _linger_after_streams_finish才有意义</strong></li>
<li><strong>unclean_shutdown 时 , _linger_after_streams_finish无意义</strong>。因为unclean_shutdown 不在乎bytestream有没有 正确的完全的 递送给接收方</li>
<li>_linger_after_streams_finish含义 : <strong>本端在满足#1 #3之后 是否需要再等待一段时间以满足 #4</strong><ul>
<li>也即，断开连接时是进入TIME_WAIT状态,还是直接进入CLOSED</li>
<li><strong>bool _linger_after_streams_finish{true};</strong><ul>
<li>在TCPConnection刚构造时初始化为true , 意味着初始时认为本端在满足#1#2#3之后，必须等待linger time才能满足#4，达成connection is down条件</li>
<li>宏观来看只有<strong>主动关闭连接</strong>时才有_linger_after_streams_finish = true</li>
</ul>
</li>
<li><strong>_linger_after_streams_finish = false</strong><ul>
<li>本端在满足#1#2#3之后，#4自动满足，不必等待linger time</li>
<li><strong>如果本端的inbound_stream 在本端的outbound_stream发送fin segemnt之前就end了，那么 本端是不必在双端stream finish后，等待linger time再关闭连接</strong>。</li>
<li>宏观来看只有<strong>被动关闭连接</strong>时才有_linger_after_streams_finish = false<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.state() == TCPReceiver::State::FIN_RECV &amp;&amp;</span><br><span class="line">    (_sender.state() == TCPSender::State::SYN_ACKED_2 || _sender.state() == TCPSender::State::SYN_ACKED_1))</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><strong>使用</strong>: 由后文易知，在满足#1#2#3#4时，本端tcpconnection is done<ul>
<li>被动关闭连接 </li>
<li>CLOSE_WAIT -&gt; [LAST ACK -&gt; CLOSED]</li>
<li>满足#123 , 且自动满足#4(!_linger_after_streams_finish), 进入closed<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> :</span></span><br><span class="line"><span class="function"><span class="comment">//  clean shutdown 之 本端 主动被动连接 进入 CLOSED</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(_receiver.state() == TCPReceiver::State::FIN_RECV &amp;&amp; _sender.state() == TCPSender::State::FIN_ACKED &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">    !_linger_after_streams_finish)</span> </span>&#123;</span><br><span class="line">    clean_shutdown();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// //  clean shutdown 之 本端 主动关闭连接 进入 TIME_WAIT</span></span><br><span class="line"><span class="comment">// if (_receiver.state() == TCPReceiver::State::FIN_RECV &amp;&amp; _sender.state() == TCPSender::State::FIN_ACKED &amp;&amp;</span></span><br><span class="line"><span class="comment">//     _linger_after_streams_finish) &#123;</span></span><br><span class="line"><span class="comment">//         //  TIME_WAIT !</span></span><br><span class="line"><span class="comment">//         //  在tick时检验是否需要断开连接</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li>
<li>主动关闭连接</li>
<li>FIN_WAIT1 -&gt; [FIN_WAIT2 -&gt; TIME_WAIT -&gt; CLOSED]</li>
<li>满足#123，且需要等待linger time才能满足#4<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> :</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(_receiver.state() == TCPReceiver::State::FIN_RECV &amp;&amp; _sender.state() == TCPSender::State::FIN_ACKED &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">    _linger_after_streams_finish)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_time_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout)</span><br><span class="line">        clean_shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>反应本端tcp是否仍然存活</p>
<ul>
<li>bool _active{true};</li>
<li>什么时候为true ?<ul>
<li>一开始就是true</li>
</ul>
</li>
<li>什么时候为false ?<ul>
<li>clean shutdown 和 unclean shutdown</li>
</ul>
</li>
</ul>
</li>
<li><p>size_t _time_since_last_segment_received{0};  </p>
<ul>
<li>距离收到上个sgement过去了多长时间，用于TIME_WAIT</li>
</ul>
</li>
<li><p><strong>clean shutdown</strong></p>
<ul>
<li><strong>each of the two ByteStreams has been reliably delivered completely to the receiving peer</strong><ul>
<li>more complicated but beautiful</li>
<li>尽可能地保证两个outbound_stream 都被<strong>完全的可靠的</strong> 传递给receiver_peer</li>
</ul>
</li>
<li>clean_shutdown()<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::clean_shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>unclean shutdown</strong></p>
<ul>
<li>tcpconnection 接收或者发送 rst segment</li>
<li>动作<ul>
<li>outbound and inbound stream 置为 state error</li>
<li>active() can return false immediately.</li>
</ul>
</li>
<li>unclean shutdown()<ul>
<li>发送rst segment，主动: true ;</li>
<li>接收rst segment，被动: false</li>
<li>已知在发送rst segment之前，segments_out()可能会有未发送的报文，将他们清空。（未找到理论依据，不过test让我们这么干）<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::unclean_shutdown</span><span class="params">(<span class="keyword">bool</span> rst_to_send <span class="comment">/* = false */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TCPSegment&gt; empty;</span><br><span class="line">    _sender.segments_out().swap(empty);</span><br><span class="line">    <span class="keyword">if</span> (rst_to_send) &#123;</span><br><span class="line">        _sender.send_empty_segment(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;send_segments();</span><br><span class="line">    &#125;</span><br><span class="line">    _sender.stream_in().set_error();</span><br><span class="line">    _receiver.stream_out().set_error();</span><br><span class="line"></span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCP-State-Transitions"><a href="#TCP-State-Transitions" class="headerlink" title="TCP State Transitions"></a><strong>TCP State Transitions</strong></h3><p><a href="https://ttcplinux.sourceforge.net/documents/one/tcpstate/tcpstate.html">重要参考</a></p>
<p>tcpconnection状态<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-12-11-03-42.png"></p>
<ul>
<li>我的实现中，虽然指导书说不要求在Sender和Receiver维护状态，不过为了更清晰，我还是为Sender和Reciever依据lab123所述分别维护了状态。<ul>
<li>Receiver<img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-16-49-28.png"></li>
<li>Sender<img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-16-50-02.png"></li>
</ul>
</li>
</ul>
<ul>
<li>TCPConnection和TCPSender、TCPReciever的状态关系如下表<ul>
<li>背景:1. client 主动发起连接 到 server，2. client主动断开连接.</li>
<li>server状态表如下<table>
<thead>
<tr>
<th>TCPConnection State</th>
<th>TCPReceiver State</th>
<th>TCPSender State</th>
<th>linger_after_stream_finish</th>
<th>active</th>
</tr>
</thead>
<tbody><tr>
<td>1. (被动发起连接)LISTEN</td>
<td>LISTEN</td>
<td>CLOSED</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>SYN_RCVD</td>
<td>SYN_RECV(recv syn)</td>
<td>SYN_SENT(send syn)</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>SYN_RECV</td>
<td>SYN_ACKED(recv ack)</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>2. (被动关闭连接)CLOSE_WAIT</td>
<td>FIN_RECV(recv fin)</td>
<td>SYN_ACKED</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>LAST_ACK</td>
<td>FIN_RECV</td>
<td>FIN_SENT(fin send)</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>CLOSED</td>
<td>FIN_RECV</td>
<td>FIN_ACKED(recv ack)</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
</li>
<li>client状态表如下<table>
<thead>
<tr>
<th>TCPConnection State</th>
<th>TCPReceiver State</th>
<th>TCPSender State</th>
<th>linger_after_stream_finish</th>
<th>active</th>
</tr>
</thead>
<tbody><tr>
<td>1. (主动发起连接)LISTEN</td>
<td>LISTEN</td>
<td>CLOSED</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>SYN_SENT</td>
<td>LISTEN</td>
<td>SYN_SENT</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>SYN_RECV(recv syn)</td>
<td>SYN_ACKED(recv ack)</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>2. (主动关闭连接)FIN_WAIT1</td>
<td>SYN_RECV</td>
<td>FIN_SENT(send syn)</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>FIN_WAIT2</td>
<td>SYN_RECV</td>
<td>FIN_ACKED(recv ack)</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>TIME_WAIT</td>
<td>FIN_RECV</td>
<td>FIN_ACKED</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CLOSED</td>
<td>FIN_RECV</td>
<td>FIN_ACKED</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="主动关闭连接可能会经历的四种状态"><a href="#主动关闭连接可能会经历的四种状态" class="headerlink" title="主动关闭连接可能会经历的四种状态"></a>主动关闭连接可能会经历的四种状态</h4><ul>
<li><p>关于连接关闭时的state <strong>FIN_WAIT1 , FIN_WAIT2 , CLOSING , CLOSED</strong> 关系。<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-18-26-39.png"></p>
</li>
<li><p>FIN_WAIT1 -&gt; FIN_WAIT2 -&gt; TIME_WAIT -&gt; CLOSED </p>
<ul>
<li>是常规的client主动关闭连接。如上client表所述</li>
</ul>
</li>
<li><p><strong>FIN_WAIT1 -&gt; CLOSING -&gt; TIME_WAIT -&gt; CLOSED</strong></p>
<ul>
<li><strong>为什么会有 CLOSING</strong> ? <ul>
<li><strong>双方同时主动的关闭连接，也即都主动的发送fin segment</strong><ul>
<li>使得local 在收到local发送的fin的ack之前，先收到了remote peer发送的fin</li>
<li><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-12-59.png"><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-15-51.png"></li>
</ul>
</li>
<li>好比说 client主动关闭连接,发送fin；同时server也主动关闭连接,发送fin<ul>
<li>下图为client表,server表和client表一模一样。<ul>
<li>为什么需要有time_wait：当从closing -&gt; 变成 fin_recv + fin_acked的时候，已经满足#123，但无法满足#4，因为是主动发送fin，无法保证对方收到了fin的ack（被动发送fin的话，对方fin的ack会随着我方的fin被发送过去，而对方返回的对我们的fin的ack，就代表了对方收到了fin ack）<table>
<thead>
<tr>
<th>TCPConnection State</th>
<th>TCPReceiver State</th>
<th>TCPSender State</th>
<th>linger_after_stream_finish</th>
<th>active</th>
</tr>
</thead>
<tbody><tr>
<td>(主动关闭连接)FIN_WAIT1</td>
<td>SYN_RECV</td>
<td>FIN_SENT(send syn)</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CLOSING</td>
<td>FIN_RECV(recv fin)</td>
<td>FIN_SENT</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>TIME_WAIT</td>
<td>FIN_RECV</td>
<td>FIN_ACKED</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>CLOSED</td>
<td>FIN_RECV</td>
<td>FIN_ACKED</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B">FIN_WAIT1 -&gt; TIME_WAIT</a><ul>
<li>peer的fin和ack for local fin在同一个segment里一起发送过来</li>
<li>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</li>
<li>TCP 延迟确认机制:为尽量减少发送空的ack segment</li>
<li><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-19-35.png"></li>
</ul>
</li>
</ul>
<h4 id="Simultaneous"><a href="#Simultaneous" class="headerlink" title="Simultaneous"></a><strong>Simultaneous</strong></h4><h5 id="Simultaneous-Open"><a href="#Simultaneous-Open" class="headerlink" title="Simultaneous Open"></a>Simultaneous Open</h5><ul>
<li>双方同时发送syn报文</li>
<li>It’s possible for two applications to send a SYN to each other to start a TCP connection, although the possibility is small, because both sides have to know which port on the other side to send to. This process is called “<strong>Simultaneous Open</strong>“, or “<strong>simultaneous active open on both sides</strong>“.</li>
<li>For example: An application at host A uses 7777 as the local port and connects to port 8888 on host B. At the same time, an application at host B uses 8888 as the local port and connects to port 7777 on host A. This is “Simultaneous Open”.</li>
<li>TCP is specially designed to deal with “Simultaneous Open”, during which only one TCP connection is established, not two. The state transitions are shown in the following figure:<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-43-12.png"></li>
</ul>
<h5 id="Simultaneous-Close"><a href="#Simultaneous-Close" class="headerlink" title="Simultaneous Close"></a>Simultaneous Close</h5><ul>
<li>双方同时发送 fin 报文</li>
<li>It’s permitted in TCP for both sides to do “active close”, which is called “<strong>Simultaneous Close</strong>“. The state transitions are shown in the following figure:<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-21-53.png"></li>
</ul>
<p>故此 当然我的实现也可以正常处理这2种情况</p>
<h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>我写完第一次测试时 在模拟测试阶段，遇到了一些special case的bug，不过改起来也很愉快，写在case里。</p>
<p>第二次测试时，惊人的发现所有真实发送segment的测试都fail了，一度心态崩溃道心破碎，自己开server client 来回发送segment抓包还能正常工作，也看不到有什么异常的segment。明明没错啊但是还一个test都过不了，简直是给我搞得抓心挠肝。</p>
<p>后来研究了一下他的测试原理，应该是将我们tcpconnection收发的segment以及tcpconnection的类中所有的输出 都重定向到了测试文件a里。然后将这个a和输入的文件进行比较是否相等。由于重定向，我在code中的cout也被输入到了文件a中，故fail。</p>
<p>相等，则pass<br>不等，则fail</p>
<p>这谁能想到，遂将所有cout注释掉，测试，all passed，吾喜而笑，洗盏更酌，睡觉。</p>
<p>测试原理明天再整理.</p>
<h2 id="Over"><a href="#Over" class="headerlink" title="Over !"></a>Over !</h2><p><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-15-23-44-33.png"></p>
<h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><p>closing case. 整理完上面的Closing State , 这个就很显然了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;*********************start in CLOSING, send ack, time out**********************&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//  review</span></span><br><span class="line"><span class="comment">// test #2: start in CLOSING, send ack, time out</span></span><br><span class="line">&#123;</span><br><span class="line">    TCPTestHarness test_2 = TCPTestHarness::in_closing(cfg);    <span class="comment">//  closing . TCPSender : FIN_SENT , TCPReceiver : FIN_RECV</span></span><br><span class="line">    test_2.execute(Tick(<span class="number">4</span> * cfg.rt_timeout));                   <span class="comment">//  超时 local重传fin segment</span></span><br><span class="line">    test_2.execute(ExpectOneSegment&#123;&#125;.with_fin(<span class="literal">true</span>));          <span class="comment">//  check local是否重传fin segment</span></span><br><span class="line">    test_2.execute(ExpectState&#123;State::CLOSING&#125;);                <span class="comment">//  local state still = closing</span></span><br><span class="line">    test_2.send_ack(WrappingInt32&#123;<span class="number">2</span>&#125;, WrappingInt32&#123;<span class="number">2</span>&#125;);        <span class="comment">//  收到ack</span></span><br><span class="line">    test_2.execute(ExpectNoSegment&#123;&#125;);                          <span class="comment">//  local send no segment</span></span><br><span class="line">    test_2.execute(ExpectState&#123;State::TIME_WAIT&#125;);              <span class="comment">//  local in time_wait</span></span><br><span class="line">    test_2.execute(Tick(<span class="number">10</span> * cfg.rt_timeout - <span class="number">1</span>));              </span><br><span class="line">    test_2.execute(ExpectState&#123;State::TIME_WAIT&#125;);</span><br><span class="line">    test_2.execute(Tick(<span class="number">2</span>));</span><br><span class="line">    test_2.execute(ExpectState&#123;State::CLOSED&#125;);                 <span class="comment">//  local pass time_wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再举出一个client、server的例子</p>
<hr>
<h2 id="优化-后续"><a href="#优化-后续" class="headerlink" title="优化.. 后续"></a>优化.. 后续</h2><ul>
<li>Does the TCPConnection need any fancy data structures or algorithms?<ul>
<li>No, it really doesn’t. The <strong>heavy lifting is all done by the TCPSender and TCPReceiver</strong> that you’ve already implemented.  </li>
<li>The work here is really just about wiring everything up, and dealing with some lingering connection-wide subtleties that can’t easily be factored in to the sender and receiver.</li>
<li><strong>The hardest part will be deciding when to fully terminate a TCPConnection and declare it no longer active.</strong></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS144</category>
      </categories>
      <tags>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-链路层和局域网</title>
    <url>/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<p>链路层和物理层<br>链路层的MAC协议有<br>信道划分协议、随即加入协议、轮询协议<br>LAN局域网<br>链路层地址,又称 LAN地址(LAN address) , 物理地址(phyiscal address) , MAC地址(MAC address)<br>地址解析协议ARP<br>交换机：链路层设备（检查链路层头部）,根据MAC地址进行转发<br>路由器：网络层设备（检查网络层的头部）, 根据IP地址进行转发</p>
<span id="more"></span>

<h1 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为什么在链路层和传输层都实现了可靠性 ？<br>因为一个点到点 一个端到端 ? </p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul>
<li><p>传输层功能：解决进程到进程的区分，加强网络服务从不可靠变成可靠</p>
</li>
<li><p>网络层功能：解决端到端传输 ; 也即解决一个网络如何到达另一个网络的路由问题</p>
</li>
<li><p>链路层功能：解决点到点传输 ; 也即解决在一个网络内部如何由一个节点（主机或者路由器）到达另外一个相邻节点</p>
</li>
<li><p>目标</p>
<ul>
<li>理解数据链路层服务的原理:<ul>
<li>检错和纠错</li>
<li>共享广播信道：多点接入（多路访问）</li>
<li>链路层寻址</li>
<li>LAN:以太网、WLAN、VLANs</li>
<li>可靠数据传输，流控制: 解决!</li>
</ul>
</li>
<li>实例和各种链路层技术的实现</li>
</ul>
</li>
<li><p><strong>WAN : World Area NetWork</strong></p>
<ul>
<li><strong>广域网</strong>、外网、公网</li>
<li>网络形式采用<strong>点到点链路</strong> <ul>
<li>带宽大、距离远（延迟大） &gt;带宽延迟积大 </li>
<li>如果采用多点连接方式 <ul>
<li>竞争方式：一旦冲突代价大</li>
<li>令牌等协调方式：在其中协调节点的发送代价大</li>
</ul>
</li>
</ul>
</li>
<li><strong>点到点链路的链路层服务实现非常简单，封装和解封装</strong></li>
</ul>
</li>
<li><p><strong>LAN : Local Area NetWork</strong></p>
<ul>
<li><strong>局域网</strong></li>
<li>一般采用<strong>多点连接</strong>方式 <ul>
<li>连接节点非常方便 </li>
<li>接到共享型介质上（或网络交换机），就可以连接所有其他节点</li>
</ul>
</li>
<li>多点连接方式网络的链路层功能实现相当复杂 <ul>
<li>多点接入：协调各节点对共享性介质的访问和使用 </li>
<li>竞争方式：冲突之后的协调</li>
<li>令牌方式：令牌产生，占有和释放等</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>术语</strong></p>
<ul>
<li>节点 node : 任何运行链路层协议的设备称为节点，包括主机、路由器、交换机、wifi接入点</li>
<li>链路 link :  沿着通信路径,连接个相邻节点通信信道的是链路<ul>
<li>有线链路 </li>
<li>无线链路 </li>
<li>局域网，共享性链路</li>
</ul>
</li>
<li>帧 frame : 第二层协议数据单元帧frame，封装数据报</li>
</ul>
</li>
<li><p>数据链路层负责从一个节点通过链路将（帧中的）数据报发送到相邻的物理节点（一个子网内部的2节点）</p>
</li>
</ul>
<p>链路层功能：解决点到点。在相邻两点之间，传输以帧为单位的数据</p>
<h3 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h3><ul>
<li><p><strong>成帧(frame)</strong> </p>
<ul>
<li>链路层协议将网络层数据报用链路层帧封装起来，然后放入链路传送</li>
</ul>
</li>
<li><p><strong>链路接入</strong> </p>
<ul>
<li>媒体访问控制(Medium Access Control , MAC)协议规定了frame在链路上传输的规则</li>
<li>对于点到点链路(链路的一端仅有一个发送方,另一端仅有一个接收方)<ul>
<li>MAC协议比较简单</li>
<li>即无论何时链路空闲，发送方都能够发送帧</li>
</ul>
</li>
<li>对于多个节点共享单个广播链路(即多路访问问题)<ul>
<li>MAC协议负责协调多个节点的帧传输</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>可靠交付</strong></p>
<ul>
<li>当链路层协议提供可靠交付服务时,它保证无差错地经链路层移动每个网络层数据报 <ul>
<li>在（一个网络内）相邻两个节点完成可靠数据传递</li>
</ul>
</li>
<li>与TCP提供可靠交付服务类似，链路层也是通过确认和重传实现可靠交付</li>
<li>链路层可靠交付服务通常用于易于产生高差错率的链胳,如无线链路<ul>
<li>其目的是本地(也就是在差错发生的链路上)纠正一个差错，而不是通过运输层或应用层协议迫使迸行端到端的数据重传 </li>
</ul>
</li>
<li>然而，对于低比特差错的链路，括光纤、同轴电缆和许多双绞铜钱链路，链路层可靠交付可能会被认为是一种不必要的开销 由于这个原因，许多有线的链路层协议不提供可靠交付服务.</li>
</ul>
</li>
<li><p>差错检测和纠正</p>
<ul>
<li>差错检测 : 逼运输层、网络层的因特网校验和更复杂一些.</li>
<li>差错纠正 : 接收端检查和纠正bit错误，不通过重传来纠正错误</li>
</ul>
</li>
</ul>
<p>以太网 链路层 不保证可靠传输协议（因为以太网本身比较可靠，所以不需要通过协议实现可靠）<br>waln(无线局域网) 链路层 保证可靠传输协议(发出去之后需要确认)（因为无线网络本身出错率就比较高，存在电磁波衰减、干扰问题；所以需要人为地通过协议保证可靠）</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>链路层在哪里实现 ?</p>
<ul>
<li><p>首先，<strong>网络适配器(network adapter)<strong>，又称</strong>网络接口卡(Network Interface Card, NIC)<strong>，就是所谓的</strong>网卡</strong></p>
</li>
<li><p><strong>链路层功能主体在网卡上实现,也有功能在软件实现</strong>,软硬件结合<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-08-40-04.png"></p>
<ul>
<li>每个主机/路由器/交换机上插若干网卡,每个网卡上实现了链路层和相应物理层功能、</li>
<li>网卡写死了自己的MAC地址</li>
</ul>
</li>
<li><p><strong>网卡/适配器通信</strong><br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-08-42-58.png"></p>
<ul>
<li>发送方: <ul>
<li>在帧中封装数据报 </li>
<li>加上差错控制编码，实现RDT和流量控制功能等</li>
</ul>
</li>
<li>接收方 <ul>
<li>检查有无出错，执行rdt和流量控制功能等</li>
<li>解封装数据报，将至交给上层</li>
</ul>
</li>
<li>适配器是半自治的,实现了链路和物理层功能</li>
<li>一个适配器可以同时发/接</li>
</ul>
</li>
</ul>
<h2 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h2><ul>
<li>链路层会提供 <strong>比特级差错检测和纠正(bit-level error detection and correction)</strong> 服务</li>
<li>理论基础 : <ul>
<li>发送方 : 为保护比特受损，使用<strong>差错检测和纠正位(Error-Detection and Correction , EDC)<strong>来</strong>增强数据D</strong><ul>
<li>数据D不仅包括网络层数据报，还包括链路层首部</li>
</ul>
</li>
<li>接收方 : 收到D’和EDC’,确定D’和原D是否相同</li>
<li>检测并非100%有效，可能出现<strong>未检出比特差错(undetected bit error)</strong><ul>
<li>导致接收方向上提交一个受损的数据报</li>
<li>因此，我们要选择一个差错检测方案，使得这种事件发生的概率很小<ul>
<li>奇偶校验<ul>
<li>用来描述差错检测和纠正背后隐含的基本思想</li>
</ul>
</li>
<li>检验和方法<ul>
<li>更多地应用于运输层</li>
</ul>
</li>
<li>循环冗余检测<ul>
<li>更多地应用在适配器中的链路层<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-08-59-01.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="奇偶检验"><a href="#奇偶检验" class="headerlink" title="奇偶检验"></a>奇偶检验</h3><ul>
<li>单bit奇偶校验 : 检测单(奇数)个bit级错误<ul>
<li>采用一个奇偶检验位.</li>
<li><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-09-08-59.png"></li>
</ul>
</li>
<li>2维奇偶校验 : 检测和纠正单个bit错误,检测两个bit差错的任意组合<ul>
<li>i+j+1个奇偶检验位</li>
<li><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-09-09-30.png"></li>
</ul>
</li>
</ul>
<h3 id="校验和方法"><a href="#校验和方法" class="headerlink" title="校验和方法"></a>校验和方法</h3><p>略</p>
<h3 id="循环冗余检测-CRC"><a href="#循环冗余检测-CRC" class="headerlink" title="循环冗余检测 CRC"></a>循环冗余检测 CRC</h3><p>略</p>
<ul>
<li>CRC : Cyclic Redundancy Check </li>
</ul>
<h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><ul>
<li><p>两种类型的链路（一个子网内部链路连接形式）：</p>
<ul>
<li><strong>点对点链路(point-to-point link)</strong><ul>
<li>由链路一段的单个发送方和链路另一端的单个接收方组成 <ul>
<li>如以太网交换机和主机之间的点对点链路</li>
</ul>
</li>
<li>为点对点链路设计的链路层协议 , 如点对点协议 PPP ; HDLC</li>
</ul>
</li>
<li><strong>广播链路(broadcast link)</strong> (共享线路或媒体)<ul>
<li>多个发送和接收节点都连接在同一个，单一的，共享的，广播信道上</li>
<li>“广播”是因为当任何一个节点传输一个帧时，信道广播该帧，每个其他节点都收到一个副木。 </li>
<li>以太网和无线局域网是广播链路层技术的例子。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>多路访问问题 ( mu1tiple access problem )</strong></p>
<ul>
<li><strong>如何协调多个发送和接收节点对一个共享广播信道的访问 ?</strong> </li>
<li>在本节，我们暂缓讨论特定的链路层协议，而先研究这个对链路层很重要的问题. </li>
<li><strong>广播信道通常用于局域网中</strong>，局域网是一个地理上集中在一座建筑物中(或者在一个公司，或者在大学校园)的网络。因此我们还将在本节后面考察一下多路访问信道是如何在局域网中使用的</li>
</ul>
</li>
</ul>
<p>以太网：(Ethernet)，以太网可以看成是一种实现局域网通信的技术标准，是目前最广泛的局域网技术。以太网的运行速率有10Mbps,100Mbps,1Gbps,10Gbps的，它的传输介质有的是双绞线，有的是光纤。 简单的说，以太网就是在局域网内，把附近的设备连接起来，可以进行通讯。</p>
<h3 id="多路访问协议-媒体访问控制协议-MAC"><a href="#多路访问协议-媒体访问控制协议-MAC" class="headerlink" title="多路访问协议 / 媒体访问控制协议(MAC)"></a>多路访问协议 / 媒体访问控制协议(MAC)</h3><ul>
<li><strong>碰撞 (collision)</strong><ul>
<li>多个节点在同一个时刻发送，接收方则会收到2个或多个信号叠加</li>
<li>通常，当碰撞发生时，没有一个接收节点能够有效地获得任何传输的帧;在某种意义下，碰撞帧的信号纠缠在一起 因此，涉及此次碰撞的所有帧都丢失了，在碰撞时间间隔中的广播信道被浪费了 </li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>多路访问协议 (multiple access protocol)</strong> </p>
<ul>
<li>即节点通过这些协议来规范它们在共享的广播信道上的传输行为</li>
<li>在实践中，数以百计或者甚至数以千计个节点能够通过一个广播信道直接通信</li>
<li>即 <strong>介质/媒体访问控制协议：MAC</strong><ul>
<li>分布式算法-决定节点如何使用共享信道，即：决定节点什么时候可以发送？</li>
<li>关于共享控制的通信必须用借助信道本身传输,没有带外信道.</li>
</ul>
</li>
</ul>
</li>
<li><p>理想多路访问协议</p>
<ul>
<li>给定：Rbps的广播信道</li>
<li>必要条件：<ul>
<li><ol>
<li>当一个节点要发送时，可以R速率发送. </li>
</ol>
</li>
<li><ol start="2">
<li>当M个节点要发送，每个可以以R/M的平均速率发送</li>
</ol>
</li>
<li><ol start="3">
<li>完全分布的:不会因某主节点故障而使得整个系统崩溃</li>
</ol>
<ul>
<li>没有特殊节点协调发送</li>
<li>没有时钟和时隙的同步</li>
</ul>
</li>
<li><ol start="4">
<li>简单</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MAC协议分类"><a href="#MAC协议分类" class="headerlink" title="MAC协议分类"></a>MAC协议分类</h3><p>P294</p>
<ul>
<li>MAC协议可分为如下三大来<ul>
<li><strong>信道划分协议(channel partitioning protocol)</strong><ul>
<li>把信道划分成小片（时间、频率、编码）</li>
<li>分配片给每个节点专用</li>
</ul>
</li>
<li><strong>随机访问协议(random access protocol)</strong><ul>
<li>信道不划分，允许冲突</li>
<li>冲突后恢复</li>
</ul>
</li>
<li><strong>依次轮流协议(taking-turns protocol)</strong><ul>
<li>节点依次轮流</li>
<li>但是有很多数据传输的节点可以获得较长的信道使用权</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><h5 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h5><ul>
<li>TDMA:time division multiple access<ul>
<li>信道的时间分时间帧(time frame),每个时间帧划分为n个时隙(slot)</li>
<li>节点轮流使用信道,每个节点使用每周期中固定的时隙(长度=帧传输时间)传输帧</li>
<li>如果站点无帧传输，时隙空闲-》浪费</li>
<li>如：6站LAN，1、3、4有数据报，时隙2、5、6空闲<blockquote>
<p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-09-50-54.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h5><ul>
<li>FDMA: frequency division multiple access<ul>
<li>信道的有效频率范围被分成一个个小的频段</li>
<li>每个站点被分配一个固定的频段</li>
<li>分配给站点的频段如果没有被使用，则空闲</li>
<li>例如：6站LAN，1、3、4有数据报，频段2、5、 6空闲<blockquote>
<p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-09-51-04.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h5><ul>
<li>码分多路访问 CDMA (code division multiple access) : <ul>
<li>所有站点在整个频段上同时进行传输, 采用编码原理加以区分 </li>
<li>完全无冲突 </li>
<li>假定:信号同步很好,线性叠加</li>
<li>比方<ul>
<li>TDM:不同的人在不同的时刻讲话</li>
<li>FDM:不同的组在不同的小房间里通信</li>
<li>CDMA:不同的人使用不同的语言讲话</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h4><ul>
<li><p>当节点有帧要发送时</p>
<ul>
<li>以信道带宽的全部 R bps发送</li>
<li>没有节点间的预先协调</li>
<li>两个或更多节点同时传输，会发生➜冲突“collision” </li>
</ul>
</li>
<li><p>随机接入协议规定: </p>
<ul>
<li>如何检测冲突</li>
<li>如何从冲突中恢复（如：通过稍后的重传）</li>
</ul>
</li>
<li><p>有如下随机接入MAC协议:</p>
<ul>
<li>时隙ALOHA</li>
<li>ALOHA</li>
<li>CSMA, CSMA/CD, CSMA/CA</li>
</ul>
</li>
</ul>
<h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5><p>略</p>
<h5 id="纯ALOHA-非时隙"><a href="#纯ALOHA-非时隙" class="headerlink" title="纯ALOHA(非时隙)"></a>纯ALOHA(非时隙)</h5><p>略</p>
<h5 id="CSMA-载波侦听多路访问"><a href="#CSMA-载波侦听多路访问" class="headerlink" title="CSMA(载波侦听多路访问)"></a>CSMA(载波侦听多路访问)</h5><p>略</p>
<h5 id="CSMA-CD-冲突检测"><a href="#CSMA-CD-冲突检测" class="headerlink" title="CSMA/CD(冲突检测)"></a>CSMA/CD(冲突检测)</h5><p>略</p>
<h6 id="以太网的MAC协议-CSMA-CD"><a href="#以太网的MAC协议-CSMA-CD" class="headerlink" title="以太网的MAC协议 : CSMA/CD"></a>以太网的MAC协议 : CSMA/CD</h6><h5 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h5><p>略</p>
<h6 id="无线局域网中的MAC协议：CSMA-CA"><a href="#无线局域网中的MAC协议：CSMA-CA" class="headerlink" title="无线局域网中的MAC协议：CSMA/CA"></a>无线局域网中的MAC协议：CSMA/CA</h6><p>略</p>
<h4 id="轮流协议-Taking-Turns"><a href="#轮流协议-Taking-Turns" class="headerlink" title="轮流协议 Taking Turns"></a>轮流协议 Taking Turns</h4><ul>
<li>信道划分MAC协议:<ul>
<li>共享信道在高负载时是有效和公平的</li>
<li>在低负载时效率低下 <ul>
<li>只能等到自己的时隙开始发送或者利用1/N的信道频率发送 </li>
<li>当只有一个节点有帧传时，也只能够得到1/N个带宽分配</li>
</ul>
</li>
</ul>
</li>
<li>随机访问MAC协议<ul>
<li>在低负载时效率高：单个节点可以完全利用信道全部带宽</li>
<li>高负载时：冲突开销较大，效率极低，时间很多浪费在冲突中</li>
</ul>
</li>
<li>轮流协议 : 有2者的优点</li>
</ul>
<h5 id="轮询协议-polling-protocol"><a href="#轮询协议-polling-protocol" class="headerlink" title="轮询协议 polling protocol"></a>轮询协议 polling protocol</h5><ul>
<li>主节点邀请从节点依次传送</li>
</ul>
<ul>
<li>缺点: <ul>
<li>轮询开销：轮询本身消耗信道带宽 </li>
<li>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能够发送 </li>
<li>单点故障：主节点失效时造成整个系统无法工作<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-10-17-39.png"></li>
</ul>
</li>
</ul>
<h5 id="令牌传递协议-token-passing-protocol"><a href="#令牌传递协议-token-passing-protocol" class="headerlink" title="令牌传递协议 token-passing protocol"></a>令牌传递协议 token-passing protocol</h5><ul>
<li>令牌控制<ul>
<li>控制令牌( token)循环从一个节点到下一个节点传递</li>
<li>令牌报文：特殊的帧</li>
<li>缺点: <ul>
<li>令牌开销：本身消耗带宽 </li>
<li>延迟：只有等到抓住令牌，才可传输 </li>
<li>单点故障 (token)：令牌丢失系统级故障，整个系统无法传输<br>  <img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-10-17-32.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MAC协议总结"><a href="#MAC协议总结" class="headerlink" title="MAC协议总结"></a>MAC协议总结</h3><ul>
<li>多点接入问题：对于一个共享型介质，各个节点如何协调对它的访问和使用?<ul>
<li>MAC协议负责协调，MAC协议可划分为<ul>
<li>信道划分协议：按时间、频率或者编码<ul>
<li>TDMA、FDMA、CDMA</li>
</ul>
</li>
<li>随机访问协议 (动态)<ul>
<li>ALOHA, S-ALOHA, CSMA, CSMA/CD</li>
<li>载波侦听: 在有些介质上很容易 (wire：有线介质), 但在有些介质上比较困难 (wireless：无线)</li>
<li>CSMA/CD ：802.3 Ethernet网中使用</li>
<li>CSMA/CA ：802.11 WLAN中使用</li>
</ul>
</li>
<li>依次轮流协议 <ul>
<li>集中：由一个中心节点轮询；分布：通过令牌控制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="LAN-局域网"><a href="#LAN-局域网" class="headerlink" title="LAN 局域网"></a>LAN 局域网</h2><p>Local Area NetWork</p>
<h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><h4 id="链路层地址-MAC地址"><a href="#链路层地址-MAC地址" class="headerlink" title="链路层地址 (MAC地址)"></a>链路层地址 (MAC地址)</h4><ul>
<li><p>32bitIP地址: 网络层地址</p>
<ul>
<li>前n-1跳：用于使数据报到达目的IP子网</li>
<li>最后一跳：到达子网中的目标节点</li>
</ul>
</li>
<li><p>主机和路由器不但具有网络层地址，而且具有链路层地址（实际上是网卡具有）</p>
</li>
<li><p><strong>链路层地址</strong>,又称 <strong>LAN地址(LAN address) , 物理地址(phyiscal address) , MAC地址(MAC address)</strong></p>
<ul>
<li>用于使帧从一个网卡传递到与其物理连接的另一个网卡(在同一个物理网络中)</li>
<li>6bytes , 48bit </li>
<li>MAC地址被设计为永久的</li>
<li>理论上全球任何2个网卡的MAC地址都不相同 e.g.: 1A-2F-BB-76-09-AD</li>
</ul>
</li>
<li><p>网络层地址和MAC地址分离</p>
<ul>
<li>IP地址和MAC地址的作用不同<ul>
<li>IP地址是分层的<ul>
<li>一个子网所有站点网络号一致，为了路由聚集，减少路由表消耗内存</li>
<li>IP地址完成网络到网络的交付</li>
</ul>
</li>
<li>mac地址是一个平面的<ul>
<li>网卡在生产时不知道被用于哪个网络，因此给网卡一个唯一的标示，用于区分一个网络内部不同的网卡即可</li>
<li>可以完成一个物理网络内部的节点到节点的数据交付</li>
</ul>
</li>
</ul>
</li>
<li>局域网是为网络层协议设计的，而不仅仅是ip协议.如果适配器吧指派IP地址而非独立的MAC地址，则适配器不能方便的支持其他网络层协议</li>
<li>如果适配器使用网络层地址而不使用MAC地址<ul>
<li>则网络层地址存入适配器，那么每次适配器移动都需要重新配置</li>
<li>则网络层地址不存入适配器，而是适配器将收到的每个帧（向cpu发起中断，内核跳转到相应中断处理程序）沿协议栈向上传递到网络层.由网络层判断收到的帧的网络层地址是否匹配。这就造成，主机会被局域网上收到的每个帧中断.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><ul>
<li><p><strong>ARP : Address Resolution Protocol</strong></p>
<ul>
<li><strong>负责网络层地址(IP地址)和链路层地址(MAC地址)的转换</strong><br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-11-51-58.png"> </li>
</ul>
</li>
<li><p>在LAN上的每个IP节点都有一个ARP表</p>
</li>
<li><p>ARP表：包括一些LAN节点IP/MAC地址的映射</p>
<ul>
<li>&lt; IP address; MAC address; TTL&gt; </li>
<li>TTL时间是指MAC地址映射失效的时间 ,典型是20min<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-11-57-06.png"></li>
</ul>
</li>
<li><p>A要发送帧给B(B的IP地址已知),A需要根据ipB解析出macB.</p>
<ul>
<li>如果arp table中有该ipB的entry，那么易得mac地址</li>
<li>如果arp table中没有该ipB的entry(如222.222.222.222)，那么如何 ?<ul>
<li><strong>A广播包含B的IP地址的ARP查询包</strong><ul>
<li>ARP查询分组</li>
<li>目的地址使用MAC广播地址，子网LAN上的所有节点都会收到该查询包<ul>
<li>Dest MAC address = FF-FF-FF-FF-FF-FF </li>
</ul>
</li>
<li>子网中的其他适配器接收到该用于arp查询的帧，将该帧中的ARP分组向上传递给arp模块，arp模块检验该arp分组要查询的ip地址是否是本机的ip地址. 无论是否匹配 , 都缓存下收到的该查询分组&lt; sender_ip - sender_mac_addr &gt; 若匹配,</li>
</ul>
</li>
<li>B给A发送回一个响应ARP分组，告知其B的MAC地址<ul>
<li>该分组的目的地址为A的MAC地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ARP是即插即用的 </p>
<ul>
<li>节点自己创建ARP的表项 </li>
<li>无需网络管理员干预</li>
</ul>
</li>
<li><p>ARP报文结构<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-17-21-02.png"></p>
</li>
</ul>
<ul>
<li>ARP协议是网络层协议还是链路层协议 ? <ul>
<li>ARP分组既包含链路层地址，又包含网络层地址.</li>
<li>将ARP看成是跨越链路层和网络层边界的协议<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">===================</span><br><span class="line">    传输层 </span><br><span class="line">    TCP/UDP</span><br><span class="line">===================</span><br><span class="line">    网络层</span><br><span class="line">    ICMP</span><br><span class="line">    IP</span><br><span class="line">======# ARP #=======</span><br><span class="line">    链路层</span><br><span class="line">    Ethernet 以太网帧</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="发送数据报到子网外-路由到其他LAN"><a href="#发送数据报到子网外-路由到其他LAN" class="headerlink" title="发送数据报到子网外 / 路由到其他LAN"></a>发送数据报到子网外 / 路由到其他LAN</h4><p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-12-34-23.png"></p>
<ul>
<li><p>Walkthrough :发送数据报：由A通过R到B，假设A知道B的IP地址</p>
</li>
<li><p>在路由器R上有两个ARP表，分别对应两个LAN</p>
</li>
<li><p>在源主机的路由表中，发现到目标主机的下一跳时111.111.111.110</p>
</li>
<li><p>在源主机的ARP表中，发现其MAC地址是E6-E9-00-17-BB-4B, etc</p>
</li>
<li><p>A创建数据报，源IP地址：A；目标IP地址：B </p>
</li>
<li><p>A创建一个链路层的帧，目标MAC地址是R，该帧包含A到B的IP数据报<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-12-44-59.png"></p>
</li>
<li><p>帧从A发送到R</p>
</li>
<li><p>帧被R接收到，从中提取出IP分组，交给上层IP协议实体<br>  <img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-12-53-41.png"></p>
</li>
<li><p>R转发数据报，数据报源IP地址为A，目标IP地址为B</p>
</li>
<li><p>R创建一个链路层的帧，目标MAC地址为B，帧中包含 A到B的IP 数据报.</p>
<ul>
<li>R查询路由表得知下一跳的IP，然后查询ARP表，进而得知下一跳的MAC地址，进而将MAC地址写入链路层帧中<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-13-02-32.png"></li>
</ul>
</li>
</ul>
<h3 id="Ethernet-以太网"><a href="#Ethernet-以太网" class="headerlink" title="Ethernet 以太网"></a>Ethernet 以太网</h3><ul>
<li>基于集线器(hub)/交换机(switch)的星形拓扑结构<ul>
<li>每个节点以及相连的交换机端口使用（独立的）以太网协议(不会和其他节点的发送产生碰撞)</li>
<li>集线器只是重新生成接收的bit，将其能量强度放大并向其他接口传输出去</li>
<li><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-13-41-15.png"></li>
</ul>
</li>
</ul>
<h4 id="以太帧结构"><a href="#以太帧结构" class="headerlink" title="以太帧结构"></a>以太帧结构</h4><ul>
<li>发送方适配器在以太网帧中封装IP数据报，或其他网络层协议数据单元 </li>
</ul>
<p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-13-53-41.png"></p>
<ul>
<li><p>地址：6字节源MAC地址，目标MAC地址</p>
<ul>
<li>如：帧目标地址=本站MAC地址，或是广播地址，接收，递交帧中的数据到网络层</li>
<li>否则，适配器忽略该帧</li>
</ul>
</li>
<li><p>dest address : 6 bytes</p>
<ul>
<li>目标适配器的MAC address</li>
<li>若收到以太网帧，<ul>
<li>其目的地址是本机MAC地址或者MAC广播地址，则将该帧的数据字段传递给网络层;</li>
<li>否则丢弃</li>
</ul>
</li>
</ul>
</li>
<li><p>src address : 6 bytes</p>
<ul>
<li>源mac地址</li>
</ul>
</li>
<li><p>类型：指出高层协议(IP , Novell IPX , AppleTalk , ARP等)</p>
</li>
<li><p>payload : 承载 IP 数据报。</p>
<ul>
<li>payload最大 即 以太网的最大传输单元(MTU) 1500 字节 <ul>
<li>如果IP数据报 &gt;  1500 byte 则必须分片</li>
</ul>
</li>
<li>payload最小 为 46bytes <ul>
<li>如果IP数据报 &lt; 46 byte 则必须填充到46bytes</li>
</ul>
</li>
</ul>
</li>
<li><p>CRC：在接收方校验</p>
<ul>
<li>如果没有通过校验，丢弃错误帧</li>
</ul>
</li>
</ul>
<h4 id="以太网-无连接、不可靠的服务"><a href="#以太网-无连接、不可靠的服务" class="headerlink" title="以太网 : 无连接、不可靠的服务"></a>以太网 : 无连接、不可靠的服务</h4><ul>
<li>无连接：帧传输前，发送方和接收方之间没有握手</li>
<li>不可靠：接收方适配器不发送ACKs或NAKs给发送方<ul>
<li>递交给网络层的数据报流可能有gap</li>
<li>传输层使用TCP(rdt)，应用不会看到gap(tcp协议会导致重传)(这里以太网确实会重传数据，只不过是因为tcp协议而非以太网协议)</li>
<li>udp，应用层就会看到gap</li>
</ul>
</li>
<li>以太网的MAC协议：采用二进制退避的CSMA/CD<br>介质访问控制形式</li>
</ul>
<h4 id="以太网的MAC协议-CSMA-CD-1"><a href="#以太网的MAC协议-CSMA-CD-1" class="headerlink" title="以太网的MAC协议 : CSMA/CD"></a>以太网的MAC协议 : CSMA/CD</h4><p>略</p>
<h3 id="IEEE-802-11-Wireless-LAN-略"><a href="#IEEE-802-11-Wireless-LAN-略" class="headerlink" title="IEEE 802.11 Wireless LAN 略"></a>IEEE 802.11 Wireless LAN 略</h3><p>以太网是一种广泛应用的局域网 是有线的</p>
<p>WLAN也是一种局域网 是无线的</p>
<h4 id="802-11-LAN-体系结构"><a href="#802-11-LAN-体系结构" class="headerlink" title="802.11 LAN 体系结构"></a>802.11 LAN 体系结构</h4><p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-05-13.png"></p>
<h4 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h4><p>WLAN帧 <img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-02-48.png"></p>
<p>略</p>
<h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>我对链路层交换机的印象 : 对Host来说完全透明. 从TCP/IP协议栈到最底层的网卡Network Interface都不需要管链路层交换机. 不需要在帧里指定的填写字段说明发送给某个链路层交换机. 链路层交换机更像是一个被动的捕获网络中的帧, 作用仅仅是 将其信号放大 , 并正确的转发出去. </p>
<p>链路层交换机</p>
<ul>
<li><p><strong>执行转发和过滤</strong></p>
<ul>
<li>交换机基于 MAC 地址而不是基于 IP 地址转发分组</li>
<li>通过<strong>交换机表(switch table)a</strong>完成<ul>
<li>该表记录了从交换机某接口出发可以到达的MAC地址</li>
<li>交换机表中的一个表项包含:<ul>
<li>一个MAC 地址 </li>
<li>MAC 地址的交换机接口</li>
<li>表项放置在表中的时间<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-24-09.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>透明</strong>：主机对交换机的存在可以不关心 </p>
<ul>
<li>通过交换机相联的各节点好像这些站点是直接相联的一样 </li>
</ul>
</li>
<li><p><strong>即插即用，自学习</strong>：</p>
<ul>
<li>交换机无需配置</li>
<li>如何自学习配置switch table ? <ul>
<li><ol>
<li>交换机表初始为空</li>
</ol>
</li>
<li><ol start="2">
<li>对于在每个接口接收到的每个人帧，该交换机在其表中存储:</li>
</ol>
<ul>
<li>在该帧源地址字段中的 MAC 地址;</li>
<li>该 帧到达的接口;</li>
<li>当前时间 </li>
<li>交换机如此记录了发送节点所在的局域网网段 如果在局域网上的每个主机最终都发送了一个帧，则每个主机最终将在这张表中留有记录.</li>
</ul>
</li>
<li><ol start="3">
<li>如果在一段时间(aging time)后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址.</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可以多路同时传输</p>
<ul>
<li>主机有一个专用和直接到交换机的连接</li>
<li>交换机缓存到来的帧</li>
<li>对每个帧进入的链路使用以太网协议，没有碰撞；全双工<ul>
<li>每条链路都是一个独立的碰撞域</li>
<li>MAC协议在其中的作用弱化了</li>
</ul>
</li>
<li>交换：A-to-A’ 和 B-to-B’ 可以同时传输，没有碰撞</li>
<li><blockquote>
<p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-35-52.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="链路层交换机-vs-路由器"><a href="#链路层交换机-vs-路由器" class="headerlink" title="链路层交换机 vs 路由器"></a>链路层交换机 vs 路由器</h4><p>P316</p>
<ul>
<li>都是存储转发设备，但层次不同<ul>
<li>交换机：链路层设备（检查链路层头部）,根据MAC地址进行转发</li>
<li>路由器：网络层设备（检查网络层的头部）, 根据IP地址进行转发<br>以下还有点不懂</li>
</ul>
</li>
<li>都有转发表：<ul>
<li>交换机：维护交换表，按照MAC地址转发<ul>
<li>执行过滤、自学习和生成树算法</li>
<li>即插即用；二层设备，速率高 </li>
<li>执行生成树算法，限制广播帧的转发</li>
<li>ARP表项随着站点数而增多</li>
</ul>
</li>
<li>路由器：维护路由表，执行路由算法<ul>
<li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络</li>
<li>对广播分组做限制</li>
<li>不是即插即用的，配置网络地址（子网前缀）</li>
<li>三层设备，速率低<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-45-48.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h3><p>略</p>
<h2 id="链路虚拟化：MPLS"><a href="#链路虚拟化：MPLS" class="headerlink" title="链路虚拟化：MPLS"></a>链路虚拟化：MPLS</h2><p>略</p>
<h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>略</p>
<h2 id="a-day-in-life-of-web-request"><a href="#a-day-in-life-of-web-request" class="headerlink" title="a day in life of web request"></a>a day in life of web request</h2>]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-传输层-拥塞控制</title>
    <url>/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>TCP 拥塞控制 : 为了公平性<br>原理(拥塞窗口)、原因、算法<br>算法包括 慢启动 拥塞避免 快速恢复 拥塞发生</p>
<span id="more"></span>

<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><ul>
<li>拥塞:<ul>
<li>非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力” </li>
<li>与流量控制含义不同<ul>
<li>流量控制 是为了 让发送端的发送速度和接收端的接受速度匹配，避免接收端接收缓存溢出</li>
<li>拥塞 是指 网络拥塞导致发送端发送的分组在路由器缓存溢出。</li>
<li>但行为是一致的：都是遏制发送方。</li>
</ul>
</li>
<li>拥塞的表现:<ul>
<li>分组丢失 (路由器缓冲区溢出)</li>
<li>分组经历比较长的延迟(在路由器的队列中排队)</li>
</ul>
</li>
</ul>
</li>
<li>拥塞控制问题<ul>
<li>与rdt一样，是网络中前十位的问题</li>
<li>如 ：拥塞控制如何在上层应用得到的服务性能中明确的显露出来？如何可用各种方法来避免网络拥塞或对他作出反应？</li>
</ul>
</li>
</ul>
<h2 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h2><ul>
<li><p>代价</p>
<ul>
<li>在分组的到达速率接近链路容量时，分组经历巨大的排队时延</li>
<li>发送方必须重传以补偿因为缓存溢出而丢失的分组</li>
<li>发送方在遇到大时延所进行的不必要重传会引起路由器利用其链路带宽转发不必要的分组副本</li>
<li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了</li>
</ul>
</li>
<li><p>场景见补充</p>
</li>
</ul>
<h2 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h2><p>根据网络层是否为运输层拥塞控制提供显示支持</p>
<ul>
<li><p>端到端拥塞控制</p>
<ul>
<li>没有来自网络的显式反馈，即网络层不为运输层拥塞控制提供显示支持</li>
<li>端系统根据分组丢失和时延推断是否有拥塞</li>
<li>TCP采用的方法</li>
</ul>
</li>
<li><p>网络辅助的拥塞控制</p>
<ul>
<li>路由器提供给端系统以反馈信息,即网络层为运输层拥塞控制提供显示支持</li>
<li>单个bit置位，显示拥塞情况 (SNA, DECbit, TCP/IP ECN, ATM)</li>
<li>显式提供发送端可以采用的速率</li>
<li>例子：ATM可用比特率 (略)</li>
</ul>
</li>
</ul>
<h2 id="TCP拥塞控制概述"><a href="#TCP拥塞控制概述" class="headerlink" title="TCP拥塞控制概述"></a>TCP拥塞控制概述</h2><ul>
<li><strong>一种形式受限的拥塞控制</strong> : <strong>Timer定时器的RTO在每次重传之后呈指数型增长</strong><ul>
<li>定时器过期很可能是由网络拥塞引起的，即太多的分组到达路径中的路由器队列中，造成分组丢失或较长排队时延。在拥塞时如果持续重传分组，会使得分组更加严重；于是，TCP采用更文雅的方式，每个发送方的分组都是经过越来越长的时间间隔后进行。</li>
</ul>
</li>
<li>下面介绍更复杂的TCP拥塞控制形式。</li>
</ul>
<h3 id="拥塞感知"><a href="#拥塞感知" class="headerlink" title="拥塞感知"></a>拥塞感知</h3><p>发送端如何探测到拥塞 ?<br>根据《自顶向下》: 发生丢包<br>先声明：TCP的丢包事件 定义为<br>要么 1. 出现超时<br>要么 2. 收到来自接收方的3个冗余ACK(一般收到三个冗余ack时还没超时 因为RTO设置的相对保守)</p>
<ul>
<li><strong>某个segment超时了 : 拥塞</strong><ul>
<li>超时时间到，某个段的确认没有来 </li>
<li>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大 </li>
<li>原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小 </li>
<li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-50-36.png"></p>
<ul>
<li><strong>有关某个段的3次冗余ACK：轻微拥塞</strong><ul>
<li>第1个ACK : 正常ACK. ackno = 3460 , 确认绿色segment</li>
<li>2，3，4次ACK：三次冗余ack. ackno = 3460 , 确认乱序到达的蓝色,橙色,灰色segment</li>
<li>粉色segment仍然没被确认，其后面的segment却确认了，故粉色segment丢失的可能性很大</li>
<li>网络这时还能够进行一定程度的传输，拥塞情况轻于第一种</li>
</ul>
</li>
</ul>
<h3 id="拥塞控制-1"><a href="#拥塞控制-1" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制中，TCP如何限制Sender发送segment ? –&gt; 通过维护拥塞窗口</p>
<ul>
<li><strong>拥塞窗口 Congestion Window</strong><ul>
<li><strong>cwnd</strong></li>
<li>TCPSender 维护一个 <strong>拥塞窗口</strong><ul>
<li>在整个过程中保证(<strong>流量控制和拥塞控制的联合动作</strong>) <ul>
<li><strong>send_window(bytes sent but not acked) &lt;= min {cwnd(拥塞控制),rwnd(流量控制)}</strong><ul>
<li>rwnd : 满足接收方不会缓存溢出</li>
<li>cwnd : 满足网络可以不拥塞的传输分组</li>
</ul>
</li>
<li>本part关注拥塞控制，故假设接收缓存无限大 -&gt; receive_window_size 无限大<ul>
<li>故 bytes sent but not acked &lt; cwnd</li>
<li>Sender 发送速率 为 cwnd / RTT   byte/s</li>
</ul>
</li>
</ul>
</li>
<li>从而粗略地控制发送方的往网络中注入的速率</li>
</ul>
</li>
<li><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-22-04-18.png"></li>
</ul>
</li>
</ul>
<h3 id="cwnd变化"><a href="#cwnd变化" class="headerlink" title="cwnd变化"></a>cwnd变化</h3><p>通过调节cwnd来控制发送速率,那么TCPSender该怎样确定应当发送的速率呢 ?</p>
<ul>
<li>CongWin是动态的，是感知到的网络拥塞程度的函数<ul>
<li>超时或者3个重复ack，CongWin↓<ul>
<li>超时：CongWin降为1MSS,进入SS阶段然后再倍增到 CongWin/2（每个RTT），从而进入CA阶段 </li>
<li>3个重复ack ：CongWin降为CongWin/2,CA阶段</li>
</ul>
</li>
<li>否则（正常收到Ack，没有发送以上情况）：CongWin跃跃欲试↑<ul>
<li>SS阶段：加倍增加(每个RTT)</li>
<li>CA阶段：线性增加(每个RTT)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h2><h3 id="慢启动-slow-start-SS"><a href="#慢启动-slow-start-SS" class="headerlink" title="慢启动 slow-start (SS)"></a>慢启动 slow-start (SS)</h3><ul>
<li><p>连接刚建立, CongWin = 1 MSS </p>
<ul>
<li>如: MSS = 1460bytes &amp; RTT = 200 msec </li>
<li>初始速率 = 58.4kbps</li>
<li>可用带宽可能&gt;&gt;MSS/RTT<ul>
<li>应该尽快加速，到达希望的速率</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>指数性增加CongWin</strong> </p>
<ul>
<li>每经过一个RTT， CongWin加倍  &lt;—&gt; 每收到一个ACK时，CongWin加1MSS (这两个概念是一致的) </li>
<li><strong>慢启动阶段：只要不超时或3个冗余ack 且 cwnd &lt; sstresh，每经过一个RTT，CongWin *= 2</strong></li>
<li><strong>在丢包之前，当cwnd达到sstresh，进入拥塞避免阶段，cwnd线性增长</strong></li>
<li>ssthresh : 上次发生超时时的窗口的一半<br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-22-40-38.png"></li>
</ul>
</li>
<li><p><strong>SS总结: 初始速率很慢，但是加速却是指数性的</strong> </p>
<ul>
<li><strong>SS时间很短，长期来看可以忽略</strong></li>
<li>慢启动阶段并不慢</li>
</ul>
</li>
</ul>
<h3 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h3><ul>
<li><strong>AMID : Additive-Increase , Multiplicative-Decrease</strong><ul>
<li>TCP拥塞控制常被称为<strong>加性增，乘性减</strong>的拥塞控制方式<br>cwnd窗口大小随时间：锯齿形<br>慢启动阶段忽略不计，因为很快<br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-22-34.png"></li>
</ul>
</li>
</ul>
<h4 id="加性增"><a href="#加性增" class="headerlink" title="加性增"></a><strong>加性增</strong></h4><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><ul>
<li>还没发生拥塞</li>
<li>当cwnd &gt; ssthresh时，进入<strong>拥塞避免</strong><ul>
<li><strong>一个RTT如没有发生丢失事件 ,将cwnd加1MSS(为了探测)</strong><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-33-55.png"></li>
</ul>
</li>
</ul>
<h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>不知道该不该放在加性增下面 我觉得应该反正放在这个下面<br>参考小林coding &amp; 自顶向下 &amp; 郑老师</p>
<ul>
<li>快速重传的拥塞发生 和 快速恢复算法 搭配使用</li>
<li>快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</li>
<li>如拥塞发生所说<ul>
<li>cwnd = cwnd/2</li>
<li>ssthresh = cwnd;</li>
</ul>
</li>
<li>然后，进入快速恢复算法如下<ul>
<li>cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值<ul>
<li>原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态</li>
</ul>
</li>
<li><blockquote>
<p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-09-43.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="乘性减"><a href="#乘性减" class="headerlink" title="乘性减"></a><strong>乘性减</strong></h4><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>发生拥塞时</p>
<ul>
<li><p>根据是快速重传还是超时重传区分<strong>拥塞发生算法</strong></p>
</li>
<li><ol>
<li><strong>当收到3个重复的ACKs</strong>: 不进入慢启动阶段</li>
</ol>
<ul>
<li>cwnd /= 2</li>
<li>ssthresh = cwnd</li>
<li>进入快速恢复阶段 / 或者仅仅就是cwnd线性增长</li>
</ul>
</li>
<li><ol start="2">
<li>当<strong>超时事件发生</strong>时: 进入慢启动阶段</li>
</ol>
<ul>
<li>ssthresh = cwnd / 2</li>
<li>cwnd = 1 MSS，<strong>进入SS阶段</strong><blockquote>
<p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-09-57-23.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol>
<li>3个重复的ACK表示网络还有一定的段传输能力<br>超时之前的3个重复的ACK表示“警报” : 即将发生拥塞<br>故收到三个重复ACK并不会使得cwnd = 1</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>当CongWin＜Threshold, 发送端处于<strong>慢启动阶段（slow-start）</strong>, 窗口指数性增长. </li>
<li>当CongWin &gt; Threshold, 发送端处于<strong>拥塞避免（congestion-avoidance）</strong>, 窗口线性增长. </li>
<li>当收到三个重复的ACKs (triple duplicate ACK),<ul>
<li>Threshold设置成 CongWin/2</li>
<li>进入<strong>快速恢复</strong> , CongWin=Threshold+3. </li>
</ul>
</li>
<li>当超时事件发生时timeout, <ul>
<li>Threshold=CongWin/2</li>
<li>CongWin=1 MSS，进入 <strong>SS慢启动阶段</strong></li>
</ul>
</li>
</ul>
<p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-16-08.png"></p>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-19-04.png"></p>
<h2 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h2><ul>
<li>公平性目标: <ul>
<li>如果 K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R/K<br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-39-36.png"></li>
</ul>
</li>
</ul>
<ul>
<li>为什么公平 ? <ul>
<li>因为拥塞控制算法</li>
<li>2个竞争的TCP会话:<ul>
<li>加性增加，斜率为1, 吞吐量增加</li>
<li>乘性减，吞吐量比例减少<br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-38-03.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-40-35.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>公平性和 UDP<ul>
<li>多媒体应用通常不是用TCP <ul>
<li>应用发送的数据速率希望不受拥塞控制的节制</li>
</ul>
</li>
<li>使用UDP: <ul>
<li>音视频应用泵出数据的速率是恒定的, 忽略数据的丢失</li>
</ul>
</li>
<li>研究领域: TCP 友好性</li>
</ul>
</li>
<li>公平性和并行TCP连接<ul>
<li>2个主机间可以打开多个并行的TCP连接</li>
<li>例如: <ul>
<li>带宽为R的链路支持了9个BB’TCP连接;</li>
<li>AA’建立一条新TCP连接,占据带宽R/10</li>
<li>那么AA’占据带宽9/10,BB’占据带宽9/10</li>
<li><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-43-20.png"></li>
</ul>
</li>
<li>故TCP的公平也只是大致公平<h2 id="补充-拥塞场景"><a href="#补充-拥塞场景" class="headerlink" title="补充 : 拥塞场景"></a>补充 : 拥塞场景</h2>《自顶向下》P172</li>
</ul>
</li>
<li>场景一<ul>
<li><blockquote>
<p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-20-58-17.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>场景二<blockquote>
<p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-20-59-05.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-01-13.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-01-18.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-01-31.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-01-44.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-20-59-59.png"></p>
</blockquote>
</li>
<li>场景三<blockquote>
<p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-00-48.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-00-57.png"></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次stack-use-after-scope和ASAN</title>
    <url>/2022/09/20/%E8%AE%B0%E4%B8%80%E6%AC%A1stack-use-after-scope%E5%92%8CASAN/</url>
    <content><![CDATA[<ul>
<li><a href="https://github.com/google/sanitizers">参考</a></li>
<li><a href="https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f">参考</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143187115#:~:">参考</a></li>
</ul>
<h2 id="bug及解决"><a href="#bug及解决" class="headerlink" title="bug及解决"></a>bug及解决</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><ul>
<li><p>起因：参考《Linux多线程服务端编程》第8章写my_muduo的class EventLoopThread时,想通过timerfd定时器测试功能,结果死循环。</p>
<ul>
<li>注册回调：在main中给EventLoopThread注册回调函数，在回调函数中创建channel以及事件。注册的回调函数会在EventLoopThread startLoop前调用。</li>
</ul>
</li>
<li><p>两处罪魁祸首<br>  <img src="/2022/09/20/%E8%AE%B0%E4%B8%80%E6%AC%A1stack-use-after-scope%E5%92%8CASAN/2022-09-20-13-24-01.png"><br>  <img src="/2022/09/20/%E8%AE%B0%E4%B8%80%E6%AC%A1stack-use-after-scope%E5%92%8CASAN/2022-09-20-13-29-50.png"></p>
</li>
<li><p>问题发生处<br><img src="/2022/09/20/%E8%AE%B0%E4%B8%80%E6%AC%A1stack-use-after-scope%E5%92%8CASAN/2022-09-20-13-58-12.png"></p>
</li>
<li><p>因此会与预期不符。</p>
</li>
<li><p>可以看到 注册到epoll上的是timerfd=5，实际上返回的events.data.ptr指向的channel却是fd=0。<br><img src="/2022/09/20/%E8%AE%B0%E4%B8%80%E6%AC%A1stack-use-after-scope%E5%92%8CASAN/2022-09-20-14-03-44.png"></p>
</li>
<li><p>日志打到这里时怀疑是使用了一个已经释放的对象，当时以为会是移动造成，又或者是使用了已经free的堆造成的。</p>
</li>
<li><p>但其实还是不能肯定是内存方面的问题。因为没core dump.很奇怪为啥没core dump?</p>
</li>
</ul>
<h3 id="ASAN"><a href="#ASAN" class="headerlink" title="ASAN"></a>ASAN</h3><ul>
<li>参考<a href="https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f">资料</a>配置AddressSanitizer</li>
<li>很强。一下子确定了在何处发生了什么错误。如下，在channel-&gt;handleEvent()时，发生stack-use-after-scope。比吭哧吭哧打日志方便很多。<ul>
<li>并且还可以编译时warning是否有初始化顺序不恰当的代码，比如类的成员在构造函数中初始化与在类中的声明顺序不一致。</li>
</ul>
</li>
<li>如此，可以确定时channel指针引用的对象已经不存在，并且是stack-use-after-scope而非heap-use-after-free。问题范围缩小一大半，直接去找定义该channel的地方。发现是在注册的回调函数中定义。因此，该channel出了回调函数就会被析构。（之前误以为注册给EventLoopThread的回调函数在其内部调用会展开，故认为loop结束前channel不会被析构，槽点过多）。</li>
<li>更改channel定义的位置，使其不会在loop结束前被析构即可。</li>
<li>也不是什么难bug，就是之前对这个内存方面的错误有些阴影，又恰好了解了asan这么好用的工具，因此在这里记录下。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[INFO] <span class="number">2022</span><span class="number">-09</span><span class="number">-20</span><span class="number">-12</span><span class="number">-30</span><span class="number">-33</span> : /home/shc/Muduo/src/main.<span class="built_in">cpp</span> (<span class="number">64</span>) &lt;main&gt;   startloop <span class="keyword">return</span> eventloop <span class="number">0x7f329bafdc40</span> </span><br><span class="line"></span><br><span class="line">[INFO] <span class="number">2022</span><span class="number">-09</span><span class="number">-20</span><span class="number">-12</span><span class="number">-30</span><span class="number">-38</span> : /home/shc/Muduo/src/EpollPoller.<span class="built_in">cpp</span> (<span class="number">147</span>) &lt;poll&gt;   <span class="number">1</span> events happneded</span><br><span class="line"></span><br><span class="line">[INFO] <span class="number">2022</span><span class="number">-09</span><span class="number">-20</span><span class="number">-12</span><span class="number">-30</span><span class="number">-38</span> : /home/shc/Muduo/src/EpollPoller.<span class="built_in">cpp</span> (<span class="number">180</span>) &lt;fillActiveChannels&gt;   fill <span class="number">5</span> </span><br><span class="line"></span><br><span class="line">[INFO] <span class="number">2022</span><span class="number">-09</span><span class="number">-20</span><span class="number">-12</span><span class="number">-30</span><span class="number">-38</span> : /home/shc/Muduo/src/EventLoop.<span class="built_in">cpp</span> (<span class="number">109</span>) &lt;loop&gt;   <span class="number">1</span> IN HANDLING <span class="number">0</span></span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> ：stack-use-after-scope</span></span><br><span class="line">==<span class="number">14905</span>==ERROR: AddressSanitizer: stack-use-after-scope on address <span class="number">0x7f329bafd1d8</span> at pc <span class="number">0x55840a7a315c</span> bp <span class="number">0x7f329bafba70</span> sp <span class="number">0x7f329bafba60</span></span><br><span class="line">READ of size <span class="number">1</span> at <span class="number">0x7f329bafd1d8</span> thread T1</span><br><span class="line"># 显示过程调用栈 自出现问题处回溯一个个函数</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x55840a7a315b</span> in Channel::<span class="built_in">handleEvent</span>(Timestamp <span class="keyword">const</span>&amp;) /home/shc/Muduo/src/Channel.cpp:<span class="number">44</span></span><br><span class="line">    #<span class="number">1</span> <span class="number">0x55840a7b2707</span> in EventLoop::<span class="built_in">loop</span>() /home/shc/Muduo/src/EventLoop.cpp:<span class="number">112</span></span><br><span class="line">    #<span class="number">2</span> <span class="number">0x55840a7bab27</span> in EventLoopThread::<span class="built_in">threadFunc</span>() /home/shc/Muduo/src/EventLoopThread.cpp:<span class="number">93</span></span><br><span class="line">    #<span class="number">3</span> <span class="number">0x55840a7bc5f3</span> in <span class="keyword">void</span> std::__invoke_impl&lt;<span class="keyword">void</span>, <span class="built_in"><span class="keyword">void</span></span> (EventLoopThread::*&amp;)(), EventLoopThread*&amp;&gt;(std::__invoke_memfun_deref, <span class="built_in"><span class="keyword">void</span></span> (EventLoopThread::*&amp;)(), EventLoopThread*&amp;) /usr/include/c++/<span class="number">7</span>/bits/invoke.h:<span class="number">73</span></span><br><span class="line">    #<span class="number">4</span> <span class="number">0x55840a7bc450</span> in std::__invoke_result&lt;<span class="built_in"><span class="keyword">void</span></span> (EventLoopThread::*&amp;)(), EventLoopThread*&amp;&gt;::type std::__invoke&lt;<span class="built_in"><span class="keyword">void</span></span> (EventLoopThread::*&amp;)(), EventLoopThread*&amp;&gt;(<span class="built_in"><span class="keyword">void</span></span> (EventLoopThread::*&amp;)(), EventLoopThread*&amp;) /usr/include/c++/<span class="number">7</span>/bits/invoke.h:<span class="number">95</span></span><br><span class="line">    #<span class="number">5</span> <span class="number">0x55840a7bc2e9</span> in <span class="keyword">void</span> std::_Bind&lt;<span class="built_in"><span class="keyword">void</span></span> (EventLoopThread::*(EventLoopThread*))()&gt;::__call&lt;<span class="keyword">void</span>, , <span class="number">0ul</span>&gt;(std::tuple&lt;&gt;&amp;&amp;, std::_Index_tuple&lt;<span class="number">0ul</span>&gt;) /usr/include/c++/<span class="number">7</span>/functional:<span class="number">467</span></span><br><span class="line">    #<span class="number">6</span> <span class="number">0x55840a7bbf99</span> in <span class="keyword">void</span> std::_Bind&lt;<span class="built_in"><span class="keyword">void</span></span> (EventLoopThread::*(EventLoopThread*))()&gt;::<span class="built_in"><span class="keyword">operator</span></span>()&lt;, <span class="keyword">void</span>&gt;() /usr/include/c++/<span class="number">7</span>/functional:<span class="number">551</span></span><br><span class="line">    #<span class="number">7</span> <span class="number">0x55840a7bb9a2</span> in std::_Function_handler&lt;<span class="built_in"><span class="keyword">void</span></span> (), std::_Bind&lt;<span class="built_in"><span class="keyword">void</span></span> (EventLoopThread::*(EventLoopThread*))()&gt; &gt;::_M_invoke(std::_Any_data <span class="keyword">const</span>&amp;) /usr/include/c++/<span class="number">7</span>/bits/std_function.h:<span class="number">316</span></span><br><span class="line">    #<span class="number">8</span> <span class="number">0x55840a7a483b</span> in std::function&lt;<span class="built_in"><span class="keyword">void</span></span> ()&gt;::<span class="built_in"><span class="keyword">operator</span></span>()() <span class="keyword">const</span> /usr/include/c++/<span class="number">7</span>/bits/std_function.h:<span class="number">706</span></span><br><span class="line">    #<span class="number">9</span> <span class="number">0x55840a7c27c2</span> in <span class="built_in"><span class="keyword">operator</span></span>() /home/shc/Muduo/src/Thread.cpp:<span class="number">63</span></span><br><span class="line">    #<span class="number">10</span> <span class="number">0x55840a7c2f78</span> in __invoke_impl&lt;<span class="keyword">void</span>, Thread::<span class="built_in">start</span>()::&lt;<span class="built_in">lambda</span>()&gt; &gt; /usr/include/c++/<span class="number">7</span>/bits/invoke.h:<span class="number">60</span></span><br><span class="line">    #<span class="number">11</span> <span class="number">0x55840a7c2bc2</span> in __invoke&lt;Thread::<span class="built_in">start</span>()::&lt;<span class="built_in">lambda</span>()&gt; &gt; /usr/include/c++/<span class="number">7</span>/bits/invoke.h:<span class="number">95</span></span><br><span class="line">    #<span class="number">12</span> <span class="number">0x55840a7c32e5</span> in _M_invoke&lt;<span class="number">0</span>&gt; /usr/include/c++/<span class="number">7</span>/thread:<span class="number">234</span></span><br><span class="line">    #<span class="number">13</span> <span class="number">0x55840a7c326b</span> in <span class="built_in"><span class="keyword">operator</span></span>() /usr/include/c++/<span class="number">7</span>/thread:<span class="number">243</span></span><br><span class="line">    #<span class="number">14</span> <span class="number">0x55840a7c31cf</span> in _M_run /usr/include/c++/<span class="number">7</span>/thread:<span class="number">186</span></span><br><span class="line">    #<span class="number">15</span> <span class="number">0x7f329f47e4bf</span>  (/usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span>+<span class="number">0xd44bf</span>)</span><br><span class="line">    #<span class="number">16</span> <span class="number">0x7f329f7be6da</span> in <span class="built_in">start_thread</span> (/lib/x86_64-linux-gnu/libpthread.so<span class="number">.0</span>+<span class="number">0x76da</span>)</span><br><span class="line">    #<span class="number">17</span> <span class="number">0x7f329eec261e</span> in __clone (/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>+<span class="number">0x12161e</span>)</span><br><span class="line"># 在哪里发生错误</span><br><span class="line">Address <span class="number">0x7f329bafd1d8</span> is located in stack of thread T1 at offset <span class="number">5720</span> in frame</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x55840a7b189d</span> in EventLoop::<span class="built_in">loop</span>() /home/shc/Muduo/src/EventLoop.cpp:<span class="number">81</span></span><br><span class="line"></span><br><span class="line">This frame has <span class="number">26</span> <span class="built_in">object</span>(s):</span><br><span class="line">    [<span class="number">32</span>, <span class="number">33</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">96</span>, <span class="number">97</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">160</span>, <span class="number">161</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">224</span>, <span class="number">225</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">288</span>, <span class="number">289</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">352</span>, <span class="number">353</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">416</span>, <span class="number">417</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">480</span>, <span class="number">481</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">544</span>, <span class="number">552</span>) <span class="string">&#x27;__for_begin&#x27;</span></span><br><span class="line">    [<span class="number">608</span>, <span class="number">616</span>) <span class="string">&#x27;__for_end&#x27;</span></span><br><span class="line">    [<span class="number">672</span>, <span class="number">704</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">736</span>, <span class="number">768</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">800</span>, <span class="number">832</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">864</span>, <span class="number">896</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">928</span>, <span class="number">960</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">992</span>, <span class="number">1024</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">1056</span>, <span class="number">1088</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">1120</span>, <span class="number">1152</span>) <span class="string">&#x27;&lt;unknown&gt;&#x27;</span></span><br><span class="line">    [<span class="number">1184</span>, <span class="number">1696</span>) <span class="string">&#x27;header&#x27;</span></span><br><span class="line">    [<span class="number">1728</span>, <span class="number">2240</span>) <span class="string">&#x27;header&#x27;</span></span><br><span class="line">    [<span class="number">2272</span>, <span class="number">2784</span>) <span class="string">&#x27;header&#x27;</span></span><br><span class="line">    [<span class="number">2816</span>, <span class="number">3328</span>) <span class="string">&#x27;header&#x27;</span></span><br><span class="line">    [<span class="number">3360</span>, <span class="number">4384</span>) <span class="string">&#x27;buf&#x27;</span></span><br><span class="line">    [<span class="number">4416</span>, <span class="number">5440</span>) <span class="string">&#x27;buf&#x27;</span></span><br><span class="line">    [<span class="number">5472</span>, <span class="number">6496</span>) <span class="string">&#x27;buf&#x27;</span> &lt;== Memory access at offset <span class="number">5720</span> is inside <span class="keyword">this</span> variable</span><br><span class="line">    [<span class="number">6528</span>, <span class="number">7552</span>) <span class="string">&#x27;buf&#x27;</span></span><br><span class="line">HINT: <span class="keyword">this</span> may be a <span class="literal">false</span> positive <span class="keyword">if</span> your program uses some custom stack unwind mechanism <span class="keyword">or</span> <span class="built_in">swapcontext</span></span><br><span class="line">    (longjmp <span class="keyword">and</span> C++ exceptions *are* supported)</span><br><span class="line"></span><br><span class="line"># Thred T1在何处由T0生成</span><br><span class="line">Thread T1 created by T0 here:</span><br><span class="line">    #<span class="number">0</span> <span class="number">0x7f329fa0dd2f</span> in __interceptor_pthread_create (/usr/lib/x86_64-linux-gnu/libasan.so<span class="number">.4</span>+<span class="number">0x37d2f</span>)</span><br><span class="line">    #<span class="number">1</span> <span class="number">0x7f329f47e765</span> in std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, <span class="built_in"><span class="keyword">void</span></span> (*)()) (/usr/lib/x86_64-linux-gnu/libstdc++.so<span class="number">.6</span>+<span class="number">0xd4765</span>)</span><br><span class="line">    #<span class="number">2</span> <span class="number">0x55840a7c2931</span> in Thread::<span class="built_in">start</span>() /home/shc/Muduo/src/Thread.cpp:<span class="number">64</span></span><br><span class="line">    #<span class="number">3</span> <span class="number">0x55840a7ba49a</span> in EventLoopThread::<span class="built_in">startLoop</span>() /home/shc/Muduo/src/EventLoopThread.cpp:<span class="number">53</span></span><br><span class="line">    #<span class="number">4</span> <span class="number">0x55840a7c5b0a</span> in main /home/shc/Muduo/src/main.cpp:<span class="number">62</span></span><br><span class="line">    #<span class="number">5</span> <span class="number">0x7f329edc2c86</span> in __libc_start_main (/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>+<span class="number">0x21c86</span>)</span><br><span class="line"></span><br><span class="line"># 总结：handleEvent时 发生 stack-use-after-scope</span><br><span class="line">SUMMARY: AddressSanitizer: stack-use-after-scope /home/shc/Muduo/src/Channel.cpp:<span class="number">44</span> in Channel::<span class="built_in">handleEvent</span>(Timestamp <span class="keyword">const</span>&amp;)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line"><span class="number">0x0fe6d37579e0</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d37579f0</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d3757a00</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d3757a10</span>: f8 f8 f8 f8 f8 f8 f8 f8 f2 f2 f2 f2 f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d3757a20</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line">=&gt;<span class="number">0x0fe6d3757a30</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8[f8]f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d3757a40</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d3757a50</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d3757a60</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d3757a70</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line"><span class="number">0x0fe6d3757a80</span>: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8</span><br><span class="line">Shadow byte <span class="built_in">legend</span> (one shadow byte represents <span class="number">8</span> application bytes):</span><br><span class="line">Addressable:           <span class="number">00</span></span><br><span class="line">Partially addressable: <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> </span><br><span class="line">Heap left redzone:       fa</span><br><span class="line">Freed heap region:       fd</span><br><span class="line">Stack left redzone:      f1</span><br><span class="line">Stack mid redzone:       f2</span><br><span class="line">Stack right redzone:     f3</span><br><span class="line">Stack after <span class="keyword">return</span>:      f5</span><br><span class="line">Stack use after scope:   f8</span><br><span class="line">Global redzone:          f9</span><br><span class="line">Global init order:       f6</span><br><span class="line">Poisoned by user:        f7</span><br><span class="line">Container overflow:      fc</span><br><span class="line">Array cookie:            ac</span><br><span class="line">Intra object redzone:    bb</span><br><span class="line">ASan internal:           fe</span><br><span class="line">Left alloca redzone:     ca</span><br><span class="line">Right alloca redzone:    cb</span><br><span class="line">==<span class="number">14905</span>==ABORTING</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ASan-Address-Sanitizer"><a href="#ASan-Address-Sanitizer" class="headerlink" title="ASan Address Sanitizer"></a>ASan Address Sanitizer</h2><ul>
<li><a href="https://hardcore.feishu.cn/docx/doxcnXfsINxeICDFXePBelN3p5f">以下来自</a></li>
<li>谷歌有一系列Sanitizer官网见<a href="https://github.com/google/sanitizers%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%BD%8D%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84Sanitizer%E5%8C%85%E6%8B%AC">https://github.com/google/sanitizers，可以用于定位程序中的系列问题，常用的Sanitizer包括</a><ul>
<li>Address Sanitizer（ASan）：用于检测内存使用错误</li>
<li>Leak Sanitizer（LSan）：用于检测内存泄漏</li>
<li>Thread Sanitizer（TSan）：用于检测多线程间的数据竞争和死锁</li>
<li>Memory Sanitizer（MSan）：用于检测使用未初始化内存的行为</li>
</ul>
</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>ASan 是 Address Sanitizer 简称，它是一种基于编译器用于快速检测原生代码中内存错误的工具。</li>
<li>简而言之，ASan 就是一个用于快速检测内存错误的工具，目前已经集成在LLVM 3.1+和GCC 4.8+中</li>
<li>可检测类型<br>  <img src="/2022/09/20/%E8%AE%B0%E4%B8%80%E6%AC%A1stack-use-after-scope%E5%92%8CASAN/2022-09-20-14-48-25.png"></li>
<li><a href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm">原理</a><ul>
<li>在编译时，ASan会替换malloc/free接口</li>
<li>在程序申请内存时，ASan会额外分配一部分内存来标识该内存的状态</li>
<li>在程序使用内存时，ASan会额外进行判断，确认该内存是否可以被访问，并在访问异常时输出错误信息</li>
</ul>
</li>
</ul>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><ul>
<li><p>CMakeLists.txt</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 编译设置</span><br><span class="line">add_compile_options(-O0 -ggdb -<span class="built_in">std</span>=c++<span class="number">14</span> -Wall -Wextra -mavx2</span><br><span class="line">    -fsanitize=address</span><br><span class="line">    -fno-omit-frame-pointer</span><br><span class="line">    -fno-optimize-sibling-calls</span><br><span class="line">    -fsanitize-address-use-after-scope</span><br><span class="line">    -fsanitize-recover=address)</span><br><span class="line"># 链接设置</span><br><span class="line">target_link_libraries(muduo pthread -fsanitize=address)</span><br></pre></td></tr></table></figure></li>
<li><p>环境变量</p>
<ul>
<li>llvm-symbolizer运行路径：export ASAN_SYMBOLIZER_PATH=”/usr/bin/llvm-symbolizer”</li>
<li>ASAN_OPTIONS为ASan运行的Flags：export ASAN_OPTIONS=”halt_on_error=0:log_path=xxx/asan.log:detect_stack_use_after_return=1”<br><img src="/2022/09/20/%E8%AE%B0%E4%B8%80%E6%AC%A1stack-use-after-scope%E5%92%8CASAN/2022-09-20-14-52-55.png"></li>
</ul>
</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>ASan版本程序在Linux环境下运行时会额外申请20TB的虚拟内存<ul>
<li>需要确保/proc/sys/vm/overcommit_memory的值不为2</li>
<li>这也可以作为检验ASan是否工作的标志</li>
</ul>
</li>
<li>ASan版本性能大幅受损，大约会下降2x左右</li>
<li>ASan工具不是万能的，他必须要跑到有问题的代码才可以暴漏出来</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式原则</p>
<span id="more"></span>

<h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="面向对象设计原则-1"><a href="#面向对象设计原则-1" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h3><ul>
<li>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</li>
<li>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</li>
<li>举例<ul>
<li>应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返还类型说明，以及数据类型的转换等，而不要使用具体类</li>
</ul>
</li>
</ul>
<h3 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h3><ul>
<li>对扩展开放，对更改封闭。</li>
<li>类模块应该是可扩展的，但是不可修改。</li>
<li>应该尽量通过扩展的方式来支持未来的变化，而不是直接改源代码来支持变化。</li>
</ul>
<h3 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h3><ul>
<li>一个类应该仅有一个引起它变化的原因。</li>
<li>变化的方向隐含着类的责任。</li>
</ul>
<h3 id="Liskov-替换原则（LSP）"><a href="#Liskov-替换原则（LSP）" class="headerlink" title="Liskov 替换原则（LSP）"></a>Liskov 替换原则（LSP）</h3><ul>
<li>子类必须能够替换它们的基类(IS-A)。</li>
<li>继承表达类型抽象。</li>
</ul>
<h3 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h3><ul>
<li>不应该强迫客户程序依赖它们不需要的接口。</li>
<li>接口应该小而完备。</li>
</ul>
<h3 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h3><ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li>
<li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li>
</ul>
<h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h3><ul>
<li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li>
</ul>
<h3 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h3><ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li>
<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</li>
<li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案</li>
</ul>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ul>
<li>我们所要减少的依赖是编译时依赖，而非运行时依赖</li>
</ul>
<h3 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h3><p><a href="https://blog.csdn.net/weixin_42927264/article/details/82963556">类的关系</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单一职责模式</title>
    <url>/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单一职责模式：装饰模式、桥模式</p>
<span id="more"></span>

<h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1><ul>
<li>在软件组件的设计中，如果<strong>责任划分的不清晰</strong>，使用<strong>继承</strong>得到的结果往往是随着需求的变化，子类急剧膨胀，同时<strong>充斥着重复代码</strong>，这时候的关键是<strong>划清责任。</strong><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2>把编译时的事情延迟到运行时去做<br>设计模式真谛：编译时让他复用；需求，变化都放到运行时。</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul>
<li>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于<strong>继承为类型引入的静态特质</strong>（写死的语句），使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</li>
<li>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-09-04-00.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>通过<strong>采用组合而非继承的</strong>手法， Decorator模式实现了在运行时<strong>动态扩展对象功能</strong>的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</li>
<li>Decorator类在<strong>接口上</strong>表现为is-a Component的<strong>继承</strong>关系，即 Decorator类继承了Component类所具有的接口。但在<strong>实现上又 表现为</strong>has-a Component的<strong>组合</strong>关系，即Decorator类又使用了另外一个Component类。</li>
<li>Decorator模式的目的并非解决“多子类衍生的多继承”问题， <strong>Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义</strong></li>
</ul>
<p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-09-13-46.png"></p>
<ul>
<li>装饰者的继承：为了完善接口规范<ul>
<li><code>class Deractor : public Base&#123;&#125;</code> </li>
</ul>
</li>
<li>装饰者的组合：为了实现支持将来实现类的调用<ul>
<li><code>&#123;Base * b&#125;</code></li>
</ul>
</li>
<li>看到一个class A 他既继承自父类Base，又有父类Base*成员，那么，基本上就是装饰者模式了。</li>
<li>同时继承和组合，基本上就是装饰者模式。</li>
</ul>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><ul>
<li>最开始 总共有 <code>1 + n + n*m!</code> 个类<br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-09-01-38.png"></li>
<li>有最普通的读，有加密的读，有缓存的读，有缓存+加密的读<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  重复代码</span></span><br><span class="line"><span class="comment">//  加密操作是一样的</span></span><br><span class="line"><span class="comment">//  缓冲操作是一样的</span></span><br><span class="line"><span class="comment">//  read seek write操作不同类不同，但是都继承自Stream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoFileStream</span> :</span><span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Read</span>(number);<span class="comment">//读文件流     //  继承引入的静态机制！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoNetworkStream</span> :</span> :<span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Read</span>(number);<span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位网络流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Write</span>(data);<span class="comment">//写网络流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoMemoryStream</span> :</span> <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Read</span>(number);<span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位内存流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Write</span>(data);<span class="comment">//写内存流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedFileStream</span> :</span> <span class="keyword">public</span> FileStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedNetworkStream</span> :</span> <span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedMemoryStream</span> :</span> <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoBufferedFileStream</span> :</span><span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//编译时装配</span></span><br><span class="line">    CryptoFileStream *fs1 = <span class="keyword">new</span> <span class="built_in">CryptoFileStream</span>();</span><br><span class="line">    BufferedFileStream *fs2 = <span class="keyword">new</span> <span class="built_in">BufferedFileStream</span>();</span><br><span class="line">    CryptoBufferedFileStream *fs3 =<span class="keyword">new</span> <span class="built_in">CryptoBufferedFileStream</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>一个类 继承自Stream 且与Stream类组合</li>
<li><code>class CryptoStream :public Stream &#123; Stream* stream ...&#125;</code></li>
<li>继承原因：为了实现基类的接口规范</li>
<li>组合原因：为了实现功能<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  【2】继承自Stream ，为了继承Stream的接口 (virtual Read...)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> Stream &#123;     </span><br><span class="line">    <span class="comment">//  FileStream / NetworkStream / MemoryStream</span></span><br><span class="line">    <span class="comment">//  运行时依赖</span></span><br><span class="line">    <span class="comment">//  【1】与Stream类组合，实现功能</span></span><br><span class="line">    Stream* stream;<span class="comment">//...    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* stm):<span class="built_in">stream</span>(stm)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> :</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream* stm):<span class="built_in">stream</span>(stm)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配 即编译时依赖优化成运行时依赖</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1);      <span class="comment">//  加密    Stream* 接收 FileStream*</span></span><br><span class="line">    BufferedStream* s3=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s1);  <span class="comment">//  缓冲</span></span><br><span class="line">    BufferedStream* s4=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s2);  <span class="comment">//  加密 + 缓冲 Stream* 接收 CryptoStream*</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果多个子类有相同字段时，那么要将这个字段往上（往父类或者新建一个这种字段的中间类）提。 --马丁</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-08-55-22.png"></p>
<ul>
<li>Decorator装饰类</li>
<li>如果多个子类有相同字段时，那么要将这个字段往上（往父类或者新建一个这种字段的中间类）提。 –马丁</li>
<li><code>class Decorator : public Stream&#123;Stream *stream&#125;</code><ul>
<li><code>stream*</code>：用组合来代替继承实现多态<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作类</span></span><br><span class="line"><span class="comment">//  DacoratorStream：要将CryptoStream以及BufferedStream的相同字段Stream*提出来。而放在Stream基类中发现不合适（主题类不需要Stream*字段）。因此，构造一个中间类。</span></span><br><span class="line"><span class="comment">//  用组合的方式，引出对多态的支持</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Stream* stream; <span class="comment">//核心！！！</span></span><br><span class="line">    <span class="built_in">DecoratorStream</span>(Stream * stm):<span class="built_in">stream</span>(stm)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读文件流     组合的动态特质</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> :</span> <span class="keyword">public</span> DecoratorStream&#123;</span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1);</span><br><span class="line">    BufferedStream* s3=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s1);</span><br><span class="line">    BufferedStream* s4=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h3><ul>
<li>装饰器模式 <code>Decorator</code><ul>
<li>通过子类实现功能增强的问题：为了增强现有类的功能，通过实现子类的方式，</li>
<li>重写接口，是可以完成功能扩展的，但是代码中有太多的子类添加进来了</li>
</ul>
</li>
<li> 车 A ,B ,C</li>
<li> 这些车，有的功能只有<code>base</code> ， 有的有<code>brake ， hasten ， boom</code> 以及他们的组合<br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-10-17-24.png"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by dell on 2022-03-28.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  车 A ,B ,C</span></span><br><span class="line"><span class="comment">//  这些车，有的功能只有base ， 有的有brake ， hasten ， boom 以及他们的组合</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACar</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A car : base , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BCar</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B car : base , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;C car : base , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>:</span><span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Decorator</span>(Car *p):<span class="built_in">p_car</span>(p)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Car *p_car;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator1</span> :</span> <span class="keyword">public</span> Decorator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorator1</span>(Car* p_car):<span class="built_in">Decorator</span>(p_car)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p_car-&gt;<span class="built_in">show</span>();  <span class="comment">//  父类的show (原先就有的功能)</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;hasten , &quot;</span>;  <span class="comment">//  添加功能</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator2</span> :</span> <span class="keyword">public</span> Decorator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorator2</span>(Car *p): <span class="built_in">Decorator</span>(p)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span>    <span class="comment">//  添加功能</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p_car-&gt;<span class="built_in">show</span>();  <span class="comment">//  父类的show</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;brake , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator3</span> :</span> <span class="keyword">public</span> Decorator&#123;</span><br><span class="line">    <span class="built_in">ConcreteDecorator3</span>(Car *p): <span class="built_in">Decorator</span>(p)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span>    <span class="comment">//  添加功能</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p_car-&gt;<span class="built_in">show</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;boom , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  一个ACar 加上了装饰器1的功能hasten 之后就可以通过pA来调用这个加上了装饰器1功能的Acar对象</span></span><br><span class="line">    ConcreteDecorator1 *pA =  <span class="keyword">new</span> <span class="built_in">ConcreteDecorator1</span>(<span class="keyword">new</span> <span class="built_in">ACar</span>());</span><br><span class="line">    pA-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  一个BCar pB-&gt; &#123;装饰器1功能 + 装饰器2功能 + BCar对象&#125;</span></span><br><span class="line">    ConcreteDecorator2 *pB = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator2</span>(<span class="keyword">new</span> <span class="built_in">ConcreteDecorator1</span>(<span class="keyword">new</span> <span class="built_in">BCar</span>()));</span><br><span class="line">    pB-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  不添加装饰器功能</span></span><br><span class="line">    CCar *pC = <span class="keyword">new</span> <span class="built_in">CCar</span>();</span><br><span class="line">    pC-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A car : base , hasten ,</span><br><span class="line">B car : base , hasten , brake ,</span><br><span class="line">C car : base ,</span><br></pre></td></tr></table></figure>

<h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><ul>
<li>一个类中要实现两种不同维度的功能，就把这个类分成两个类，把两个不同维度的功能分开。</li>
<li>把继承变组合实现多态</li>
<li>几个子类中有公共字段，那么要把这个字段向上提。<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3></li>
<li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度乃至多个纬度的变化。</li>
<li>如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>将<strong>抽象部分(业务功能)<strong>与</strong>实现部分(平台实现)<strong>分离，使它们都可以</strong>独立</strong>地变化。</li>
</ul>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-29-15-10-49.png"></p>
<h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul>
<li><p>Bridge模式使用<strong>s“对象间的组合关系”s</strong>解耦了抽象和实现之间固 有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”他们。</p>
</li>
<li><p>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背 单一职责原则（即一个类只有一个变化的原因），复用性比较差。<strong>Bridge模式是比多继承方案更好的解决方法。</strong></p>
</li>
<li><p>Bridge模式的应用一般在“<strong>两个非常强的变化维度</strong>”，有时一个 类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</p>
<h3 id="重构-1"><a href="#重构-1" class="headerlink" title="重构"></a>重构</h3></li>
<li><p>初始</p>
</li>
<li><p>要实现的类：<code>1+n+n*m</code><br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-29-15-04-36.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//平台实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerLite</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerPerfect</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerLite</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerPerfect</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译时装配</span></span><br><span class="line">        Messager *m =</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">MobileMessagerPerfect</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>重构后</p>
</li>
<li><p>1+n+m</p>
</li>
</ul>
<p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-29-15-04-13.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     MessagerImp* messagerImp;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MessagerImp</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//平台实现 n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象 m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的数目：1+n+m</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerLite</span> :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerPerfect</span>  :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    MessagerImp* mImp=<span class="keyword">new</span> <span class="built_in">PCMessagerImp</span>();</span><br><span class="line">    Messager *m =<span class="keyword">new</span> <span class="built_in">MessagerLite</span>(mImp);    <span class="comment">//  实现 PCMessageImp平台 + MessagerLite业务 组合   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-网络层</title>
    <url>/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<p>网络层-数据平面<br>路由器、IP协议(格式、IP分片、DHCP、NAT)<br>数据平面转发分为两类：基于目的地转发和通用转发. 通用转发涉及SDN<br>二者都是 匹配加动作 原则</p>
<p>参考 《自顶向下》《中科大》</p>
<span id="more"></span>

<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><ul>
<li>网络层的连接和传输层的连接不一样<ul>
<li>传输层tcp的连接只是体现在端系统,所以称为面向连接</li>
<li>网络层的连接 不仅在端系统,在中间的路由器上,也维护了通信的状态所以称为有连接</li>
<li>也即 运输层只存在于网络边缘（端点）（主机）, 网络层存在于网络边缘（每一台主机）和网络中心（路由器）上</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-09-28-07.png"></p>
<p>注 : </p>
<ul>
<li><ol>
<li>很多人互换的使用 转发 和 交换 这两个术语</li>
</ol>
</li>
<li><ol start="2">
<li>约定 <strong>分组交换机</strong> 指 通用分组交换设备. 功能：根据分组首部字段的值，将分组从从输入链路接口转移到输出链路接口. </li>
</ol>
<ul>
<li>其中有两种分组交换机<ul>
<li><strong>链路层交换机</strong>(linker-layer switch)<ul>
<li>链路层的分组交换机(链路层/第二层设备)</li>
<li>基于链路层帧中的字段值进行转发</li>
</ul>
</li>
<li><strong>路由器</strong>(router) <ul>
<li>网络层的分组交换机 (网络层/第三层设备)</li>
<li>基于网络层数举报的首部字段值进行转发</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>分组交换器 其实应该叫分组路由器<br>交换器是对数据链路层的帧来说的。<br>所以说名字起的不好</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>网络层作用从整体来看为：将分组从一台发送主机移动到另一台接收主机</li>
<li>为此，网络层实现了两方面的重要功能：数据平面和控制平面</li>
</ul>
<p>路由表 是 数据功能和控制功能的粘合剂<br>控制平面的功能体现在最后的结果：路由表<br>路由表交给ip协议<br>ip协议根据路由表对到来的分组做转发，实现数据平面功能</p>
<h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><p>数据平面</p>
<ul>
<li><strong>转发 forwarding</strong><ul>
<li>是每个路由器本地的功能</li>
<li>IP协议实现转发功能(局部) : IP协议根据forwarding table 将分组从路由器的输入接口转发到合适的输出接口</li>
<li><strong>转发方式</strong><ul>
<li><strong>传统</strong>：基于目标地址+转发表(forwarding table) </li>
<li><strong>通用转发</strong>：基于多个字段+流表 </li>
</ul>
</li>
<li>转发是在数据平面唯一实现的功能</li>
<li>转发的时间尺度很短(几ns), 通常用硬件实现</li>
</ul>
</li>
</ul>
<h4 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h4><p>控制平面</p>
<ul>
<li><strong>路由选择 routing</strong><ul>
<li>路由选择协议实现了路由功能(全局)<ul>
<li>路由选择算法 决定数据报如何在路由器之间路由 ; 决定分组从发送主机到目标接收主机的路径</li>
</ul>
</li>
<li><strong>路由选择算法 routing algorithm</strong><ul>
<li><strong>传统路由选择算法: 在路由器中实现</strong><ul>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-18-44.png"><ul>
<li>数据平面传统转发 &amp;&amp; 控制平面传统路由选择</li>
</ul>
</li>
<li>路由选择算法routing algorithm运行在每台路由器中,<strong>每台路由器中都包含 forwarding转发 和 routing路由选择 两种功能</strong></li>
<li>一台路由器的routing algorithm路由选择算法与其他路由器中的routing algorithm交互，以计算出其forwarding table的值</li>
</ul>
</li>
<li><strong>Software-Defined Networking SDN : 在远程服务器实现</strong><ul>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-11-05-42.png"><ul>
<li>数据平面通用转发 + 控制平面SDN控制</li>
</ul>
</li>
<li>与传统方式不同（各个路由器运行路由选择算法并彼此通信），控制平面或许有其他方来填写数据平面的forwarding table。<ul>
<li>控制平面将路由选择功能从路由器中分离，由远程服务器负责</li>
</ul>
</li>
<li><strong>远程服务器承担路由选择功能：计算和分发转发表给路由器</strong></li>
<li><strong>路由器只承担数据平面的转发功能</strong></li>
<li>路由器和远程控制器交换包含转发表和其他路由选择信息的报文进行通信。</li>
<li>为什么叫Software-Defined : 因为计算forwarding table进而与router交互的控制器由软件实现。</li>
</ul>
</li>
</ul>
</li>
<li>路由器采用的 路由转发算法 决定了 forwarding table 的内容(传统和sdn符合这句话?)</li>
<li>路由选择的时间尺度较长(几s), 通常用软件实现</li>
</ul>
</li>
</ul>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><ul>
<li><p>从发送方主机到接收方主机传输数据报的“通道” , 网络提供什么样的服务模型？</p>
<ul>
<li>感觉就是网络层对运输层做出的保证</li>
</ul>
</li>
<li><p>对于单个数据报的服务</p>
<ul>
<li>可靠传送</li>
<li>延迟保证，如：少于40ms的延迟</li>
</ul>
</li>
<li><p>对于数据报流的服务:</p>
<ul>
<li>保序数据报传送</li>
<li>保证流的最小带宽</li>
<li>分组之间的延迟</li>
</ul>
</li>
<li><p>连接建立 : 在某些网络架构中是第三个重要的功能</p>
<ul>
<li>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接<ul>
<li>涉及到路由器</li>
</ul>
</li>
<li>网络层和传输层连接服务区别:<ul>
<li>网络层: 在2个主机之间，涉及到路径上的一些路由器</li>
<li>传输层: 在2个进程之间，只体现在端系统上(TCP连接)</li>
</ul>
</li>
</ul>
</li>
<li><p>Internet 因特网的网络层提供服务：<strong>best-effort service 尽力而为</strong></p>
<ul>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-12-07-05.png"></li>
</ul>
</li>
</ul>
<p>ip网络没有连接建立的功能，有些网络提供了连接建立功能<br>ip网络向上层提供转发功能 ：ip协议（数据功能），路由选择协议（控制功能）</p>
<p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-09-18-22.png"></p>
<h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ul>
<li>高层面(非常简化的)通用路由器体系架构<ul>
<li>路由：运行路由选择算法／协议 (RIP, OSPF, BGP)-生成路由表</li>
<li>转发：从输入到输出链路交换数据报-根据路由表进行分组的转发</li>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-12-52-24.png"></li>
</ul>
</li>
</ul>
<h3 id="输入端口处理-基于目的地转发"><a href="#输入端口处理-基于目的地转发" class="headerlink" title="输入端口处理 + 基于目的地转发"></a>输入端口处理 + 基于目的地转发</h3><ul>
<li><strong>输入端口重要功能</strong>:(look up forwarding table)查找转发表，决定分组的输出端口<ul>
<li>转发表由路由选择处理器生成<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-14-52-02.png"></li>
</ul>
</li>
</ul>
<ul>
<li><strong>输入端口缓存</strong><ul>
<li>当交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队<ul>
<li><strong>排队延迟以及由于输入缓存溢出会造成丢失!</strong></li>
</ul>
</li>
<li>Head-of-the-Line (HOL) blocking: 排在队头的数据报阻止了队列中其他数据报向前移动<ul>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-15-45-13.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>匹配加动作</strong></p>
<ul>
<li>匹配：输入端口查找目的IP，</li>
<li>动作：输入端口将分组送入交换结构(差不多就是转发)</li>
<li>是一种匹配加动作的特定情况</li>
</ul>
</li>
<li><p><strong>routing processor 路由选择处理器</strong></p>
<ul>
<li>传统路由器中，routing processor 执行路由选择协议</li>
<li>SDN路由器中，routing processor 与远程控制器通信</li>
</ul>
</li>
</ul>
<h4 id="基于目的地转发"><a href="#基于目的地转发" class="headerlink" title="基于目的地转发"></a>基于目的地转发</h4><p><strong>关于转发</strong></p>
<ul>
<li><strong>基于目的地转发</strong> : 只依赖IP数据报的目标IP地址这一个因素，来决定分组的输出端口。<ul>
<li>前缀匹配（且是最长前缀匹配）<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-02-09-08-23-34.png"> -&gt;<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-02-09-08-24-03.png"></li>
</ul>
</li>
</ul>
<h4 id="通用转发-见后文"><a href="#通用转发-见后文" class="headerlink" title="通用转发 (见后文)"></a>通用转发 (见后文)</h4><ul>
<li><strong>通用转发</strong></li>
</ul>
<h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><ul>
<li><p>将分组从输入缓冲区传输到合适的输出端口</p>
</li>
<li><p>交换速率：分组可以按照该速率从输入传输到输出</p>
<ul>
<li>运行速度经常是输入/输出链路速率的若干</li>
<li>N 个输入端口：交换机构的交换速度是输入线路速度的N倍比较理想，才不会成为瓶颈</li>
</ul>
</li>
<li><p>典型交换结构</p>
<blockquote>
<p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-15-50-02.png"></p>
</blockquote>
</li>
<li><p>经内存交换…</p>
</li>
<li><p>经总线交换…</p>
</li>
<li><p>经互联网交换…</p>
</li>
</ul>
<h3 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h3><ul>
<li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-15-59-04.png"></p>
</li>
<li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-01-20.png"></p>
</li>
<li><p>当数据报从交换机构的到达速度比传输速率快,就需要输出端口缓存</p>
</li>
<li><p>排队带来延迟，由于输出端口缓存<strong>溢出</strong>则<strong>丢弃</strong>数据报</p>
</li>
<li><p>由调度规则选择排队的数据报进行传输</p>
</li>
<li><p><strong>调度机制</strong></p>
<ul>
<li>调度: 选择下一个要通过链路传输的分组</li>
<li>FIFO (first in first out) scheduling:<ul>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-06-04.png"> </li>
<li>按照分组到来的次序发送 </li>
<li>丢弃策略: 如果分组到达一个满的队列，哪个分组将会被抛弃?<ul>
<li>tail drop: 丢弃刚到达的分组</li>
<li>priority: 根据优先权丢失/移除分组</li>
<li>random: 随机地丢弃/移除</li>
</ul>
</li>
</ul>
</li>
<li>Priority Queuing 优先权调度：<ul>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-13-34.png"></li>
<li>发送最高优先权的分组</li>
<li>多类，不同类别有不同的优先权 <ul>
<li>类别可能依赖于标记或者其他的头部字段, e.g. IP source/dest, port numbers, ds，etc. </li>
<li>先传高优先级的队列中的分组</li>
</ul>
</li>
</ul>
</li>
<li>Round Robin Queuing Discipline 循环排队规则<ul>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-13-02.png"></li>
<li>循环扫描不同类型的队列, 发送完一类的一个分组，再发送下一个类的一个分组，循环所有类</li>
</ul>
</li>
<li>Weighted Fair Queuing (WFQ)<ul>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-15-41.png"></li>
<li>一般化的Round Robin</li>
<li>在一段时间内，每个队列得到的服务时间是：Wi/(XIGMA(Wi)) *t，和权重成正比</li>
<li>每个类在每一个循环中获得不同权重的服务量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><ul>
<li>主机、路由器中的网络层功能<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-30-49.png"></li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-31-16.png"></p>
<ul>
<li><p>length 数据报长度 : IP数据报总长度（首部+数据）。单位字节。</p>
</li>
<li><p>identifier 标识 , flags 标志 , fragment offset 片偏移 : 与ip分片有关</p>
</li>
<li><p>time to live : 允许经过的路由器数</p>
</li>
<li><p>upper layer : 指示数据部分的协议，仅当ip数据报到达最终目的地时才有效</p>
</li>
<li><p>check sum 首部检验和 : 帮助路由器检测ip数据报的比特错误</p>
<ul>
<li>路由器会丢弃检测出错误的数据报</li>
<li>为什么tcp/ip在运输层和网络层都进行差错检测 ?<ul>
<li><ol>
<li>ip层只对ip首部进行检验，而tcp/udp是对整个tcp/ucp报文进行检测的。</li>
</ol>
</li>
<li><ol start="2">
<li>ip不一定和tcp/udp在同一协议栈上</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>source ip , des ip : ip字段在ip报文首部，port字段在tcp/udp报文首部</p>
</li>
<li><p>data : tcp/udp segment , icmp segment</p>
</li>
<li><p>IP数据报传输TCP段 由器的列表.时头部有多少?</p>
<ul>
<li>20 bytes of TCP +</li>
<li>20 bytes of IP +</li>
<li>app layer overhead</li>
</ul>
</li>
</ul>
<h3 id="IPv4数据报分片-和-重组"><a href="#IPv4数据报分片-和-重组" class="headerlink" title="IPv4数据报分片 和 重组"></a>IPv4数据报分片 和 重组</h3><ul>
<li><p>路由器进行分片，目的主机进行重组</p>
</li>
<li><p>Max Transmission Unit , MTU (最大传输单元) </p>
<ul>
<li>链路层帧所携带的最大数据长度 </li>
<li>不同的链路类型有不同的MTU</li>
</ul>
</li>
<li><p>大的IP数据报在网络上被分片(“fragmented”) </p>
<ul>
<li>一个数据报被分割成若干个小的数据报 </li>
<li>“重组”只在最终的目标主机进行 </li>
<li>IP头部的信息片偏移被用于标识，排序相关分片 <ul>
<li>identifier 标识 : 同一数据报的切片具有相同的ID</li>
<li>flags 标志 : 同一数据报的最后一个切片的flags标志字段置为0</li>
<li>fragment offset : 代表该切片的ip载荷部分的第一个字节，在整个ip数据报的载荷部分的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>例子<br>  <img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-17-39-49.png"></p>
</li>
</ul>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><ul>
<li>IP地址: 网络设备(包括主机,路由器)和网络的接口的标识<ul>
<li>一个IP地址和一个接口相关联</li>
<li>接口: 主机/路由器和物理链路的连接处 <ul>
<li>路由器通常拥有多个接口(路由器和不同网络的接口 ; 路由器至少有两个ip地址，否则路由器没有办法在网络之间进行分组转发) </li>
<li>主机也有可能有多个接口(只不过这多个接口很可能都是主机和同一网络的接口)</li>
<li>IP地址和每一个接口关联</li>
</ul>
</li>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-17-52-58.png"></li>
</ul>
</li>
</ul>
<p>主机有一个ip地址即可，也可以有多个ip地址。</p>
<blockquote>
<p>Q: 这些接口是如何连接的?<br>A: 我们将会在第5，6章学习<br>前：无需担心一个接口是如何<br>接到另外一个接口 (中间没有路由器)</p>
</blockquote>
<p>网络内部 ip之间如何进行分组的发送和接收？— 帧 – 交换机 — 数据链路层</p>
<h4 id="子网-Subnets"><a href="#子网-Subnets" class="headerlink" title="子网 Subnets"></a>子网 Subnets</h4><ul>
<li>IP地址:<ul>
<li>子网部分(高位bits)</li>
<li>主机部分(地位bits) </li>
</ul>
</li>
<li><strong>什么是子网(subnet)</strong> ?<ul>
<li>一个子网内的节点（主机或者路由器）它们的<strong>IP地址的高位部分相同</strong>，这些节点构成的网络的一部分叫做子网</li>
<li>子网内<strong>无需路由器介入</strong>，子网内各主机可以在物理上相互直接到达</li>
<li>一个子网的ip定义并不局限于多台主机到一个路由器接口的以太网段</li>
</ul>
</li>
</ul>
<ul>
<li><strong>判断子网</strong>:<ul>
<li>要判断一个子网, 将每一个接口(ip)从主机或者路由器上分开,构成了一个个网络的孤岛</li>
<li>每一个孤岛（网络）都是一个都可以被称之为subnet.</li>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-20-01-59.png"></li>
<li>223.1.1.0/24 223.1.2.0/24 223.1.3.0/24 223.1.8.0/24 223.1.7.0/24 223.1.9.0/24</li>
</ul>
</li>
</ul>
<h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p>一种分类编址 classful addressing</p>
<ul>
<li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-20-12-50.png"></p>
<ul>
<li>A: <ul>
<li>0.0.0.0 - 127.255.255.255 ; </li>
<li>126 networks ，16777214 hosts ; </li>
<li>mask 255.0.0.0</li>
</ul>
</li>
<li>B: <ul>
<li>128.0.0.0 - 191.255.255.255 ; </li>
<li>16382networks ，65534 hosts ; </li>
<li>mask 255.255.0.0</li>
</ul>
</li>
<li>C : <ul>
<li>192.0.0.0 - 223.255.255.255 ; </li>
<li>2 million networks ，254 hosts ; </li>
<li>mask 255.255.255.0</li>
</ul>
</li>
<li>D : <ul>
<li>224.0.0.0 - 239.255.255.255 ; </li>
<li>multicast</li>
</ul>
</li>
<li>E : <ul>
<li>240.0.0.0 - 247.255.255.255 ; </li>
<li>reserved for future</li>
</ul>
</li>
</ul>
</li>
<li><p>可以看出ABC三类地址分为网络号和主机号</p>
<ul>
<li>特殊ip地址<ul>
<li>主机号全为 1 : 广播地址,该网络下的所有主机</li>
<li>主机号全为 0 : 指定本主机<ul>
<li>故计算网络内最大主机数 = 2^(主机号位数) - 2</li>
</ul>
</li>
<li>子网部分全为 0 : 本网络</li>
<li><blockquote>
<p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-20-57-02.png"></p>
</blockquote>
</li>
<li><strong>回路地址/测试地址</strong><ul>
<li>127开头的ip地址为回路地址：127.x.x.x 如常见的127.0.0.1</li>
<li>目标地址为127.x.x.x的不会发送出网卡，到网络层监测到ip为回环地址后就直接将数据包返回到运输层</li>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-19-16-09-26.png"></li>
</ul>
</li>
<li>子网内的广播地址 : 255.255.255.255(理论依据呢 ?)</li>
<li>本机地址 : 0.0.0.0(理论依据呢 ?)</li>
</ul>
</li>
</ul>
</li>
<li><p>ABC三类地址中，一部分为专用ip，一部分为公用ip</p>
<ul>
<li>内网IP = 专用IP = 私有IP</li>
<li>私有ip只在局域网中有意义，不会出现在公网中</li>
<li>路由器不对目标地址是私有ip的分组进行转发</li>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-20-30-37.png"><ul>
<li>其中A mask为 255.0.0.0 ；B mask 255.255.0.0 ; C mask 255.255.255.0 </li>
</ul>
</li>
<li>那么易知，我租的服务器的ip为114.132.58.229，显然是A中的公有ip ; 易知虚拟机ifconfig看到的192.168.147.162，显然是C的私有ip ; wsl ifconfig看到的172.17.247.46，显然是B的私有ip</li>
</ul>
</li>
</ul>
<ul>
<li>而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E 类是预留的分类，暂时未使用。<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-09-43-41.png"></li>
</ul>
<h4 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h4><ul>
<li>CIDR : Classless InterDomain Routing. 无分类地址 也叫 无类域间路由<ul>
<li>子网部分和主机部分可以在任意的位置临界</li>
<li>地址格式 : a.b.c.d/x , x为子网号长度</li>
<li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-21-20-29.png"></li>
<li>因特网的地址分配策略是CIDR</li>
</ul>
</li>
</ul>
<h4 id="子网掩码-subnet-mask"><a href="#子网掩码-subnet-mask" class="headerlink" title="子网掩码 subnet mask"></a>子网掩码 subnet mask</h4><ul>
<li>32bits ,0 or 1 in each bit<ul>
<li><strong>1: bit位置表示子网部分</strong> </li>
<li><strong>0: bit位置表示主机部分</strong></li>
</ul>
</li>
<li>原始的A、B、C类网络的子网掩码分别是 <ul>
<li>A：255.0.0.0 ：11111111 00000000 0000000 00000000 </li>
<li>B：255.255.0.0：11111111 11111111 0000000 00000000 </li>
<li>C：255.255.255.0：11111111 11111111 11111111 00000000</li>
</ul>
</li>
<li>CIDR下的子网掩码例子：<ul>
<li>11111111 11111111 11111100 0000000</li>
</ul>
</li>
<li>也可通过/x表示子网掩码<ul>
<li>如子网掩码为223.1.1.0/24<ul>
<li>意味着高24bit地址定义了子网地址. 任何其他要求接入223.1.1.0/24 网络的主机都要求具有223.1.1.xxx的形式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="转发表和转发算法"><a href="#转发表和转发算法" class="headerlink" title="转发表和转发算法"></a>转发表和转发算法</h4><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-21-52-41.png"></p>
<ul>
<li>已知获得IP数据报的目标地址IP Des addr , 那么对于转发表中的每一个表项<ul>
<li>如 (IP Des addr) &amp; (mask)== destination, 则按照表项对应的接口转发该数据报</li>
<li>如果都没有找到,则使用默认表项转发数</li>
</ul>
</li>
</ul>
<h3 id="如何获得ip地址"><a href="#如何获得ip地址" class="headerlink" title="如何获得ip地址"></a>如何获得ip地址</h3><p>上述学习ipv4编址 那么主机或者子网最初是如何得到他们的地址的 ?</p>
<ol>
<li> 组织如何为其设备得到一个ip地址块</li>
<li> 组织中的设备如何从地址块中获得一个ip地址</li>
</ol>
<h4 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h4><ul>
<li>组织如何为其设备得到一个地址块 ? 即 如何为子网获取一个ip地址快 即 如何获得一个网络的子网部分（网络号部分 ? ）</li>
<li>解：从ISP地址块 中 被分配到一个块地址快<br>  <img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-09-40-27.png"></li>
<li>ISP如何获得地址块 : ICANN<ul>
<li>分配地址</li>
<li>管理DNS</li>
<li>分配域名，解决</li>
</ul>
</li>
</ul>
<h4 id="获取主机地址-DHCP"><a href="#获取主机地址-DHCP" class="headerlink" title="获取主机地址 : DHCP"></a>获取主机地址 : DHCP</h4><p>组织中的设备如何从地址块中获得一个ip地址</p>
<ul>
<li><p>DHCP : Dynamic Host Configuration Protocol 动态主机配置协议</p>
<ul>
<li><p>DHCP基于udp</p>
</li>
<li><blockquote>
<p>路由器的ip和主机的ip都可以手工配置，但更好的方法是采用dhcp. dchp允许主机每次接入网络时能得到一个临时的ip地址, 每次接入网络时得到的地址也许是不同的.</p>
</blockquote>
</li>
<li><p>dhcp实例: 主机频繁的加入和离开网络. 如我们在宿舍和在实验室会发现本机的ip地址不同. 就是两次接入网络时dhcp获取的ip不同</p>
</li>
<li><p><strong>目标</strong>: 允许主机在加入网络的时候，动态地从服务器那里获得IP地址： </p>
<ul>
<li>可以更新对主机在用IP地址的租用期-租期快到了 </li>
<li>重新启动时，允许重新使用以前用过的IP地址 </li>
<li>支持移动用户加入到该网络（短期在网）</li>
</ul>
</li>
<li><p>对于一台新到达的主机，DHCP协议分为4步</p>
<ul>
<li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-08-56-13.png"></p>
</li>
<li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-09-24-25.png"></p>
</li>
<li><p><strong>DHCP服务器发现 (寻找DHCP Server)</strong></p>
<ul>
<li>为寻找DHCP Server,主机广播 <strong>DHCP发现报文(DHCP discover message)</strong> <ul>
<li>目的地址 广播 255.255.255.255 </li>
<li>源地址 本主机0.0.0.0</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DHCP服务器提供 （DHCPServer 给 client推荐ip）</strong></p>
<ul>
<li>DHCPServer 广播 <strong>DHCP提供报文(DHCP offer message)</strong><ul>
<li>目的地址 广播: 255.255.255.255</li>
<li>源地址 : DHCP Server IP</li>
<li><strong>内容</strong>  <ul>
<li>IP 地址 及 租用期</li>
<li>第一跳路由器的IP地址（默认网关） </li>
<li>DNS服务器的域名和IP地址 </li>
<li>子网掩码 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DHCP请求    （client 确认并回显 DHCPServer的推荐）</strong></p>
<ul>
<li>主机从多个DHCP服务器中选择一个，并响应。通过发送<strong>DHCP请求报文(DHCP request message)</strong>. 回显配置的参数</li>
</ul>
</li>
<li><p><strong>DHCP ACK （DHCP确认）</strong></p>
<ul>
<li>DHCP Server 发送 <strong>DHCP请求确认(DHCP ACK message)</strong> DHCP请求报文</li>
<li>client收到ack后 交互便完成.</li>
</ul>
</li>
</ul>
</li>
<li><p>DHCP 缺陷 :</p>
<ul>
<li>每当节点连接到一个新子网，要从DHCP获取一个新的IP地址，当移动节点在子网之间移动时，<strong>不能维持原先的TCP连接</strong>.</li>
</ul>
</li>
<li><blockquote>
<p>由于dhcp具有将主机连接进一个网络的网络相关方面的自动能力，故被称为即插即用协议(plug-and-play protocol) / 零配置(zeroconf)协议</p>
</blockquote>
</li>
</ul>
</li>
<li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-09-29-08.png"></p>
</li>
</ul>
<h3 id="网络地址转换-Network-Address-Translation"><a href="#网络地址转换-Network-Address-Translation" class="headerlink" title="网络地址转换 Network Address Translation"></a>网络地址转换 Network Address Translation</h3><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-11-08-29.png"><br>NAT 理解: 将内部的专用地址转化成公有唯一地址</p>
<ul>
<li><strong>NAT路由器</strong><ul>
<li>NAT路由器对于外部世界表现得不像一台路由器，而是一台具有单一IP地址的单一设备。<ul>
<li>本质 : NAT路由器对外界隐藏了子网内的细节</li>
</ul>
</li>
<li>动机: 本地网络只有一个有效IP地址(子网内的设备对外使用同一个ip)<ul>
<li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备–省钱</li>
<li>可以在局域网改变设备的地址情况下而无须通知外界</li>
<li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li>
<li>局域网内部的设备没有明确的地址，对外是不可见的–安全</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>实现</strong>: NAT 路由器必须:<ul>
<li>外出数据包：<ul>
<li>重写源IP和源Port 为NAT IP地址和NAT Port，目标IP和Port不变</li>
<li>远端的C/S将会用NAT IP地址，新端口号作为目标地址</li>
</ul>
</li>
<li>在NAT转换表中记录对应关系 <ul>
<li>&lt;NAT IP, NAT Port ; 源IP,源Port &gt;</li>
<li><strong>NAT转化表 NAT translation table</strong><ul>
<li>{WAN端IP NATPort} , {LAN端IP SRCPort}</li>
</ul>
</li>
</ul>
</li>
<li>进入数据包：<ul>
<li>重写目标IP和目的Port 为源IP，端口 . (根据NAT table.)<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-12-41-02.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>因为Port为16-bit: <ul>
<li>故一个局域网内可以至多同时有6万多个同时连接</li>
</ul>
</li>
<li>对NAT是有争议的: <ul>
<li>路由器只应该对第3层(网络层)做信息处理，而这里对端口号（4层）(应用层作了处理</li>
<li>违反了end-to-end 原则 <ul>
<li>端到端原则：复杂性放到网络边缘 <ul>
<li>使得无需借助中转和变换，就可以直接传送到目标主机 </li>
</ul>
</li>
<li>NAT可能要被一些应用设计者考虑, eg, P2P applications </li>
<li>外网的机器无法主动连接到内网的机器上(因为) </li>
</ul>
</li>
<li>地址短缺问题可以被IPv6 解决 </li>
<li>NAT穿越： 如果客户端需要连接在NAT后面的服务器，如何操作 ? </li>
</ul>
</li>
</ul>
<h4 id="NAT穿越-NAT-traversal"><a href="#NAT穿越-NAT-traversal" class="headerlink" title="NAT穿越 NAT traversal"></a>NAT穿越 NAT traversal</h4><ul>
<li>问题描述 : client需要连接ip(10.0.0.1)的server(即客户要连接一个位于NAT背后的Server) <ul>
<li>易知10.0.0.1 为 LAN本地地址 (client不能够使用其作为目标地址) </li>
<li>整网只有一个外部可见地址: 138.76.29.7<blockquote>
<p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-09-18.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>方案1: 静态配置NAT：转发进来的对服务器特定端口连接请求<ul>
<li>即在nat translation table上手动配置 {(123.76.29.7, port 25000) , (10.0.0.1 port 25000)} ，使得(123.76.29.7, port 2500) 总是转发到(10.0.0.1 port 25000)</li>
</ul>
</li>
</ul>
<ul>
<li>方案2: Universal Plug and Play (UPnP) Internet Gateway Device (IGD) 协议. 允许NATted主机可以:<ul>
<li>获知网络的公共 IP地址(138.76.29.7)</li>
<li>列举存在的端口映射</li>
<li>增/删端口映射 (在租用时间内)</li>
<li>i.e., 自动化静态NAT端口映射配置<blockquote>
<p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-17-20.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>方案 3: 中继 (used in Skype)<ul>
<li>?? ques 不太理解 中继是怎么和Server连起来的</li>
<li>NAT后面的服务器建立和中继的连接</li>
<li>外部的客户端链接到中继</li>
<li>中继在2个连接之间桥接<blockquote>
<p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-16-15.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="中间盒"><a href="#中间盒" class="headerlink" title="中间盒"></a>中间盒</h2><ul>
<li>还有其他种类繁多网络设备（中间盒）：<ul>
<li>中间盒运行在网络层且不执行传统的数据转发</li>
<li>如<ul>
<li>NAT : <strong>重写</strong>首部ip和port</li>
<li>防火墙 : 基于首部字段<strong>阻拦</strong>流量或<strong>重定向</strong>分组</li>
<li>负载均衡 : 按算法转发给server </li>
</ul>
</li>
<li>未来：不断增加的需求和相应的网络设备</li>
<li>P227</li>
<li>需要不同的设备去实现不同的网络功能 <ul>
<li>每台设备集成了控制平面和数据平面的功能 </li>
<li>控制平面分布式地实现了各种控制平面功能 </li>
<li>升级和部署网络设备非常困难</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h2><ul>
<li><p>路由器的网络层功能：</p>
<ul>
<li>IP转发：对于到来的分组按照路由表决定如何转发；属于数据平面</li>
<li>路由：决定路径，计算路由表；属于控制平面</li>
</ul>
</li>
<li><p>传统方式实现网络功能的问题</p>
<ul>
<li>垂直集成&gt;昂贵、不便于创新的生态</li>
<li>分布式、固化设备功能==网络设备种类繁多<ul>
<li>无法改变路由等工作逻辑，无法实现流量工程等高级特性</li>
<li>配置错误影响全网运行；升级和维护会涉及到全网设备：管理困难</li>
<li>要增加新的网络功能，需要设计、实现以及部署新的特定设备，设备种类繁多</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SDN-控制平面"><a href="#SDN-控制平面" class="headerlink" title="SDN (控制平面)"></a>SDN (控制平面)</h3><ul>
<li><p>SDN：逻辑上集中的控制平面</p>
</li>
<li><p>一个不同的（通常是远程）控制器和CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑。</p>
<ul>
<li><strong>远程控制器计算和分发匹配加动作表</strong></li>
<li>实现网络设备数据平面和控制平面分离<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-52-02.png"></li>
</ul>
</li>
<li><p>见导论功能控制平面</p>
</li>
</ul>
<h3 id="通用转发-数据平面"><a href="#通用转发-数据平面" class="headerlink" title="通用转发 (数据平面)"></a>通用转发 (数据平面)</h3><ul>
<li>基于目的地转发可分为两步骤<ul>
<li>匹配 : 查找目的IP地址</li>
<li>动作 : 将分组发送到有特定输出端口的交换结构</li>
<li>可以看到这是匹配 + 动作的一种特例<br>下面看一下通用的匹配加动作范式</li>
</ul>
</li>
<li><strong>匹配加动作</strong><ul>
<li>匹配: 可以对协议栈的多个首部字段进行 匹配 ， 这些首部字段与不同层次的协议关联</li>
<li>动作: 将分组转发到一个或多个输出端口(像基于目的地转发一样),负责均衡,重写首部值(像NAT一样),阻挡/丢弃分组(像防火墙一样)等等</li>
</ul>
</li>
</ul>
<hr>
<p>以下所述都是基于Open Flow<br>OpenFlow : 匹配加动作抽象,控制器,SDN概念 的标准</p>
<ul>
<li><p><strong>Flow table 流表</strong></p>
<ul>
<li><strong>匹配加动作转发表</strong>在OpenFlow中被称为<strong>流表</strong></li>
<li>表项包括<ul>
<li>首部字段值的集合 Rule </li>
<li>所采取<strong>动作</strong>集合 Action: <strong>转发 / 丢弃 / 重写</strong></li>
<li>计数器集合 Stats: Packet + byte counters</li>
</ul>
</li>
</ul>
</li>
<li><p>分组交换机 or 路由器 ?</p>
<ul>
<li>由于流表 除了网络层之外，还需要链路层的首部字段来做出动作决定，所以不能再叫路由器（网络层）了，当然也不能叫(第二层)交换机，我们将其称为 分组交换机</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-14-35-05.png"></p>
<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><ul>
<li>OpenFlow的匹配抽象允许对来自三个层次的协议的首部字段进行匹配</li>
<li>流表中的表项结构如下<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-15-25-31.png"></li>
</ul>
<h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><ul>
<li>转发 : 分组转发到指定端口 / 广播道所有端口 / 多播 / 发给远程控制器(远程控制器可能安装新的流表)等 </li>
<li>丢弃 : 流表项中无动作</li>
<li>修改字段 : 重写分组首部字段(234层)</li>
</ul>
<h3 id="匹配加动作-例子"><a href="#匹配加动作-例子" class="headerlink" title="匹配加动作 例子"></a>匹配加动作 例子</h3><p>分组交换机(路由器)匹配加动作操作 充当<br>简单转发<br>负载均衡<br>防火墙<br>这样就不必通过中间盒<br>自顶向下P234</p>
<h2 id="数据平面data-plane小结"><a href="#数据平面data-plane小结" class="headerlink" title="数据平面data plane小结"></a>数据平面data plane小结</h2><ul>
<li>网络层的数据平面功能 : <ul>
<li>即路由器的转发功能<ul>
<li>决定到达路由器的输入链路之一的分组如何转发到路由器的输出链路</li>
</ul>
</li>
</ul>
</li>
<li>数据平面<ul>
<li>传统转发 -&gt; 通用转发(匹配加动作)</li>
</ul>
</li>
<li>相应的控制平面<ul>
<li>传统路由 -&gt; SDN</li>
<li>(控制)SDN和(数据)通用转发搭配</li>
<li>(控制)传统路由和(数据)传统转发搭配</li>
</ul>
</li>
<li>路由器结构</li>
<li>除此之外还学习了IP编址 , DHCP协议 , 什么是传说中的NAT(就是通过重写ip+port以及记录转换表 将私有ip转化为公有ip) , 知道了中间盒都是什么，如nat 防火墙等</li>
</ul>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>对象创建模式</title>
    <url>/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>对象创建模式：工厂模式、单例模式、原型模式</p>
<span id="more"></span>

<h1 id="对象创建模式"><a href="#对象创建模式" class="headerlink" title="对象创建模式"></a>对象创建模式</h1><ul>
<li>通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li>
<li>典型模式<ul>
<li>Factory Method</li>
<li>Abstract Factory</li>
<li>Prototype</li>
<li>Builder</li>
</ul>
</li>
</ul>
<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><ul>
<li>简单工厂 Simple Factory : <ul>
<li>把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象</li>
</ul>
</li>
<li>好处（是个工厂都有这好处）：客户不用自己负责new对象，不用了解对象创建的详细过程</li>
<li>缺点：提供创建对象实例的接口函数不闭合，不能对修改关闭</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">简单工厂 Simple Factory : </span></span><br><span class="line"><span class="comment">把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象</span></span><br><span class="line"><span class="comment">客户不用自己负责new对象，不用了解对象创建的详细过程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提供创建对象实例的接口函数不闭合，不能对修改关闭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">工厂方法 Factory Method</span></span><br><span class="line"><span class="comment">Factory基类，提供了一个纯虚函数（创建产品），定义派生类（具体产品的工厂）负责创建对应的</span></span><br><span class="line"><span class="comment">产品，可以做到不同的产品，在不同的工厂里面创建，能够对现有工厂，以及产品的修改关闭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实际上，很多产品是有关联关系的，属于一个产品簇，不应该放在不同的工厂里面去创建，这样</span></span><br><span class="line"><span class="comment">一是不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">抽象工厂 Abstract Factory</span></span><br><span class="line"><span class="comment">把有关联关系的，属于一个产品簇的所有产品创建的接口函数，放在一个抽象工厂里面AbstractFactory</span></span><br><span class="line"><span class="comment">，派生类（具体产品的工厂）应该负责创建该产品簇里面所有的产品</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">工厂模式：主要是封装了对象的创建</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系列产品1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name) :_name(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bmw</span> :</span> <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bmw</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取了一辆宝马汽车:&quot;</span> &lt;&lt; _name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> :</span> <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取了一辆奥迪汽车:&quot;</span> &lt;&lt; _name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CarType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	BMW,AUDI</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(CarType ct)</span> <span class="comment">// 不符合软件设计 “开-闭”</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (ct)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> BMW:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line">		<span class="keyword">case</span> AUDI:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cerr &lt;&lt; <span class="string">&quot;传入工厂的参数不正确:&quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;SimpleFactory&gt; <span class="title">factory</span><span class="params">(<span class="keyword">new</span> SimpleFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(factory-&gt;createCar(BMW))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(factory-&gt;createCar(AUDI))</span></span>;</span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul>
<li><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型<strong>经常变化</strong>。</p>
</li>
<li><p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li>
<li><p><strong>工厂定义一个用于创建对象的接口，让子类决定实例化哪一个类。<code>Factory Method</code>使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。</strong></p>
<h3 id="过程推演"><a href="#过程推演" class="headerlink" title="过程推演"></a>过程推演</h3></li>
<li><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-16-59-29.png"></p>
</li>
<li><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-13-24.png"></p>
</li>
<li><p>virtual：一种延迟，延迟绑定到运行时<br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-18-31.png"></p>
</li>
<li><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-26-57.png"></p>
</li>
<li><p>C++语言本身没有提供多态new，但是我们通过virtual和指针，创造出了多态new</p>
</li>
<li><p>虽然之后还会在类外面new 具体的 factory，但是 MainForm里面，再也没有对具体Factory的依赖了。</p>
</li>
<li><p><strong>设计模式的松耦合设计，很多时候并不是把变化消灭，也即：并不是把依赖具体类的这个事情消灭掉，而是把它们转移到某个局部的地方。</strong></p>
<ul>
<li><strong>也就是，把“变化”这只猫关进笼子里，而不是让他在代码里跳来跳去</strong></li>
</ul>
</li>
</ul>
<h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><ul>
<li><p>抽象类和工厂基类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>具体类和具体工厂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>依赖代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;<span class="comment">//工厂基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(SplitterFactory*  factory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ISplitter * splitter=</span><br><span class="line">            factory-&gt;<span class="built_in">CreateSplitter</span>(); <span class="comment">//多态new</span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>为什么要有一个抽象ISplitter基类？因为需要这样一个抽象引用去接收实际的具体对象。</p>
</li>
<li><p>为什么要有一个抽象factory基类？因为需要依赖于抽象去动态绑定。</p>
</li>
<li><p>原本<br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-43-02.png"></p>
</li>
<li><p>工厂模式之后，不再依赖于具体类（<strong>变化）</strong>，而是依赖于抽象类（<strong>稳定）</strong><br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-42-00.png"></p>
</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-55-24.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Factory Method模式用于隔离类对象的使用者和具体类型之间的 耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。</li>
<li>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作<strong>延迟</strong>到子类（virtual函数），从而实现一种<strong>扩展（而非更改）</strong>的策略，较好地解决了这种紧耦合关系。</li>
<li>Factory Method模式解决“单个对象”的需求变化。缺点在于要 求创建方法/参数相同。</li>
</ul>
<h2 id="抽象工厂（家族工厂，这个工厂可以创造一家子相关操作）"><a href="#抽象工厂（家族工厂，这个工厂可以创造一家子相关操作）" class="headerlink" title="抽象工厂（家族工厂，这个工厂可以创造一家子相关操作）"></a>抽象工厂（家族工厂，这个工厂可以创造一家子相关操作）</h2><ul>
<li>工厂模式的基础上，将有关系的内容都放到一个工厂里，一起生产出来。<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3></li>
<li>在软件系统中，经常面临着“<strong>一系列相互依赖的对象</strong>”的创建工作；同时，由于需求的变化，往往<strong>存在更多系列对象的创建工作</strong>。（一系列：Oracle有一系列数据库访问操作，MySql有一系列数据库访问操作，其他数据库又有一系列数据库访问操作）</li>
<li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>提供一个接口，让该接口负责创建<strong>一系列“相关或者相互依赖的对象”</strong>，（如数据库访问的一系列关联操作），无需指定它们具体的类。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库访问有关的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnection</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommand</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReader</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  （创建数据库访问相关的）基类工厂（可创建一系列数据库访问，如SQL数据库访问，Oracle数据路访问）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//支持SQL Server</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlDBFactory</span>:</span><span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//支持Oracle的相关访问操作</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OracleConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OracleCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OracleDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  负责 创建Oracle数据库访问的一系列操作 的工厂</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OracleDBFactory</span>:</span><span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    <span class="comment">//  只需要一个基类工厂就可以。</span></span><br><span class="line">    IDBFactory* dbFactory;      <span class="comment">//  创建一系列操作的工厂（针对某一数据库的一系列访问操作）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection =</span><br><span class="line">            dbFactory-&gt;<span class="built_in">CreateDBConnection</span>();    <span class="comment">//  sql/oracle 工厂创建出 sql/oracle 连接操作 </span></span><br><span class="line">        connection-&gt;<span class="built_in">ConnectionString</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* command =</span><br><span class="line">            dbFactory-&gt;<span class="built_in">CreateDBCommand</span>();       <span class="comment">//  sql/oracle 工厂创建出 sql/oracle 命令操作</span></span><br><span class="line">        command-&gt;<span class="built_in">CommandText</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        command-&gt;<span class="built_in">SetConnection</span>(connection);     <span class="comment">//  体现出connection与command的关联性</span></span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = command-&gt;<span class="built_in">ExecuteReader</span>(); <span class="comment">//  command与reader的关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="结构总结"><a href="#结构总结" class="headerlink" title="结构总结"></a>结构总结</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-18-47-16.png"></p>
<h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul>
<li>如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。</li>
<li><strong>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖</strong>。</li>
<li>Abstract Factory模式主要在于<strong>应对“新系列”的需求</strong>变动。其缺点在于<strong>难以应对“新对象”的需求变动</strong><ul>
<li>也就是 工厂基类（IDBFactory）不能够增添操作（纯虚函数。）。因为我们假定他是稳定的，也就是这个模式就是在利用那个基类的稳定性，如果变了，那么我们该采用其他模式。</li>
</ul>
</li>
</ul>
<h3 id="工厂方法到抽象工厂"><a href="#工厂方法到抽象工厂" class="headerlink" title="工厂方法到抽象工厂"></a>工厂方法到抽象工厂</h3><ul>
<li>工厂模式是抽象工厂的一种特殊情况！（也即，工厂基类里的方法只有一个而非多个，只负责创建一个对象而非一系列相互依赖的对象）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库访问有关的基类 以及相应基类工厂</span></span><br><span class="line"><span class="comment">//  如果不用抽象工厂，那么，三个相关基类，三个相关工厂。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnection</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnectionFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommand</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommandFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReader</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReaderFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持SQL Server</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnectionFactory</span>:</span><span class="keyword">public</span> IDBConnectionFactory&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommandFactory</span>:</span><span class="keyword">public</span> IDBCommandFactory&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReaderFactory</span>:</span><span class="keyword">public</span> IDataReaderFactory&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持Oracle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleFactory</span>:</span><span class="keyword">public</span> OralceFactory&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;&#125;;</span><br><span class="line">OracleCommand工厂</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;&#125;;</span><br><span class="line">OracleDataReader工厂</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    <span class="comment">//  三个基类指针 指向 工厂</span></span><br><span class="line">    IDBConnectionFactory* dbConnectionFactory;</span><br><span class="line">    IDBCommandFactory* dbCommandFactory;</span><br><span class="line">    IDataReaderFactory* dataReaderFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  可以看出这三个工厂所要创作的三个对象相互依赖相互关联。是一系列一系列的操作。因此，可以把他们放入同一工厂。由同一工厂生产。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection =</span><br><span class="line">            dbConnectionFactory-&gt;<span class="built_in">CreateDBConnection</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">ConnectionString</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* command =</span><br><span class="line">            dbCommandFactory-&gt;<span class="built_in">CreateDBCommand</span>();</span><br><span class="line">        command-&gt;<span class="built_in">CommandText</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        command-&gt;<span class="built_in">SetConnection</span>(connection); <span class="comment">//关联性</span></span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = command-&gt;<span class="built_in">ExecuteReader</span>(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>())&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最终代码-施磊"><a href="#最终代码-施磊" class="headerlink" title="最终代码(施磊)"></a>最终代码(施磊)</h3><ul>
<li>子类必须实现父类的纯虚函数，不然无法new<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系列产品1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name) :_name(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Car</span>()&#123;&#125;        <span class="comment">//  基类的虚构函数写成虚的！</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bmw</span> :</span> <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bmw</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取了一辆宝马汽车:&quot;</span> &lt;&lt; _name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> :</span> <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取了一辆奥迪汽车:&quot;</span> &lt;&lt; _name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系列产品2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BmwLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;BMW light!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudiLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Audi light!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法 =&gt; 抽象工厂(对有一组关联关系的产品簇提供产品对象的统一创建)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>; <span class="comment">// 工厂方法 创建汽车</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Light* <span class="title">createCarLight</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 工厂方法 创建汽车关联的产品，车灯</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 宝马工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> :</span> <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BmwLight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 奥迪工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> :</span> <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudiLight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 现在考虑产品  一类产品（有关联关系的系列产品）</span></span><br><span class="line">	<span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A8&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Light&gt; <span class="title">l1</span><span class="params">(bmwfty-&gt;createCarLight())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Light&gt; <span class="title">l2</span><span class="params">(audifty-&gt;createCarLight())</span></span>;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	l1-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	l2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>讲给h<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">工厂模式：简要来说就是：一个抽象类（字母），以及诸多具体类（a,b,c,d）。+ 一个工厂基类，以及诸多具体工厂类（对应生产a,b,c,d）。当需要a对象时，在相应代码段处，通过工厂基类指针，使用a工厂来创建a对象，用抽象基类（字母类型来接收）</span><br><span class="line">宗旨：避免依赖具体的类（尽量依赖抽象类），将本要使用具体类的代码段和具体类分离开（通过使用抽象类和工厂）。</span><br><span class="line">情景：假设现在要在一个类的成员函数FUNC（）内使用对象a/b/c/d。但是，由于需求的变化，我们所要创建的对象的具体类型经常变化，所以，我们要找一个机制来避开常规的<span class="keyword">new</span>语句。</span><br><span class="line">因为，如果正常的<span class="keyword">new</span>，就意味着我们必须在这个函数的代码段内明确说出要创建的对象的类型，那么就会造成紧耦合（如 A *p = <span class="keyword">new</span> <span class="built_in">A</span>()，指明了=号左侧的A和右侧的A类型）。</span><br><span class="line">所以，对于a,b,c,d类，我们需要有一个他们的抽象基类：字母类，来接收具体的a、b、c对象。（因为抽象，所以稳定）。</span><br><span class="line">如 字母 *p = <span class="keyword">new</span> <span class="built_in">A</span>()。那么，=号的左边就解决了。使用抽象类来接收具体的对象。</span><br><span class="line">但是，在=号右边。我们还是要指明具体的A类型，也就是说还是依赖一个具体的类。</span><br><span class="line">所以，为了不依赖它，我们得把<span class="keyword">new</span> <span class="built_in">A</span>()这个语句从本函数拿出来。</span><br><span class="line">所以，我们新建一个类，把这个<span class="keyword">new</span>的任务交给那个新类去处理，那个新类就叫做a工厂类，称为AFactory，内有create方法。</span><br><span class="line">那么，现在的语句就变成 字母* p = pointer_to_AFactory-&gt;<span class="built_in">create</span>();	</span><br><span class="line">但是，此时我们还是需要指出，这个工厂的名字叫做AFactory。那么对于b，c，d来说，我们还是需要指出使用BFactory，CFactory...这还是需要依赖具体的类，所以还需要继续改进。</span><br><span class="line">所以，我们设置一个抽象基类 BaseFactory 里面有纯虚函数 <span class="built_in">create</span>()，BaseFactory的指针/引用，可以用来接收A/B/CFactory。</span><br><span class="line">那么，这条语句就变成 字母 *p = pointer_to_BaseFactory -&gt; <span class="built_in">create</span>();</span><br><span class="line">create（）函数的调用利用了多态的机制，将本应该编译时绑定的函数延迟到运行时进行绑定。</span><br><span class="line">（这也就是通过面向对象的手法，将所要创建的具体对象延迟到子类中去进行。（延迟到子类中的C++中的<span class="keyword">virtual</span>函数，Java中子类实现父类的函数），从而实现一种扩展（而非更改）的策略，较好地解决了原本的紧耦合关系）</span><br><span class="line">这个pointer_to_BaseFactory，就是调用本语句所在的函数时传入的参数。这样，在FUNC（）内，就不回依赖于具体的类（易变化），只依赖于抽象类（稳定）。</span><br><span class="line">将对具体类的依赖从本成员函数内转移到其他代码处。</span><br><span class="line"></span><br><span class="line">之前讲得工厂模式 是 一个工厂类里只负责一个对象的创建。</span><br><span class="line">抽象工厂，就是一个工厂类负责多个对象的创建。其中，这多个对象有相互依赖、相互影响的关系。</span><br><span class="line">如，我们要做访问数据库，对于每种数据库都会有三个操作，connection连接，read读取以及command发出命令。而connection又会影响read和command。</span><br><span class="line">但是，每种数据库之间的具体操作又不同，如Oracle和mySQL之间的connection，read，command方式不会相同。</span><br><span class="line">所以，我们可以看出，在要访问数据库时，我们需要生成负责connection的对象，负责read的对象和负责command的对象。</span><br><span class="line">而这些对象之间又相互依赖相互影响。也即，我们实际需要connection、read、command对象是一系列一系列的。（也可以说是一组一组的）</span><br><span class="line">所以，对于访问mySQL数据库，我们需要一个mySQLFactory&#123;&#125;，里面负责生成mySQL数据库系列的connection、read、command对象。</span><br><span class="line">对于Oralce数据库，同理，需要一个OracleFactory&#123;&#125;，里面负责生成Oracle数据库系列的connection、read、command对象。</span><br><span class="line"></span><br><span class="line">剩下的还是和工厂模式一样，一个数据库抽象基类，一个工厂的抽象基类，就是抽象工厂类负责一系列相关对象</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><ul>
<li>特殊的类，必须保证他们在系统中只存在一个实例，才能保证他们的逻辑正确性、以及良好的效率。</li>
</ul>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li>保证一个类仅有一个实例，并提供一个该实例的全局访问点</li>
</ul>
<h3 id="懒汉-推演"><a href="#懒汉-推演" class="headerlink" title="懒汉 推演"></a>懒汉 推演</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; other);</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;   </span><br><span class="line"><span class="comment">//  注意必须是静态！ 定义一个唯一的类的实例对象（不然就会依赖于对象）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  必须是静态！不然要调用非静态方法需要通过对象调用，但是对象还没有。</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>单线程用这个即可。线程不安全<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>多线程最初：线程安全但性能差<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;          <span class="comment">//  当对象已经创建出来、多个线程都只需要读时，会付出不必要的代价来等待锁</span></span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;    </span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>多线程改进：<strong>双检查锁</strong>。看似正确，很有可能出<strong>reorder问题</strong>。<strong>不能用！！</strong><ul>
<li><strong>锁前检查</strong>：避免当两个线程都是读取操作时，发生不必要的上锁解锁以及等待来提高效率</li>
<li><strong>锁后检查</strong>：避免重复new对象。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-22-13-36-54.png"></li>
</ul>
</li>
<li><strong>漏洞：</strong><ul>
<li>正常应该是 <ul>
<li>先malloc 再 构造 再返回地址给 m_instance，</li>
</ul>
</li>
<li>但是，编译器出于优化，可能会发生这样：<ul>
<li>先malloc，然后返回地址，之后再构造</li>
</ul>
</li>
<li>就会造成，假设有2个线程，一个进入 <code>m_instance = new Singleton</code>。但是编译器优化，返回了地址却没调用构造函数，就会出<strong>现<code>m_instance!=nullptr</code> 但是 <code>m_instance</code>指向的对象还没被构造</strong>，而另一个线程在锁前检查发现不是<code>nullptr</code>，就直接返回<code>m_instance</code>，也即<strong>返回了一个不能使用的对象</strong></li>
</ul>
</li>
<li><strong>volatile</strong><ul>
<li>volatile（vaoleitou） 易变的；无定性的；不稳定的</li>
<li>volatile是一个特征修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。volatile是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。也即，编译器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。编译器会逐一地进行编译并产生相应的机器代码。</li>
<li><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">volatile</a></li>
</ul>
</li>
</ul>
<ul>
<li><p>volatile在多线程的作用。也是因为这个让编译器从内存读取变量的值而非寄存器/缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile作用在变量上。不把变量存储在寄存器中，每次使用该变量都从内存中读取。这样做的目的是告诉编译器该变量的值可能会随时改变，因此需要从内存中而非寄存器中读取以确保变量的值准确。</span><br><span class="line">在一些多线程的程序里一些全局变量可能会被其他线程修改，这时候要用volatile确保这个变量的值正确。(但是光用volatile也不够，但这就是另一个topic了)</span><br></pre></td></tr></table></figure></li>
<li><p>我总结：volatile的作用就是防止编译器对指令进行优化</p>
<ul>
<li>从而防止编译器从寄存器而非内存中读值（避免多线程情况下发生错误）</li>
<li>从而防止单例模式中new对象时改变指令顺序返回空对象</li>
</ul>
</li>
<li><p><strong>好博客：<a href="https://cloud.tencent.com/developer/article/1177406">博客</a></strong></p>
</li>
</ul>
<h3 id="懒汉最终：懒汉模式线程安全-有效率-无reorder"><a href="#懒汉最终：懒汉模式线程安全-有效率-无reorder" class="headerlink" title="懒汉最终：懒汉模式线程安全+有效率+无reorder"></a><strong>懒汉最终：懒汉模式线程安全+有效率+无reorder</strong></h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getSingleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>) <span class="comment">//  提高效率</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)     <span class="comment">//  防止重复new</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_instance =  <span class="keyword">new</span> <span class="built_in">Singleton</span>();  <span class="comment">// 访问volatile变量 汇编指令顺序不变。保证先malloc，然后构造，最后返回。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton * <span class="keyword">volatile</span> m_instance;</span><br><span class="line">    <span class="comment">//  volatile：使得编译器在编译访问m_instance代码时，对指令（的顺序）就不再优化。也即m_instance = new Singleton()的汇编顺序不会改变</span></span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//  构造函数、拷贝构造、复制重载私有化或删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* <span class="keyword">volatile</span> Singleton:: m_instance = <span class="literal">nullptr</span>;  <span class="comment">//  static变量需要在类外初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="2（通过static局部变量）"><a href="#2（通过static局部变量）" class="headerlink" title="2（通过static局部变量）"></a>2（通过static局部变量）</h4><ul>
<li>对于static静态局部变量的初始化，编译器会自动对它的初始化进行加锁lock和解锁unlock控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量，因此如下的懒汉单例模式是线程安全的单例模式</li>
<li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88544524?spm=1001.2014.3001.5502">shilei</a></li>
<li>static instance：C++11在static局部变量初始化时自动进行加锁和解锁控制</li>
<li>static 函数：为了在没有对象时就可调用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  懒汉式单例模式另一种写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getSingleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//  static局部变量</span></span><br><span class="line">        <span class="comment">//  static：生命周期为全局</span></span><br><span class="line">        <span class="comment">//  static + 局部 ：汇编层面已经自动添加线程互斥指令</span></span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span>=(Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-23-20-03-29.png"></p>
</blockquote>
</li>
</ul>
<h3 id="饿汉-线程安全"><a href="#饿汉-线程安全" class="headerlink" title="饿汉 线程安全"></a>饿汉 线程安全</h3><ul>
<li>饿汉单例模式中，单例对象定义成了一个static静态对象，<strong>它是在程序启动时，main函数运行之前就初始化好的，因此不存在线程安全问题</strong>，可以放心的在多线程环境中使用。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getSingleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton:: m_instance;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><ol>
<li>构造函数私有化</li>
</ol>
</li>
<li>2/3. 定义一个唯一的类的实例对象</li>
<li>3/2. 获取类的唯一实例对象的接口方法</li>
</ul>
<p>可重入：可以在多线程下运行，且不会发生竞态条件。</p>
<h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h2><p>一个小模式，不常用，是factory的变体</p>
<ul>
<li>为了获取相同状态的对象。</li>
<li>当对象的创建复杂繁琐时。</li>
</ul>
<h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-04-01-20-46-38.png"></p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-04-01-20-47-05.png"></p>
<h3 id="要点总结-1"><a href="#要点总结-1" class="headerlink" title="要点总结"></a>要点总结</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-04-01-20-44-28.png"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">//通过克隆自己来创建对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  具体类</span></span><br><span class="line"><span class="comment">//  调用父类克隆函数</span></span><br><span class="line"><span class="comment">//  每回调用clone就是返回了一个clone欸到对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>(*<span class="keyword">this</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  用户代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    ISplitter*  prototype;<span class="comment">//原型对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(ISplitter*  prototype)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prototype=prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ISplitter * splitter=</span><br><span class="line">            prototype-&gt;<span class="built_in">clone</span>(); <span class="comment">//克隆原型</span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>轮子-nginx内存池移植代码</title>
    <url>/2022/04/30/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<p>nginx 内存池移植</p>
<span id="more"></span>

<h1 id="OOP移植内存池"><a href="#OOP移植内存池" class="headerlink" title="OOP移植内存池"></a>OOP移植内存池</h1><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="/2022/04/30/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%A7%BB%E6%A4%8D/2022-05-01-09-17-05.png"></p>
<h2 id="ngx-mem-pool-h"><a href="#ngx-mem-pool-h" class="headerlink" title="ngx_mem_pool.h"></a>ngx_mem_pool.h</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> nginx_memory_pool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nginx_memory_pool</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> u_char = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ngx_uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  小内存池（Block）头信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char* last;                           <span class="comment">//  可用内存起始</span></span><br><span class="line">    u_char* end;                            <span class="comment">//  内存末尾</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* next;                       <span class="comment">//  小内存Block链表</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;           <span class="comment">//  分配内存是否成功</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  大内存池（Block）头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* next;     <span class="comment">//   大内存Block的头信息链表</span></span><br><span class="line">    <span class="keyword">void</span>* alloc;                <span class="comment">//   指向申请的大内存Block</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span>* data)</span></span>;     <span class="comment">//  回调函数；负责清理外部资源</span></span><br><span class="line"><span class="comment">//  外部资源的头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_t</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;      <span class="comment">//  处理外部资源的回调函数</span></span><br><span class="line">    <span class="keyword">void</span>* data;                         <span class="comment">//  传给handler的参数</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* next;           <span class="comment">//  外部资源头信息链表。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  管理整个内存池的头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;                <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;              <span class="comment">//  大块内存和小块内存的分界线。p-&gt;max：一个小块Block块内最多能分配多大的内存。其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095              </span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* current;                    <span class="comment">//  指向第一块提供小块内存分配的小块内存Block地址</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;                <span class="comment">//  大内存Block头信息的链表入口</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* cleanup;            <span class="comment">//  外部资源的头信息链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  32位 4   64位 8</span></span><br><span class="line"><span class="comment">//  小块内存考虑字节对齐时的单位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_ALIGNMENT = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);    <span class="comment">/* platform word */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  默认一个页面大小：4KB</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ngx_pagesize = <span class="number">4096</span>;  <span class="comment">//  1024B = 1KB</span></span><br><span class="line"><span class="comment">//  ngx小块内存block里可分配的最大空间。（也即不能超过一个页）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MAX_ALLOC_FROM_POOL = ngx_pagesize - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  默认创建的内存池大小为16K</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_DEFAULT_POOL_SIZE = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//  对齐为16的整数倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_POOL_ALIGNMENT = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将d上调至a的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align(d,a) ( ((d)+(a-1)) &amp; ~(a-1) )</span></span><br><span class="line"><span class="comment">//  把指针p调整到a的临近倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                   \</span></span><br><span class="line"><span class="meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memset(buf, c, n)     (void) memset(buf, c, n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ngx小块内存池最小的size调整成 NGX_POOL_ALIGNMENT 的倍数</span></span><br><span class="line"><span class="comment">//  保证至少能有一个ngx_pool_t头信息的大小 如 sizeof(ngx_pool_t)【15】 + 2*8 = 31    调整至32</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MIN_POOL_SIZE = <span class="built_in">ngx_align</span>((<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>)), NGX_POOL_ALIGNMENT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* OOP 移植nginx内存池</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ngx_mem_pool</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  构造函数，创建内存池。</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span>(<span class="keyword">size_t</span> size = NGX_DEFAULT_POOL_SIZE);</span><br><span class="line">    <span class="comment">//  析构函数，释放内存池</span></span><br><span class="line">    ~<span class="built_in">ngx_mem_pool</span>();</span><br><span class="line">    <span class="comment">//  考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  不考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_pnalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  调用ngx_palloc，并初始化为0.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_pcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  释放大块内存block。ngx不提供释放小块内存的接口。原因见博客</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_pfree</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</span><br><span class="line">    <span class="comment">//  内存重置函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">//  添加回调清理操作函数</span></span><br><span class="line">    <span class="function"><span class="keyword">ngx_pool_cleanup_t</span>* <span class="title">ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  指向nginx内存池的入口指针，一个内存池只有一个pool。即第一个创建的内存block里的ngx_pool_t。pool_的指向不会改变，始终是第一个，因为只有第一个有。会发生改变的是它指向的current，next之类的东西。</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* pool_;                      </span><br><span class="line">    <span class="comment">//  尝试从内存池中拿出size大小内存。内存池不够则从操作系统开辟。align=1意味着需要内存对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span>;</span><br><span class="line">    <span class="comment">//  从操作系统开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用ngx_memalign。在unix平台下ngx_memalign就是ngx_alloc</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  从操作系统开辟大块内存，挂载到某个已有的大块头信息下。（或再从内存池申请一块用作大内存block头信息）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;           </span><br><span class="line">    <span class="comment">//  销毁内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span><span class="params">()</span></span>;           </span><br><span class="line">    <span class="comment">//  创建size大小的内存池  （每个小内存block的大小均为size）</span></span><br><span class="line">    <span class="function"><span class="keyword">ngx_pool_t</span>* <span class="title">ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//    void* ngx_alloc(size_t size);  //  从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="ngx-mem-pool-cpp"><a href="#ngx-mem-pool-cpp" class="headerlink" title="ngx_mem_pool.cpp"></a>ngx_mem_pool.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;ngx_mem_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//  创建size大小的内存池  （每个小内存block的大小均为size）</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span>* <span class="title">ngx_mem_pool::ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pool_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_t</span>*&gt;(<span class="built_in">malloc</span>(size));</span><br><span class="line">    <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;d.last = (u_char*)pool_ + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    pool_-&gt;d.end = (u_char*)pool_ + size;</span><br><span class="line">    pool_-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    pool_-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    pool_-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;current = pool_;</span><br><span class="line">    pool_-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">    pool_-&gt;cleanup = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pool_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  考虑字节对齐，从内存池申请size大小的内存。下层有可能从操统开辟新内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool_-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  尝试从内存池中拿出size大小内存。内存池不够则从操作系统开辟。align=1意味着需要内存对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc_small</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char* m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p;</span><br><span class="line">    p = pool_-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align) &#123;</span><br><span class="line">            m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT));  <span class="comment">//  ??</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>)(p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操作系统malloc开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用ngx_memalign。在unix平台下ngx_memalign就是ngx_alloc。（就是对malloc的浅封装）</span></span><br><span class="line"><span class="keyword">void</span>* ngx_mem_pool :: <span class="built_in">ngx_palloc_block</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char* m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p, * new_m;</span><br><span class="line"></span><br><span class="line">    psize = (<span class="keyword">size_t</span>)(pool_-&gt;d.end - (u_char*)pool_);</span><br><span class="line"></span><br><span class="line">    m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">malloc</span>(psize));   <span class="comment">//  ngx_alloc底层就是malloc</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new_m = (<span class="keyword">ngx_pool_t</span>*)m;</span><br><span class="line"></span><br><span class="line">    new_m-&gt;d.end = m + psize;</span><br><span class="line">    new_m-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    new_m-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT));</span><br><span class="line">    new_m-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool_-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool_-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = new_m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操作系统malloc开辟大块内存，挂载到某个已有的大块头信息下。（或再从内存池申请一块用作大内存block头信息）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc_large</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (large = pool_-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_large_t</span>*&gt;(<span class="built_in">ngx_palloc_small</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool_-&gt;large;</span><br><span class="line">    pool_-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</span></span><br><span class="line"><span class="comment">// void* ngx_mem_pool::ngx_alloc(size_t size)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     void* p = malloc(size);</span></span><br><span class="line"><span class="comment">//     return p;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  释放大块内存block。ngx不提供释放小块内存的接口。原因见博客</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_pfree</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* l;</span><br><span class="line">    <span class="keyword">for</span> (l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_pnalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool_-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用ngx_palloc，并初始化为0.</span></span><br><span class="line"><span class="keyword">void</span>* ngx_mem_pool :: <span class="built_in">ngx_pcalloc</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  从内存池申请内存</span></span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">ngx_palloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;    <span class="comment">//  清0操作</span></span><br><span class="line">        <span class="built_in">ngx_memzero</span>(p, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  内存重置函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_reset_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  自己加的：释放外部资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">ngx_pool_cleanup_t</span>* c = pool_-&gt;cleanup; c; c = c-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler&amp;&amp;c-&gt;data) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">            c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line">            c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">ngx_pool_large_t</span>* l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重置小块内存</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p = pool_;</span><br><span class="line">    p-&gt;d.last = (u_char*)p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = p-&gt;d.next; p; p = p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;d.last = (u_char*)p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for (p = pool_; p; p = p-&gt;d.next) &#123;</span></span><br><span class="line">    <span class="comment">//    p-&gt;d.last = (u_char*)p + sizeof(ngx_pool_t);</span></span><br><span class="line">    <span class="comment">//    p-&gt;d.failed = 0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//  重置pool_成员</span></span><br><span class="line">    pool_-&gt;current = pool_;</span><br><span class="line">    pool_-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  销毁内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_destroy_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p, * n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放外部资源</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool_-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放小块内村</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool_, n = pool_-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  申请外部资源信息头、添加回调清理操作函数</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_cleanup_t</span>* <span class="title">ngx_mem_pool::ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* c;</span><br><span class="line"></span><br><span class="line">    c = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_cleanup_t</span>*&gt;(<span class="built_in">ngx_palloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line">    c-&gt;next = pool_-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ngx_mem_pool::<span class="built_in">ngx_mem_pool</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    pool_ = <span class="built_in">ngx_create_pool</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_mem_pool::~<span class="built_in">ngx_mem_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~ngx_mem_pool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">ngx_destroy_pool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="test-mem-pool-cpp"><a href="#test-mem-pool-cpp" class="headerlink" title="test_mem_pool.cpp"></a>test_mem_pool.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;ngx_mem_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//  多个指针</span></span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    FILE* pfile;</span><br><span class="line">    <span class="keyword">char</span>* ptr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">yData</span> <span class="title">yData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler\n&quot;</span>);</span><br><span class="line">    stData* q = (stData*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(q-&gt;pfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler_02</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* q = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler_02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. ngx_create_pool 造内存池</span></span><br><span class="line">        <span class="comment">//  第一块内存Block。里面有完整的ngx_pool_t</span></span><br><span class="line">        <span class="comment">// ngx_pool_t::max = min(512 - sizeof(ngx_pool_t) , 4095)     </span></span><br><span class="line">        <span class="function">ngx_mem_pool <span class="title">mem_pool</span><span class="params">(<span class="number">512</span>)</span></span>;</span><br><span class="line">    <span class="comment">//  2. 小块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请小块内存</span></span><br><span class="line">        stData* p1 = <span class="keyword">static_cast</span>&lt;stData*&gt;(mem_pool.<span class="built_in">ngx_palloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(yData))); <span class="comment">// 从小块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc %d bytes fail\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(yData));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  小块内存保存的指针管理的外部资源</span></span><br><span class="line">        p1-&gt;ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        p1-&gt;pfile = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        p1-&gt;ptr2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr2, <span class="string">&quot;goodbye world&quot;</span>);</span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span>* c1 = mem_pool.<span class="built_in">ngx_pool_cleanup_add</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(yData));     <span class="comment">//  开辟内存，用于handler传参</span></span><br><span class="line">        c1-&gt;handler = self_handler;</span><br><span class="line">        <span class="built_in">memcpy</span>(c1-&gt;data, p1, <span class="built_in"><span class="keyword">sizeof</span></span>(yData));                                      <span class="comment">//  用户只负责拷贝！！将外部资源拷贝一下到c1-&gt;data。将p1指针指向的内容逐字节拷贝到c-&gt;data指向的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 大块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请大块内存</span></span><br><span class="line">        yData* p2 = <span class="keyword">static_cast</span>&lt;yData*&gt;(mem_pool.<span class="built_in">ngx_palloc</span>(<span class="number">512</span>)); <span class="comment">// 从大块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 512 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  外部资源</span></span><br><span class="line">        p2-&gt;ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p2-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span>* c2 = mem_pool.<span class="built_in">ngx_pool_cleanup_add</span>(<span class="number">0</span>);                   <span class="comment">//  不开辟内存，直接让c-&gt;data指向要释放的内存</span></span><br><span class="line">        c2-&gt;handler = self_handler_02;</span><br><span class="line">        c2-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  重置内存池</span></span><br><span class="line">        <span class="comment">//  mem_pool.ngx_reset_pool();</span></span><br><span class="line">        <span class="comment">//  std::cout &lt;&lt; &quot;reset over&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  释放内存池</span></span><br><span class="line">        <span class="comment">//   ~mem_pool() 调用mem_pool.ngx_destroy_pool(); // 1.调用所有的预置的清理函数 2.释放大块内存 3.释放小块内存池所有内存</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul>
<li>环境 ubuntu / VS均可<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/my_nginx$ ./test_mem_pool.out </span><br><span class="line">~ngx_mem_pool</span><br><span class="line">self_handler_02</span><br><span class="line">free ptr mem!</span><br><span class="line">self_handler</span><br><span class="line">free ptr mem!</span><br><span class="line">free ptr mem!</span><br><span class="line">close file!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><ul>
<li>出现<code>heap corruption detected</code><ul>
<li>测试代码问题：添加外部资源时的大小不对。已解决</li>
</ul>
</li>
</ul>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2>]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>轮子-sgi_stl二级空间配置器移植代码</title>
    <url>/2022/04/30/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>轮子-sgi_stl二级空间配置器移植</p>
<span id="more"></span>

<h1 id="sgi-stl-内存池"><a href="#sgi-stl-内存池" class="headerlink" title="sgi_stl 内存池"></a>sgi_stl 内存池</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><ul>
<li><code>template&lt;typename T&gt; class my_allocator&#123;&#125;</code><br><img src="/2022/04/30/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-20-40-33.png"><br><img src="/2022/04/30/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-20-41-44.png"></li>
</ul>
<h2 id="OOP封装"><a href="#OOP封装" class="headerlink" title="OOP封装"></a>OOP封装</h2><ul>
<li>对外接口<ul>
<li>allocate、deallocate、reallocate、construct、destroy<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 移植SGI STL二级空间配置器源码</span></span><br><span class="line"><span class="comment">* 不同于nginx内存池，二级空间配置器中使用到的内存池需要注意多线程问题</span></span><br><span class="line"><span class="comment">* nginx内存池，可以一个线程创建一个内存池</span></span><br><span class="line"><span class="comment">* 而二级空间配置器，是用来给容器使用的，如vector对象。而一个vector对象很有可能在多个线程并发使用</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 移植成功！一个线程安全的二级空间配置器 my_allocator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//  一级空间配置器 将对象构造和内存开辟分开</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first_level_my_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		T* p = <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T)*size);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; _val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (p) <span class="built_in">T</span>(_val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; rval)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (p) <span class="built_in">T</span>(std::<span class="built_in">move</span>(rval));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="comment">//  预制的回调函数 _S_oom_malloc -&gt; __malloc_alloc_oom_handler</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//  尝试分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);	<span class="comment">//  尝试释放nbytes内存，返回给result</span></span><br><span class="line">		<span class="keyword">return</span> __result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">free</span>(__p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新分配new_sz大小内存 </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">		<span class="keyword">return</span> __result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//  用户通过这个接口来预制自己的回调函数。用以释放内存来解决内存不足的问题</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">void</span></span> (*__old)() = __malloc_alloc_oom_handler;</span><br><span class="line">		__malloc_alloc_oom_handler = __f;</span><br><span class="line">		<span class="keyword">return</span>(__old);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  my_allocator中用到的__malloc_alloc_template中的两个函数和一个成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		__my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) &#123; <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); &#125;</span><br><span class="line">		(*__my_malloc_handler)();</span><br><span class="line">		__result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">		<span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		__my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) &#123; <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); &#125;</span><br><span class="line">		(*__my_malloc_handler)();</span><br><span class="line">		__result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">		<span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*__malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">using</span> malloc_alloc = __malloc_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  二级空间配置器 对外接口为allocate、deallocate、reallocate、construct、destroy</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> _Newfirst = T;</span><br><span class="line">	<span class="keyword">using</span> _From_primary = my_allocator;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">(<span class="keyword">const</span> my_allocator&amp;)</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Other</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">(<span class="keyword">const</span> my_allocator&lt;_Other&gt;&amp;)</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  开辟内存</span></span><br><span class="line">	<span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新分配内存。并将原先的内存归还给操作系统。并且不要再使用p的原指向地址</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  构建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* __p, <span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (__p) <span class="built_in">T</span>(val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* __p, T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (__p) <span class="built_in">T</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* __p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		__p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">	<span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _ALIGN = <span class="number">8</span> &#125;;								<span class="comment">//  自由链表从8bytes开始，以8bytes为对齐方式，一直扩充到128Bytes</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _MAX_BYTES = <span class="number">128</span> &#125;;							<span class="comment">//  最大块大小   &gt;128就不会放到内存池里了，也即不会用二级空间配置器。会用一级空间配置器</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _NFREELISTS = <span class="number">16</span> &#125;;  						<span class="comment">//  自由链表成员个数  _MAX_BYTES/_ALIGN</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  将byte上调至8的倍数</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  计算出bytes大小的chunk应该挂载到自由链表free-list的哪个成员下</span></span><br><span class="line">	<span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">		<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  开辟内存池，挂载到freelist成员下，返回请求的内存块。</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">	<span class="comment">//  从还没形成链表的原始内存中取内存分配给自由链表成员，去形成链表。如果原始空闲内存不够了，则再开辟</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  每个chunk块的信息。_M_free_list_link指向下一个chunk块</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">		<span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  基于free-list的内存池，需要考虑线程安全</span></span><br><span class="line">	<span class="keyword">static</span> _Obj* <span class="keyword">volatile</span> _S_free_list[_NFREELISTS];	<span class="comment">//  防止被线程缓存</span></span><br><span class="line">	<span class="keyword">static</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  static：类内声明、类外定义。</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;         <span class="comment">//   空闲free内存的起始start位置 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;           <span class="comment">//   空闲free内存的结束end位置 ) </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;         <span class="comment">//   总共malloc过的内存大小（因为malloc是从堆heap上请求的，所以叫heapsize）</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  static 类内声明，类外定义/初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::mutex my_allocator&lt;T&gt;::mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> my_allocator&lt;T&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> my_allocator&lt;T&gt;::_Obj* <span class="keyword">volatile</span></span><br><span class="line">my_allocator&lt;T&gt; ::_S_free_list[my_allocator&lt;T&gt;::_NFREELISTS] </span><br><span class="line">= &#123; <span class="literal">nullptr</span>,<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* my_allocator&lt;T&gt;::<span class="built_in">allocate</span>(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	__n = __n * <span class="built_in"><span class="keyword">sizeof</span></span>(T);		<span class="comment">//  因为vector容器传来的是元素个数</span></span><br><span class="line">	<span class="comment">//  std::cout &lt;&lt; &quot;user allocate &quot; &lt;&lt; __n &lt;&lt; std::endl;</span></span><br><span class="line">	<span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES) &#123;</span><br><span class="line">		__ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		_Obj* <span class="keyword">volatile</span>* __my_free_list</span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);</span><br><span class="line">		<span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">		<span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">		<span class="comment">// unwinding.</span></span><br><span class="line">		<span class="comment">//  _S_free_list 是所有线程共享的。加锁实现线程安全</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">		_Obj* __result = *__my_free_list;</span><br><span class="line">		<span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">			__ret = _S_refill(_S_round_up(__n));</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			*__my_free_list = __result-&gt;_M_free_list_link;</span><br><span class="line">			__ret = __result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T*&gt;(__ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* my_allocator&lt;T&gt;::_S_refill(<span class="keyword">size_t</span> __n)  <span class="comment">//  n是一个chunk块的大小</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  分配指定大小的内存池    __nobjs：chunk内存块数量 ；这里的 __n：每个chunk内存块大小。</span></span><br><span class="line">	<span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">	_Obj* <span class="keyword">volatile</span>* __my_free_list;</span><br><span class="line">	_Obj* __result;</span><br><span class="line">	_Obj* __current_obj;</span><br><span class="line">	_Obj* __next_obj;</span><br><span class="line">	<span class="keyword">int</span> __i;</span><br><span class="line">	<span class="comment">//  __nobjs：申请到的chunk块数量。当只申请到一个时，直接返回该内存块给上一级使用。无需建立各个chunk的连接关系，无需挂载到相应的freelist成员下。（因为只有一个）</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line"></span><br><span class="line">	__my_free_list = _S_free_list + _S_freelist_index(__n);     <span class="comment">//  根据内存块大小求出内存池应该在由freelist第几个成员管理（指向）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  静态链表：把每个chunk块通过Obj*里的指针连接起来</span></span><br><span class="line">	<span class="comment">//  每个内存块，有一部分的内存时union联合体Obj，里面有一个Obj*指针，负责连接每个空闲内存块。</span></span><br><span class="line">	<span class="comment">/* Build free list in chunk */</span></span><br><span class="line">	__result = (_Obj*)__chunk;</span><br><span class="line">	*__my_free_list = __next_obj = (_Obj*)(__chunk + __n);    <span class="comment">//  __n：一个内存块的大小（因为第一个内存块要分配出去）</span></span><br><span class="line">	<span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">		__current_obj = __next_obj;</span><br><span class="line">		__next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);          <span class="comment">//   维护内存块间的连接  char* 因此+__n是偏移n个bytes +n是为了一次跑一个chunk块</span></span><br><span class="line">		<span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;                               <span class="comment">//   空闲内存块数为0?</span></span><br><span class="line">			__current_obj-&gt;_M_free_list_link = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			__current_obj-&gt;_M_free_list_link = __next_obj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(__result);   <span class="comment">//  返回第一个内存块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size,<span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span>* __result;</span><br><span class="line">	<span class="keyword">size_t</span> __total_bytes = __size * __nobjs;            <span class="comment">//  本次总共需要请求的内存大小</span></span><br><span class="line">	<span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//  __default_alloc_template&lt;__threads, __inst&gt; 从开始到现在，请求的剩余空闲的的内存大小。不包括回收的。只是开辟的。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;                <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">		__result = _S_start_free;                       <span class="comment">//  __result 作为返回内存首地址</span></span><br><span class="line">		_S_start_free += __total_bytes;                 <span class="comment">//  移动_S_start_free</span></span><br><span class="line">		<span class="keyword">return</span>(__result);                               <span class="comment">//  [result , _S_start_free)  作为请求结果返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;                <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">		__nobjs = (<span class="keyword">int</span>)(__bytes_left / __size);</span><br><span class="line">		__total_bytes = __size * __nobjs;</span><br><span class="line">		__result = _S_start_free;</span><br><span class="line">		_S_start_free += __total_bytes;</span><br><span class="line">		<span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;                                            <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">		<span class="keyword">size_t</span> __bytes_to_get =                         <span class="comment">//  当剩余的空闲内存不够时，需要向操统malloc内存。这是计算出需要malloc内存的大小（至少malloc出来要求内存的(__total_bytes)两倍）</span></span><br><span class="line">			<span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">		<span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">		<span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">		<span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                         <span class="comment">//  </span></span><br><span class="line">			_Obj* <span class="keyword">volatile</span>* __my_free_list =</span><br><span class="line">				_S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">			((_Obj*)_S_start_free)-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">			*__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">		&#125;</span><br><span class="line">		_S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//  向操统malloc内存</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == _S_start_free) &#123;                       <span class="comment">//  malloc失败</span></span><br><span class="line">			<span class="keyword">size_t</span> __i;</span><br><span class="line">			_Obj* <span class="keyword">volatile</span>* __my_free_list;</span><br><span class="line">			_Obj* __p;</span><br><span class="line">			<span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">			<span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">			<span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="comment">//  从别的freelist成员管理的原始备用内存池中借用至少size大小的chunk块</span></span><br><span class="line">			<span class="keyword">for</span> (__i = __size;__i &lt;= (<span class="keyword">size_t</span>)_MAX_BYTES;__i += (<span class="keyword">size_t</span>)_ALIGN) </span><br><span class="line">			&#123;</span><br><span class="line">				__my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">				__p = *__my_free_list;</span><br><span class="line">				<span class="keyword">if</span> (<span class="literal">nullptr</span> != __p) &#123;</span><br><span class="line">					*__my_free_list = __p-&gt;_M_free_list_link;</span><br><span class="line">					_S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">					_S_end_free = _S_start_free + __i;</span><br><span class="line">					<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">					<span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">					<span class="comment">// right free list.</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//  都没有时，只能allcoate</span></span><br><span class="line">			_S_end_free = <span class="literal">nullptr</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">			_S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">			<span class="comment">// This should either throw an</span></span><br><span class="line">			<span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">			<span class="comment">// succeeded.</span></span><br><span class="line">		&#125;</span><br><span class="line">		_S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">		_S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">		<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* __p may not be 0 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> my_allocator&lt;T&gt;::<span class="built_in">deallocate</span>(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)		<span class="comment">//  因为vector容器传来的是字节大小</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES)	<span class="comment">//  n&gt;128 同一级空间配置器</span></span><br><span class="line">	&#123;</span><br><span class="line">		malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		_Obj* <span class="keyword">volatile</span>* __my_free_list</span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);  <span class="comment">//  找到相应freelist成员</span></span><br><span class="line">		_Obj* __q = (_Obj*)__p;       <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// acquire lock</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">		__q-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">		*__my_free_list = __q;</span><br><span class="line">		<span class="comment">// lock is released here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* my_allocator&lt;T&gt;::<span class="built_in">reallocate</span>(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line">	<span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  old new都&gt;128byets，那么用的就应当是和一级空间配置器一样的方法malloc</span></span><br><span class="line">	<span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>)_MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>)_MAX_BYTES) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  如果即将分配的chunk块大小一致，那么不必，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="keyword">return</span>(__p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新开辟new_size大小内存，并拷贝数据到新开辟的内存里</span></span><br><span class="line">	__result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">	__copy_sz = __new_sz &gt; __old_sz ? __old_sz : __new_sz;</span><br><span class="line">	<span class="built_in">memcpy</span>(__result, __p, __copy_sz); <span class="comment">//  拷贝数据</span></span><br><span class="line">	<span class="built_in">deallocate</span>(__p, __old_sz);  <span class="comment">//  释放</span></span><br><span class="line">	<span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;myallocator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>,my_allocator&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">		std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/sgi_stl$ g++ *.cpp -o sgi_stl_allocator.out -Wall</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/sgi_stl$ ./sgi_stl_allocator.out </span><br><span class="line"><span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure>



<p><img src="/2022/04/30/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-20-40-33.png"><br><img src="/2022/04/30/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-20-41-44.png"></p>
<blockquote>
<p><img src="/2022/04/30/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-21-13-13.png"></p>
</blockquote>
<p>二级空间配置器总结：<br>在一级空间配置器的基础上 增加了 基于 freelist 实现的内存池<br>freelist的每个成员下面挂了一链大小相等的内存块。freelist0挂8byte，freelist1挂16byte诸如此类<br>当user allocate的时候 就会根据alloc的大小（比如说32bytes）到相应的freelist成员下面去取出内存块。（避免了遍历链表寻找内存块，且可以提供一定程度的并发）<br>如果此时该成员(3)下有一32bytes块，那么取下该块，并返回给user<br>如果没有，那么耳机空间配置器向下（向原始内存）请求，20个32bytes块。<br>    插一句，我们可以将这个二级空间配置器的内存，分为三部分：一部分是已经返回给user使用的内存，一部分是挂在freelist之下的、形成链表的内存块，另一部分是：还没挂在freelist之下的内存块（称为原始内存吧先）<br>原始内存尽可能多的给我们返回的32bytes块，如果原始内存中已经连一个32bytes都没有的时候，原始内存通过malloc向os请求内存。请求内存的大小为20<em>32</em>2。注意这个<em>2，每次多申请一倍，减少syscall。（这也就是为什么会有原始内存）<br>如果malloc失败，则抛出异常。malloc成功，则此时原始内存有new mem(20</em>32*2) + old left mem(less than 32)，于是返回20个32bytes给之前向我们请求20个32bytes块的freelist成员；且，很巧妙的，为榨干所有内存，原始内存又为old left mem，找到其可以挂到的freelist成员下，将其挂在下面–这样就成功利用了每一寸内存。再说之前返回的20个32bytes，freelist成员(3) 将其串成链表，挂在自己之下，然后向user返回一个32bytes块。结束。</p>
<p>那么说说优点<br>freelist 相同大小内存块放在一个freelist[i]成员下，避免了遍历链表寻找合适内存块的开销，直接定位到在哪个freelist[i]下了；且可以提供一定的并发性。<br>对于每一个字节数的chunk块分配，都是返回给用户一个使用的内存块，并给freelist一个内存池，，并留有另一部分作为备用内存池。这个备用可以给当前的字节数freelist成员使用，也可以给其他字节数的freelist成员使用。<br>对于原始内存之前剩余的小块内村，也不会浪费，会将其挂到相应成员下。</p>
<p>缺点：因为不会归还内存给os，所以可能耗尽内存资源。（user通过二级空间配置其的释放动作只会将内存块挂到freelist的成员下）<br>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过 程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全 是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：<br>1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失 败；<br>2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请 不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</p>
]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>轮子-日志库</title>
    <url>/2022/11/27/%E8%BD%AE%E5%AD%90-%E6%97%A5%E5%BF%97%E5%BA%93/</url>
    <content><![CDATA[<p>todo<br>关于双缓冲的思想</p>
<span id="more"></span>

<p><img src="/2022/11/27/%E8%BD%AE%E5%AD%90-%E6%97%A5%E5%BF%97%E5%BA%93/2022-11-27-12-45-43.png"></p>
]]></content>
      <categories>
        <category>TODO</category>
      </categories>
      <tags>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title>轮子-sgi_stl二级空间配置器</title>
    <url>/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
    <content><![CDATA[<p>轮子-sgi_stl二级空间配置器原理</p>
<span id="more"></span>

<ul>
<li>分离存储策略 : 简单分离存储（我认为是）</li>
</ul>
<h2 id="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。"><a href="#一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。" class="headerlink" title="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。"></a>一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。</h2><h2 id="二级空间配置器就是-一级空间配置器-基于freelist实现的内存池的结合"><a href="#二级空间配置器就是-一级空间配置器-基于freelist实现的内存池的结合" class="headerlink" title="二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合"></a>二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合</h2><h1 id="SGI-STL-二级空间配置器-原理"><a href="#SGI-STL-二级空间配置器-原理" class="headerlink" title="SGI STL 二级空间配置器 原理"></a>SGI STL 二级空间配置器 原理</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><ul>
<li> <code>template&lt;typename T&gt; class my_allocator&#123;&#125;</code></li>
<li>整体<ul>
<li><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-17-24.png"></li>
</ul>
</li>
<li>_S_chunk_alloc<ul>
<li><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-18-11.png"></li>
</ul>
</li>
</ul>
<h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><ul>
<li>SGI STL包含了一级空间配置器和二级空间配置器，<ul>
<li>其中一级空间配置器allocator采用malloc和free来管理内存，和C++标准库中提供的allocator是一样的，</li>
<li>但其二级空间配置器allocator采用了基于freelist（自由链表）原理的内存池机制实现内存管理。</li>
</ul>
</li>
<li>SGI STL二级空间配置器：线程安全</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) allocator<span class="meta-string">&lt; T &gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) alloc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  一级空间配置器</span></span><br><span class="line">allocator&lt; T &gt;：</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> // 一级空间配置器内存管理类 -- 通过<span class="title">malloc</span>和<span class="title">free</span>管理内</span></span><br><span class="line"><span class="class">存</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//  二级空间配置器</span></span><br><span class="line"><span class="class"><span class="title">alloc</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span> <span class="comment">// 二级空间配置器内存管理类 -- 通过自定义内存池实现内存管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> :</span> <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>

<h2 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h2><ul>
<li><p>内存池粒度信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;       <span class="comment">//  内存对齐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">//  最大块大小   &gt;128就不会放到内存池里了，也即不会用二级空间配置器。会用一级空间配置器  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">//  静态链表的成员个数 _MAX_BYTES/_ALIGN</span></span><br></pre></td></tr></table></figure></li>
<li><p>每一个内存chunk块的头信息</p>
<ul>
<li>chunk：数据块，区块。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自由链表数组。数组的每个成员是静态的_Obj*指针。_STL_VOLATILE是为了保证多线程安全（通过防止线程缓存？多线程中一般堆上和数据段都会加volatile）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;__threads, __inst&gt;::_Obj* __STL_VOLATILE</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::</span><br><span class="line">_S_free_list[_NFREELISTS] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Chunk allocation state</code>. 记录内存<code>chunk</code>块的分配情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  static：类内声明、类外定义。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;         <span class="comment">//   空闲free内存的起始start位置 [</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;           <span class="comment">//   空闲free内存的结束end位置 )       (包括回收的吗？)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;         <span class="comment">//   总共malloc过的内存大小（因为malloc是从堆heap上请求的，所以叫heapsize）</span></span><br><span class="line"><span class="comment">//  类外定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>我认为SGI STL二级空间配置器中的<strong>内存池</strong>，分为<strong>三部分</strong></p>
<ul>
<li>一部分给用户使用</li>
<li>一部分是用户还没使用的，已经形成chunk链表内存池</li>
<li>一部分是还没加入chunk链表内存池的原始空闲内存</li>
</ul>
</li>
</ul>
<h2 id="重要辅助函数"><a href="#重要辅助函数" class="headerlink" title="重要辅助函数"></a>重要辅助函数</h2><ul>
<li>将bytes上调至最邻近的_ALIGN = 8的倍数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分析<ul>
<li>计组复习：<ul>
<li>机器数的解释规则都是补码。也就是计算机里的数都是以补码形式存储的。</li>
<li>补码<ul>
<li>正数：补码=原码=真值</li>
<li>负数：补码=~原码+1<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">枚举变量的取值为花括号内的任意一个值（有且只能有其中一个值），而这个值是<span class="keyword">int</span>型的。</span><br><span class="line">在X86系统中，所以<span class="built_in"><span class="keyword">sizeof</span></span>(_ALIGN) = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) = <span class="number">4</span>，也就是枚举变量的值为<span class="number">4</span></span><br><span class="line">_ALIGN</span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00001000</span></span><br><span class="line">_ALIGN - <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000111</span></span><br><span class="line">~(ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN</span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00001000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span></span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000111</span></span><br><span class="line"></span><br><span class="line">~((<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span> + bytes</span><br><span class="line"><span class="number">000.</span>..| <span class="number">00000111</span>    +<span class="number">0</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001000</span>    +<span class="number">1</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001001</span>    +<span class="number">2</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001111</span>    +<span class="number">8</span></span><br><span class="line"><span class="comment">// -&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00010000</span>    +<span class="number">9</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00010111</span>    +<span class="number">16</span></span><br><span class="line"><span class="comment">// -&gt; 16</span></span><br><span class="line"></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00011000</span>    +<span class="number">17</span></span><br><span class="line"><span class="comment">// -&gt; 24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp; </span><br><span class="line">~((<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">111.</span>..| <span class="number">11111000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>返回位于第几个内存块<ul>
<li>bytes &gt;= 1  内存块号 &gt;= 0<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//  bytes &gt;= 1  内存块号 &gt;= 0</span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">      <span class="comment">//  (bytes + 7)/(ALIGN = 8) - 1。（+7(ALIGN-1)：为了保证12345678位于同一组？</span></span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>][<span class="number">9</span>,<span class="number">16</span>][<span class="number">17</span>,<span class="number">24</span>]</span><br><span class="line">  <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> _ALIGN = <span class="number">8</span> &#125;;     <span class="comment">//  4</span></span><br><span class="line"><span class="comment">//  将bytes上调至最邻近的8的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回位于第几个内存块</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);   <span class="comment">//  (bytes + 7)/8  -1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;                    <span class="comment">//  4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;              <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;     <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>) &lt;&lt; endl;                 <span class="comment">//  8    </span></span><br><span class="line">    <span class="comment">//  size_t ：unsigned long long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(_ALIGN) &lt;&lt; endl;                 <span class="comment">//  4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(_ALIGN).<span class="built_in">name</span>() &lt;&lt; endl;          <span class="comment">//  enum &lt;unnamed-enum-_ALIGN&gt;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>((<span class="keyword">size_t</span>)_ALIGN) &lt;&lt; endl;         <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>((<span class="keyword">size_t</span>)_ALIGN).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">//  unsigned __int64</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; _ALIGN &lt;&lt; endl;                         <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _ALIGN<span class="number">-1</span> &lt;&lt; endl;                       <span class="comment">//  7</span></span><br><span class="line">    cout &lt;&lt; ~(_ALIGN - <span class="number">1</span>) &lt;&lt; endl;                  <span class="comment">//  -8</span></span><br><span class="line">    cout &lt;&lt; ((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &lt;&lt; endl;           <span class="comment">//  7</span></span><br><span class="line">    cout &lt;&lt; (~(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &lt;&lt; endl;          <span class="comment">//  18446744073709551606</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">0</span>) &lt;&lt; endl;                 <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">1</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">7</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">8</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">9</span>) &lt;&lt; endl;                 <span class="comment">//  16</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">16</span>) &lt;&lt; endl;                <span class="comment">//  16</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">17</span>) &lt;&lt; endl;                <span class="comment">//  24</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//  cout &lt;&lt; _S_freelist_index(0) &lt;&lt; endl;   bytes至少&gt;=1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">1</span>) &lt;&lt; endl;           <span class="comment">//  0   </span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">7</span>) &lt;&lt; endl;           <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">8</span>) &lt;&lt; endl;           <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">15</span>) &lt;&lt; endl;          <span class="comment">//  1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">16</span>) &lt;&lt; endl;          <span class="comment">//  1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">17</span>) &lt;&lt; endl;          <span class="comment">//  2</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">24</span>) &lt;&lt; endl;          <span class="comment">//  2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h2><ul>
<li>概述：根据n大小，采取相应方式获取内存，并返回。<ul>
<li>n&gt;128<ul>
<li>malloc_alloc::allocate(__n)。同一级空间配置器。开辟后返回</li>
</ul>
</li>
<li>n&lt;128<ul>
<li>根据n大小，借助free从freelist相应元素管理的内存池中取出相应大小内存块。当内存池不存在时，开辟内存池。</li>
<li>对于传入的请求内存大小n，n决定了请求那个freelist成员指向的内存池的内存块。<ul>
<li><code>_Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n)</code></li>
</ul>
</li>
<li>如果相应的<code>freelist</code>成员=nullptr的话，<ul>
<li>调用<code>_S_refill</code>：<code>__ret = _S_refill(_S_round_up(__n));</code><ul>
<li>开辟内存块数=nobjs(20)的内存池，内存池中的每个内存块的大小都是传入的<code>__n</code><ul>
<li><code>char* __chunk = _S_chunk_alloc(__n, __nobjs);</code></li>
</ul>
</li>
<li>_S_refill根据传入的n大小，计算出开辟的内存池应该由哪个freelist成员管理。<ul>
<li><code>__my_free_list = _S_free_list + _S_freelist_index(__n);</code></li>
</ul>
</li>
<li>将内存池挂到freelist相应成员下，</li>
<li>并维护每个空闲内存块之间指向关系。（每个空闲内存块连接在一起组成内存池）</li>
<li>返回第一个内存块。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>freelist[]（自由链表）是一个静态的链表</li>
<li>数组的每个元素指向一个内存池。</li>
<li>同一内存池的chunk内存块的大小一致。</li>
<li>不同内存池的chunk内存块大小不一致。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span>     <span class="comment">//  请求的一块大小为n的空间</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果&gt;128bytes，那么调用malloc_alloc::allocate（同一级空间配置器的allocator的allocate一样)</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);          <span class="comment">//  应当在哪个</span></span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;                            <span class="comment">//  上锁</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;      <span class="comment">//  __RESTRICT线程安全</span></span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//  _S_round_up(n)（向上取8的倍数）。根据n的大小，计算出应该开辟多大内存。</span></span><br><span class="line">      <span class="comment">//  _S_refill：在相应freelist成员下开辟内存池，且内存池的每个内存块大小都为__n向上取8的倍数。并返回内存池的第一个内存块。</span></span><br><span class="line">      <span class="comment">//   如何确定将内存池接在哪个freelist成员下？通过_S_freelist_index(n)计算出。</span></span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));            <span class="comment">//  开辟内存池</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-07-18.png"></p>
<h2 id="S-refill"><a href="#S-refill" class="headerlink" title="_S_refill"></a>_S_refill</h2><ul>
<li><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-08-25.png"></li>
<li>__n：内存池里每个内存块的大小。并且可以借助n计算出该内存池应该接在那个freelist成员下。</li>
<li>概述：当freelist的某个元素obj*=nullptr时，会调用_S_refill，(<code>_S_refill</code>向下调用<code>_S_chunk_alloc</code>)开辟内存池，并返回内存池的第一个内存块。并且<code>_S_refill</code>内维护从原始内存中申请来的内存池中每个内存块chunk节点之间的指向关系。<ul>
<li><code>_S_chunk_alloc</code>：分配指定大小的内存池</li>
<li>静态链表：把每个chunk块通过Obj*里的指针连接起来</li>
</ul>
</li>
<li>allocate函数中调用_S_refill。n是传入的参数，代表allocate请求一个多大的内存块。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns an object of size __n, and optionally adds to size __n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that __n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)  <span class="comment">//  n是一个chunk块的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  分配指定大小的内存池    __nobjs：chunk内存块数量 ；这里的 __n：每个chunk内存块大小。</span></span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  __nobjs：申请到的chunk块数量。当只申请到一个时，直接返回该内存块给上一级使用。无需建立各个chunk的连接关系，无需挂载到相应的freelist成员下。（因为只有一个）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);  </span><br><span class="line">    </span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);     <span class="comment">//  根据内存块大小求出内存池应该在由freelist第几个成员管理（指向）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  静态链表：把每个chunk块通过Obj*里的指针连接起来</span></span><br><span class="line">    <span class="comment">//  每个内存块，有一部分的内存时union联合体Obj，里面有一个Obj*指针，负责连接每个空闲内存块。</span></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      __result = (_Obj*)__chunk;</span><br><span class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);    <span class="comment">//  __n：一个内存块的大小（因为第一个内存块要分配出去）</span></span><br><span class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">        __current_obj = __next_obj;                             </span><br><span class="line">        __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);          <span class="comment">//   维护内存块间的连接  char* 因此+__n是偏移n个bytes +n是为了一次跑一个chunk块</span></span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;                               <span class="comment">//   空闲内存块数为0?</span></span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);   <span class="comment">//  返回第一个内存块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="S-chunk-alloc"><a href="#S-chunk-alloc" class="headerlink" title="_S_chunk_alloc"></a>_S_chunk_alloc</h2><ul>
<li><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-20-41-44.png"></li>
<li><code>allocate(size_t n) -&gt; _S_refill(size_t n) -&gt; _S_chunk_alloc(size_t __size__,int &amp;nobjs)</code></li>
<li>将所有备用内存池都应用到，哪怕只剩下<code>8bytes</code>（最小的块就是<code>8bytes</code>，将这些用不到的小内存块挂载到相应的<code>freelist</code>成员下。）。</li>
<li><code>chunk_alloc</code>里可能<code>malloc</code>，也可能不<code>malloc</code>。<ul>
<li><code>malloc</code>：备用内存(当前<code>start-end</code>)不够</li>
<li>不<code>malloc</code>：备用内存(当前<code>start-end</code>)本身就够<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></li>
</ul>
</li>
<li>从 【备用空闲内存池申请】 或者 【操作系统中开辟】 内存池。这个内存池中，每个<code>chunk</code>大小为<code>size</code> bytes，数量为<code>_nobjs</code>。将所申请的这一整个池子的首地址返回给上一级–_S_refill。在_S_refill中，负责将该池子中的每个chunk块建立起链表关系，并挂载到相应free-list成员下。并且_S_refill负责把一个size大小的chunk返回给上一级allocate。（用户调用请求函数）。</li>
<li>而在_S_chunk_alloc中，对于内存池子是从备用内存池请求，还是再从操统中开辟，又分以下情况讨论<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">    <span class="keyword">if</span>(_bytes_left &gt;= total_bytes)&#123; </span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> result;  <span class="comment">//  total大小内存块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(__bytes_left &gt;= __size)&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> result;  <span class="comment">//  尽量return大点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 后半+的这个是为了malloc越来越大</span></span><br><span class="line">      <span class="comment">// 计算要malloc多少内存s</span></span><br><span class="line">      bytes_to_get = <span class="number">2</span>*__total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// malloc内存</span></span><br><span class="line">      _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">            <span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">            <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                          </span><br><span class="line">              <span class="comment">//  头插法</span></span><br><span class="line">              <span class="comment">//  start_free头插接入_S_free_list + _S_freelist_index(__bytes_left)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      _S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">      _S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">      <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;            <span class="comment">//  本次总共需要请求的内存大小</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//  __default_alloc_template&lt;__threads, __inst&gt; 从开始到现在，请求的剩余空闲的的内存大小。不包括回收的。只是开辟的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;                <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">        __result = _S_start_free;                       <span class="comment">//  __result 作为返回内存首地址</span></span><br><span class="line">        _S_start_free += __total_bytes;                 <span class="comment">//  移动_S_start_free</span></span><br><span class="line">        <span class="keyword">return</span>(__result);                               <span class="comment">//  [result , _S_start_free)  作为请求结果返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;                <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get =                         <span class="comment">//  当剩余的空闲内存不够时，需要向操统malloc内存。这是计算出需要malloc内存的大小（至少malloc出来要求内存的(__total_bytes)两倍）</span></span><br><span class="line">	  <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                         <span class="comment">//  </span></span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//  向操统malloc内存</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;                       <span class="comment">//  malloc失败</span></span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">	    _Obj* __p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="comment">//  从别的freelist成员管理的原始备用内存池中借用至少size大小的chunk块</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size;</span><br><span class="line">                 __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES;</span><br><span class="line">                 __i += (<span class="keyword">size_t</span>) _ALIGN) &#123;</span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  都没有时，尝试下allcoate来补救</span></span><br><span class="line">	    _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        _S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><ul>
<li><p>什么时候调用chunk_alloc?当某个freelist成员的内存池为空时。（没分配过内存池或者内存池耗尽）</p>
</li>
<li><p><strong>调用上下文</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">allocate中：<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">_Obj* __RESTRICT __result </span>= *__my_free_list;</span><br><span class="line"><span class="comment">//  当某个freelist成员的内存池为空时。（没分配过内存池或者内存池耗尽） 调用__S_chunk_alloc</span></span><br><span class="line"><span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">  __ret = _S_refill(_S_round_up(__n));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//  消耗内存池</span></span><br><span class="line">  *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">  __ret = __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __ret;</span><br><span class="line"></span><br><span class="line">S_refill中</span><br><span class="line"><span class="number">1.</span> <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line"><span class="number">2.</span> 连接得到的chunk块</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>整体<blockquote>
<p><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-21-13-13.png"></p>
</blockquote>
</li>
<li>我将图中形成链表的自由（空闲）内存节点们称为内存池。</li>
<li>将没有建立链表连接的称为原始内存（或者叫备用内存池）。</li>
</ul>
<hr>
<ul>
<li>大体：<code>start-free==0</code>时，就是一点 <strong>备用的 空闲的</strong> 内存也没有了<ul>
<li>备用内存：<ul>
<li>优先是只进行了malloc的空闲原始内存，也就是没有被形成freelist某成员内存池的</li>
<li>如果没有，其次是已经参与形成内存链表池的空闲chunk块。</li>
</ul>
</li>
</ul>
</li>
<li>当没有备用内存(<code>bytes_left==0</code>)时，正常从操统中malloc内存<ul>
<li>一小块返回给用户使用，</li>
<li>一部分返回给上一级加工成内存池（把chunk块之间连起来）</li>
<li>一部分在 <code>[_start_free</code> 和 <code>_end_free)</code>之间，用作备用内存（备用内存池/原始内存）。</li>
</ul>
</li>
<li><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-09-38.png"></li>
</ul>
<hr>
<ul>
<li>当有备用内存时<ul>
<li>start和free之间malloc的原始内存，还没参与形成内存池</li>
<li> [start，free) &gt; size (nobjs&gt;1)，则将这块内存挂给相应freelist成员</li>
<li>图中为空闲内存有160bytes，而上层申请16*20bytes内存<br><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-10-52.png"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>条件同上<ul>
<li>start和free之间malloc的原始内存，还没参与形成内存池</li>
<li>nobjs = [start，free) / size = 1，则将这内存块返回。（因为只有一个，所以不必挂载形成内存池） </li>
<li>图中空闲内存为160bytes，而上层申请16*128bytes内存。<ul>
<li>返回1个128bytes内存块</li>
</ul>
</li>
<li>用户又接着申请32bytes</li>
<li>用户接着申请128bytes</li>
</ul>
</li>
<li><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-08-16.png"></li>
<li><blockquote>
<p><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-08-39-50.png"></p>
</blockquote>
</li>
<li>第三张红圈的例子：解释如下。<ul>
<li>只返回一个<code>128bytes</code>块时，<code>freelist</code>的<code>128bytes</code>成员仍是空，因为返回的这一个直接就用作请求结果了，并没空闲内存块。</li>
<li>当上层(allocate)再次请求128Bytes时，_S_refill调用<code>chunk = _S_chunk_alloc(size_t __size = 128, int&amp; __nobjs = 20)</code>。由于剩下<code>__bytes_left = 32bytes &lt; size = 128bytes</code>。故进入<code>else</code>。</li>
<li>剩余的<code>32bytes</code>被<code>freelist</code>的<code>32bytes</code>成员管理（因为这个<code>32bytes</code>对于128bytes的chunk块来说无用）。再开辟<code>bytes_to_get</code>的内存。移动<code>free_start</code>。接下来的操作同一开始malloc内存。（再循环调用<code>chunk_alloc...</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>malloc失败<ul>
<li>从别的freelist成员已经形成链表的内存池中，拿出一块chunk，给本次请求用<blockquote>
<p><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-10-58-25.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h2><ul>
<li>功能概述：归还p指向的、大小为n的内存块，还给内存池链表。（n用于计算归还的该块内存应该在哪个freelist成员管理的内存之中）<ul>
<li>将p头插入法插入内存池链表中。</li>
<li><img src="/2022/04/16/%E8%BD%AE%E5%AD%90-sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-32-12.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)  <span class="comment">//  n&gt;128 同一级空间配置器</span></span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);  <span class="comment">//  找到相应freelist成员</span></span><br><span class="line">      _Obj* __q = (_Obj*)__p;       <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="malloc-alloc-template"><a href="#malloc-alloc-template" class="headerlink" title="__malloc_alloc_template"></a>__malloc_alloc_template</h2><ul>
<li><p>辅助__malloc_alloc_template的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  申请nbytes。如果空间不足，则释放nbytes</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  释放p</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>malloc_alloc:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="malloc-alloc-allocate"><a href="#malloc-alloc-allocate" class="headerlink" title="malloc_alloc::allocate"></a>malloc_alloc::allocate</h3><ul>
<li>功能概述<ul>
<li>分配nbytes成功 返回result</li>
<li>分配失败，那么就调用预制好的_S_oom_malloc，释放nbytes空间，给result<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>调用上下文<ul>
<li>在没有空间（不能malloc）的情况下，又必须进行malloc。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_S_chunk_alloc()&#123;</span><br><span class="line">  malloc = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 没有空间 却又只能allcoate</span></span><br><span class="line">  _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">  _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="malloc-alloc-S-oom-malloc"><a href="#malloc-alloc-S-oom-malloc" class="headerlink" title="malloc_alloc::_S_oom_malloc"></a>malloc_alloc::_S_oom_malloc</h3><ul>
<li>功能概述：循环调用用户预制的回调函数，以期解决内存不够的问题，好拿出nbyte内存。</li>
<li>oom：out of memory 内存耗尽</li>
<li>用户先前设置好回调函数<code>__malloc_alloc_oom_handler</code><ul>
<li>设置：那么这个回调函数必须实现 释放其他内存，使得可以给当前请求分配内存的功能。否则会陷入死循环，直到可以malloc内存。<code>return</code>malloc的内存。</li>
<li>没设置：直接抛异常 throw bad_alloc<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __my_malloc_handler)();   <span class="comment">//  用于接收回调函数</span></span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;   <span class="comment">//  设置回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<span class="comment">//  如果用户之前没设置回调函数，那么直接抛异常</span></span><br><span class="line">        (*__my_malloc_handler)();                           <span class="comment">//  调用回调函数</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);                       <span class="comment">//  </span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="reallocate"><a href="#reallocate" class="headerlink" title="reallocate"></a>reallocate</h2><ul>
<li>功能概述<ul>
<li>为指针p重新分配指向的空间，大小为new_sz。并返回这块新内存的地址。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">reallocate</span>(<span class="keyword">void</span>* __p,size_t__old_sz,<span class="keyword">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  old new都&gt;128byets，那么用的就应当是和一级空间配置器一样的方法malloc</span></span><br><span class="line">    <span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));   <span class="comment">//  重新分配内存。释放p地址内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果即将分配的chunk块大小一致，那么不必，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="keyword">return</span>(__p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重新从内存池中申请new_size大小内存，并拷贝数据到新申请来的内存里</span></span><br><span class="line">    __result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">    __copy_sz = __new_sz &gt; __old_sz? __old_sz : __new_sz;</span><br><span class="line">    <span class="built_in">memcpy</span>(__result, __p, __copy_sz); <span class="comment">//  拷贝数据</span></span><br><span class="line">    <span class="built_in">deallocate</span>(__p, __old_sz);  <span class="comment">//  将p指向的内存还给内存池链表</span></span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="经典内存池优点"><a href="#经典内存池优点" class="headerlink" title="经典内存池优点"></a>经典内存池优点</h2><ul>
<li><p>C/C++下内存管理是让几乎每一个程序员头疼的问题，分配足够的内存、追踪内存的分配、在不需要的时候释放内存——这个任务相当复杂。而直接使用系统调用malloc/free、new/delete进行内存分配和释放，有以下弊端：<br>利用默认的内存管理函数new/delete或malloc/free在堆上分配和释放内存会有一些额外的开销。</p>
</li>
<li><p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。</p>
</li>
<li><p>默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。 </p>
</li>
<li><p>可见，如果应用程序频繁地在堆上分配和释放内存，则会导致性能的损失。并且会使系统中出现大量的内存碎片，降低程序性能，降低内存的利用率。</p>
</li>
<li><p>默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池则可以获得更好的性能。</p>
</li>
<li><p>内存池（memory pool)是代替直接调用malloc/free、new/delete进行内存管理的常用方法，当我们申请内存空间时，首先到我们的内存池中查找合适的内存块，而不是直接向操作系统申请，优势在于：</p>
<ul>
<li>比malloc/free进行内存申请/释放的方式快;</li>
<li>不会产生或很少产生堆碎片;</li>
<li>可避免内存泄漏;</li>
</ul>
</li>
<li><p>普通内存池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象。</span><br><span class="line"></span><br><span class="line">（2）每个对象连同一个指向下一个对象的指针一起构成一个内存节点（Memory Node）。各个空闲的内存节点通过指针来形成一个链表，链表的每一个内存节点都是一块可供分配的内存空间。</span><br><span class="line"></span><br><span class="line">（3）某个内存节点一旦分配出去，就将从链表中去除。</span><br><span class="line"></span><br><span class="line">（4）一旦释放了某个内存节点的空间，又将该节点重新加入自由内存节点链表。</span><br><span class="line"></span><br><span class="line">（5）如果一个内存块的所有内存节点分配完毕，若程序继续申请新的对象空间，则会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。</span><br><span class="line"></span><br><span class="line">经典内存池的实现过程大致如上面所述，其形象化的过程如下图所示： </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SGI-STL-二级空间配置器优点"><a href="#SGI-STL-二级空间配置器优点" class="headerlink" title="SGI STL 二级空间配置器优点"></a>SGI STL 二级空间配置器优点</h2><ul>
<li>对于每一个字节数的chunk块分配，都是返回给用户一个使用的内存块，并给freelist一个内存池，，并留有另一部分作为备用内存池。这个备用可以给当前的字节数freelist成员使用，也可以给其他字节数的freelist成员使用。</li>
<li>对于备用内存池划分chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的内存块再次分配出去，备用内存池使用的一滴不剩。</li>
<li>当指定bytes字节数内存分配失败以后，有一个异常处理的过程，bytes -&gt; 128字节所有的chunk块进行查看，如果哪个freelist成员下的内存链表池中有chunk块，借一个出去。<ul>
<li>如果操作失败，会调用<code>_S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get)</code>来malloc内存；<ul>
<li><code>allocate</code>里面通过调用<code>oom_malloc</code>，来调用预先设置好的回调函数<code>__malloc_alloc_oom_handler</code>。用于处理<code>malloc</code>失败的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缺点-我认为"><a href="#缺点-我认为" class="headerlink" title="缺点 我认为"></a>缺点 我认为</h2><ul>
<li>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：<ul>
<li>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它 会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造 成很多内部碎片；</li>
<li>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过 程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全 是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有： <ul>
<li>1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失 败；</li>
<li>2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请 不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><p>问题已解决 希望我能在8月份之前写下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">灼夭. 10:11:37</span><br><span class="line">xdm 请问大家个问题。二级空间配置器真的解决了内存碎片的问题吗。我觉得虽然解决了外部碎片的问题，但好像又会导致产生很多内部碎片呀？还是说虽然会产生内部碎片，但是无所谓？对程序性能、内存利用率也没啥太大影响？</span><br><span class="line"></span><br><span class="line">灼夭. 10:11:51</span><br><span class="line">Alex💡 10:23:52</span><br><span class="line">灼夭.  </span><br><span class="line">xdm 请问大家个问题。二级空间配置器真的解决了内存碎片的问题吗。我觉得虽然解决了外部碎片的问题，但好像又会导致产生很多内部碎片呀？还是说虽然会产生内部碎片，但是无所谓？对程序性能、内存利用率也没啥太大影响？</span><br><span class="line">@灼夭. 我之前看侯捷讲的说法是，二级配置器可以很好的解决频繁调用malloc带来的时间消耗以及额外内存消耗，但是与此同时，内存池分配的小块内存都是8的倍数，也会存在一定的内部碎片，但相对于malloc而言，其性能还是好的。</span><br><span class="line"></span><br><span class="line">灼夭. 10:27:53</span><br><span class="line">Alex💡  </span><br><span class="line">@灼夭. 我之前看侯捷讲的说法是，二级配置器可以很好的解决频繁调用malloc带来的时间消耗以及额外内存消耗，但是与此同时，内存池分配的小块内存都是8的倍数，也会存在一定的内部碎片，但相对于malloc而言，其性能还是好的。</span><br><span class="line">@Alex💡 哦哦哦 多谢xd</span><br><span class="line"></span><br><span class="line">Alex💡 10:28:17</span><br><span class="line">没事儿。</span><br></pre></td></tr></table></figure>


<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p><a href="https://blog.csdn.net/fdk_lcl/article/details/89482835">https://blog.csdn.net/fdk_lcl/article/details/89482835</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">round - 必应词典</span><br><span class="line">美[raʊnd]英[raʊnd]</span><br><span class="line">n.旋转；巡视；一连串；绕圈</span><br><span class="line">adv.环绕；附近；各处；向四面</span><br><span class="line">prep.环绕；在…周围；始终</span><br><span class="line">v.绕过；拐过；使成圆形；把…四舍五入</span><br><span class="line">adj.圆的；球形的；肥胖的；弧形的</span><br><span class="line">网络回合；轮；圆形的</span><br><span class="line"></span><br><span class="line">round up 向上取整</span><br></pre></td></tr></table></figure>








<ul>
<li>计组<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>计算机里的数都是补码形式，因为CPU只会做加法，数的补码形式就可以用加法实现减法运算，进而以加法完成所有的运算。至于数以什么码的形式输入和输出，编程人员是可以控制的。</span><br><span class="line"><span class="number">2.</span>计算机里数码的位数是<span class="number">2</span>的正整数次方，比如<span class="number">4</span>位、<span class="number">8</span>位、<span class="number">16</span>位，因为CPU及周边电路一旦制成，一次处理数据位数、总线位数、各种寄存器位数就都固定下来，都是<span class="number">2</span>的正整数次方位，这样选择的理由很多，可参照有关资料了解。</span><br><span class="line"><span class="number">3.</span>一个<span class="number">8</span>位的补码数，它表示数的范围是<span class="number">-128</span>~+<span class="number">127</span>，原码表示数的范围是<span class="number">-127</span>~+<span class="number">127</span>，反码表示数的范围是<span class="number">-127</span>~+<span class="number">127</span>，就是因为最高位是符号位，实际数位只有<span class="number">7</span> 位。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存碎片是问题吗？"><a href="#内存碎片是问题吗？" class="headerlink" title="内存碎片是问题吗？"></a>内存碎片是问题吗？</h2><ul>
<li>截</li>
</ul>
<hr>
<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Default node allocator.</span></span><br><span class="line"><span class="comment">// With a reasonable compiler, this should be roughly as fast as the</span></span><br><span class="line"><span class="comment">// original STL class-specific allocators, but with less fragmentation.</span></span><br><span class="line"><span class="comment">// Default_alloc_template parameters are experimental and MAY</span></span><br><span class="line"><span class="comment">// DISAPPEAR in the future.  Clients should just use alloc for now.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Important implementation properties:</span></span><br><span class="line"><span class="comment">// 1. If the client request an object of size &gt; _MAX_BYTES, the resulting</span></span><br><span class="line"><span class="comment">//    object will be obtained directly from malloc.</span></span><br><span class="line"><span class="comment">// 2. In all other cases, we allocate an object of size exactly</span></span><br><span class="line"><span class="comment">//    _S_round_up(requested_size).  Thus the client has enough size</span></span><br><span class="line"><span class="comment">//    information that we can return the object to the proper free list</span></span><br><span class="line"><span class="comment">//    without permanently losing part of the object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The first template parameter specifies whether more than one thread</span></span><br><span class="line"><span class="comment">// may use this allocator.  It is safe to allocate an object from</span></span><br><span class="line"><span class="comment">// one instance of a default_alloc and deallocate it with another</span></span><br><span class="line"><span class="comment">// one.  This effectively transfers its ownership to the second one.</span></span><br><span class="line"><span class="comment">// This may have undesirable effects on reference locality.</span></span><br><span class="line"><span class="comment">// The second parameter is unreferenced and serves only to allow the</span></span><br><span class="line"><span class="comment">// creation of multiple default_alloc instances.</span></span><br><span class="line"><span class="comment">// Node that containers built on different allocator instances have</span></span><br><span class="line"><span class="comment">// different types, limiting the utility of this approach.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size __n, and optionally adds to size __n free list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_THREADS</span></span><br><span class="line">    <span class="keyword">static</span> _STL_mutex_lock _S_node_allocator_lock;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It would be nice to use _STL_auto_lock here.  But we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need the NULL check.  And we do need a test whether</span></span><br><span class="line">    <span class="comment">// threads have actually been started.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125;</span><br><span class="line">            ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size __n, and optionally adds to size __n free list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_THREADS</span></span><br><span class="line">    <span class="keyword">static</span> _STL_mutex_lock _S_node_allocator_lock;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It would be nice to use _STL_auto_lock here.  But we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need the NULL check.  And we do need a test whether</span></span><br><span class="line">    <span class="comment">// threads have actually been started.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125;</span><br><span class="line">            ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  申请nbytes。如果空间不足，则释放nbytes</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  释放p</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>组件协作模式</title>
    <url>/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>组件协作模式：模板方法、策略模式、观察者模式</p>
<span id="more"></span>

<ul>
<li>前言<ul>
<li>设计模式的假定条件：必须有一个稳定点！</li>
<li>所有都是变化的，那么没有任何一个设计莫斯是有用的</li>
<li>所有都是稳定的，那么就没有必要用设计模式了。</li>
<li>设计模式就是在稳定和变化中寻求隔离</li>
<li>大多数设计模式都追求：稳定中有变化<h1 id="组件协作模式"><a href="#组件协作模式" class="headerlink" title="组件协作模式"></a>组件协作模式</h1></li>
</ul>
</li>
</ul>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul>
<li>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作<br>结构，但各个子步骤却有很多改变的需求，或者由于固有的原因<br>（比如框架与应用之间的关系）而无法和任务的整体结构同时实现  </li>
<li>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变<br>化或者晚期实现需求</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>定义一个操作中的算法的<strong>骨架 (稳定)<strong>，而将一些步骤</strong>延迟(变化)到</strong>子类中。Template Method使得子类可以<strong>不改变(复用)一</strong>个算法的结构即可重定义(override 重写)该算法的<br>某些特定步骤<ul>
<li>延迟到子类：让子类实现或override父类的virtual</li>
<li>如果没有稳定的骨架（Run）怎么办？那么前提就不成立了，就要换一种设计模式</li>
</ul>
</li>
</ul>
<h3 id="早-晚绑定"><a href="#早-晚绑定" class="headerlink" title="早/晚绑定"></a>早/晚绑定</h3><p><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-24-18-08-37.png"></p>
<ul>
<li><strong>反向控制结构</strong><br><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-24-18-08-12.png"></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>稳定的函数：设非虚</li>
<li>变化的函数：设virtual<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  非虚函数Run：稳定</span></span><br><span class="line"><span class="comment">//  虚函数：变化(step3,step4)</span></span><br><span class="line">	<span class="comment">//稳定 template method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Step2</span>()) &#123; <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">            <span class="built_in">Step3</span>(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">Step4</span>(); <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Step5</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">		<span class="comment">//.....</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>=<span class="number">0</span>; <span class="comment">//变化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> Library &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    Library* pLib=<span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">	    lib-&gt;<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> pLib;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-24-18-13-29.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>Template Method</code>模式是一种非常基础性的设计模式，在面向对<br>象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）<br>为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本<br>实现结构。</li>
<li>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用<br>你”的<strong>反向控制结构</strong>是<code>Template Method</code>的典型应用。</li>
<li>在具体实现方面，被<code>Template Method</code>调用的虚方法可以具有实<br>现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将<br>它们设置为<code>protected</code>方法（一般在父类所写的核心流程里的上下文中调用才有意义，类外调用没意义）。</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-29-15-35-48.png"></p>
<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><ul>
<li>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担</li>
<li>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>定义一系列算法，把它们一个个封装起来，并且使它们可<strong>互相替换（变化）</strong>。该模式使得算法可<strong>独立于</strong>使用它的<strong>客户程序(稳定)<strong>而</strong>变化（扩展，子类化）</strong>。</li>
</ul>
<h3 id="什么是复用，什么是扩展-修改？"><a href="#什么是复用，什么是扩展-修改？" class="headerlink" title="什么是复用，什么是扩展/修改？"></a>什么是复用，什么是扩展/修改？</h3><ul>
<li>扩展是为了实现复用.<h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4></li>
<li>拷贝粘贴不叫复用</li>
<li><strong>不是源代码级别的复用</strong></li>
<li><strong>复用</strong>而是<strong>编译</strong>、部署之后，<strong>二进制级别的复用</strong>。是编译部署之后，原封不动的。</li>
<li>所以，在一堆if-else后面再加一个if-else，是修改而不是扩展<ul>
<li><strong>不是扩展（改变了此文件的源代码,需要重新编译）</strong></li>
<li>因此没实现复用（复用之前的if-else？放屁！）</li>
</ul>
</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li>不改变现有类的代码,而是通过新增加一个文件来增加一个类等.</li>
</ul>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><ul>
<li><p>修改现有类的源代码</p>
</li>
<li><p><strong>开闭原则</strong></p>
<ul>
<li>对扩展开放</li>
<li>对修改关闭</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TaxBase</span> &#123;</span></span><br><span class="line">	CN_Tax,</span><br><span class="line">	US_Tax,</span><br><span class="line">	DE_Tax,</span><br><span class="line">	FR_Tax       <span class="comment">//更改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  增加新算法时,需要修改代码(加if-else),违反开闭原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line">    TaxBase tax;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (tax == CN_Tax)&#123;</span><br><span class="line">            <span class="comment">//CN***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == US_Tax)&#123;</span><br><span class="line">            <span class="comment">//US***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == DE_Tax)&#123;</span><br><span class="line">            <span class="comment">//DE***********</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tax == FR_Tax)&#123;  <span class="comment">//更改   </span></span><br><span class="line">        <span class="comment">// 这里叫做修改 而非扩展！！</span></span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><ul>
<li>扩展</li>
<li>如果有改变的话,我们新增文件FRTax.cpp , 在里面写要增加的类即可 , 其他类文件的代码不会改变 , 实现了(二进制级别的)复用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaxStrategy</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DETax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  扩展</span></span><br><span class="line"><span class="comment">//  如果有改变的话,我们新增文件FRTax.cpp , 在里面写要增加的类即可.</span></span><br><span class="line"><span class="comment">//  其他类文件的代码不会改变</span></span><br><span class="line"><span class="comment">//  实现了(二进制级别的)复用</span></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">		<span class="comment">//.........</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;  <span class="comment">//  常用指针而非引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;   <span class="comment">//  工厂</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="built_in">NewStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SalesOrder</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        Context context;</span><br><span class="line">        <span class="keyword">double</span> val = </span><br><span class="line">            strategy-&gt;<span class="built_in">Calculate</span>(context); <span class="comment">//多态调用</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-25-17-52-55.png"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>用扩展的方式,去面对需求的变化</strong></p>
</li>
<li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在<strong>运行时</strong>方便地根据需要在各个算法之间进行切换 </p>
<ul>
<li>运行时:多态,虚函数调用 </li>
</ul>
</li>
<li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。<strong>含有许多条件判断语句的代码通常都需要Strategy模式!!!</strong></p>
</li>
<li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销.</p>
</li>
<li><p>出现很多if-else的地方,且可能需要增加改变时,就是我们需要用到策略模式的地方.</p>
</li>
<li><p><code>if-else : bad smile</code></p>
</li>
<li><p>实际上的算法远比上面的+-复杂。</p>
</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>策略模式仅仅封装算法</li>
<li>方便新的算法插入到已有系统中，以及老算法从系统中“退休”，实现方法替换</li>
<li>策略模式并不决定何时使用何种算法，什么情况下使用什么算法由用户决定。</li>
<li>策略模式的重心：策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</li>
<li>算法的平等性：策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的</li>
<li>运行时策略的唯一性：运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个</li>
<li>它把采取哪一种算法或采取哪一种行为的逻辑与算法本身分离，避免程序中使用多重条件转移语句，使系统更灵活，并易于扩展</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</li>
<li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">行为型模式：主要关注的是对象之间的通信</span></span><br><span class="line"><span class="comment">观察者模式Observer Pattern（发布-订阅模式）设计模式:主要关注的是对象的一对多的关系，也就是多个对象</span></span><br><span class="line"><span class="comment">都依赖一个对象，当该对象的状态发生改变时，其它对象都能够接收到相应的通知。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一组数据（数据对象）   =&gt;  通过这一组数据 =》  曲线图(对象1)/柱状图(对象2)/圆饼图(对象3)</span></span><br><span class="line"><span class="comment">当数据对象改变时，对象1、对象2、对象3应该及时的收到相应的通知！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Observer1  Observer2   Observer3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		   Subject（主题）主题有更改，应该及时通知相应的观察者，去处理相应的事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  观察者模式 / 监听者模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  发布-订阅</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者 Observer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> :</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer1 recv 1 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer1 recv 2 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer1 recv unknown msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer2</span>:</span><span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer2 recv 1 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer2 recv unknown msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer3</span>:</span><span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer3 recv 1 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer3 recv 2 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer3 recv 3 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer3 recv unknown msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  主题类</span></span><br><span class="line"><span class="comment">//  记录了每个要观察的对象int msg和观察者Observe的关联情况</span></span><br><span class="line"><span class="comment">//  内含会发生变化的主体。也就是观察者要观察的东西</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer *obs,<span class="keyword">int</span> msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        m_subMap[msg].push_back(obs);   //  原先没有：创建并加入；原先有：加入</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,list&lt;Observer*&gt;&gt; ::iterator iter = m_subMap.<span class="built_in">find</span>(msg);</span><br><span class="line">        <span class="keyword">if</span>(iter==m_subMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            m_subMap.insert(&#123;msg,list&lt;Observer*&gt;&#123;obs&#125;&#125;);</span></span><br><span class="line">            list&lt;Observer*&gt; l;</span><br><span class="line">            l.<span class="built_in">push_back</span>(obs);</span><br><span class="line">            m_subMap.<span class="built_in">insert</span>(&#123;msg,l&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_subMap[msg].<span class="built_in">push_back</span>(obs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  检测发生改变，通知相应观察者对象处理事件</span></span><br><span class="line">    <span class="comment">//  msg：要改变的对象（这里用int代替，实际上会是一个事件对象，对象内部的属性发生改变）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="keyword">int</span> msg)</span>       <span class="comment">//   派遣</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = m_subMap.<span class="built_in">find</span>(msg);</span><br><span class="line">        <span class="keyword">if</span>(iter==m_subMap.<span class="built_in">end</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Observer *obs : iter-&gt;second)</span><br><span class="line">        &#123;</span><br><span class="line">            obs-&gt;<span class="built_in">handler</span>(msg);  <span class="comment">//  处理变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,list&lt;Observer*&gt; &gt; m_subMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject s;</span><br><span class="line">    Observer1 obs1;</span><br><span class="line">    Observer2 obs2;</span><br><span class="line">    Observer3 obs3;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs1,<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs1,<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs2,<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs3,<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs3,<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs3,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;几号事件发生改变&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        s.<span class="built_in">dispatch</span>(ch);     <span class="comment">//  主体通知事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">鍑犲彿浜嬩欢鍙戠敓鏀瑰彉</span><br><span class="line"><span class="number">7</span></span><br><span class="line">鍑犲彿浜嬩欢鍙戠敓鏀瑰彉</span><br><span class="line"><span class="number">1</span></span><br><span class="line">Observer1 recv <span class="number">1</span> msg</span><br><span class="line">Observer2 recv <span class="number">1</span> msg</span><br><span class="line">Observer3 recv <span class="number">1</span> msg</span><br><span class="line">鍑犲彿浜嬩欢鍙戠敓鏀瑰彉</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Observer1 recv <span class="number">2</span> msg</span><br><span class="line">Observer3 recv <span class="number">2</span> msg</span><br><span class="line">鍑犲彿浜嬩欢鍙戠敓鏀瑰彉</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Observer3 recv <span class="number">3</span> msg</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>轮子-nginx内存池</title>
    <url>/2022/04/22/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0/</url>
    <content><![CDATA[<p>nginx内存池原理</p>
<!---more--->


<h1 id="轮子-nginx内存池"><a href="#轮子-nginx内存池" class="headerlink" title="轮子-nginx内存池"></a>轮子-nginx内存池</h1><ul>
<li>内存池中分为大内存block和小内存block</li>
<li>大内存block的头信息在小内存块中。大内存块头信息通过链表连接起来。</li>
</ul>
<p><img src="/2022/04/22/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-29-10-55-50.png"></p>
<h2 id="内存池结构"><a href="#内存池结构" class="headerlink" title="内存池结构"></a>内存池结构</h2><blockquote>
<p><img src="/2022/04/22/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-10-40-03.png"></p>
</blockquote>
<h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><ul>
<li>内存池<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;                <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;              <span class="comment">//  p-&gt;max：一个Block块内最多能分配多大的小内存。其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095              </span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* current;                    <span class="comment">//  指向当前内存块</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;                <span class="comment">//  大内存Block头信息的链表入口</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* cleanup;            <span class="comment">//  外部资源的头信息链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="小内存Block-头信息"><a href="#小内存Block-头信息" class="headerlink" title="小内存Block 头信息"></a>小内存Block 头信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  小内存池头信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char               *last;             <span class="comment">//  可用内存起始</span></span><br><span class="line">    u_char               *end;              <span class="comment">//  内存末尾</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *next;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;           <span class="comment">//  分配内存是否成功</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>            <span class="title">ngx_pool_t</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="大内存Block-头信息"><a href="#大内存Block-头信息" class="headerlink" title="大内存Block 头信息"></a>大内存Block 头信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  大内存池头信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *next;</span><br><span class="line">    <span class="keyword">void</span>                 *alloc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="外部资源-头信息"><a href="#外部资源-头信息" class="headerlink" title="外部资源  头信息"></a>外部资源  头信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;</span><br><span class="line">    <span class="keyword">void</span>                 *data;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>     <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>   <span class="title">ngx_pool_cleanup_t</span></span></span><br></pre></td></tr></table></figure>


<h3 id="一些宏"><a href="#一些宏" class="headerlink" title="一些宏"></a>一些宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_DEFAULT_POOL_SIZE    (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MIN_POOL_SIZE                                                     \</span></span><br><span class="line"><span class="meta">    ngx_align((sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t)),            \</span></span><br><span class="line"><span class="meta">              NGX_POOL_ALIGNMENT)</span></span><br></pre></td></tr></table></figure>


<h2 id="创建内存池-ngx-create-pool"><a href="#创建内存池-ngx-create-pool" class="headerlink" title="创建内存池 ngx_create_pool"></a>创建内存池 ngx_create_pool</h2><h3 id="ngx-create-pool"><a href="#ngx-create-pool" class="headerlink" title="ngx_create_pool"></a>ngx_create_pool</h3><ul>
<li>创造的是一个内存Block，从操作系统malloc而来。是打头的那个。有完整的ngx_pool_t，记录了整个内存池的信息。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  size：内存池大小（实际可以使用的比size小）</span></span><br><span class="line"><span class="comment">//  log：日志</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  开辟内存池。依据平台调用相应函数</span></span><br><span class="line">    <span class="comment">//  ngx_pool_t + 自由内存</span></span><br><span class="line">    p = <span class="built_in">ngx_memalign</span>(NGX_POOL_ALIGNMENT, size, log);    </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);      <span class="comment">//  内存池起始</span></span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;                     <span class="comment">//  内存池末尾</span></span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;                                   <span class="comment">//  下一个小内存block</span></span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;                                    <span class="comment">//  当前内存块分配内存失败次数</span></span><br><span class="line"></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);                   <span class="comment">//  内存Block实际能使用的大小。整个内存池大小size - 内存池头信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  p-&gt;max：一个Block块内最多能分配多大的小内存。</span></span><br><span class="line">        <span class="comment">//  其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095</span></span><br><span class="line">    <span class="comment">//  p-&gt;max = min(size,4095)</span></span><br><span class="line">    <span class="comment">//  max不超过一个页面的大小</span></span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;log = log;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ngx-memalign"><a href="#ngx-memalign" class="headerlink" title="ngx_memalign"></a>ngx_memalign</h3></li>
<li>向操作系统malloc内存</li>
<li><code>ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)</code>：<ul>
<li>开辟内存池（size和log参数起作用），并根据平台选择是否内存对齐（alignment参数起作用）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux has memalign() or posix_memalign()</span></span><br><span class="line"><span class="comment"> * Solaris has memalign()</span></span><br><span class="line"><span class="comment"> * FreeBSD 7.0 has posix_memalign(), besides, early version&#x27;s malloc()</span></span><br><span class="line"><span class="comment"> * aligns allocations bigger than page size at the page boundary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  根据平台选择是否内存对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span>;  <span class="comment">//  进行内存对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memalign(alignment, size, log)  ngx_alloc(size, log)    <span class="comment">//  ngx_alloc(size,log) 不进行内存对齐</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//  ngx_alloc：就是malloc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">// void *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log);  //  内存对齐的malloc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    <span class="keyword">int</span>    err;</span><br><span class="line">    err = <span class="built_in">posix_memalign</span>(&amp;p, alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, err,</span><br><span class="line">                      <span class="string">&quot;posix_memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug3</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;posix_memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (NGX_HAVE_MEMALIGN)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    p = <span class="built_in">memalign</span>(alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug3</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="内存Block分配-ngx-palloc"><a href="#内存Block分配-ngx-palloc" class="headerlink" title="内存Block分配 ngx_palloc"></a>内存Block分配 ngx_palloc</h2><ul>
<li>小块内存分配、大块内存分配</li>
<li>ngx_palloc 考虑了内存对齐<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line"><span class="comment">//  分配小块内存（优先从内存池分配，如果没有，再新开辟ngx_memalign）</span></span><br><span class="line"><span class="comment">//  size：上级要请求的</span></span><br><span class="line"><span class="comment">//  pool-&gt;max block块内空闲内存的上限</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(pool, size, <span class="number">1</span>); <span class="comment">//  指针 ，大小 ，1:对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//  分配大块内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ngx-palloc-small-小块内存分配"><a href="#ngx-palloc-small-小块内存分配" class="headerlink" title="ngx_palloc_small 小块内存分配"></a>ngx_palloc_small 小块内存分配</h3><ul>
<li><p>从操作系统开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用memalign。</p>
</li>
<li><p><strong>效率极高</strong>：如何分配内存：通过移动last指针分配内存。将移出的size内存返回给上级</p>
</li>
<li><p><img src="/2022/04/22/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-55-14.png"></p>
</li>
<li><p><img src="/2022/04/22/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-55-41.png"></p>
</li>
<li><p>ngx_palloc_small</p>
<ul>
<li>先尝试用已有的内存池中拿出size大小的内存块，当内存池里没有可分配的满足size大小的内存块时，再ngx_palloc_block开辟新block块。从block里拿出size大小的内存返回给上级。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line">        <span class="keyword">if</span> (align) &#123;    <span class="comment">//  如果要求对齐</span></span><br><span class="line">            m = <span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT);    <span class="comment">//  内存对齐：把指针调整到平台相关的4/8倍数。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  内存池的空闲内存大于要申请的内存</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            <span class="comment">//  m指针偏移size字节，即内存池给应用程序分配内存</span></span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  如果本block块剩余的不够size，那么顺着p-&gt;d.next向下走到第二个内存块block。</span></span><br><span class="line">        p = p-&gt;d.next;      </span><br><span class="line">    &#125; <span class="keyword">while</span> (p);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  从pool-&gt;current开始 遍历完了 所有的block，也没找到够用的空闲内存</span></span><br><span class="line">    <span class="comment">//  那么就只能新开辟block</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span>(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>ngx_palloc_block<ul>
<li>原有内存池内存不够，分配新的内存块加入内存池<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p, *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (pool-&gt;d.end - (u_char *) pool);   <span class="comment">//  Block大小</span></span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">ngx_memalign</span>(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = (<span class="keyword">ngx_pool_t</span> *) m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span>-&gt;d.end = m + psize;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT);</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  由于进入到这个函数必然意味着之前的block都分配内存失败</span></span><br><span class="line">    <span class="comment">//  所以要把前几个block的fail次数都++;</span></span><br><span class="line">    <span class="comment">//  当一个block了=块分配内存失败次数</span></span><br><span class="line">    <span class="comment">//  当一个block块失败次数&gt;4之后，就认为这块Block的剩余内存已经很少，之后请求小内存时就不从这块Block开始请求</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>ngx_free 释放大块内存<br>小块内存不释放</p>
<h3 id="ngx-palloc-large-大内存块分配"><a href="#ngx-palloc-large-大内存块分配" class="headerlink" title="ngx_palloc_large 大内存块分配"></a>ngx_palloc_large 大内存块分配</h3><ul>
<li><p>从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</p>
</li>
<li><p><img src="/2022/04/22/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-54-56.png"></p>
</li>
<li><p>malloc大块内存用于存储数据；从小内存池申请一块内存用作大内存池头信息；维护大内存池链表；将本次malloc的大块内存全部返回给上级使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>              *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  malloc大块内存；不进行字节对齐</span></span><br><span class="line">    p = <span class="built_in">ngx_alloc</span>(size, pool-&gt;log);     </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  以pool-&gt;large为起始 遍历大内存池头信息节点</span></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//  如果遍历到的这块大内存池节点的头信息的alloc==nullptr</span></span><br><span class="line">        <span class="comment">//  意味着并这个ngx_pool_large_t没有管理一块大内存。</span></span><br><span class="line">        <span class="comment">//  所以直接由他管理</span></span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  为了效率</span></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  向小内存池申请一段内存用作大内存池头信息</span></span><br><span class="line">    large = <span class="built_in">ngx_palloc_small</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;    <span class="comment">//  没申请来就放弃本次操作</span></span><br><span class="line">        <span class="built_in">ngx_free</span>(p);    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  将大内存池头插法插入large起始的链表中</span></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ngx_alloc() 分配大块内存，不进行内存对齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ngx_free()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_free          free</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="大小内存Block的重置-ngx-reset-pool"><a href="#大小内存Block的重置-ngx-reset-pool" class="headerlink" title="大小内存Block的重置 ngx_reset_pool"></a>大小内存Block的重置 ngx_reset_pool</h2><ul>
<li><code>nginx</code>大块内存block通过<code>malloc</code>分配  <ul>
<li>大块内存：通过<code>free</code>释放</li>
</ul>
</li>
<li><code>nginx</code>小内存通过在内存池（的一个小内存块）中移动last指针来实现内存分配<ul>
<li>小块内存：无<code>free</code>释放，只是通过移动last指针来重置</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_reset_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>        *p;   <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;   <span class="comment">//  大内存Block的头信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  大块内存 free掉</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  小块内存 不释放。只是移动指针。</span></span><br><span class="line">        <span class="comment">//  因为从实现方式上来看，就释放不了。我们通过移动last指针来分配内存。可能我们要释放2号内存，但是我们只有last和end的两个指针，且last指向5号内存。</span></span><br><span class="line">        <span class="comment">//  从nginx的功能来看，也无需释放。</span></span><br><span class="line">    <span class="comment">// for (p = pool; p; p = p-&gt;d.next) &#123;</span></span><br><span class="line">    <span class="comment">//     p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);</span></span><br><span class="line">    <span class="comment">//     p-&gt;d.failed = 0;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    p = pool;</span><br><span class="line">    p-&gt;d.last = (u_char*)p+<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=p-&gt;d.next;p;p=p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;d.last = (u_char*)p+<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重置首块内存Block中用于管理所有内存Block的</span></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="释放指定大内存块-ngx-pfree"><a href="#释放指定大内存块-ngx-pfree" class="headerlink" title="释放指定大内存块 ngx_pfree"></a>释放指定大内存块 ngx_pfree</h2><ul>
<li>释放指定大内存块<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_int_t</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_pfree</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="为什么reset-pool中nginx内存池的小内存块不free释放？？"><a href="#为什么reset-pool中nginx内存池的小内存块不free释放？？" class="headerlink" title="为什么reset_pool中nginx内存池的小内存块不free释放？？"></a><strong>为什么reset_pool中nginx内存池的小内存块不free释放？？</strong></h2><ul>
<li>因为没有free小块内存的接口。</li>
<li>所以只能移动last指针<h3 id="1-为什么没free接口"><a href="#1-为什么没free接口" class="headerlink" title="1. 为什么没free接口"></a>1. 为什么没free接口</h3></li>
<li>首先nginx内存池的没办法回收针对某一特定小内存块进行free回收。 <ul>
<li>因为从实现方式上来看，就释放不了。我们通过移动last指针来分配内存。可能我们要释放2号内存，但是我们只有last和end的两个指针，且last指向3号下的free内存。那么如果移动last到2那里然后free，那么就会把3也free掉</li>
<li><blockquote>
<p><img src="/2022/04/22/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-18-47-48.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>因此</strong>nginx<strong>没有提供</strong>free回收小块内存的接口函数</li>
<li>所以重置时我们只能通过移动last指针来表示哪些内存是空闲内存</li>
</ul>
<h3 id="2-为什么移动last可以"><a href="#2-为什么移动last可以" class="headerlink" title="2. 为什么移动last可以"></a>2. 为什么移动last可以</h3><ul>
<li>那么在释放内存时为什么移动last就可以。这样能表明装有没用数据的内存是空闲的，不害怕有用的内存被覆盖吗？</li>
<li>当<code>reset_pool</code>时，不会有有用的内存块。因为我们是短连接。</li>
<li><code>nginx</code>本质：<code>http</code>服务器。<strong>短连接、间歇性。</strong><ul>
<li>client向nginx server发送请求后，nginx处理完请求，并发送完response响应后；即一次服务处理完后，就主动和客户端断开tcp连接，该次连接的资源就都可以释放了。（server就像和client端没见过面一样。之前的东西都不必再保留，一干二净。）</li>
<li><strong>所以，当nginx server 处理完一次请求后，就可以调用<code>ngx_reset_pool</code>，free大块内存；将小块内存的last指针回退，等待下次覆盖。</strong></li>
</ul>
</li>
<li>而<strong>长连接</strong>不论client是否发来请求，server和client是不能断开的。也即处理完请求后，连接也不能断开，资源也不允许释放，直到系统资源耗尽。长连接的这种server应该用SGI STL的二级空间配置器中的内存池。？？？？？？<ul>
<li>长连接举例：<code>http1.1 keep-alive = 60s</code>，即http服务器返回响应后，需等待<code>60s</code>。如果这段时间之内客户端又发来请求，那么重置等待时间。如果没发来请求，那么就断开连接。</li>
</ul>
</li>
<li>以上关于nginx用于短连接的场景我可以理解。不过他为什么不能用于长连接？我只写过短连接的webserver，还没写过长连接的。等写了长连接的server应该就能理解了吧。</li>
<li><strong><a href="https://www.jianshu.com/p/3fc3646fad80">长连接短连接</a></strong></li>
<li><a href="https://www.jianshu.com/p/734ef8e5a712">nginx服务器入门</a></li>
</ul>
<h2 id="nginx内存池和sgi-stl二级空间配置器"><a href="#nginx内存池和sgi-stl二级空间配置器" class="headerlink" title="nginx内存池和sgi stl二级空间配置器"></a>nginx内存池和sgi stl二级空间配置器</h2><ul>
<li>nginx对于小块内存的分配效率绝对比sgi stl二级空间配置器高，因为nginx只需要移动指针。</li>
<li>nginx无法释放小块内存。sgi stl 小块和大块都释放。<ul>
<li>故nginx适用于短连接Web服务器（http服务器）。sgi stl适用于长连接服务器。</li>
</ul>
</li>
</ul>
<h2 id="内存池外部资源释放"><a href="#内存池外部资源释放" class="headerlink" title="内存池外部资源释放"></a>内存池外部资源释放</h2><h3 id="外部资源信息头"><a href="#外部资源信息头" class="headerlink" title="外部资源信息头"></a>外部资源信息头</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;</span><br><span class="line">    <span class="keyword">void</span>                 *data;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>     <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>   <span class="title">ngx_pool_cleanup_t</span></span></span><br></pre></td></tr></table></figure>

<h3 id="内存池外部资源释放-1"><a href="#内存池外部资源释放-1" class="headerlink" title="内存池外部资源释放"></a>内存池外部资源释放</h3><p><img src="/2022/04/22/%E8%BD%AE%E5%AD%90-nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-29-10-59-23.png"></p>
<h4 id="对于cleanup-add的使用有两种方式"><a href="#对于cleanup-add的使用有两种方式" class="headerlink" title="对于cleanup_add的使用有两种方式"></a>对于cleanup_add的使用有两种方式</h4><ul>
<li><ol>
<li>一种是给c-&gt;data开辟一块内存，然后把外部资源拷贝进去。之后destroy中c-&gt;handler(void*p)</li>
</ol>
<ul>
<li><code>ngx_pool_cleanup_t * c = ngx_pool_cleanup_add(pool,sizeof(x))</code></li>
<li>感觉适用于一个这块内存里很多指针管理很多外部资源，可以省去挨个设置外部资源信息头以及回调函数。</li>
</ul>
</li>
<li><ol start="2">
<li>一种是不给c-&gt;data开辟内存，直接让c-&gt;data指向要释放的内存。</li>
</ol>
<ul>
<li><code>ngx_pool_cleanup_t * c = ngx_pool_cleanup_add(pool,0)</code></li>
</ul>
</li>
<li>我觉得在一块申请的内存中由很多指针管理外部资源时，【第一种优于第二种】。<ul>
<li>相较于【第二种不拷贝方法】单独为 每个指针管理的外部资源都设置一个外部资源信息头，以及一个释放的回调函数；不如【第一种方法】只设置一个回调函数和一个信息头。将这些外部资源拷贝到一块内存中，然后将这块内存传入即可。这样就可以用一个信息头，一个回调函数，即可释放多个资源。</li>
</ul>
</li>
</ul>
<h4 id="源码论证"><a href="#源码论证" class="headerlink" title="源码论证"></a>源码论证</h4><ul>
<li>第【1】种<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  结构体</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">ngx_fd_t</span>              fd;</span><br><span class="line">        u_char               *name;</span><br><span class="line">        <span class="keyword">ngx_log_t</span>            *log;</span><br><span class="line">    &#125; <span class="keyword">ngx_pool_cleanup_file_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  为c-&gt;data开辟内存</span></span><br><span class="line">    cln = <span class="built_in">ngx_pool_cleanup_add</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_file_t</span>));</span><br><span class="line">    ....</span><br><span class="line">    cln-&gt;handler = clean ? ngx_pool_delete_file : ngx_pool_cleanup_file;</span><br><span class="line">    <span class="comment">//  将管理的资源地址拷贝到c-&gt;data指向的内存</span></span><br><span class="line">    clnf = cln-&gt;data;</span><br><span class="line">    clnf-&gt;fd = file-&gt;fd;</span><br><span class="line">    clnf-&gt;name = file-&gt;name.data;</span><br><span class="line">    clnf-&gt;log = pool-&gt;log;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  预制的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_pool_delete_file</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data;</span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, c-&gt;log, <span class="number">0</span>, <span class="string">&quot;file cleanup: fd:%d %s&quot;</span>,</span><br><span class="line">                   c-&gt;fd, c-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ngx_delete_file</span>(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ngx_close_file</span>(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第【2】种<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  不申请内存</span></span><br><span class="line">cln = <span class="built_in">ngx_pool_cleanup_add</span>(r-&gt;pool, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (cln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  直接将地址给cln-&gt;data</span></span><br><span class="line">cln-&gt;handler = ngx_http_file_cache_cleanup;</span><br><span class="line">cln-&gt;data = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  预制回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_http_file_cache_cleanup</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_http_cache_t</span>  *c = data;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;updated) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug0</span>(NGX_LOG_DEBUG_HTTP, c-&gt;file.log, <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;http file cache cleanup&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;updating &amp;&amp; !c-&gt;background) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_http_file_cache_free</span>(c, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>cleanup_add功能概述：通过预置回调函数，实现c++中对象析构的功能。也即释放内存。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_pool_cleanup_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    <span class="comment">//  从小内存block中 分配一块内存用作ngx_pool_cleanup_t</span></span><br><span class="line">    c = <span class="built_in">ngx_palloc</span>(p, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  看用户是怎么调用的</span></span><br><span class="line">        <span class="comment">//  size&gt;0 从内存池中申请一块内存。用作之后用户将外部资源拷贝到这里</span></span><br><span class="line">        <span class="comment">//  size=0 不申请内存。用户直接将c-&gt;data = 外部资源地址</span></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span>(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, p-&gt;log, <span class="number">0</span>, <span class="string">&quot;add cleanup: %p&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内存池销毁"><a href="#内存池销毁" class="headerlink" title="内存池销毁"></a>内存池销毁</h3><ul>
<li>先遍历链表执行外部资源的释放操作；再遍历链表执行释放大块内存的操作；再遍历链表重置小块内存Block   </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    <span class="comment">//  遍历外部资源信息头链表， 调用预设置的回调函数handler，释放外部资源。</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;run cleanup: %p&quot;</span>, c);</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;free: %p, unused: %uz&quot;</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历大块内存信息头，释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历小块内存信息头，释放小块内村</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">ngx_free</span>(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><ul>
<li>环境：ubuntu 18.04 ； nginx-1.12.2 ；工具：Source Insigh4.0</li>
<li>指令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line">gcc -o ngx_testpool ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br></pre></td></tr></table></figure></li>
<li><code>void *memcpy(void *des, const void *src, size_t n)</code><ul>
<li>将src指向的内存中的内容逐字节的拷贝到des指向的内存<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span>* q = &amp;b;	<span class="comment">//  q不能=null！因为是要把p指向的内存的内容拷贝到q的内存里。q如果是null则error</span></span><br><span class="line">	<span class="built_in">memcpy</span>(q, p, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">	cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00000021</span>ACF5F904</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">00000021</span>ACF5F8E4</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ngx_testpool.c<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span><span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *log, <span class="keyword">ngx_err_t</span> err,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//  多个指针</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">    <span class="keyword">char</span> *ptr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">yData</span> <span class="title">yData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler\n&quot;</span>);</span><br><span class="line">    stData *q = (stData*) p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(q-&gt;pfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler_02</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *q = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler_02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. ngx_create_pool 造内存池</span></span><br><span class="line">        <span class="comment">//  第一块内存Block。里面有完整的ngx_pool_t</span></span><br><span class="line">        <span class="comment">// ngx_pool_t::max = min(512 - sizeof(ngx_pool_t) , 4095)     </span></span><br><span class="line">        <span class="keyword">ngx_pool_t</span> *pool = <span class="built_in">ngx_create_pool</span>(<span class="number">512</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(pool == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_create_pool fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 小块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请小块内存</span></span><br><span class="line">        stData *p1 = <span class="built_in">ngx_palloc</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(yData)); <span class="comment">// 从小块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 128 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  小块内存保存的指针管理的外部资源</span></span><br><span class="line">        p1-&gt;ptr = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        p1-&gt;pfile = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        p1-&gt;ptr2 = <span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr2, <span class="string">&quot;hhhh&quot;</span>);</span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span> *c1 = <span class="built_in">ngx_pool_cleanup_add</span>(pool,<span class="built_in"><span class="keyword">sizeof</span></span>(yData));     <span class="comment">//  开辟内存，用于handler传参</span></span><br><span class="line">        c1-&gt;handler = self_handler;</span><br><span class="line">        <span class="built_in">memcpy</span>(c1-&gt;data,p1,<span class="built_in"><span class="keyword">sizeof</span></span>(yData));                                      <span class="comment">//  用户只负责拷贝！！将外部资源拷贝一下到c1-&gt;data。将p1指针指向的内容逐字节拷贝到c-&gt;data指向的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 大块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请大块内存</span></span><br><span class="line">        yData *p2 = <span class="built_in">ngx_palloc</span>(pool, <span class="number">512</span>); <span class="comment">// 从大块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 512 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  外部资源</span></span><br><span class="line">        p2-&gt;ptr = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p2-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span> *c2 = <span class="built_in">ngx_pool_cleanup_add</span>(pool,<span class="number">0</span>);                   <span class="comment">//  不开辟内存，直接让c-&gt;data指向要释放的内存</span></span><br><span class="line">        c2-&gt;handler = self_handler_02;</span><br><span class="line">        c2-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放内存池</span></span><br><span class="line">    <span class="built_in">ngx_destroy_pool</span>(pool); <span class="comment">// 1.调用所有的预置的清理函数 2.释放大块内存 3.释放小块内存池所有内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ gcc -o ngx_testpool.out ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ ./ngx_testpool.out </span><br><span class="line">self_handler_02</span><br><span class="line">free ptr mem!</span><br><span class="line">self_handler</span><br><span class="line">free ptr mem!</span><br><span class="line">free ptr mem!</span><br><span class="line">close file!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存对齐好处"><a href="#内存对齐好处" class="headerlink" title="内存对齐好处"></a>内存对齐好处</h2><ul>
<li>较少cpu的IO次数</li>
<li>内存对齐博客待完善</li>
</ul>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><ul>
<li>gcc -g 生成的可执行文件可以调试</li>
<li>gdb …out   </li>
<li>start 开始一行一行运行</li>
<li>n 下一行</li>
<li>s（step）进入函数</li>
<li>finish 跳出函数</li>
<li>quit 退出</li>
<li>l 当前附近代码</li>
</ul>
<h2 id="轮子-nginx内存池不足（我认为）"><a href="#轮子-nginx内存池不足（我认为）" class="headerlink" title="轮子-nginx内存池不足（我认为）"></a>轮子-nginx内存池不足（我认为）</h2><ul>
<li>链表管理<ul>
<li>链表的查找遍历时间复杂度是 O(n)。ngx_pfree 效率不高</li>
</ul>
</li>
<li>小内存块链表，current 问题：<ul>
<li>当遇到密集地分配比较大的小内存场景时，导致已分配结点，分配失败，failed 次数增加。current 指向新的结点，由于是单向链表，前面的结点其实还有足够的空闲空间分配给其它小内存的，导致空闲空间利用率不高。</li>
</ul>
</li>
<li>ngx_reset_pool中没有释放外部资源。需要等到destroy时才可以释放。</li>
<li>ngx_reset_pool中，在重置小块内村的last指针时，有一部分没有重置，造成内存碎片。</li>
</ul>
<h2 id="我"><a href="#我" class="headerlink" title="我?"></a>我?</h2><ul>
<li>移植之后解决了ngx_reset_pool中没有释放外部资源的问题</li>
<li>解决了reset中last指针的问题。</li>
</ul>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>轮子</tag>
        <tag>源码</tag>
      </tags>
  </entry>
</search>
