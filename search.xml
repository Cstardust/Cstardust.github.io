<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux-mmap</title>
    <url>/2022/05/10/Linux-mmap/</url>
    <content><![CDATA[<p>Memory Mapped Files<br>什么是 mmap<br>mmap 全称 Memory Mapped Files，是一种内存文件映射的方法，将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中的一段虚拟地址的一一映射关系，映射关系生成之后，用户进程可以通过指针操作内存中的文件数据，系统会自动将操作后的数据写入到磁盘中，而不需要调用 read(),write()等系统调用来操作数据。</p>
<p><a href="https://blog.csdn.net/yetaibing1990/article/details/85008702">mmap共享内存</a><br><a href="https://www.cnblogs.com/huxiao-tee/p/4657851.html">好！从内核文件系统看文件读写过程</a> </p>
<p><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html#4008787">mmap共享内存</a></p>
<p><a href="https://mp.weixin.qq.com/s/HZFbPxaEC0rwA98qp9MZcw">好博客</a></p>
<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzIyNjMxOTY0NA==&action=getalbum&album_id=1359683016842608641&scene=173&from_msgid=2247487574&from_itemidx=1&count=3&nolastread=1#wechat_redirect">看</a></p>
<p><a href="https://xie.infoq.cn/article/1b9e202c9210305cc9ba07c39#:~:text=mmap%20%E5%85%A8%E7%A7%B0%20Memory%20Mapped,Files%EF%BC%8C%E6%98%AF%E4%B8%80%E7%A7%8D%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E8%80%85%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E5%88%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98%E5%9C%B0%E5%9D%80%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E4%B8%80%E6%AE%B5%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%9A%84%E4%B8%80%E4%B8%80%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E7%94%9F%E6%88%90%E4%B9%8B%E5%90%8E%EF%BC%8C%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%B0%E7%A3%81%E7%9B%98%E4%B8%AD%EF%BC%8C%E8%80%8C%E4%B8%8D%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8%20read%20%28%29%2Cwrite%20%28%29%E7%AD%89%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9D%A5%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E3%80%82">博客</a></p>
]]></content>
      <categories>
        <category>待做</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-三级映射</title>
    <url>/2021/12/03/Linux-%E4%B8%89%E7%BA%A7%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>Linux三级映射（待做）</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP(预习)</title>
    <url>/2022/04/10/HTTP/</url>
    <content><![CDATA[<ul>
<li>密码系统：算法+密钥组成。明文和密钥是原材料，算法是加工的方式，产出的就是密文。</li>
<li>密钥是要保密的。密码算法不用保密。因为密码算法终究hui’bei’po’jie，不能依赖保密算法提高安全性。</li>
<li><strong>对称加密</strong>：发送和接收方共用同一套密钥。<a href="https://zhuanlan.zhihu.com/p/436455172">对称密钥</a></li>
<li><strong>非对称加密</strong>：发送方和接受方各自设定一套私钥和公钥。<a href="https://zhuanlan.zhihu.com/p/436455172">非对称密钥</a><ul>
<li>使用对方的提供的公钥来进行加密，加密发送给对方后，对方有私钥负责解密。公钥是之前就互相提供给对方的，<br><img src="/2022/04/10/HTTP/2022-04-10-09-55-20.png"></li>
</ul>
</li>
<li><strong>混合加密</strong>：对称加密和非对称加密结合<ul>
<li>通信建立前：采用<strong>非对称加密方式</strong>交换<em>会话密钥</em>，后续就不再使用非对称加密</li>
<li>通信过程：通信过程中全部使用<strong>对称加密</strong>的<em>会话密钥</em>的方式</li>
<li><a href="https://www.cnblogs.com/r1-12king/p/15880436.html#:~:text=%E5%AE%83%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AF%86%E9%92%A5%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%8F%AB%E2%80%9C%E5%85%AC%E9%92%A5%E2%80%9D%EF%BC%88public,key%EF%BC%89%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%8F%AB%E2%80%9C%E7%A7%81%E9%92%A5%E2%80%9D%EF%BC%88private%20key%EF%BC%89%E3%80%82">暴力加密</a></li>
</ul>
</li>
</ul>
<h2 id="HTTPS通信"><a href="#HTTPS通信" class="headerlink" title="HTTPS通信"></a>HTTPS通信</h2><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https">记录</a></p>
<ul>
<li>http由于明文传输，所以存在以下问题<ul>
<li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li>篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎</li>
<li>冒充风险，比如冒充淘宝网站，用户钱容易没</li>
</ul>
</li>
<li>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：<br><img src="/2022/04/10/HTTP/2022-04-10-12-00-59.png"><ul>
<li>信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li>校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li>身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
</li>
<li>可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。</li>
<li>HTTPS 是如何解决上面的三个风险的？<ul>
<li><strong>混合加密</strong>的方式实现信息的机密性，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
</li>
<li>HTTPS 是如何建立连接的？其间交互了什么？<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
<li>前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。</li>
</ul>
</li>
<li>SSL/TLS 的「握手阶段」涉及四次通信，可见下图：</li>
</ul>
<p><img src="/2022/04/10/HTTP/2022-04-10-11-30-05.png"><br>cipher 密码<br>spec 规格</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ClientHello</span><br><span class="line"></span><br><span class="line">首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</span><br><span class="line"></span><br><span class="line">在这一步，客户端主要向服务器发送以下信息：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）客户端支持的 SSL/TLS 协议版本，如 TLS <span class="number">1.2</span> 版本。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）客户端支持的密码套件列表，如 RSA 加密算法。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> SeverHello</span><br><span class="line"></span><br><span class="line">服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）确认的密码套件列表，如 RSA 加密算法。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）服务器的数字证书。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>客户端回应</span><br><span class="line"></span><br><span class="line">客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</span><br><span class="line"></span><br><span class="line">如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</span><br><span class="line"></span><br><span class="line">上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 服务器的最后回应</span><br><span class="line"></span><br><span class="line">服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</span><br><span class="line"></span><br><span class="line">至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</span><br></pre></td></tr></table></figure>


<p><strong><a href="https://www.jianshu.com/p/3fc3646fad80">长连接短连接</a></strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-守护进程</title>
    <url>/2021/12/02/Linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>Linux守护进程</p>
<span id="more"></span>

<ul>
<li>参考APUE、<a href="https://www.cnblogs.com/ybf-yyj/p/9104412.html">博客园</a></li>
</ul>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul>
<li>&amp;<ul>
<li><code>./a.out &amp;</code> ：释放对终端的占用。在后台运行</li>
</ul>
</li>
<li>jobs<ul>
<li>列出在后台运行的进程：<code>running stopped terminated</code>。jobs -l可以列出pid</li>
</ul>
</li>
<li>ctrl + z  挂起<ul>
<li>用户终端向正在运行中的由该终端启动的程序发出SIGTSTP信号。默认动作为暂停进程（并未结束）。并将该进程放到后台。（停止终端交互进程的运行。）</li>
</ul>
</li>
<li>bg<ul>
<li>启动在后台暂停的进程，并使得其在后台运行。</li>
<li>如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)</li>
<li>将任务转移到后台运行：先ctrl + z；再bg，这样进程就被移到后台运行，终端还能继续接受命令。</li>
</ul>
</li>
<li>fg<ul>
<li><code>fg %jobnum</code>将在后台暂停/运行的进程，调到前台来，使其占据终端。</li>
</ul>
</li>
<li>ctrl + c 终止<ul>
<li>用户终端向正在运行中的由该终端启动的程序发出SIGINT信号。默认动作为终止进程。</li>
</ul>
</li>
<li>ctrl + \ 退出<ul>
<li>用户终端向正在运行中的由该终端启动的程序发出SIGQUIT。默认动作为终止进程。</li>
</ul>
</li>
<li>ctrl + d<ul>
<li>输入文件结束符EOF</li>
</ul>
</li>
<li>pstree<ul>
<li>查看进程树</li>
</ul>
</li>
<li>概念：当前任务<ul>
<li>如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]” 的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”和“stop”等命令时，如果不加任何引号，则所变动的均是当前任务</li>
</ul>
</li>
<li>参考<a href="https://www.cnblogs.com/ybf-yyj/p/9104412.html">博客园</a></li>
</ul>
<h2 id="进程组与会话"><a href="#进程组与会话" class="headerlink" title="进程组与会话"></a>进程组与会话</h2><ul>
<li>进程组是一堆相关进程的集合；会话是一堆相关进程组的集合。</li>
</ul>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><ul>
<li>进程组是一个或者多个进程的集合。通常他们在同一作业中结合起来。</li>
<li>同一进程组的各进程接收来自同一终端的各种信号。每个进程组有唯一的进程组ID。函数<code>pid_t getpgrp(void);</code>可以返回调用进程的进程组ID。</li>
<li>每个进程组有一个组长进程。<strong>进程组ID等于其组长进程的进程ID</strong></li>
<li>进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要进程组中有一个进程存在，那么这个进程组就存在，与组长进程是否终止无关。</li>
<li>进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组。<ul>
<li><code>int setpgid(pid_t pid,pid_t pgid)</code></li>
<li>该函数将pid进程的进程组号设置为pgid，如果pid=pgid，则该pid进程成为组长进程。如果pid=0，即为getpid()；pgid=0，即为pid作为进程组pgid。</li>
<li>成功0，失败-1。</li>
</ul>
</li>
<li>一个进程只能为他或者他的子进程设置组进程pgid。在它的子进程调用exec后，他就不再更改子进程的进程组ID<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ps ajx</span><br><span class="line">  PPID    PID   PGID    SID TTY       TPGID STAT   UID   TIME COMMAND</span><br><span class="line">     <span class="number">0</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span> ?            <span class="number">-1</span> Ss       <span class="number">0</span>   <span class="number">0</span>:<span class="number">03</span> /sbin/init splash</span><br><span class="line"></span><br><span class="line">PPID：是当前进程的父进程号。</span><br><span class="line"></span><br><span class="line">PID：进程的唯一标识。如果一个进程含有多个线程，所有线程调用 getpid 函数会返回相同的值。</span><br><span class="line"></span><br><span class="line">PGID：进程组 ID。每个进程都会有进程组 ID，表示该进程所属的进程组。默认情况下新创建的进程会继承父进程的进程组 ID。</span><br><span class="line"></span><br><span class="line">SID：会话 ID。每个进程也都有会话 ID。默认情况下，新创建的进程会继承父进程的会话 ID。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><ul>
<li>会话是一个或者多个进程组的集合。<br><img src="/2021/12/02/Linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/2021-12-02-14-09-28.png"></li>
<li><code>pid_t setsid(void);</code><ul>
<li>如果调用此函数的进程不是一个进程组组长，那么此函数创建一个新会话。<ul>
<li>该进程会变成新会话的会话首进程（会话首进程是创建该会话的进程）。此时，该进程是新会话中的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断。<ul>
<li>即会话首进程不占有控制终端。只有会话中的前台进程组才占有终端。！</li>
</ul>
</li>
</ul>
</li>
<li>如果该调用进程是一个进程组组长，则此函数返回出错。</li>
<li>所以通常先fork，使其父进程终止，而子进程继续，因为子进程继承父进程的进程组ID，而其进程ID是新分配的，两者不可能相等，这就保证了子进程不是一个进程组组长。</li>
</ul>
</li>
<li>Single UNIX 没有类似于进程组ID的会话ID，由于会话首进程是具有唯一进程ID的单个进程，所以可以将会话首进程的进程ID视为会话ID。</li>
<li>SVR4引入会话ID。<ul>
<li><code>pid_t getsid(pid_t pid);</code></li>
<li>返回pid进程的会话首进程的进程组ID。pid=0，则返回调用进程的。</li>
<li>若pid不属于调用者所在会话，那么就不能得到会话ID。</li>
</ul>
</li>
<li>尽量避免使用“会话ID”，而是称其为“会话首进程的进程组ID”。会话首进程总是一个进程组的组长进程，所以两者等价。</li>
</ul>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><ul>
<li>一般情况下 session 和终端是一对一的关系，当我们打开多个终端窗口时，实际上就创建了多个 session。</li>
<li><code>./a.out &amp;</code>。表示将命令放入后台执行。这样该命令对应的进程组即为后台进程组。</li>
<li>shell 中可以存在多个进程组，无论是前台进程组还是后台进程组，它们或多或少存在一定的联系，为了更好地控制这些进程组（或者称为作业），系统引入了会话的概念。</li>
<li><strong>会话（Session）的意义在于将很多的工作集中在一个终端，选取其中一个作为前台来直接接收终端的输入及信号，其他的工作则放在后台执行。</strong></li>
<li>以上几点参考<a href="https://rongweihe.github.io/">博客.io</a><br><img src="/2021/12/02/Linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/2021-12-02-14-31-39.png"></li>
<li>一个会话可以有一个控制终端（ controlling terminal）。这通常是我们在其上登录的终端设备（终端登录情况）或伪终端设备（网络登录情况）。</li>
<li>建立与控制终端连接的会话首进程，被称之为控制进程（controlling process）。</li>
<li><strong>一个会话的几个进程组可被分成一个前台进程组（foreground process group）以及一个或几个后台进程组（background process group）。</strong><ul>
<li>在任意时刻，可能同时存在多个后台进程组，但是不管什么时候都只能有一个前台进程组。</li>
</ul>
</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组则为后台进程组。</li>
<li>无论何时键入中断键（常常是DELETE或Ctrl - C）或退出键（常常是Ctrl - \），就会造成将中断信号或退出信号<strong>送至前台进程组的所有进程。</strong><ul>
<li><strong>只有在前台进程组中进程才能在控制终端读取输入</strong>。当用户在终端输入信号生成终端字符（如 ctrl+c、ctrl+z、ctr+\等）时，对应的信号只会发送给前台进程组。从前台进程组的输出也会显示在控制终端上。</li>
</ul>
</li>
<li>如果终端界面检测到调制解调器已经脱开连接，则将挂断信号送至控制进程（会话首进程。）</li>
</ul>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><ul>
<li>作业：几个进程的集合，通常是一个进程管道<ul>
<li><code>vim main.c</code><ul>
<li>在前台起到了只有一个进程组成的作业。</li>
</ul>
</li>
<li><code>pr *.c | lpr &amp;       。      make all &amp;</code><ul>
<li>在后台启动两个作业。后台运行。</li>
<li>使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组</li>
</ul>
</li>
</ul>
</li>
<li>以后补充。</li>
</ul>
<h2 id="守护（daemon）进程"><a href="#守护（daemon）进程" class="headerlink" title="守护（daemon）进程"></a>守护（daemon）进程</h2><ul>
<li>系统引导装入时启动，系统关闭时终止。</li>
<li>由于无控制终端，所以说是在后台运行的。</li>
</ul>
<ul>
<li>创建守护进程<ul>
<li>关键<ul>
<li>创建会话Session</li>
</ul>
</li>
<li>流程<ul>
<li>fork之后，父进程exit。<ul>
<li>进程组组长不能创建会话</li>
</ul>
</li>
<li>setsid子进程创建会话。<ul>
<li><code>pid_t setsid()</code></li>
<li>子进程成为新的会话的首进程</li>
<li>子进程成为一个新进程组的组长</li>
<li>子进程脱离控制终端，在后台运行</li>
</ul>
</li>
<li>chdir更改工作目录<ul>
<li><code>int chdir(const char *path);</code></li>
<li>root用户才有权限</li>
</ul>
</li>
<li>umask设置文件权限掩码<ul>
<li><code>mode_t umask(mode_t mask);</code></li>
<li>将文件模式创建屏蔽字设置为一个已知值。（通常为0）。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。</li>
</ul>
</li>
<li>关闭非必要文件描述符<ul>
<li>继承的打开文件不会用到，浪费系统资源，无法卸载</li>
</ul>
</li>
<li>某些进程打开/dev/null 赋值给 stdin ，stdout ，stderr。<ul>
<li><blockquote>
<p>任何一个试图读取标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程不予终端设备相关联，所以其输出无处显示，也无处从交互式用户那里接收输入。</p>
</blockquote>
</li>
<li><blockquote>
<p>即使守护进程是从交互式会话启动的，但是守护进程是在后台运行的，所以登录会话的终止不会影响守护进程。如果其他用户在同一终端设备上登录，我们不希望再该终端上见到守护进程的输出，用户也不期望他们在终端上的输入被守护进程读取。</p>
</blockquote>
</li>
<li><blockquote>
<p>APUE</p>
</blockquote>
</li>
</ul>
</li>
<li>开始执行守护进程核心工作守护进程退出处理程序模型</li>
</ul>
</li>
</ul>
</li>
<li><strong>问题？</strong><ul>
<li>守护进程处理SIGCHLD信号。</li>
<li><blockquote>
<p>处理SIGCHLD信号<br>处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果<strong>父进程不对残留信息进行处理</strong>，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程wait子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。</p>
</blockquote>
</li>
<li><code>signal(SIGCHLD,SIG_IGN);</code></li>
<li>SIG_IGN即我们不关心这个信号，系统也就懂了我们不关心它的死法。子进程死亡的话则直接释放资源即可。没死的话，也是忽略。</li>
<li>详情见进程–<code>wait</code>和信号–<code>SIGCHLD</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. fork，父进程exit。（为了创建会话）</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  2. setsid()创建会话。当前子进程成为会话首进程，接着成为新进程族的组长进程，并且没有控制终端</span></span><br><span class="line">    <span class="comment">//  为了满足dameon的”在后台运行” 。（由于会话首进程无控制终端，所以说是在后台运行的。）</span></span><br><span class="line">    pid = setsid();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>) </span><br><span class="line">        sys_err(<span class="string">&quot;pid error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  3. 改变工作目录。防止被卸载。</span></span><br><span class="line">    <span class="comment">//  为了满足daemon进程的“系统引导装入时启动，系统关闭时终止。”</span></span><br><span class="line">    <span class="comment">//  sudo 只有根目录才有权限切换</span></span><br><span class="line">    <span class="comment">//  并且我实验当前虚拟机关机重启之后那个dameon进程就没了</span></span><br><span class="line">    <span class="comment">//  感觉因为守护进程在系统引导装入时启动，系统关闭时终止。</span></span><br><span class="line">    <span class="comment">//  而如果是一个用户远程登陆linux系统的话，那么这个用户退出登陆之后，不会影响这个daemon进程</span></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(<span class="string">&quot;/root&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">       sys_err(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4.  改变权限</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  5.  关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  6.  打开null，重定向文件描述符号</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);   <span class="comment">//  模拟守护进程业务</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ sudo ./daemon_shc.out </span><br><span class="line">[sudo] shc 的密码： </span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ps ajx</span><br><span class="line">  <span class="number">1624</span>   <span class="number">2730</span>   <span class="number">2730</span>   <span class="number">2730</span> ?            <span class="number">-1</span> Rs       <span class="number">0</span>   <span class="number">0</span>:<span class="number">20</span> ./daemon_shc.out</span><br></pre></td></tr></table></figure>

<h2 id="manpage阅读"><a href="#manpage阅读" class="headerlink" title="manpage阅读"></a>manpage阅读</h2><ul>
<li>umask<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       <span class="built_in">umask</span> - <span class="built_in">set</span> file mode creation mask</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line">       <span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line">       mode_t <span class="built_in">umask</span>(mode_t mask);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       <span class="built_in">umask</span>() sets the calling process<span class="string">&#x27;s file mode creation mask (umask) to mask &amp; 0777 (i.e., only the file permission bits of mask are used), and returns the previous value of the mask.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The  umask  is  used  by  open(2), mkdir(2), and other system calls that create files to modify the permissions placed on newly created files or directories.  Specifically, permissions in the</span></span><br><span class="line"><span class="string">       umask are turned off from the mode argument to open(2) and mkdir(2).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Alternatively, if the parent directory has a default ACL (see acl(5)), the umask is ignored, the default ACL is inherited, the permission bits are set based on the inherited ACL, and  permis‐</span></span><br><span class="line"><span class="string">       sion bits absent in the mode argument are turned off.  For example, the following default ACL is equivalent to a umask of 022:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           u::rwx,g::r-x,o::r-x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Combining the effect of this default ACL with a mode argument of 0666 (rw-rw-rw-), the resulting file permissions would be 0644 (rw-r--r--).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The constants that should be used to specify mask are described in inode(7).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The typical default value for the process umask is S_IWGRP | S_IWOTH (octal 022).  In the usual case where the mode argument to open(2) is specified as:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       (octal 0666) when creating a new file, the permissions on the resulting file will be:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       (because 0666 &amp; ~022 = 0644; i.e., rw-r--r--).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RETURN VALUE</span></span><br><span class="line"><span class="string">       This system call always succeeds and the previous value of the mask is returned.</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程补充"><a href="#进程补充" class="headerlink" title="进程补充"></a>进程补充</h2><ul>
<li>进程是系统分配资源的最小单位。</li>
<li><code>pstree</code>查看进程家族树<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemd─┬─ModemManager───2*[&#123;ModemManager&#125;]</span><br><span class="line">        ├─NetworkManager─┬─dhclient</span><br><span class="line">        │                └─2*[&#123;NetworkManager&#125;]</span><br><span class="line">        ├─VGAuthService</span><br><span class="line">        ├─accounts-daemon───2*[&#123;accounts-daemon&#125;]</span><br><span class="line">        ├─acpid</span><br><span class="line">        ├─cupsd</span><br><span class="line">        ├─dbus-daemon</span><br><span class="line">        ├─fwupd───4*[&#123;fwupd&#125;]</span><br><span class="line">        ├─gdm3─┬─gdm-session-wor─┬─gdm-wayland-ses─┬─gnome-session-b─┬─gnome-shell─┬─Xwayland───8*[&#123;Xwayland&#125;]</span><br><span class="line">        │      │                 │                 │                 │             ├─ibus-daemon─┬─ibus-dconf───3*[&#123;ibus-dconf&#125;]</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-信号</title>
    <url>/2021/11/30/Linux-%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<p>Linux信号</p>
<span id="more"></span>

<ul>
<li>参考 APUE，牛客以及黑马讲义</li>
</ul>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a><strong>信号</strong></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>特点：简单 ； 不能携带大量信息 ； 满足某个特设条件才发送</li>
<li>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉</li>
<li>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</li>
<li>递达：递送并且到达进程。</li>
<li>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</li>
<li>产生信号: <ul>
<li> 按键产生，如：<code>Ctrl+c、Ctrl+z、Ctrl+\</code></li>
<li> 系统调用产生，如：<code>kill、raise、abort</code></li>
<li> 软件条件产生，如：定时器 <code>alarm</code></li>
<li> 硬件异常产生，如：非法访问内存(段错误)、除 0(浮点数例外)、内存对齐出错(总线错误)</li>
<li> 命令产生，如：<code>kill</code> 命令</li>
</ul>
</li>
<li><strong>信号的处理方式:</strong><ul>
<li><strong>执行默认动作</strong><ul>
<li><code>Term：</code>终止进程</li>
<li> <code>Ign：</code> 忽略信号 (默认即时对该种信号忽略操作)</li>
<li> <code>Core</code>：终止进程，生成 Core 文件。(查验进程死亡原因， 用于 <code>gdb</code> 调试)</li>
<li> <code>Stop：</code>停止（暂停）进程</li>
<li> <code>Cont</code>：继续运行进程</li>
</ul>
</li>
<li><strong>忽略(丢弃)</strong></li>
<li> <strong>捕捉(调用户处理函数)</strong><h2 id="信号要素"><a href="#信号要素" class="headerlink" title="信号要素"></a>信号要素</h2></li>
</ul>
</li>
<li><strong>信号4要素</strong><ul>
<li>编号  </li>
<li>名称 </li>
<li>事件 </li>
<li>默认处理动作<ul>
<li> <code>Term：</code>终止进程</li>
<li> <code>Ign：</code> 忽略信号 (默认即时对该种信号忽略操作)</li>
<li> <code>Core</code>：终止进程，生成 Core 文件。(查验进程死亡原因， 用于 <code>gdb</code> 调试)</li>
<li> <code>Stop：</code>停止（暂停）进程</li>
<li> <code>Cont</code>：继续运行进程</li>
</ul>
</li>
</ul>
</li>
<li> 1~31常规信号  </li>
<li> <code>9 SIGKILL ; 19 SIGSTOP</code> 信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</li>
<li> 只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 2) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">1)  SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">2)  SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">3)  SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">4)  SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">5)  SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">6)  SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">7)  SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">8)  SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">9)  SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">10) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">11) SIGRTMAX-1	64) SIGRTMAX	</span><br></pre></td></tr></table></figure></li>
<li>常规信号的编号，名称，对应事件，默认处理动作。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) SIGHUP: 当用户退出 shell 时，由该 shell 启动的所有进程将收到这个信号，默认动作为终止进程</span><br><span class="line"><span class="number">2</span>) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</span><br><span class="line"><span class="number">3</span>) SIGQUIT：当用户按下&lt;ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</span><br><span class="line"><span class="number">4</span>) SIGILL：CPU 检测到某进程执行了非法指令。默认动作为终止进程并产生 core 文件</span><br><span class="line"><span class="number">5</span>) SIGTRAP：该信号由断点指令或其他 trap 指令产生。默认动作为终止里程 并产生 core 文件。</span><br><span class="line"><span class="number">6</span>) SIGABRT: 调用 abort 函数时产生该信号。默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">7</span>) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">8</span>) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 <span class="number">0</span> 等所有的算法错误。</span><br><span class="line">默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">9</span>) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了</span><br><span class="line">可以杀死任何进程的方法。</span><br><span class="line"><span class="number">10</span>) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line"><span class="number">11</span>) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">12</span>) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line"><span class="number">13</span>) SIGPIPE：Broken pipe 向一个没有读端的管道写数据。默认动作为终止进程。</span><br><span class="line"><span class="number">14</span>) SIGALRM: 定时器超时，超时的时间 由系统调用 alarm 设置。默认动作为终止进程。</span><br><span class="line"><span class="number">15</span>) SIGTERM：程序结束信号，与 SIGKILL 不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。</span><br><span class="line">执行 shell 命令 Kill 时，缺省产生这个信号。默认动作为终止进程。</span><br><span class="line"><span class="number">16</span>) SIGSTKFLT：Linux 早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</span><br><span class="line"><span class="number">17</span>) SIGCHLD：子进程状态发生变化时，父进程会收到这个信号。默认动作为忽略这个信号。</span><br><span class="line"><span class="number">18</span>) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</span><br><span class="line"><span class="number">19</span>) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</span><br><span class="line"><span class="number">20</span>) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</span><br><span class="line"><span class="number">21</span>) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</span><br><span class="line"><span class="number">22</span>) SIGTTOU: 该信号类似于 SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</span><br><span class="line"><span class="number">23</span>) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外</span><br><span class="line">数据到达，默认动作为忽略该信号。</span><br><span class="line"><span class="number">24</span>) SIGXCPU：进程执行时间超过了分配给该进程的 CPU 时间 ，系统产生该信号并发送给该进程。默认动作为</span><br><span class="line">终止进程。</span><br><span class="line"><span class="number">25</span>) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</span><br><span class="line"><span class="number">26</span>) SIGVTALRM：虚拟时钟超时时产生该信号。类似于 SIGALRM，但是该信号只计算该进程占用 CPU 的使用时</span><br><span class="line">间。默认动作为终止进程。</span><br><span class="line"><span class="number">27</span>) SGIPROF：类似于 SIGVTALRM，它不公包括该进程占用 CPU 时间还包括执行系统调用时间。默认动作为终止</span><br><span class="line">进程。</span><br><span class="line"><span class="number">28</span>) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</span><br><span class="line"><span class="number">29</span>) SIGIO：此信号向进程指示发出了一个异步 IO 事件。默认动作为忽略。</span><br><span class="line"><span class="number">30</span>) SIGPWR：关机。默认动作为终止进程。</span><br><span class="line"><span class="number">31</span>) SIGSYS：无效的系统调用。默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">34</span>) SIGRTMIN ～ (<span class="number">64</span>) SIGRTMAX：LINUX 的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时</span><br><span class="line">信号的默认动作都为终止进程。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="阻塞信号集（信号屏蔽字）；未决信号集"><a href="#阻塞信号集（信号屏蔽字）；未决信号集" class="headerlink" title="阻塞信号集（信号屏蔽字）；未决信号集"></a>阻塞信号集（信号屏蔽字）；未决信号集</h2><ul>
<li><p>内核会为每个进程维护一个信号掩码，即一组信号，并将阻塞其针对该进程的传递。如果将遭阻塞的信号发给某进程，那么对该信号的传递将延后，直至从进程信号掩码中移除该信号，从而解除阻塞为止。（信号掩码实际属于线程属性，在多线程进程中，每个线程都可使用 pthread_sigmask() 函数来独立检查和修改其信号掩码。）</p>
<ul>
<li>貌似：所以阻塞信号集就是所谓的信号掩码？</li>
<li><a href="https://blog.csdn.net/big_bit/article/details/51338523">sigprocmask函数</a></li>
</ul>
</li>
<li><p>阻塞信号集(信号屏蔽字)</p>
<ul>
<li>将某些信号加入集合，屏蔽他们。当收到x信号时，不处理x信号，直到对x的屏蔽解除后才处理。</li>
</ul>
</li>
<li><p>未决信号集</p>
<ul>
<li>信号产生，未决信号集中描述该信号的位立刻翻转为 1，表信号处于未决状态。当信号被处理对应位翻转回为 0。这一时刻往往非常短暂。</li>
<li>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，<br>信号一直处于未决状态</li>
</ul>
</li>
<li><p>我们可以通过修改信号屏蔽字，来影响未决信号集。</p>
</li>
<li><p>其实就是加要屏蔽的信号加入信号屏蔽字，目的就是造成某些信号被屏蔽。<br>  <img src="/2021/11/30/Linux-%E4%BF%A1%E5%8F%B7/2021-11-30-18-43-32.png"></p>
<p>  <img src="/2021/11/30/Linux-%E4%BF%A1%E5%8F%B7/2021-11-30-18-45-07.png"></p>
</li>
</ul>
<h2 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h2><ul>
<li><p>按键</p>
<ul>
<li><code>Ctrl+c : SIGINT</code>。终端、中断。<code>interrupt</code></li>
<li><code>Ctrl+z : SIGTSTP</code>。暂停、停止。<code>terminal stop</code></li>
<li><code>Ctrl+\ : SIGQUIT</code></li>
</ul>
</li>
<li><p><code>kill</code> 命令</p>
<ul>
<li><code>kill -SIGKILL pid</code></li>
</ul>
</li>
<li><p><code>kill</code> 函数</p>
<ul>
<li>给指定进程发送指定信号(不一定杀死)</li>
<li><code>int kill(pid_t pid, int sig);</code></li>
<li> 成功：0；失败：-1 (ID 非法，信号非法，普通用户杀 init 进程等权级问题)，设置 errno</li>
<li>参数<ul>
<li> <code>sig</code>：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li>
<li><code>pid</code><ul>
<li> <code>pid &gt; 0</code>: 发送信号给指定的进程。</li>
<li> <code>pid = 0</code>: 发送信号给 与调用 kill 函数进程属于同一进程组的所有进程。</li>
<li> <code>pid &lt; 0</code>: 取<code>|pid|</code>发给对应进程组。</li>
<li> <code>pid = -1</code>：发送给进程有权限发送的系统中所有进程。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组 ID 与进程组长 ID 相同。</p>
</li>
<li><p>权限保护：<code>super</code> 用户(<code>root</code>)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 <code>kill -9 (root 用户的 pid)</code> 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发<br>送信号。普通用户基本规则是：发送者实际或有效用户 <code>ID</code> == 接收者实际或有效用户 ID</p>
</li>
<li><p><code>alarm</code> 函数</p>
<ul>
<li><code>unsigned int alarm(unsigned int seconds);</code> 返回 0 或剩余的秒数，无失败。 </li>
<li>设置定时器(闹钟)。在指定 <code>seconds</code> 后，内核会给当前进程发送 <code>14）SIGALRM</code> 信号。进程收到该信号，默认动作终止。</li>
<li>要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。</li>
<li><code>alarm(0)</code>：取消定时器，返回闹钟剩余秒数。</li>
<li>如果在seconds秒内再次调用了alarm函数设置了新的闹钟，则后面定时器的设置将覆盖前面的设置，即之前设置的秒数被新的闹钟时间取代；当参数seconds为0时，之前设置的定时器闹钟将被取消，并将剩下的时间返回。</li>
<li>如果<code>fork</code>了 <code>alarm</code>好像只会让内核把信号发给子进程？？</li>
</ul>
</li>
<li><p><code>setitimer</code> 函数（比alarm精细）</p>
<ul>
<li><code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</code> </li>
<li>日后补充<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">  <span class="built_in">which</span>：	ITIMER_REAL： 采用自然计时。 ——&gt; SIGALRM</span><br><span class="line"></span><br><span class="line">    ITIMER_VIRTUAL: 采用用户空间计时  ---&gt; SIGVTALRM</span><br><span class="line"></span><br><span class="line">    ITIMER_PROF: 采用内核+用户空间计时 ---&gt; SIGPROF</span><br><span class="line">  </span><br><span class="line">  new_value：定时秒数</span><br><span class="line"></span><br><span class="line">              类型：struct itimerval &#123;</span><br><span class="line"></span><br><span class="line">                    struct timeval &#123;</span><br><span class="line">                      time_t      tv_sec;         /* seconds */</span><br><span class="line">                      suseconds_t tv_usec;        /* microseconds */</span><br><span class="line"></span><br><span class="line">                &#125;it_interval;---&gt; 周期定时秒数</span><br><span class="line"></span><br><span class="line">                      struct timeval &#123;</span><br><span class="line">                      time_t      tv_sec;         </span><br><span class="line">                      suseconds_t tv_usec;        </span><br><span class="line"></span><br><span class="line">                &#125;it_value;  ---&gt; 第一次定时秒数  </span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">  old_value：传出参数，上次定时剩余时间。</span><br><span class="line"></span><br><span class="line">  e.g.</span><br><span class="line">    struct itimerval new_t;	</span><br><span class="line">    struct itimerval old_t;	</span><br><span class="line"></span><br><span class="line">    new_t.it_interval.tv_sec = 0;</span><br><span class="line">    new_t.it_interval.tv_usec = 0;</span><br><span class="line">    new_t.it_value.tv_sec = 1;</span><br><span class="line">    new_t.it_value.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">    int ret = setitimer(&amp;new_t, &amp;old_t);  定时1秒</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">  成功： 0</span><br><span class="line"></span><br><span class="line">  失败： -1 errno</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其他几个发信号函数：</p>
<ul>
<li><code>int raise(int sig);</code></li>
<li><code>void abort(void);</code></li>
</ul>
</li>
</ul>
<h2 id="信号屏蔽字操作函数"><a href="#信号屏蔽字操作函数" class="headerlink" title="信号屏蔽字操作函数"></a>信号屏蔽字操作函数</h2><ul>
<li><p>信号集操作函数 </p>
<ul>
<li>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字 mask 可以影响未决信号集。而我们可以在程序中自定义 set 来改变 mask。已达到屏蔽指定信号的目的。</li>
</ul>
</li>
<li><p>修改自己预备的信号屏蔽字set</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//  修改自己的希望设置的信号屏蔽字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; <span class="comment">//  信号屏蔽字啥也不屏蔽</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;  <span class="comment">//  信号屏蔽字啥都屏蔽</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;   <span class="comment">//  信号屏蔽字屏蔽signum</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;   <span class="comment">//  信号屏蔽字解除屏蔽signum</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  看这个信号集set（一般是未决信号集）里面 是否有signum信号（看signum信号是否没被处理）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>sigprocmask</code>。修改<code>PCB</code>中的信号屏蔽字<code>mask</code></p>
<ul>
<li>用来<strong>屏蔽信号、解除屏蔽</strong>。其本质，读取或修改进程的信号屏蔽字(PCB 中)</li>
<li>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</li>
<li><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code> <ul>
<li>成功：0；</li>
<li>失败：-1，设置 <code>errno</code></li>
</ul>
</li>
<li>参数：<ul>
<li><code>set</code>：传入自己预先准备好的信号屏蔽字。是一个位图，<code>set</code> 中哪位置 1，就表示当前进程屏蔽/解除哪个信号。</li>
<li><code>oldset</code>：传出参数，保存旧的信号屏蔽集。</li>
<li><code>how</code> 参数取值： 假设当前的信号屏蔽字为 <code>mask</code><ul>
<li><code>SIG_BLOCK</code>: 当 <code>how</code> 设置为此值，<code>set</code> 表示需要屏蔽的信号。相当于 <code>mask = mask|set</code></li>
<li><code>SIG_UNBLOCK</code>: 当 <code>how</code> 设置为此，<code>set</code> 表示需要解除屏蔽的信号。相当于 <code>mask = mask &amp; ~set</code></li>
<li><code>SIG_SETMASK</code>: 当 <code>how</code> 设置为此，<code>set</code> 表示用于替代原始屏蔽及的新屏蔽集。相当于 <code>mask = set</code></li>
</ul>
</li>
</ul>
</li>
<li>若，调用 <code>sigprocmask</code> 解除了对当前若干个信号的阻塞，则在 <code>sigprocmask</code> 返回前，至少将其中一个信号递达。</li>
</ul>
</li>
<li><p><code>sigpending</code></p>
<ul>
<li><code>int sigpending(sigset_t *set);</code></li>
<li>读取当前未决信号集合 </li>
</ul>
</li>
<li><p>例子：当前进程屏蔽<code>SIGINT</code>以及<code>SIGQUIT</code>，观察未决信号集变化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SYNOPSIS</span></span><br><span class="line"><span class="comment">      #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigemptyset(sigset_t *set);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigfillset(sigset_t *set);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigaddset(sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigdelset(sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigismember(const sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment">sigset_t</span></span><br><span class="line"><span class="comment">struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  unsigned long int __val[_SIGSET_NWORDS];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_pending_set</span><span class="params">(<span class="keyword">sigset_t</span> *pending_set)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;++i)	<span class="comment">//  看前31种信号</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(sigismember(pending_set,i))	</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sigset_t</span></span><br><span class="line"><span class="comment">信号屏蔽字操作函数</span></span><br><span class="line"><span class="comment">sigemptyset</span></span><br><span class="line"><span class="comment">sigaddset</span></span><br><span class="line"><span class="comment">sigprocmask</span></span><br><span class="line"><span class="comment">sigpending</span></span><br><span class="line"><span class="comment">sigismember</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  set 我们希望制造的信号屏蔽字</span></span><br><span class="line">  <span class="keyword">sigset_t</span> <span class="built_in">set</span>;	</span><br><span class="line">  <span class="keyword">sigset_t</span> oldset;</span><br><span class="line">  sigemptyset(&amp;<span class="built_in">set</span>);	<span class="comment">//  清0</span></span><br><span class="line">  sigaddset(&amp;<span class="built_in">set</span>,SIGINT);	<span class="comment">//  屏蔽 SIGINT (即讲SIGINT信号加入信号屏蔽字)</span></span><br><span class="line">  sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);<span class="comment">//  屏蔽 SIGQUIT</span></span><br><span class="line">  <span class="comment">//  这些信号被加入了set，而后set又被添加进PCB的信号屏蔽字，因此如果之后内核对这个进程发出了SIGINT 和 SIGQUIT信号，内核不会处理。因此未决信号集中会出现这两个信号</span></span><br><span class="line">  <span class="keyword">int</span> ret = sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);	<span class="comment">//  SIG_BLOCK 向PCB中的信号屏蔽字加入set</span></span><br><span class="line">  <span class="keyword">if</span>(ret==<span class="number">-1</span>) sys_err(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">  <span class="keyword">sigset_t</span> pending_set;	<span class="comment">//  未决信号集</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    sigpending(&amp;pending_set);	<span class="comment">// 读取当前进程的未决信号集</span></span><br><span class="line">    print_pending_set(&amp;pending_set);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./sig_shc.out </span><br><span class="line"><span class="number">0000000000000000000000000000000</span></span><br><span class="line"><span class="number">0000000000000000000000000000000</span></span><br><span class="line">^C0100000000000000000000000000000 ctrl + c  SIGINT</span><br><span class="line"><span class="number">0100000000000000000000000000000</span></span><br><span class="line">^\<span class="number">0110000000000000000000000000000</span> ctrl + \  SIGQUI</span><br><span class="line"><span class="number">0110000000000000000000000000000</span></span><br><span class="line">^Z                                 ctrl + z SIGTSTP</span><br><span class="line">[<span class="number">4</span>]+  已停止               ./sig_shc.out</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="捕捉"><a href="#捕捉" class="headerlink" title="捕捉"></a><strong>捕捉</strong></h2><h3 id="内核实现捕捉过程"><a href="#内核实现捕捉过程" class="headerlink" title="内核实现捕捉过程"></a>内核实现捕捉过程</h3><p><img src="/2021/11/30/Linux-%E4%BF%A1%E5%8F%B7/2021-12-01-09-40-14.png"></p>
<ul>
<li><code>signal signaction</code> 注册。捕捉的动作不是他完成的</li>
</ul>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a><strong>signal</strong></h3><ul>
<li><code>sighandler_t signal(int signum, sighandler_t handler);</code><ul>
<li><code>signum：</code>要捕捉信号</li>
<li><code>handler：</code>相应处理函数</li>
<li><code>return：</code>上一个处理函数</li>
</ul>
</li>
<li><code>typedef void (*sighandler_t)(int)</code><ul>
<li>先看<code>sighandler_t</code> ：是一个指针变量。并且是函数指针，指向返回类型为<code>void</code> 参数为<code>int</code>的一个函数。</li>
<li><code>typedef</code>：前面有一个<code>typedef</code>，就将这个指针变量定义成一个指针类型而不再是一个变量，类型的名字就叫<code>sighandler_t</code>，返回void 参数int。</li>
<li><code>handler</code>的参数为信号的<code>number</code></li>
</ul>
</li>
</ul>
<h3 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a><strong>sigaction</strong></h3><ul>
<li><code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact);</code></li>
<li><code>sigaction</code>结构体<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The sigaction structure is defined as something like:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); abandon</span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;           <span class="comment">//  一般为0   用来设置捕捉信号期间的信号屏蔽字   </span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;          <span class="comment">//  一般为0   默认屏蔽当前捕捉信号</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);  <span class="comment">//  abandon</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>使用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(signo==SIGQUIT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch SIGQUI\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(signo==SIGINT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch SIGINT\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,<span class="title">oldact</span>;</span></span><br><span class="line">    <span class="comment">//  准备act</span></span><br><span class="line">    act.sa_handler = <span class="keyword">catch</span>;    <span class="comment">// 回调函数</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;  <span class="comment">// 设置默认属性, 本信号自动屏蔽</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask); <span class="comment">// 设置捕捉函数执行期间屏蔽字 一般为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  注册捕捉SIGQUIT信号</span></span><br><span class="line">    <span class="keyword">int</span> ret = sigaction(SIGQUIT,&amp;act,&amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;perror(<span class="string">&quot;sigaction&quot;</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="comment">//  注册捕捉SIGINT信号</span></span><br><span class="line">    sigaction(SIGINT,&amp;act,&amp;oldact);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./sigaction_shc.out </span><br><span class="line">^Ccatch SIGINT</span><br><span class="line">^\<span class="keyword">catch</span> SIGQUI</span><br><span class="line">^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^Ccatch SIGINT</span><br><span class="line">^\<span class="keyword">catch</span> SIGQUI</span><br><span class="line">^\^\^\^\^\^\^C^C^C^C^Ccatch SIGQUI</span><br><span class="line"><span class="keyword">catch</span> SIGINT</span><br><span class="line">^Ccatch SIGINT</span><br><span class="line">^\<span class="keyword">catch</span> SIGQUI</span><br><span class="line">^Z</span><br><span class="line">[<span class="number">2</span>]+  已停止               ./sigaction_shc.out</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><strong>信号捕捉特性：</strong><ul>
<li>捕捉函数执行期间，信号屏蔽字 由 <code>PCB</code>控制块中的<code>mask --&gt; sigaction</code>结构体中的<code>sa_mask</code> , 捕捉函数执行结束。 恢复为<code>mask</code></li>
<li>捕捉函数执行期间，本信号自动被屏蔽—<code>(sa_flags = 0)</code>.</li>
<li>信号<strong>不支持排队</strong>，捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次。</li>
</ul>
</li>
</ul>
<h2 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h2><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><ul>
<li><p>子进程终止时</p>
</li>
<li><p>子进程接收到 <code>SIGSTOP</code> 信号停止时</p>
</li>
<li><p>子进程处在停止态，接受到 <code>SIGCONT</code> 后唤醒时</p>
<h3 id="利用SIGCHLD回收子进程"><a href="#利用SIGCHLD回收子进程" class="headerlink" title="利用SIGCHLD回收子进程"></a>利用SIGCHLD回收子进程</h3></li>
<li><p> 回收子进程常见方案，一定要会： 利用信号机制去回收子进程，防止使用execlp等而无法回收子线程的情况</p>
</li>
<li><p><strong>思路1：</strong></p>
<ul>
<li> 直接设置<code>signal(SIGCHLD,SIG_IGN)</code>忽略这个信号即可。系统就懂了我们不需要残留的信息，直接释放残留资源。</li>
</ul>
</li>
<li><p><strong>思路2：</strong></p>
<ul>
<li> 在父进程中注册<code>SIGCHLD</code>信号，回调函数里负责循环回收死掉的子进程。</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>回收用<code>while</code>不用<code>if</code><ul>
<li> 使用<code>while</code>，防止僵尸进程 如果使用<code>if</code>的话，在处理一个进程A死亡的<code>SIGHCLD</code>信号时，可能会有另几个进程B,C,D死亡也使得内核发送<code>SIGCHLD</code>信号，这时<code>SIGCHLD</code>信号已经被屏蔽，所以进程B,C,D的<code>SIGCHLD</code>信号在未决信号集中只有一次（信号不支持排队）。所以之后如果用if也只能处理掉BCD中的一个进程，所以会出现僵尸进程。</li>
</ul>
</li>
<li>改进<ul>
<li> 如果在父进程还没有注册这个信号的处理函数时，子进程就全部死亡，之后就是注册了也不会有<code>SIGCHLD</code>去激活这个函数，那么就不会起到回收子进程的作用，怎么办？</li>
<li> 在注册之前，屏蔽<code>（SIG_BLOCK)SIGCHLD</code>，使得如果有<code>SIGCHLD</code>产生，那么就一直不处理，留在未决信号集中，等到注册完毕，解除<code>(SIG_UNBLOCK)</code>对<code>SIGCHLD</code>的屏蔽即可。</li>
</ul>
</li>
</ul>
</li>
<li><p>一些问题</p>
<ul>
<li> <code>wait waitpid</code>阻塞等待时会让出cpu资源么？</li>
<li> 那么在这里这样看是不是阻塞要比waitpid非阻塞好？waitpid不会阻塞，会一直while循环，不让出cpu资源。</li>
</ul>
</li>
<li><p>代码</p>
<ul>
<li><p>无注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  回收子进程比较好的方案，一定要会！！： 利用信号机制去回收子进程，防止使用execlp而无法回收子线程的情况</span></span><br><span class="line"><span class="comment">//  利用的信号：SIGCHLD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> signo)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">// while((wpid=wait(&amp;status)))</span></span><br><span class="line">    <span class="comment">// while((wpid=waitpid(-1,&amp;status,0)!=-1))</span></span><br><span class="line">    <span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG))!=<span class="number">-1</span>)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(wpid==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d exit with %d\n&quot;</span>,wpid,WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d killed with %d\n&quot;</span>,wpid,WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  设置PCB中的mask屏蔽字屏蔽SIGCHLD</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//  在进行主函数逻辑之前</span></span><br><span class="line">        <span class="comment">//  注册信号处理函数 来 处理捕捉信号</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  准备act</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_handler = <span class="keyword">catch</span>;    </span><br><span class="line">        act.sa_flags = <span class="number">0</span>;  </span><br><span class="line">        sigemptyset(&amp;act.sa_mask); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注册捕捉信号的处理函数  </span></span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解除屏蔽</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  模拟后序逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child id = %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./signal_to_catch_child.out </span><br><span class="line">i am child id = 8585</span><br><span class="line">i am child id = 8586</span><br><span class="line">i am child id = 8589</span><br><span class="line">i am child id = 8588</span><br><span class="line">i am child id = 8587</span><br><span class="line">i am child id = 8590</span><br><span class="line">i am child id = 8593</span><br><span class="line">i am child id = 8591</span><br><span class="line">i am child id = 8594</span><br><span class="line">i am child id = 8592</span><br><span class="line">child 8585 <span class="built_in">exit</span> with 0</span><br><span class="line">child 8586 <span class="built_in">exit</span> with 1</span><br><span class="line">child 8587 <span class="built_in">exit</span> with 2</span><br><span class="line">child 8588 <span class="built_in">exit</span> with 3</span><br><span class="line">child 8589 <span class="built_in">exit</span> with 4</span><br><span class="line">child 8590 <span class="built_in">exit</span> with 5</span><br><span class="line">child 8591 <span class="built_in">exit</span> with 6</span><br><span class="line">child 8592 <span class="built_in">exit</span> with 7</span><br><span class="line">child 8593 <span class="built_in">exit</span> with 8</span><br><span class="line">child 8594 <span class="built_in">exit</span> with 9</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></li>
<li><p>注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  回收子进程比较好的方案，一定要会！！： 利用信号机制去回收子进程，防止使用execlp而无法回收子线程的情况</span></span><br><span class="line"><span class="comment">//  利用的信号：SIGCHLD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> signo)</span>   <span class="comment">//  signo 当前处理的信号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">// while((wpid=wait(&amp;status)))</span></span><br><span class="line">    <span class="comment">// while((wpid=waitpid(-1,&amp;status,0)!=-1))</span></span><br><span class="line">    <span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG))!=<span class="number">-1</span>)   <span class="comment">//  使用while，防止僵尸进程 如果使用if的话，在处理一个进程A死亡的SIGHCLD信号时，可能会有另几个进程B,C,D死亡也使得内核发送SIGCHLD信号，这时SIGCHLD信号已经被屏蔽，所以进程B,C,D的SIGCHLD信号在未决信号集中只有一次（信号不支持排队）。所以之后如果用if也只能处理掉BCD中的一个进程，所以会出现僵尸进程。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(wpid==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d exit with %d\n&quot;</span>,wpid,WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d killed with %d\n&quot;</span>,wpid,WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  设置PCB中的mask屏蔽字屏蔽SIGCHLD</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//  在进行主函数逻辑之前</span></span><br><span class="line">        <span class="comment">//  注册信号处理函数 来 处理捕捉信号</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  准备act</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_handler = <span class="keyword">catch</span>;    <span class="comment">//  设置处理函数</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;  <span class="comment">//  默认属性 屏蔽当前捕捉信号</span></span><br><span class="line">        sigemptyset(&amp;act.sa_mask); <span class="comment">//  设置处理信号期间屏蔽字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注册捕捉信号的处理函数  </span></span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解除屏蔽</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  模拟后序逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child id = %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  改进</span></span><br><span class="line"><span class="comment">//  如果在父进程还没有注册这个信号的处理函数时，子进程就全部死亡，之后就是注册了也不会有SIGCHLD去激活这个函数，那么就不会起到回收子进程的作用，怎么办？</span></span><br><span class="line"><span class="comment">//  在注册之前，屏蔽调SIGCHLD，使得如果有SIGCHLD产生，那么就一直不处理，留在未决信号集中，等到注册完毕，解除(sigdel)对SIGCHLD的屏蔽即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  一些问题</span></span><br><span class="line"><span class="comment">//  wait waitpid阻塞等待时会让出cpu资源么？</span></span><br><span class="line"><span class="comment">//  那么在这里这样看是不是阻塞要比waitpid非阻塞好？waitpid不会阻塞，会一直while循环</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果不先屏蔽<code>SIGCHLD</code>，那么结果如下。只有父进程死亡后，整个地址空间都会被销毁，僵尸子进程才没了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./signal_to_catch_child2.out</span><br><span class="line">i am child id = 8875</span><br><span class="line">i am child id = 8876</span><br><span class="line">i am child id = 8878</span><br><span class="line">i am child id = 8879</span><br><span class="line">i am child id = 8877</span><br><span class="line">i am child id = 8880</span><br><span class="line">i am child id = 8883</span><br><span class="line">i am child id = 8881</span><br><span class="line">i am child id = 8884</span><br><span class="line">i am child id = 8882</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">ps ajx</span><br><span class="line">Z：僵尸。defunct：僵尸</span><br><span class="line">  8371   8874   8874   8371 pts/1      8874 R+    1000   0:42 ./signal_to_catch_child2.out</span><br><span class="line">  8874   8875   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8876   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8877   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8878   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8879   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8880   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8881   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8882   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8883   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8884   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>SIGCHLD</code> 信号注意问题</p>
<ul>
<li>子进程继承父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集 <code>pending。</code></li>
<li>注意注册信号捕捉函数的位置。</li>
<li>应该在 <code>fork</code> 之前，阻塞 <code>SIGCHLD</code> 信号。注册完捕捉函数后解除阻塞。</li>
</ul>
</li>
</ul>
<ul>
<li><blockquote>
<p><strong>子进程结束 对status的如何处理</strong></p>
</blockquote>
<ul>
<li><code>pid_t waitpid(pid_t pid, int *status, int options)</code></li>
<li><code>options</code>：<ul>
<li><code>WNOHANG</code>：没有子进程结束，立即返回</li>
<li><code>WUNTRACED</code>：如果子进程由于被停止产生的 <code>SIGCHLD</code>，<code>waitpid</code> 则立即返回</li>
<li><code>WCONTINUED</code>：如果子进程由于被 <code>SIGCONT</code> 唤醒而产生的 <code>SIGCHLD，waitpid</code> 则立即返回</li>
</ul>
</li>
<li><code>status：</code><ul>
<li><code>WIFEXITED(status)</code>：子进程正常 <code>exit</code> 终止，返回真</li>
<li><code>WEXITSTATUS(status)</code>：返回子进程正常退出值</li>
<li><code>WIFSIGNALED(status)</code>：子进程被信号终止，返回真</li>
<li><code>WTERMSIG(status)</code>：返回终止子进程的信号值</li>
<li><code>WIFSTOPPED(status)</code>：子进程被停止，返回真</li>
<li><code>WSTOPSIG(status)</code>：返回停止子进程的信号值</li>
<li><code>WIFCONTINUED(status)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="了解：中断系统调用"><a href="#了解：中断系统调用" class="headerlink" title="了解：中断系统调用"></a>了解：中断系统调用</h2><ul>
<li><p>系统调用可分为两类：慢速系统调用和其他系统调用。</p>
<ul>
<li>慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，<code>read、write、pause、wait...</code></li>
<li>其他系统调用：<code>getpid、getppid、fork...</code></li>
</ul>
</li>
<li><p>结合 <code>pause</code>，回顾慢速系统调用：</p>
<ul>
<li>慢速系统调用被中断的相关行为，实际上就是 <code>pause</code> 的行为： 如，<code>read</code></li>
<li>① 想中断 <code>pause</code>，信号不能被屏蔽。</li>
<li>② 信号的处理方式必须是捕捉 (默认、忽略都不可以)</li>
<li>③ 中断后返回-1， 设置 <code>errno</code> 为 <code>EINTR</code>(表“被信号中断”)</li>
<li>可修改 <code>sa_flags</code> 参数来设置被信号中断后系统调用是否重<ul>
<li><code>SA_INTERRURT</code> 不重启。 <code>SA_RESTART</code> 重启。</li>
</ul>
</li>
</ul>
</li>
<li><p>扩展了解：<br><code>sa_flags</code> 还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该<br>信号，可将 <code>sa_flags</code> 设置为 <code>SA_NODEFER</code>，除非 <code>sa_mask</code> 中包含该信号</p>
</li>
<li><p>以上了解摘自牛客讲义,APUE上也有，好多，有时间再看吧</p>
</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li>一些问题<ul>
<li> <code>wait</code> <code>waitpid</code>阻塞等待时会让出<code>cpu</code>资源么？</li>
<li> 那么在这里这样看是不是阻塞要比<code>waitpid</code>非阻塞好？<code>waitpid</code>不会阻塞，会一直<code>while</code>循环，不让出<code>cpu</code>资源</li>
</ul>
</li>
<li><code>wait(NULL)</code>与<code>signal(SIGCHLD,SIG_IGN)</code>区别？<ul>
<li>我认为，前者可以保证子进程一定会运行完再进行主进程，后者子进程不一定运行完，父进程就结束了。</li>
</ul>
</li>
</ul>
<h2 id="关于SIG-ING处理SIGCHLD不会造成僵尸"><a href="#关于SIG-ING处理SIGCHLD不会造成僵尸" class="headerlink" title="关于SIG_ING处理SIGCHLD不会造成僵尸"></a>关于SIG_ING处理SIGCHLD不会造成僵尸</h2><ul>
<li><code>SIGCHLD</code>默认处理方式是忽略，但是我们还是要显示写出来<code>signal(SIGCHLD,SIG_IGN)</code>才可以</li>
<li>所以那在处理死去的进程时，如果不需要获取这个死去进程的信息，就不需要<code>wait</code>。直接<code>signal(SIGCHLD，SIG_IGN)</code>就可以让这个死去的子进程被释放残留资源从而不变成僵尸进程</li>
<li><code>wait notes</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT flag is set for SIGCHLD [signal(SIGCHLD,SIG_IGN)](see</span><br><span class="line">    sigaction(2)), then children that terminate do not become zombies and a call to wait() or  waitpid()  will  block  until  all</span><br><span class="line">    children  have terminated, and then fail with errno set to ECHILD. </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	signal(SIGCHLD,SIG_IGN);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; i am parent \n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am %d child\n&quot;</span>,i);</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d die\n&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps ajx也没有僵尸进程</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./test01_wait.out </span><br><span class="line">i am <span class="number">0</span> child</span><br><span class="line">i am <span class="number">1</span> child</span><br><span class="line"> i am parent </span><br><span class="line">i am <span class="number">2</span> child</span><br><span class="line">i am <span class="number">3</span> child</span><br><span class="line">i am <span class="number">4</span> child</span><br><span class="line"><span class="number">0</span> die</span><br><span class="line"><span class="number">1</span> die</span><br><span class="line"><span class="number">2</span> die</span><br><span class="line"><span class="number">3</span> die</span><br><span class="line"><span class="number">4</span> die</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-socket</title>
    <url>/2021/12/07/Linux-socket/</url>
    <content><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="IP中的网络ID，主机ID以及路由器的关系"><a href="#IP中的网络ID，主机ID以及路由器的关系" class="headerlink" title="IP中的网络ID，主机ID以及路由器的关系"></a>IP中的网络ID，主机ID以及路由器的关系</h3><ul>
<li>向目标主机传输数据。<ul>
<li>首先要向目标主机<strong>所在的网络</strong>传输数据，所以先浏览IP地址中的网络地址，向构成网络的<strong>路由器或交换机</strong>传递数据</li>
<li>然后由接收数据的<strong>路由器</strong>根据数据中的<strong>主机地址</strong>向目标地址传递数据。</li>
</ul>
</li>
</ul>
<h3 id="IP地址分类方法"><a href="#IP地址分类方法" class="headerlink" title="IP地址分类方法"></a>IP地址分类方法</h3><ul>
<li>IP地址4字节</li>
<li>A：首字节0-127，0xxxxxxx <ul>
<li> A类网络地址：0.0.0.0 - 127.0.0.0</li>
</ul>
</li>
<li>B：128-191，10xxxxxx <ul>
<li> 网络地址：128.0.0.0-191.255.0.0</li>
</ul>
</li>
<li>C：192-223，110xxxxx<ul>
<li> 网络地址：192.0.0.0-223.255.255.0</li>
</ul>
</li>
<li>D：224-239，用于多播，1110xxxx <ul>
<li> 网络地址：224.0.0.0-239.255.255.255<br><img src="/2021/12/07/Linux-socket/2021-12-22-10-44-25.png"></li>
</ul>
</li>
</ul>
<h3 id="路由机、交换机作用"><a href="#路由机、交换机作用" class="headerlink" title="路由机、交换机作用"></a>路由机、交换机作用</h3><ul>
<li>路由机：作用于网络层，寻址，转发（依靠IP地址）<ul>
<li>连接2个或多个网络的硬件设备，在网络间起网关作用。是读取每一个数据包中的地址，然后决定如何传送的智能性的网络设备。（路由控制表）</li>
</ul>
</li>
<li>交换机：作用于数据链路层，过滤，转发<ul>
<li>是一种用于电（光）信号转发的网络设备。</li>
</ul>
</li>
<li>他们实际上也是一种计算机，只不过是为了特殊目的而设计运行，因而有了别名。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>图片</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始状态：客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手。</span><br><span class="line">第一次握手：客户端给服务端发一个 SYN 报文段，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_SENT 状态。（在SYN报文段中同步位SYN=1，初始序号seq=x）SYN=1的报文段不能携带数据，但要消耗掉一个序号。</span><br><span class="line">第二次握手：服务器收到客户端的 SYN 报文段之后，会以自己的 SYN 报文段作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN(c) + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN报文，此时服务器处于 SYN_RCVD 的状态。（在SYN ACK报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y）</span><br><span class="line">第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN(s) + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。（在ACK报文段中ACK=1，确认号ack=y+1，序号seq=x+1）ACK报文段可以携带数据，不携带数据则不消耗序号（第二次握手的既是ACK也是SYN报文段所以不可以）</span><br></pre></td></tr></table></figure>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><code>TCP/IP</code><ul>
<li><code>TCP</code> （<code>Transmission Control Protocol</code>）用来确保数据的正确性。</li>
<li><code>IP</code>（<code>Internet Protocol</code>，网络协议）用来控制数据如何从源头到达目的地，也就是常说的“路由”。</li>
</ul>
</li>
</ul>
<h3 id="socket概念"><a href="#socket概念" class="headerlink" title="socket概念"></a><strong>socket概念</strong></h3><ul>
<li>“插座”，书中译为“套接字”。（还不如插座。。）是计算机之间进行通信的一种约定。通过这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</li>
<li>实际为内核借助缓冲区形成的伪文件，故也有文件描述符。<ul>
<li>两个缓冲区。写，读。</li>
</ul>
</li>
<li>创建socket就是即创建一个网络连接，也就是在打开一个网络文件。</li>
</ul>
<h3 id="socket类型"><a href="#socket类型" class="headerlink" title="socket类型"></a>socket类型</h3><ul>
<li><code>SOCK_STREAM</code>（流服务）<ul>
<li>面向连接的套接字<ul>
<li><strong>可靠，按需传递，基于字节的，面向连接的数据传输方式的套接字。</strong></li>
</ul>
</li>
<li>使用<code>TCP</code>协议</li>
<li><code>SOCK_STREAM</code> 有以下几个特征：<ul>
<li>数据在传输过程中不会消失；</li>
<li>数据按序传输；</li>
<li>数据的发送和接收不是同步的。（即不存在数据边界）<ul>
<li>socket内部有buffer</li>
<li>可能客户端三次write，服务器端一次read就读取完毕</li>
</ul>
</li>
</ul>
</li>
<li><strong>所以面向连接的套接字中，read函数和write函数的调用次数并无太大意义。</strong></li>
</ul>
</li>
<li>socket缓冲已满不意味着数据丢失。<ul>
<li>socket缓冲区并不总满</li>
<li>socket缓冲区满了之后，socket不再接收数据，但即使这样也不会数据丢失。因为传输端socket会停止传输。</li>
<li>即面向连接的套接字会根据接收端的状态传输数据，如果传输出错还会提供重传服务，因此不会数据丢失。</li>
</ul>
</li>
</ul>
<ul>
<li><code>SOCK_UGRAM</code>（数据报服务）<ul>
<li>面向消息的套接字<ul>
<li><strong>不可靠、不按顺序传递、以追求速度为目的套接字</strong></li>
</ul>
</li>
<li>使用<code>UDP</code>协议</li>
<li>计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为数据报套接字所做的校验工作少，所以在传输效率方面比流格式套接字要高。</li>
<li><code>SOCK_UGRAM</code>特征<ul>
<li> 强调快速传输而非传输顺序；</li>
<li> 传输的数据可能丢失也可能损毁；</li>
<li> 限制每次传输的数据大小；</li>
<li>数据的发送和接收是同步的。（存在数据边界）<ul>
<li> 即接收数据的次数应和传输次数相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="socket前置知识"><a href="#socket前置知识" class="headerlink" title="socket前置知识"></a>socket前置知识</h2><h3 id="主机字节序、网络字节序"><a href="#主机字节序、网络字节序" class="headerlink" title="主机字节序、网络字节序"></a>主机字节序、网络字节序</h3><ul>
<li>主机字节序：小端字节序</li>
<li>网络字节序：大端字节序</li>
<li>原因：为了让接收端正确解释收到的数据</li>
<li>大端字节序：高位字节存储在内存的低地址处，低位二字节存哉内存的高地址处</li>
<li>小端字节序：高位字节存储在内存的高地址处，低位i二字节存在内存的低地址处</li>
<li><strong>大小端字节序转换</strong>函数<ul>
<li>s:（unsigned short int 2字节）（端口也是两字节）；l：（unsigned long int 4字节）ip（ip也是4字节）</li>
<li>htonl: host to network long ；ip，主机-&gt;网络</li>
<li>htons: host to network short：port，主机-&gt;网络</li>
<li>ntohl: net to host long ：ip，网络-&gt;主机</li>
<li>ntohs: net to host short：port，网络-&gt;主机</li>
</ul>
</li>
<li>任何格式化数据通过网络传输时，都应该使用这些函数来转换字节序<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netshort)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h3><ul>
<li><code>socket</code>一开始的含义是一个<code>IP</code>地址和端口对<code>（ip，port）</code>。他表示了使用<code>TCP</code>通信的一端。又称为<code>socket</code>地址</li>
<li><code>sockaddr</code> 是一种通用的结构体，可以用来保存多种类型的IP地址和端口号，sockaddr_in 是专门用来保存 IPv4 地址的结构体</li>
</ul>
<h4 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">sa_family_t</span> sa_family;      </span><br><span class="line">       <span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sa_family_t</code> 地址族类型<ul>
<li><code>AF_UNIX</code></li>
<li><code>AF_INET</code></li>
<li><code>AF_INET6</code></li>
</ul>
</li>
<li><code>sa_data</code><ul>
<li>存放<code>socket</code>地址值</li>
<li>协议族为<code>PF_INET/PFINET6</code>：<strong>端口号+<code>ip</code>地址</strong>（<code>ipv4</code>地址或<code>ipv6</code>地址）</li>
<li>协议族若为<code>PF_UNIX</code>：则是文件路径名</li>
</ul>
</li>
</ul>
<h4 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h4><ul>
<li>实际使用时强转：<code>(struct sockaddr*)</code></li>
<li><code>struct sockaddr_un</code>略</li>
</ul>
<h5 id="struct-sockaddr-in用于IPv4"><a href="#struct-sockaddr-in用于IPv4" class="headerlink" title="struct sockaddr_in用于IPv4"></a><code>struct sockaddr_in</code>用于IPv4</h5><ul>
<li>优点：<code>port</code>端口号 与 <code>ip</code>地址 分开存储<ul>
<li>端口号在<code>u_int16_t sin_port</code>中。</li>
<li>地址存储在<code>struct in_addr sin_addr</code>中。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">sa_family_t</span> sin_family;     <span class="comment">//  地址族：AF_INET</span></span><br><span class="line">       <span class="keyword">u_int16_t</span> sin_port;  <span class="comment">// 16位，端口号，注意用网络字节序！</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>    <span class="comment">//  32位，IPv4地址结构体</span></span><br><span class="line">       <span class="comment">// char            sin_zero[8];  //不使用，一般用0填充</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>u_int16_t sin_port</code><ul>
<li><code>u_int16_t</code> 的长度为两个字节，理论上端口号的取值范围为 <code>0~65536</code>，但 <code>0~1023</code> 的端口一般由系统分配给特定的服务程序，例如 Web 服务的端口号为 80，FTP 服务的端口号为 21，所以我们的程序要尽量在 1024~65536 之间分配端口号。</li>
</ul>
</li>
<li><code>sin_addr</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">u_int32_t</span> s_addr;  </span><br><span class="line">     <span class="comment">//  Ipv4地址，网络字节序表示</span></span><br><span class="line">     <span class="comment">//  即我们所说的ip</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  u_int32_t unsigned long int</span></span><br><span class="line"><span class="comment">//  而程序一般拿到的ip是一个字符串（点分十进制或者十六进制），因此需要转换函数inet_addr / inet_aton / inet_pton</span></span><br><span class="line">     <span class="comment">// unsigned long ip = inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line">     <span class="comment">// printf(&quot;%ld\n&quot;, ip); 16777343</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="struct-sockaddr-in6用于Ipv6"><a href="#struct-sockaddr-in6用于Ipv6" class="headerlink" title="struct sockaddr_in6用于Ipv6"></a><code>struct sockaddr_in6</code>用于Ipv6</h5>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">sa_family_t</span> sin6_family;    <span class="comment">// AF_INET6  </span></span><br><span class="line">     <span class="keyword">u_int16_t</span> sin6_port;        <span class="comment">// 端口号 网络字节序</span></span><br><span class="line">     <span class="keyword">u_int32_t</span> sin6_flowinfo     <span class="comment">// 流信息 设为0</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>  <span class="comment">// IPv6地址结构体</span></span><br><span class="line">     <span class="keyword">u_int32_t</span> sin6_scope_id;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sin6_addr</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">       <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><ul>
<li>点分十进制字符串 &lt;-&gt;  网络字节序整数   的转换<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp,struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *strptr)</span></span>;</span><br><span class="line"></span><br><span class="line">IPv4地址：点分十进制str  -----&gt;   网络字节序整数</span><br><span class="line">inet_addr： 直接返回网络字节序整数</span><br><span class="line">inet_aton：存在inp中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"></span><br><span class="line">Ipv4地址：网络字节序整数 ----&gt;  点分十进制str</span><br><span class="line">函数内部用一个静态变量保存结果，不可重入。若要长期保存应自己申请空间复制结果</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><code>int inet_pton(int af,const char* src,void *dst);</code><ul>
<li>p：<code>presentation</code>；n：<code>numeric</code></li>
<li>IPv4地址：字符串-&gt;网络字节序整数，转换结果存入dst</li>
<li>af：address family。地址类型 AF_INET/AF_INET6</li>
</ul>
</li>
<li><code>const char *inet_ntop(int af,const void *src,char *dst,socklen_t cnt);</code><ul>
<li>IPv4地址：网络字节序整数-&gt;<code>str</code>，转换结果存入<code>dst</code></li>
<li>参数一致</li>
<li>最后<code>socklen_t cnt</code> 为<code>dst</code>指向单元的大小</li>
</ul>
</li>
</ul>
<h2 id="socket-API"><a href="#socket-API" class="headerlink" title="socket API"></a>socket API</h2><p><img src="/2021/12/07/Linux-socket/2021-12-09-21-36-39.png"></p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><ul>
<li><p><strong>socket() 函数用来创建套接字，确定套接字的各种属性</strong></p>
<ul>
<li><strong>属性：底层协议族，服务类型，相应传输协议(如TCP或者UDP)</strong></li>
</ul>
</li>
<li><p><code>int socket(int domain, int type, int protocol);</code></p>
<ul>
<li><p>return：</p>
<ul>
<li>成功：返回socket文件描述符</li>
<li>失败：-1 + errno</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li><p>domain：底层协议族</p>
<ul>
<li>PF_INET</li>
<li>PF_INET6</li>
</ul>
</li>
<li><p>type：数据传输类型</p>
<ul>
<li>对于TCP/IP协议族而言</li>
<li>SOCK_STREAM 流服务，传输层–TCP协议</li>
<li>SOCK_DGREAM 数据报服务，传输层–UDP协议</li>
</ul>
</li>
<li><p>protocol：表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</p>
<ul>
<li>一般写0。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>有了协议族信息和数据传输方式，还不足以决定采用哪种协议吗？为什么还需要第三个参数呢？</p>
</blockquote>
<ul>
<li>同一协议族中存在多个数据传递相同的协议。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);  </span><br><span class="line"><span class="comment">// IPPROTO_TCP表示TCP协议</span></span><br><span class="line"><span class="comment">// 这种套接字称为 TCP 套接字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用 SOCK_DGRAM 传输方式，那么满足这两个条件的协议只有 UDP，因此可以这样来调用 socket() 函数：</span></span><br><span class="line"><span class="keyword">int</span> udp_socket = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); </span><br><span class="line"><span class="comment">// IPPROTO_UDP表示UDP协议</span></span><br><span class="line"><span class="comment">// 这种套接字称为 UDP 套接字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两种情况都只有一种协议满足条件，可以将 protocol 的值设为 0，系统会自动推演出应该使用什么协议，如下所示：</span></span><br><span class="line"><span class="keyword">int</span> tcp_socket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">//创建TCP套接字</span></span><br><span class="line"><span class="keyword">int</span> udp_socket = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);  <span class="comment">//创建UDP套接字</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul>
<li>socket() 函数确定了套接字的各种属性，<strong>bind() 函数让套接字与特定的IP地址和端口对应起来，这样客户端才能连接到该套接字</strong>。类似地，客户端也要用 connect() 函数建立连接。</li>
<li><code>int bind(int sockfd,const struct sockaddr_in* my_addr,socklen_t addrlen);</code><ul>
<li>return ：<ul>
<li>success：0</li>
<li>fail：-1 + errno</li>
</ul>
</li>
<li>int sockfd：之前打开的网络文件描述符</li>
<li>my_addr：<ul>
<li>传入参数</li>
<li><code>struct sockaddr_in </code><ul>
<li>sa_family，地址类型 AF_INET / AF_INET6</li>
<li>sin_port，端口号，网络字节序。</li>
<li>sin_addr，ip地址，网络字节序。</li>
</ul>
</li>
<li>addrlen:<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1.  创建socket</span></span><br><span class="line"><span class="comment">//  socket 指明ip地址类型，服务类型，具体协议</span></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sockfd&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  2.  给服务器socket绑定地址结构 -- 结构中包含IP + port。 （官话：将一个socket与socket地址绑定称之为给socket命名）</span></span><br><span class="line"><span class="comment">//  bind</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">bzero(&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr); <span class="comment">//  清0</span></span><br><span class="line">inet_pton(AF_INET,ip,&amp;serv_addr.sin_addr.s_addr);  <span class="comment">//  设置ip</span></span><br><span class="line">serv_addr.sin_port = htons(port);   <span class="comment">//  设置port</span></span><br><span class="line">serv_addr.sin_family = AF_INET;     <span class="comment">//  设置ip地址类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = bind(sockfd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr); <span class="comment">//  绑定结构体地址</span></span><br><span class="line">assert(ret&gt;=<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="（客户端）connect"><a href="#（客户端）connect" class="headerlink" title="（客户端）connect"></a>（客户端）connect</h3><ul>
<li><strong>将sockfd对应的socket连接到服务器端的目标socket上（通过服务器端的socket地址获知要连接哪个socket）</strong></li>
<li><strong>客户端通过读写这个sockfd与服务器端通信。</strong></li>
<li><code>int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen);</code><ul>
<li>return：<ul>
<li>success：0。服务器端接收连接请求。（不是accept了，而是放入等待队列中）</li>
<li>fail：-1 + errno。（断网等）</li>
</ul>
</li>
<li>参数<ul>
<li><code>sockfd</code></li>
<li><code>serv_addr</code><ul>
<li><strong>服务器地址结构，传入参数</strong></li>
<li>成员同上：地址类型，port端口号，ip地址。</li>
<li>用于告知sockfd应该连接什么样的<code>socket</code></li>
</ul>
</li>
<li><code>addrlen</code>:<ul>
<li>传入参数，serv_addr大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><ul>
<li><strong>不阻塞</strong>，设置监听队列最大长度</li>
<li><code>int listen(int sockfd,int backlog);</code></li>
<li>一般实际能<code>ESTABLISHED</code>的要比这个<code>backlog</code>略大</li>
</ul>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><ul>
<li>整体叙述：<strong>阻塞</strong>等待客户端连接，在有客户端连接之后，<strong>创建一个socket专门用于与该客户端进行通信，并返回该<code>socket</code>的<code>sockfd</code></strong></li>
</ul>
<p><img src="/2021/12/07/Linux-socket/2021-12-11-09-13-15.png"></p>
<ul>
<li><p>当服务器调用完listen，客户端主动connect之后，三次握手就已经完成，即建立了TCP连接并可以数据交互。netstat -an | grep port，可以看到状态为<code>established</code>。</p>
</li>
<li><p><strong>即三次握手建立连接是在<code>accept</code>之间建立好的。</strong></p>
</li>
<li><p>从处于 <code>established</code> 状态的等待队列头部取出一个已经完成的连接(三次握手之后)</p>
</li>
<li><p>如果没有设置<code>O_NOBLOCK</code>，并且如果这个队列没有已经完成的连接，<code>accept()</code>函数就会阻塞，直到取出队列中已完成的用户连接为止。</p>
</li>
<li><p>如果，服务器不能及时调用 <code>accept()</code> 取走队列中已完成的连接，队列满掉后会怎样呢？UNP（《unix网络编程》）说，服务器的连接队列满掉后，服务器不会对再对建立新连接的syn进行应答，所以客户端的 connect 就会返回 ETIMEDOUT</p>
</li>
<li><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);  </code></p>
<ul>
<li>return:<ul>
<li>success: <strong>用于与客户端进行通信的sockfd</strong><ul>
<li><strong>accept socket</strong></li>
</ul>
</li>
<li>fail: -1 + errno</li>
</ul>
</li>
<li>参数  <ul>
<li><code>sockfd</code><ul>
<li><strong>listen socket</strong></li>
</ul>
</li>
<li><code>addr</code><ul>
<li>可以传NULL。</li>
<li><strong>传出参数</strong></li>
<li><strong>客户端地址结构（IP+port）</strong></li>
</ul>
</li>
<li><code>addrlen</code><ul>
<li><code>addr</code>大小</li>
<li><strong>传入传出参数</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意区分<code>accept socket /  listen socket</code></strong></p>
<ul>
<li>socket分为两种，一种套接字正如accept的参数sockfd，它是listen socket，在调用listen函数之后，一个socket会从主动连接的套接字变为listen 套接字；而accept返回是一个连接套接字，它代表着一个网络已经存在的点对点连接。以后的数据交互就是基于这个连接socket ,而之前的那个listen socket可以继续工作，从而接收更多的连接。</li>
</ul>
</li>
<li><p>description</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DESCRIPTION</span><br><span class="line">       The accept() <span class="keyword">function</span> shall extract the first connection on the queue of pending connections, create a new socket with the same socket <span class="built_in">type</span> protocol and  address  family</span><br><span class="line">       as the specified socket, and allocate a new file descriptor <span class="keyword">for</span> that socket.</span><br><span class="line">      accept会抓取队列中第一个连接（已经ESTABLISEHED的），用（和sockfd指向的socket）一样的协议和地址类型来创建一个新的socket，并且为该socket分配一个新的socket。</span><br></pre></td></tr></table></figure></li>
<li><p>sockfd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The accept() function takes the following arguments：</span><br><span class="line">socket      Specifies a socket that was created with socket(), has been bound to an address with bind(), and has issued a successful call to listen().</span><br><span class="line">sockfd：已经bind和listen过的监听套接字。</span><br></pre></td></tr></table></figure></li>
<li><p>address</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address     Either a null pointer, or a pointer to a sockaddr structure where the address of the connecting socket shall be returned.</span><br><span class="line"> address：NULL / 用于接收客户端socket的sockaddr_in</span><br></pre></td></tr></table></figure></li>
<li><p>accept创建的套接字本身不能接收更多的连接。（只能和一个客户端的套接字建立连接），原先的监听套接字保持open，并且可以接收更多的连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The accepted socket cannot itself accept more connections. The original socket remains open and can accept more connections.</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><ul>
<li><code>int close(sockfd)</code><ul>
<li>引用计数减为1时，可关闭</li>
</ul>
</li>
</ul>
<h3 id="send-recv"><a href="#send-recv" class="headerlink" title="send recv"></a><code>send recv</code></h3><ul>
<li>专门用于<strong>socket</strong>数据读写的系统调用</li>
<li><code>ssize_t send(int sockfd,void *buf,size_t len,int flags);</code></li>
<li><code>send</code>：向sockfd写数据<ul>
<li>返回写入长度</li>
<li>失败 -1 + errno</li>
</ul>
</li>
<li><code>ssize_t recv(int sockfd,void *buf,size_t len,int flags);</code></li>
<li><code>recv</code>：读取sockfd上的数据<ul>
<li>return<ul>
<li>读取到的数据长度</li>
<li>0：对方已经关闭连接</li>
<li>fail：-1 + errno  </li>
</ul>
</li>
<li>参数<ul>
<li>buf：缓冲区</li>
<li>len：缓冲区大小</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关于read返回值"><a href="#关于read返回值" class="headerlink" title="关于read返回值"></a>关于read返回值</h3><ul>
<li><code>&gt; 0</code> 实际读到的字节数</li>
<li><code>= 0 </code>已经读到结尾（对端已经关闭）【 ！重 ！点 ！】</li>
<li><code>-1</code> 应进一步判断errno的值：<ul>
<li><code>errno = EAGAIN or EWOULDBLOCK:</code> 设置了非阻塞方式读。没有数据到达。网络中即读端关闭。 </li>
<li><code>errno = EINTR</code> ：慢速系统调用被中断。</li>
<li><code>errno = ECONNECT</code> ；说明；连接重置，需要close（），移除监听队列。</li>
<li><code>errno = “其他情况”</code>：异常。</li>
</ul>
</li>
</ul>
<p><img src="/2021/12/07/Linux-socket/2021-12-09-21-36-46.png"></p>
<h3 id="代码-服务器端将客户端发来的字母转为大写并返回"><a href="#代码-服务器端将客户端发来的字母转为大写并返回" class="headerlink" title="代码 服务器端将客户端发来的字母转为大写并返回"></a>代码 服务器端将客户端发来的字母转为大写并返回</h3><ul>
<li>server_shc<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// const char *ip = &quot;127.0.0.1&quot;;    //  server的ip可以随机？？？</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> backlog = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1.  创建socket</span></span><br><span class="line">    <span class="comment">//  socket 指明ip地址类型，服务类型，具体协议</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    assert(sockfd&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2.  给服务器socket绑定地址结构 -- 结构中包含IP + port。 （官话：将一个socket与socket地址绑定称之为给socket命名）</span></span><br><span class="line">    <span class="comment">//  bind</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr); <span class="comment">//  清0</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;     <span class="comment">//  设置ip地址类型</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET,ip,&amp;serv_addr.sin_addr.s_addr);  //  设置ip</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//  任意一个本地有效IP？？？？？？？？不能理解为啥可以</span></span><br><span class="line">    serv_addr.sin_port = htons(port);   <span class="comment">//  设置port</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr); <span class="comment">//  绑定结构体地址</span></span><br><span class="line">    assert(ret&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.  设置监听队列长度。 listen不阻塞！！</span></span><br><span class="line">    ret = listen(sockfd,backlog);</span><br><span class="line">    assert(ret&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4.  阻塞等待客户端连接，并返回一个新的socket，在服务器端专门用于与连接的客户端进行读写通信！！！ accept阻塞！有一个客户端连接到服务器了就不再阻塞。</span></span><br><span class="line">    <span class="comment">//  int accept(int sockfd,struct sockaddr *addr,cosklen_t *addrlen);</span></span><br><span class="line">    <span class="comment">//  sockfd 是调用过listen的监听socket（就是通过这个sockfd看有几个客户端连接上来的吧）</span></span><br><span class="line">    <span class="comment">//  *addr : 传入参数，用于接收客户端的结构体，其中包含ip，port。不然怎么与这个客户端通信</span></span><br><span class="line">    <span class="comment">//  addrlen：传入传出参数。传入时表示的是整个准备的cliet_addr结构体的大小，返回时addrlen是实际大小。</span></span><br><span class="line">    <span class="comment">//  int：返回一个新的socket，不是原先的监听socket，也不是那个用于存储客户端内容的结构体，</span></span><br><span class="line">    <span class="comment">//  而是一个新的专门的socket，用于与cliet_addr所代表的客户端进行通信</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_addr;</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(sockfd,(struct sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)    <span class="comment">//  连接失败</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;connection failed&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">//  成功则进行通信</span></span><br><span class="line">        <span class="comment">//  先汇报下客户端的ip以及port</span></span><br><span class="line">        <span class="keyword">char</span> cliet_ip[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client ip = %s , client port = %d\n&quot;</span>,</span><br><span class="line">            inet_ntop(AF_INET,&amp;cliet_addr.sin_addr.s_addr,cliet_ip,INET_ADDRSTRLEN),</span><br><span class="line">            cliet_addr.sin_port);</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// int len = read(connfd,buf,sizeof buf);  //  阻塞读取客户端</span></span><br><span class="line">            <span class="keyword">int</span> len = recv(connfd,buf,BUFSIZ,<span class="number">0</span>);    <span class="comment">//  阻塞读取客户端</span></span><br><span class="line">            assert(len!=<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)</span><br><span class="line">                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">            write(STDOUT_FILENO,buf,len);</span><br><span class="line">            <span class="comment">// write(connfd,buf,len);   //  返回给客户端</span></span><br><span class="line">            send(connfd,buf,len,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  关闭两个socket。 一个是监听socket，一个是通信socket</span></span><br><span class="line">    close(connfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// socklen_t unsigned int</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>client_shc</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  客户端程序 socket - connect - write - read - close</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  创建socket  客户端只有这一个socket，之后客户端用过这个socket与服务器进行通信</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    assert(sockfd&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  连接服务器</span></span><br><span class="line">    <span class="comment">//  int connect(int sockfd,const struct sockaddr *serv_addr,socklen_t addrlen);</span></span><br><span class="line">    <span class="comment">//  serv_addr 为服务器地址结构，是为传入参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span>   <span class="comment">//  要去连接的服务器的结构体（ 包含 ip port )</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;             <span class="comment">//  写入ip类型</span></span><br><span class="line">    serv_addr.sin_port = htons(port);           <span class="comment">//  写入port</span></span><br><span class="line">    inet_pton(AF_INET,ip,&amp;serv_addr.sin_addr);  <span class="comment">//  写入ip</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(sockfd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);  <span class="comment">//  发向服务器端起连接  </span></span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;connect failed&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">        &#123;</span><br><span class="line">            send(sockfd,<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// int len = read(sockfd,buf,BUFSIZ);</span></span><br><span class="line">            <span class="keyword">int</span> len = recv(sockfd,buf,BUFSIZ,<span class="number">0</span>);</span><br><span class="line">            write(STDOUT_FILENO,buf,len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/linux_network$ ./client_shc.out </span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">HELLO</span><br><span class="line">shc@shc-virtual-machine:~/code/linux_network$ </span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/linux_network$ ./server_shc.out client ip = 127.0.0.1 , client port = 48805</span><br><span class="line">HELLOHELLOHELLOHELLOHELLOHELLOHELLOHELLOHELLOHELLO</span><br></pre></td></tr></table></figure>



<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><ul>
<li>socket -&gt; bind -&gt; listen -&gt;while(1){accept , fork}<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  多进程服务器 </span></span><br><span class="line"><span class="comment">//  父进程手握listen socket ；注册捕捉SIGCHLD， 在回调函数中wait子进程残余 避免僵尸； （或者注册忽略）</span></span><br><span class="line"><span class="comment">//  子进程手握accept socket </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">socket()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bind</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">listen</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while(1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  connfd = accept  //  接收连接</span></span><br><span class="line"><span class="comment">  pid = fork</span></span><br><span class="line"><span class="comment">  if(pid==0)    //  子进程</span></span><br><span class="line"><span class="comment">      close(lfd); //  关闭监听套接字的fd</span></span><br><span class="line"><span class="comment">      ...</span></span><br><span class="line"><span class="comment">  else if(pid&gt;0)  //  父进程</span></span><br><span class="line"><span class="comment">      close(connfd)   //  关闭accept socket</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> backlog = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commu</span><span class="params">(<span class="keyword">int</span> connfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = recv(connfd,buf,BUFSIZ,<span class="number">0</span>);    <span class="comment">//  通信对方关闭时返回0</span></span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">-1</span>) &#123;perror(<span class="string">&quot;recv error&quot;</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)  <span class="comment">//  </span></span><br><span class="line">        &#123;</span><br><span class="line">            close(connfd);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// std::cout&lt;&lt;buf&lt;&lt;std::endl;</span></span><br><span class="line">        write(STDOUT_FILENO,buf,len);</span><br><span class="line">        send(connfd,buf,len,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler_SIGCHLD</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(wait(<span class="literal">NULL</span>)&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;port&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;htons(port)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  准备好socket地址（ip+port）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    serv_addr.sin_port = htons(port);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;serv_addr.sin_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  指明socket属性</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    assert(lfd&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  端口可复用。在bind绑定ip地址之前设置</span></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,(<span class="keyword">void</span>*)&amp;opt,<span class="keyword">sizeof</span>(opt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  绑定socket地址</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  监听队列长度</span></span><br><span class="line">    listen(lfd,backlog);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  父进程把握 listen socket</span></span><br><span class="line">    <span class="comment">//  子进程去把握 accept socket 阻塞等待连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_addr;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;getpid()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> connfd = accept(lfd,(struct sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">        <span class="keyword">if</span>(connfd==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno==EINTR)&#123;   <span class="comment">//  慢速系统调用 适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应处理函数返回时，该系统调用可能返回一个EINTR错误。所以，我们必须对慢系统调用返回的EINTR有所准备</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先 accept 从监听队列中取出已经ESTABLISED的，进行通信</span></span><br><span class="line">        <span class="comment">//  然后再fork 如果先fork而在子进程中accept的话，就很有可能会造成无数个子进程阻塞在accept上。</span></span><br><span class="line">        <span class="comment">//  而先accept就可以在fork之前就阻塞在那里。</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        assert(pid!=<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)  <span class="comment">//  子进程 </span></span><br><span class="line">        &#123;</span><br><span class="line">            close(lfd); <span class="comment">//  子进程不需要</span></span><br><span class="line">            commu(connfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 父进程 回收死去的子进程 什么时候死去？子进程的socket所连接的客户端的socket关闭时</span></span><br><span class="line">        &#123;</span><br><span class="line">            close(connfd);     <span class="comment">//  父进程不需要</span></span><br><span class="line">            <span class="comment">// signal(SIGCHLD,SIG_IGN);</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigact</span>;</span></span><br><span class="line">            sigemptyset(&amp;sigact.sa_mask);   <span class="comment">//  设置默认屏蔽字</span></span><br><span class="line">            sigact.sa_flags = <span class="number">0</span>;    <span class="comment">//  设置默认属性 本信号自动屏蔽</span></span><br><span class="line">            sigact.sa_handler = handler_SIGCHLD;</span><br><span class="line">            sigaction(SIGCHLD,&amp;sigact,<span class="literal">NULL</span>);    <span class="comment">//  注册捕捉</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为线程间共享文件描述符，因此副线程不能关闭lfd，主线程不能关闭connfd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void* tfn(void*)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  // close(lfd)			不能关闭。！！ 主线程要使用lfd</span></span><br><span class="line"><span class="comment">  利用connfd通信</span></span><br><span class="line"><span class="comment">  pthread_exit((void*)0);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lfd = socket</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">bind</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">listen</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while(1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    connfd = accept</span></span><br><span class="line"><span class="comment">    pthread_create(tfn)</span></span><br><span class="line"><span class="comment">    pthread_detach;     //  线程分离</span></span><br><span class="line"><span class="comment">    // pthead_join(tid, void **);  新线程---专用于回收子线程</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">pair</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,struct sockaddr_in&gt; PIS;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">pthread_t</span> ptd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIS* s_info = <span class="keyword">static_cast</span>&lt;PIS*&gt;(arg);</span><br><span class="line">    <span class="keyword">int</span> connfd = s_info-&gt;first;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">cliet_addr</span> =</span> &amp;(s_info-&gt;second);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;inet_ntoa(cliet_addr-&gt;sin_addr)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ntohs(cliet_addr-&gt;sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> len = recv(connfd,buf,BUFSIZ,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            close(connfd);</span><br><span class="line">            pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len==<span class="number">-1</span>)&#123;</span><br><span class="line">            close(connfd);</span><br><span class="line">            perror(<span class="string">&quot;rec error&quot;</span>);</span><br><span class="line">            pthread_exit((<span class="keyword">void</span>*)<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i) </span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line"></span><br><span class="line">        write(STDOUT_FILENO,buf,len);</span><br><span class="line">        send(connfd,buf,len,<span class="number">0</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    close(connfd);  <span class="comment">//  感觉走不到这里</span></span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  准备地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);  <span class="comment">//  任意一个有效 ip 建议这样写 具体我还没直到为啥 有空研究研究</span></span><br><span class="line">    <span class="comment">//  socket属性</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    assert(lfd&gt;=<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  绑定地址</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    listen(lfd,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_addr;</span><br><span class="line">        <span class="keyword">int</span> connfd = accept(lfd,(struct sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">        assert(connfd&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        PIS s_info = <span class="built_in">make_pair</span>(connfd,cliet_addr);</span><br><span class="line">        pthread_create(&amp;ptd,<span class="literal">NULL</span>,tfn,<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(&amp;s_info));   <span class="comment">// 创建线程</span></span><br><span class="line">        pthread_detach(ptd);    <span class="comment">//  设置线程分离 新线程结束后自动回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>select多路IO转接服务器模型<ul>
<li>我认为可以用set优化，将要监听读缓冲区的connfd加入set，之后遍历set找发生变化的fd。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// select 不用多进程多线程 实现一个server 多个cliet连接</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="comment">//    #include &lt;sys/time.h&gt;</span></span><br><span class="line"><span class="comment">//    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">//    #include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    int select(int nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="comment">//               fd_set *exceptfds, struct timeval *timeout);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    void FD_CLR(int fd, fd_set *set);</span></span><br><span class="line"><span class="comment">//    int  FD_ISSET(int fd, fd_set *set);</span></span><br><span class="line"><span class="comment">//    void FD_SET(int fd, fd_set *set);</span></span><br><span class="line"><span class="comment">//    void FD_ZERO(fd_set *set);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ip = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serv_addr,<span class="number">0</span>);</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    serv_addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lfd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lfd&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,<span class="keyword">sizeof</span> opt);    <span class="comment">//  设置端口复用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>(lfd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd,<span class="number">128</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    fd_set rset,allset; <span class="comment">//  rset：read_set 监听这些文字描述副的读缓冲区  allset：所有可以被监听的文件描述副号</span></span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;allset); </span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd,&amp;allset);</span><br><span class="line">    <span class="keyword">int</span> maxfd = lfd;    <span class="comment">//  maxfd：监听的最大文件描述符号</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rset = allset;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">select</span>(maxfd+<span class="number">1</span>,&amp;rset,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);  <span class="comment">//  三个set都是传入传出参数    select会阻塞</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">-1</span>) &#123;<span class="built_in">perror</span>(<span class="string">&quot;select error&quot;</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(lfd,&amp;rset)) <span class="comment">//  如果lfd被监测到改变，那么就是有客户端发起连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_len;</span><br><span class="line">            <span class="keyword">int</span> connfd = <span class="built_in">accept</span>(lfd,(struct sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">            <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>) &#123;<span class="built_in">perror</span>(<span class="string">&quot;accept error&quot;</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">            <span class="built_in">FD_SET</span>(connfd,&amp;allset);   <span class="comment">//  添加文件描述符</span></span><br><span class="line">            maxfd = std::<span class="built_in">max</span>(maxfd,connfd);     <span class="comment">// 为什么是max而非直接等于 因为可能之前会有客户端close使得相应server这端的connfd close，使得这次选的是小的文件描述副</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;connfd:&quot;&lt;&lt;connfd&lt;&lt;&quot; maxfd&quot;&lt;&lt;maxfd&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">1</span>) <span class="keyword">continue</span>;    <span class="comment">//  检测到lfd发生变化 &amp;&amp; 只有1个fd状态变化，那么就continue; 否则 去处理其他读文件</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//  处理读  遍历文件描述符 寻找被检测到收到数据的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fd=lfd+<span class="number">1</span>;fd!=maxfd+<span class="number">1</span>;++fd)   </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">FD_ISSET</span>(fd,&amp;rset)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;fd&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">recv</span>(fd,buf,BUFSIZ,<span class="number">0</span>);    <span class="comment">//  应该还要考虑慢速系统调用 略去</span></span><br><span class="line">            <span class="keyword">if</span>(len==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">close</span>(fd);</span><br><span class="line">                <span class="built_in">FD_CLR</span>(fd,&amp;allset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(len==<span class="number">-1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i)</span><br><span class="line">                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">write</span>(STDOUT_FILENO,buf,len);</span><br><span class="line">            <span class="built_in">send</span>(fd,buf,len,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="headerlink" title="三次握手 四次挥手"></a><strong>三次握手 四次挥手</strong></h2><ul>
<li>等学计网了再深入研究理论吧我去。<br><img src="/2021/12/07/Linux-socket/2021-12-14-21-08-48.png"></li>
</ul>
<p><img src="/2021/12/07/Linux-socket/2021-12-14-21-10-33.png"></p>
<h2 id="TCP状态时序图"><a href="#TCP状态时序图" class="headerlink" title="TCP状态时序图"></a><strong>TCP状态时序图</strong></h2><ul>
<li><p>主动发起连接请求端：    CLOSE – 发送SYN – SEND_SYN – 接收 ACK、SYN – SEND_SYN – 发送 ACK – ESTABLISHED（数据通信态）</p>
</li>
<li><p>被动接收连接请求端： CLOSE – LISTEN – 接收 SYN – LISTEN – 发送 ACK、SYN – SYN_RCVD – 接收ACK – ESTABLISHED（数据通信态）</p>
</li>
<li><p>主动关闭连接请求端： ESTABLISHED（数据通信态） – 发送 FIN – FIN_WAIT_1 – 接收ACK – FIN_WAIT_2（半关闭）    – 接收对端发送 FIN – FIN_WAIT_2（半关闭（关闭了客户端的写缓冲区））– 回发ACK – TIME_WAIT（只有主动关闭连接方，会经历该状态）    – 等 2MSL时长 – CLOSE </p>
</li>
<li><p>被动关闭连接请求端： ESTABLISHED（数据通信态） – 接收 FIN – ESTABLISHED（数据通信态） – 发送ACK – CLOSE_WAIT (说明对端【主动关闭连接端】处于半关闭状态) – 发送FIN – LAST_ACK – 接收ACK – CLOSE</p>
</li>
<li><p>重点记忆： ESTABLISHED、FIN_WAIT_2 &lt;–&gt; CLOSE_WAIT、TIME_WAIT（2MSL）</p>
<p>  netstat -apn | grep  端口号</p>
</li>
<li><p>2MSL时长：</p>
<ul>
<li>一定出现在【主动关闭连接请求端】。 — 对应 TIME_WAIT 状态。</li>
<li>保证，最后一个 ACK 能成功被对端接收。（等待期间，对端没收到我发的ACK，对端会再次发送FIN请求。）</li>
</ul>
</li>
</ul>
<p><img src="/2021/12/07/Linux-socket/2021-12-14-21-12-20.png"></p>
<p>close <strong>半关闭？？？</strong></p>
<h2 id="socket缓冲区-及半关闭"><a href="#socket缓冲区-及半关闭" class="headerlink" title="socket缓冲区 及半关闭"></a>socket缓冲区 及半关闭</h2><h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><ul>
<li>客户端半关闭是指客户端关闭了写缓冲区，不能向server写数据，但是仍然可以接收数据。</li>
<li>每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</li>
<li>write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</li>
<li>TCP协议独立于 write()/send() 函数，数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络，这取决于当时的网络情况、当前线程是否空闲等诸多因素，不由程序员控制。</li>
<li>socket被创建后会分配两个缓冲区：<ul>
<li>这些I/O缓冲区特性可整理如下：<ul>
<li>I/O缓冲区在每个TCP套接字中单独存在；</li>
<li>I/O缓冲区在创建套接字时自动生成；</li>
<li>即使关闭套接字也会继续传送输出缓冲区中遗留的数据；</li>
<li>关闭套接字将丢失输入缓冲区中的数据。<br><img src="/2021/12/07/Linux-socket/2021-12-14-18-39-45.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="慢速系统调用-博客"><a href="#慢速系统调用-博客" class="headerlink" title="慢速系统调用(博客)"></a><strong>慢速系统调用(博客)</strong></h2><ul>
<li>我们用术语慢系统调用<code>slowsystem call</code>描述accept函数，该术语也适用于那些可能永远阻塞的系统调用。永远阻塞的系统调用有可能永远无法返回，多数网络支持函数都属于这一类。举例来说，如果没有客户连接到服务器上，那么服务器的accept调用就没有返回的保证。类似的，如果客户端从未发送过数据，那么read调用将永不返回。其他慢系统调用的例子是对管道和终端设备的读和写。一个值得注意的例外是磁盘IO，它们一般都会返回到调用者（假设没有灾难性的硬件事故）。</li>
<li><strong>适用于慢系统调用的基本规则是：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应处理函数返回时，该系统调用可能返回一个EINTR错误。所以，我们必须对慢系统调用返回的EINTR有所准备。</strong></li>
<li>为了处理被中断的accept,可以改成如下形式：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  重启被信号中断的系统调用accept</span></span><br><span class="line"><span class="comment">//  对于read、write、select、open同理</span></span><br><span class="line"><span class="comment">//  根据某一博客说 但是不能重启connect</span></span><br><span class="line"><span class="comment">//  如果该函数返回EINTR，我们就不能再次调用它，否则将立即返回一个错误。当connect被一个捕获信号中断而且不自动重启时，我们必须调用select来等待连接完成。</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span>((connfd=accept(listenfd,<span class="literal">NULL</span>, <span class="literal">NULL</span>))&lt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> sys_err(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>EPOLL 的ET和LT<ul>
<li>server<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  服务器端分别采用 ET 、LT 模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[20];</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">5</span>];   <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    assert(lfd&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    serv_addr.sin_port = htons(port);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    listen(lfd,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// event.events = EPOLLIN; //  电平触发</span></span><br><span class="line">    event.events = EPOLLIN|EPOLLET; <span class="comment">//  边沿触发s</span></span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;event);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = epoll_wait(epfd,events,<span class="number">50</span>,<span class="number">-1</span>);  <span class="comment">//  返回就绪的文件描述符个数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;n = &quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  建立连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_addr; </span><br><span class="line">                <span class="keyword">int</span> connfd = accept(lfd,(struct sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;port = &quot;</span>&lt;&lt;cliet_addr.sin_port&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//  注册到内核事件表</span></span><br><span class="line">                event.data.fd = connfd;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;event);    <span class="comment">//  往事件表上注册connfd上的事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  开读写</span></span><br><span class="line">                <span class="keyword">int</span> connfd = events[i].data.fd;</span><br><span class="line">                <span class="comment">// int len = recv(connfd,buf,5,0); //  一次最多读5个 观察ET、LT模式下的区别  </span></span><br><span class="line">                <span class="keyword">int</span> len = read(connfd,buf,<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;connection &quot;</span>&lt;&lt;connfd&lt;&lt;<span class="string">&quot; is closed&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                    close(connfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(len==<span class="number">-1</span>)</span><br><span class="line">                &#123;   <span class="comment">// cliet主动关闭时会到这里，不能理解！！！！？？？</span></span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;errno&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">//  104</span></span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cerr</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//  Connection reset by peer</span></span><br><span class="line">                    <span class="keyword">if</span>(errno==EINTR)    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">else</span>   <span class="built_in">exit</span>(<span class="number">1</span>);   </span><br><span class="line">                &#125; </span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i) buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                send(connfd,buf,len,<span class="number">0</span>);</span><br><span class="line">                write(STDOUT_FILENO,buf,len);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  猜测 。 事实也是这样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   LT：</span></span><br><span class="line"><span class="comment">        n = 1;</span></span><br><span class="line"><span class="comment">        port = xxx;</span></span><br><span class="line"><span class="comment">        n = 1;</span></span><br><span class="line"><span class="comment">        aaaa</span></span><br><span class="line"><span class="comment">        n = 1</span></span><br><span class="line"><span class="comment">        bbbb</span></span><br><span class="line"><span class="comment">------------------sleep(5)-------------------</span></span><br><span class="line"><span class="comment">        n = 1;</span></span><br><span class="line"><span class="comment">        cccc</span></span><br><span class="line"><span class="comment">        n = 1;</span></span><br><span class="line"><span class="comment">        dddd</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ET：</span></span><br><span class="line"><span class="comment">        n = 1;</span></span><br><span class="line"><span class="comment">        port = xxx;</span></span><br><span class="line"><span class="comment">        n = 1;</span></span><br><span class="line"><span class="comment">        aaaa        </span></span><br><span class="line"><span class="comment">        此时recv仍可以继续读5个字符，</span></span><br><span class="line"><span class="comment">        但是由于recv完之后就到了下一轮的epoll_wait，</span></span><br><span class="line"><span class="comment">        epoll_wait是边沿触发，不是电平触发，所以epoll_wait被阻塞在这里，</span></span><br><span class="line"><span class="comment">        直到下一次cliet端发起send动作，这里的epoll才能不再被阻塞，才能走到 // 开读写 这里。rec读取之前没有读入的bbbb</span></span><br><span class="line"><span class="comment">        //（不过那bbbb之前是存在哪里呢？？？）</span></span><br><span class="line"><span class="comment">------------------sleep(5)----------------</span></span><br><span class="line"><span class="comment">        n = 1</span></span><br><span class="line"><span class="comment">        bbbb</span></span><br><span class="line"><span class="comment">------------------sleep(5)----------------</span></span><br><span class="line"><span class="comment">        n = 2;</span></span><br><span class="line"><span class="comment">        cccc</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>client<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cliet_fd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    assert(cliet_fd!=<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_port = htons(port);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>,&amp;serv_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = connect(cliet_fd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> t = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[maxn];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">4</span>)    buf[i]=<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> buf[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;maxn;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">9</span>) buf[i] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> buf[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        send(cliet_fd,buf,maxn,<span class="number">0</span>);    <span class="comment">//  send</span></span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li><strong>ET必须搭配非阻塞IO</strong></li>
<li> 代码 client同上<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  服务器端分别采用 ET 、LT 模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = <span class="number">12345</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[20];</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">5</span>];   <span class="keyword">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    assert(lfd&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    bzero(&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    serv_addr.sin_port = htons(port);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    listen(lfd,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// event.events = EPOLLIN; //  电平触发</span></span><br><span class="line">    event.events = EPOLLIN|EPOLLET; <span class="comment">//  边沿触发s</span></span><br><span class="line">    event.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&amp;event);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = epoll_wait(epfd,events,<span class="number">50</span>,<span class="number">-1</span>);  <span class="comment">//  返回就绪的文件描述符个数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;n = &quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  建立连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_addr; </span><br><span class="line">                <span class="keyword">int</span> connfd = accept(lfd,(struct sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;port = &quot;</span>&lt;&lt;cliet_addr.sin_port&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  设置connfd为非阻塞I/O!!!!</span></span><br><span class="line">                <span class="keyword">int</span> op = fcntl(connfd,F_GETFL);                </span><br><span class="line">                op |= O_NONBLOCK;</span><br><span class="line">                fcntl(connfd,F_SETFL,op);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  注册到内核事件表</span></span><br><span class="line">                event.data.fd = connfd;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;event);    <span class="comment">//  往事件表上注册connfd上的事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  开读写</span></span><br><span class="line">                <span class="keyword">int</span> connfd = events[i].data.fd;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((len=read(connfd,buf,<span class="number">5</span>))&gt;<span class="number">0</span>) <span class="comment">//  非阻塞 忙轮询</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=len;++i) buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">                    send(connfd,buf,len,<span class="number">0</span>);</span><br><span class="line">                    write(STDOUT_FILENO,buf,len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;len&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/linux_network$ ./server_epoll_ET_nonblock_IO.out</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">port = <span class="number">45799</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">AAAA</span><br><span class="line">BBBB</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">BBBB</span><br><span class="line">CCCC</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">CCCC</span><br><span class="line">DDDD</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">DDDD</span><br><span class="line">EEEE</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">EEEE</span><br><span class="line">FFFF</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">FFFF</span><br><span class="line">GGGG</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">GGGG</span><br><span class="line">HHHH</span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">-1</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">========================</span><br><span class="line">      The  epoll  event  distribution  interface  is  able to behave both as edge-triggered (ET) <span class="keyword">and</span> as level-triggered (LT).  The difference between the two mechanisms can be</span><br><span class="line">       described as follows.  Suppose that <span class="keyword">this</span> scenario happens:</span><br><span class="line"></span><br><span class="line">       <span class="number">1.</span> The file descriptor that represents the read side of a pipe (rfd) is registered on the epoll instance.</span><br><span class="line"></span><br><span class="line">       <span class="number">2.</span> A pipe writer writes <span class="number">2</span> kB of data on the write side of the pipe.</span><br><span class="line"></span><br><span class="line">       <span class="number">3.</span> A call to epoll_wait(<span class="number">2</span>) is done that will <span class="keyword">return</span> rfd as a ready file descriptor.</span><br><span class="line"></span><br><span class="line">       <span class="number">4.</span> The pipe reader reads <span class="number">1</span> kB of data from rfd.</span><br><span class="line"></span><br><span class="line">       <span class="number">5.</span> A call to epoll_wait(<span class="number">2</span>) is done.</span><br><span class="line"></span><br><span class="line">       If the rfd file descriptor has been added to the epoll interface <span class="keyword">using</span> the EPOLLET (edge-triggered) flag, the call to epoll_wait(<span class="number">2</span>) done in step  <span class="number">5</span>  will  probably  hang</span><br><span class="line">       despite the available data still present in the file input buffer; meanwhile the remote peer might be expecting a response based on the data it already sent.  The reason</span><br><span class="line">       <span class="keyword">for</span> <span class="keyword">this</span> is that edge-triggered mode delivers events only when changes occur on the monitored file descriptor.  So, in step <span class="number">5</span> the caller might end up  waiting  <span class="keyword">for</span>  some</span><br><span class="line">       data  that  is already present inside the input buffer.  In the above example, an event on rfd will be generated because of the write done in <span class="number">2</span> <span class="keyword">and</span> the event is consumed</span><br><span class="line">       in <span class="number">3.</span>  Since the read operation done in <span class="number">4</span> does <span class="keyword">not</span> consume the whole buffer data, <span class="function">the call to <span class="title">epoll_wait</span><span class="params">(<span class="number">2</span>)</span> done in step 5 might block indefinitely.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       An application that employs the EPOLLET flag should use nonblocking file descriptors to avoid having a blocking read <span class="keyword">or</span> write starve a task  that  is  handling  multiple</span></span><br><span class="line"><span class="function">       file descriptors.  The suggested way to use epoll as an edge-<span class="title">triggered</span> <span class="params">(EPOLLET)</span> interface is as follows:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">              i   with nonblocking file descriptors</span>; <span class="function"><span class="keyword">and</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">              ii  by waiting <span class="keyword">for</span> an event only after <span class="title">read</span><span class="params">(<span class="number">2</span>)</span> <span class="keyword">or</span> <span class="title">write</span><span class="params">(<span class="number">2</span>)</span> <span class="keyword">return</span> EAGAIN.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       By contrast, when used as a level-triggered <span class="title">interface</span> <span class="params">(the <span class="keyword">default</span>, when EPOLLET is <span class="keyword">not</span> specified)</span>, epoll is simply a faster <span class="title">poll</span><span class="params">(<span class="number">2</span>)</span>, <span class="keyword">and</span> can be used wherever the latter</span></span><br><span class="line"><span class="function">       is used since it shares the same semantics.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       Since even with edge-triggered epoll, multiple events can be generated upon receipt of multiple chunks of data, the caller has the option  to  specify  the  EPOLLONESHOT</span></span><br><span class="line"><span class="function">       flag, to tell epoll to disable the associated file descriptor after the receipt of an event with <span class="title">epoll_wait</span><span class="params">(<span class="number">2</span>)</span>.  When the EPOLLONESHOT flag is specified, it is the call‐</span></span><br><span class="line"><span class="function">       er&#x27;s responsibility to rearm the file descriptor <span class="keyword">using</span> <span class="title">epoll_ctl</span><span class="params">(<span class="number">2</span>)</span> with EPOLL_CTL_MOD.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>read 返回-1时不会发送信号使得进程终止 需要我们来人为判断 这里read返回-1时 就是EGAIN，是read读非阻塞文件时对面无数据返回的值，是正常情况，故我们不让其退出。<br><img src="/2021/12/07/Linux-socket/2021-12-15-20-18-17.png"></p>
<p>Epoll水平触发+非阻塞IO的理解<br>蝉鸣的夏季<br>蝉鸣的夏季<br>​关注他<br>4 人赞同了该文章<br>首先水平触发(LT)、边缘触发(ET)、阻塞IO、非阻塞IO概念我就不普及了，默认大家都懂了。经常有人会疑惑为什么ET要配合非阻塞IO？为什么ET加非阻塞IO性能更好？我就谈谈自己的理解吧。</p>
<p>首先我们考虑下面几种情况：</p>
<p>假设buffer有1024字节大小，一次读取的数据较小，小于1024：这种情况下LT、ET、阻塞和非阻塞其实都一样，没有区别。因为阻塞和非阻塞都是调用recv()函数，并且一次就能返回，并不会阻塞在这里。由于一次性读取完，epoll_wait上只会出现一次可读事件，这样ET和LT就没有任何区别了。<br>假设buffer有1024字节，一次读取的数据很大，超过1024的大小：这种情况就需要读取多次，也就是要调用多次recv函数，通常我们会用while循环一直读取，无论ET还是LT，这样LT模式就显得很鸡肋，所以一般不用LT。在ET模式下，(1)、如果用阻塞IO+while循环，当最后一个数据读取完后，程序是无法立刻跳出while循环的，因为阻塞IO会在 while(true){ int len=recv(); }这里阻塞住，除非对方关闭连接或者recv出错，这样程序就无法继续往下执行，这一次的epoll_wait没有办法处理其它的连接，会造成延迟、并发度下降。(2)、如果是非阻塞IO+while循环，当读取完数据后，recv会立即返回-1，并将errno设置为EAGAIN或EWOULDBLOCK,这就表示数据已经读取完成，已经没有数据了，可以退出循环了。这样就不会像阻塞IO一样卡在那里，这就减少了不必要的等待时间，性能自然更高。<br>LT模式就不细说了，用的很少。<br>总结下：</p>
<p>每次读取小数据，所有一切都一样，一次读完返回，不用while。<br>读大数据，LT用的很少，几乎都是ET，阻塞IO会卡在while里，非阻塞IO会立即返回，性能更好。<br>最后补充两种情况，</p>
<p>1.读数据时，如果缓冲区装满，write 会阻塞住，等待写缓冲区有空余可写，如果网络拥塞，数据迟迟没有被发送走，整个epoll连接都会中断。</p>
<p>2.epoll返回可读，数据可能因为各种原因被内核丢弃，这样你read的时候会一直卡在那里，整个epoll我也会被阻塞在那里。</p>
<p>heima :老师的意思是，程序阻塞在readn上，即便再来两个字节的数据，也轮不到wait执行，程序已经在readn那不动了，跟哪个客户端没关系</p>
<p>不到叫啥名:<br>C++多线程和C的多线程</p>
<p>trigger - 必应词典<br>美[ˈtrɪɡər]英[ˈtrɪɡə(r)]<br>n.触发器；（枪的）扳机；（尤指引发不良反应或发展的）起因；引爆器<br>v.触发；引起；发动；开动<br>网络板机；触发程序；启动</p>
<p><img src="/2021/12/07/Linux-socket/2021-12-13-18-52-31.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">端口复用:</span><br><span class="line"></span><br><span class="line">	int opt = 1;		// 设置端口复用。</span><br><span class="line"></span><br><span class="line">	setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, (void *)&amp;opt, sizeof(opt));</span><br><span class="line"></span><br><span class="line">半关闭：</span><br><span class="line"></span><br><span class="line">	通信双方中，只有一端关闭通信。  --- FIN_WAIT_2</span><br><span class="line"></span><br><span class="line">	close（cfd）;</span><br><span class="line"></span><br><span class="line">	shutdown(int fd, int how);	</span><br><span class="line"></span><br><span class="line">		how: 	SHUT_RD	关读端</span><br><span class="line"></span><br><span class="line">			SHUT_WR	关写端</span><br><span class="line"></span><br><span class="line">			SHUT_RDWR 关读写</span><br><span class="line"></span><br><span class="line">	shutdown在关闭多个文件描述符应用的文件时，采用全关闭方法。close，只关闭一个。</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">select多路IO转接：</span><br><span class="line"></span><br><span class="line">	原理：  借助内核， select 来监听， 客户端连接、数据通信事件。</span><br><span class="line"></span><br><span class="line">	void FD_ZERO(fd_set *set);	--- 清空一个文件描述符集合。</span><br><span class="line"></span><br><span class="line">		fd_set rset;</span><br><span class="line"></span><br><span class="line">		FD_ZERO(&amp;rset);</span><br><span class="line"></span><br><span class="line">	void FD_SET(int fd, fd_set *set);	--- 将待监听的文件描述符，添加到监听集合中</span><br><span class="line"></span><br><span class="line">		FD_SET(3, &amp;rset);	FD_SET(5, &amp;rset);	FD_SET(6, &amp;rset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void FD_CLR(int fd, fd_set *set);	--- 将一个文件描述符从监听集合中 移除。</span><br><span class="line"></span><br><span class="line">		FD_CLR（4， &amp;rset）;</span><br><span class="line"></span><br><span class="line">	int  FD_ISSET(int fd, fd_set *set);	--- 判断一个文件描述符是否在监听集合中。</span><br><span class="line"></span><br><span class="line">		返回值： 在：1；不在：0；</span><br><span class="line"></span><br><span class="line">		FD_ISSET（4， &amp;rset）;</span><br><span class="line">		</span><br><span class="line">	int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">		nfds：监听的所有文件描述符中，最大文件描述符+1</span><br><span class="line"></span><br><span class="line">		readfds： 读 文件描述符监听集合。	传入、传出参数</span><br><span class="line"></span><br><span class="line">		writefds：写 文件描述符监听集合。	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		exceptfds：异常 文件描述符监听集合	传入、传出参数		NULL</span><br><span class="line"></span><br><span class="line">		timeout： 	&gt; 0: 	设置监听超时时长。</span><br><span class="line"></span><br><span class="line">				NULL:	阻塞监听</span><br><span class="line"></span><br><span class="line">				0：	非阻塞监听，轮询</span><br><span class="line">		返回值：</span><br><span class="line"></span><br><span class="line">			&gt; 0:	所有监听集合（3个）中， 满足对应事件的总数。</span><br><span class="line"></span><br><span class="line">			0：	没有满足监听条件的文件描述符</span><br><span class="line"></span><br><span class="line">			-1： 	errno</span><br><span class="line"></span><br><span class="line">思路分析：</span><br><span class="line"></span><br><span class="line">	int maxfd = 0；</span><br><span class="line"></span><br><span class="line">	lfd = socket() ;			创建套接字</span><br><span class="line"></span><br><span class="line">	maxfd = lfd；</span><br><span class="line"></span><br><span class="line">	bind();					绑定地址结构</span><br><span class="line"></span><br><span class="line">	listen();				设置监听上限</span><br><span class="line"></span><br><span class="line">	fd_set rset， allset;			创建r监听集合</span><br><span class="line"></span><br><span class="line">	FD_ZERO(&amp;allset);				将r监听集合清空</span><br><span class="line"></span><br><span class="line">	FD_SET(lfd, &amp;allset);			将 lfd 添加至读集合中。</span><br><span class="line"></span><br><span class="line">	while（1） &#123;</span><br><span class="line"></span><br><span class="line">		rset = allset；			保存监听集合</span><br><span class="line">	</span><br><span class="line">		ret  = select(lfd+1， &amp;rset， NULL， NULL， NULL);		监听文件描述符集合对应事件。</span><br><span class="line"></span><br><span class="line">		if（ret &gt; 0） &#123;							有监听的描述符满足对应事件</span><br><span class="line">		</span><br><span class="line">			if (FD_ISSET(lfd, &amp;rset)) &#123;				// 1 在。 0不在。</span><br><span class="line"></span><br><span class="line">				cfd = accept（）；				建立连接，返回用于通信的文件描述符</span><br><span class="line"></span><br><span class="line">				maxfd = cfd；</span><br><span class="line"></span><br><span class="line">				FD_SET(cfd, &amp;allset);				添加到监听通信描述符集合中。</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for （i = lfd+1； i &lt;= 最大文件描述符; i++）&#123;</span><br><span class="line"></span><br><span class="line">				FD_ISSET(i, &amp;rset)				有read、write事件</span><br><span class="line"></span><br><span class="line">				read（）</span><br><span class="line"></span><br><span class="line">				小 -- 大</span><br><span class="line"></span><br><span class="line">				write();</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select优缺点：</span><br><span class="line"></span><br><span class="line">	缺点：	监听上限受文件描述符限制。 最大 1024.</span><br><span class="line"></span><br><span class="line">		检测满足条件的fd， 自己添加业务逻辑提高小。 提高了编码难度。</span><br><span class="line"></span><br><span class="line">	优点：	跨平台。win、linux、macOS、Unix、类Unix、mips</span><br><span class="line">select除了可以支持多个客户端连接 效率是不是也变高</span><br><span class="line">select</span><br><span class="line">select监听上xian受到个文件描述符限制，1024个</span><br><span class="line">优点：多路IO转接里唯一可以跨平台。</span><br><span class="line">Check the first NFDS descriptors each in READFDS (if not NULL) for read</span><br><span class="line">readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS</span><br><span class="line">(if not NULL) for exceptional conditions. If TIMEOUT is not NULL, time out</span><br><span class="line">after waiting the interval specified therein. Returns the number of ready</span><br><span class="line">descriptors, or -1 for errors.</span><br><span class="line"></span><br><span class="line">This function is a cancellation point and therefore not marked with</span><br><span class="line">__THROW.</span><br></pre></td></tr></table></figure>
<ul>
<li>Epoll 似乎不双工？？</li>
<li>似乎只能单线程？？</li>
</ul>
<p>不到叫啥名:<br><a href="https://cloud.tencent.com/developer/article/1662501">https://cloud.tencent.com/developer/article/1662501</a></p>
<p>不到叫啥名:<br><a href="https://segmentfault.com/a/1190000020031911">https://segmentfault.com/a/1190000020031911</a></p>
<p>不到叫啥名:<br><a href="https://www.cnblogs.com/rainbow70626/p/5590669.html">https://www.cnblogs.com/rainbow70626/p/5590669.html</a></p>
<p>不到叫啥名:<br><a href="https://www.cnblogs.com/Vae1990Silence/p/4335165.html">https://www.cnblogs.com/Vae1990Silence/p/4335165.html</a></p>
<p><img src="/2021/12/07/Linux-socket/2021-12-11-09-13-35.png"></p>
<p>服务器和客户端都有端口号，但是，服务器的端口号是重要的，因为客户端只有了解了服务器的地址和端口号，才可以连接到它（即使是采用UDP传输数据，也需要指定发送目标的地址和端口号）；而客户端的端口号是无关紧要的，一般由操作系统自动分配。</p>
<h2 id="服务端怎么知道和客户端的哪个进程连接"><a href="#服务端怎么知道和客户端的哪个进程连接" class="headerlink" title="服务端怎么知道和客户端的哪个进程连接???"></a>服务端怎么知道和客户端的哪个进程连接???</h2><p>对于TCP，服务器在客户端连接后，会在监听套接字之外另外生成一个新的套接字，表示与客户端的连接，这个套接字了解客户端的地址和端口号，从而可以区分是哪个客户端；<br>对于UDP，服务器在收到UDP数据时，也了解数据来自什么地址和端口，也可以区分是哪个客户端。</p>
<p>从基本的网络概念来说，网络层(IP)负责两个主机间的通信，用IP地址区分主机；传输层(TCP和UDP)处理两个进程间(可以是在同一台机器中的两个进程，也可以是不同主机中的两个进程）的通信，用端口号区分进程。两者合起来就是，用 IP地址+传输层协议+端口号 来区分与谁进行通信。(传输层协议就是指TCP或者UDP，也可以是别的传输层协议，因为互联网协议栈是个开放的结构，其他传输层协议也可以利用IP作为网络层提供的服务）</p>
<p>localhost:8080<br>localhost是回环ip的域名？ 127.0.0.1。在本地host文件就可以解析<br>8080是端口号</p>
<p><a href="https://juejin.cn/post/7013538093974323231">https://juejin.cn/post/7013538093974323231</a><br><a href="https://www.cnblogs.com/operationhome/p/8681475.html">https://www.cnblogs.com/operationhome/p/8681475.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">相关函数：getsockopt</span><br><span class="line"></span><br><span class="line">头文件：<span class="comment">#include &lt;sys/types.h&gt;   #include &lt;sys/socket.h&gt;</span></span><br><span class="line"></span><br><span class="line">定义函数：int setsockopt(int s, int level, int optname, const void * optval, ,socklen_toptlen);</span><br><span class="line"></span><br><span class="line">函数说明：setsockopt()用来设置参数s 所指定的socket 状态. 参数level 代表欲设置的网络层, 一般设成SOL_SOCKET 以存取socket 层. 参数optname 代表欲设置的选项, 有下列几种数值:</span><br><span class="line">   SO_DEBUG 打开或关闭排错模式</span><br><span class="line">   SO_REUSEADDR 允许在<span class="built_in">bind</span> ()过程中本地地址可重复使用</span><br><span class="line">   SO_TYPE 返回socket 形态.</span><br><span class="line">   SO_ERROR 返回socket 已发生的错误原因</span><br><span class="line">   SO_DONTROUTE 送出的数据包不要利用路由设备来传输.</span><br><span class="line">   SO_BROADCAST 使用广播方式传送</span><br><span class="line">   SO_SNDBUF 设置送出的暂存区大小</span><br><span class="line">   SO_RCVBUF 设置接收的暂存区大小</span><br><span class="line">   SO_KEEPALIVE 定期确定连线是否已终止.</span><br><span class="line">   SO_OOBINLINE 当接收到OOB 数据时会马上送至标准输入设备</span><br><span class="line">   SO_LINGER 确保数据安全且可靠的传送出去.</span><br><span class="line"></span><br><span class="line">参数 optval 代表欲设置的值, 参数optlen 则为optval 的长度.</span><br><span class="line"></span><br><span class="line">返回值：成功则返回0, 若有错误则返回-1, 错误原因存于errno.</span><br><span class="line"></span><br><span class="line">附加说明：</span><br><span class="line">1、EBADF 参数s 并非合法的socket 处理代码</span><br><span class="line">2、ENOTSOCK 参数s 为一文件描述词, 非socket</span><br><span class="line">3、ENOPROTOOPT 参数optname 指定的选项不正确.</span><br><span class="line">4、EFAULT 参数optval 指针指向无法存取的内存空间.</span><br></pre></td></tr></table></figure>


<p>netstat</p>
<ul>
<li>network state</li>
<li>netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</li>
<li><a href="https://www.cnblogs.com/jiujuan/p/9017541.html">看看</a></li>
</ul>
<p>slash - 必应词典<br>美[slæʃ]英[slæʃ]<br>n.斜杠；切口；斜线号；劈<br>v.劈；大幅度削减；大大降低<br>网络斩击；猛砍；大量削减<br>变形第三人称单数：slashes；现在分词：slashing；过去式：slashed；<br>搭配slash rate；slash throat；</p>
<p>请求连接<br>根据 2 个来源<br>SYN_SENT表示请求连接。 传输控制协议（英语：Transmission Control Protocol, TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。</p>
<p>netstat使用示例<br>1)列出所有端口<br>netstat -anp</p>
<p>2)列出所有 tcp 端口<br>netstat -antp</p>
<p>3)列出所有 udp 端口<br>netstat -anup</p>
<p>4)只显示所有监听端口<br>netstat -lnp</p>
<p>5)只列出所有监听 tcp 端口<br>netstat -ltnp</p>
<p>6)只列出所有监听 udp 端口<br>netstat -lunp</p>
<p>7)只列出所有监听 UNIX 端口<br>netstat -lxnp</p>
<p>8)找出程序运行的端口<br>netstat -anp | grep ssh</p>
<p>NOTE:并不是所有的进程都能找到，没有权限的会不显示，使用 root 权限查看所有的信息。</p>
<p>10)找出运行在指定端口的进程<br>netstat -anp | grep ‘:3306’</p>
<p>11)持续输出 netstat 信息(每隔一秒输出网络信息)<br>netstat -cnp</p>
<p>12)显示所有端口的统计信息<br>netstat -s<br>————————————————<br>版权声明：本文为CSDN博主「qq_34132502」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_34132502/article/details/116795765">https://blog.csdn.net/qq_34132502/article/details/116795765</a></p>
<p>非阻塞忙轮询：不阻塞 循环探查</p>
<p>客户端connect时，在server端select会监测到listen fd有变，所以select阻塞结束<br>客户端已经建立连接之后，开始写时，server端得connfd会被监测到，所以select阻塞结束<br>select只返回1时且…时，只能是监听到了listen fd<br>read=0，客户端写关闭</p>
<p>nc命令<br><a href="https://blog.csdn.net/weixin_43574962/article/details/104098571">https://blog.csdn.net/weixin_43574962/article/details/104098571</a></p>
<p>uint32_t  &lt;—&gt; unsigned int<br>protocol  &lt;—&gt; 协议</p>
<p>正在listen监听的端口的已经被连接了吗？？<br>Linux的system()和popen()差异</p>
<p>sync：synchronize<br>同步 使同步 同步化处理。</p>
<p>1、按tcp/ip协议的描述，tcp三次握手过程，tcp的状态迁移如下所示：</p>
<p>1）、客户端通过connect系统调用向处于LISTEN状态的服务端发送sync请求，客户端进入SYNC_SEND状态；</p>
<p>2）、服务端收到sync报文后，向客户端发送sync+ack报文，服务端进入SYNC_RECV状态；</p>
<p>3）、客户端收到sync+ack后，进入ESTABLISHED状态，并向服务端发送ack，服务端接收到ack后，进入ESTABLISHED状态。</p>
<pre><code> (sys_connect)          sync
</code></pre>
<p>   client（SYNC_SEND）   ———-&gt;    server（LISTEN）<br>                           sync+ack<br>   client（SYNC_SEND）   &lt;———-    server（SYNC_RECV）<br>                            ack<br>   client（ESTABLISHED） ———-&gt;    server（ESTABLISHED）<br>2、但Linux的实现跟这里的描述并非完全一致，在Linux里，服务端收到sync报文并向客户端发送sync+ack后，并没有将自己置位SYNC_RECV状态，而是申请了一个request_sock，并将request_sock挂到sock的半连接队列里，等收到客户端的ack时，再从半连接队列里找到request_sock，并将其置位ESTABLISHED，然后挂到全连接队列中。</p>
<p>3、相关实现：<br>————————————————<br>版权声明：本文为CSDN博主「zhenghuaduo」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/zgy666/article/details/106149576">https://blog.csdn.net/zgy666/article/details/106149576</a></p>
<p>listen() 函数的主要作用就是将套接字( sockfd )变成被动的连接监听套接字（被动等待客户端的连接），至于参数 backlog 的作用是设置内核中连接队列的长度（这个长度有什么用，后面做详细的解释），TCP 三次握手也不是由这个函数完成，listen()的作用仅仅告诉内核一些信息。</p>
<p>这里需要注意的是，listen()函数不会阻塞，它主要做的事情为，将该套接字和套接字对应的连接队列长度告诉 Linux 内核，然后，listen()函数就结束。</p>
<p>这样的话，当有一个客户端主动连接（connect()），Linux 内核就自动完成TCP 三次握手，将建立好的链接自动存储到队列中，如此重复。</p>
<p>所以，只要 TCP 服务器调用了 listen()，客户端就可以通过 connect() 和服务器建立连接，而这个连接的过程是由内核完成。<br>————————————————<br>版权声明：本文为CSDN博主「Mike江」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/tennysonsky/article/details/45621341">https://blog.csdn.net/tennysonsky/article/details/45621341</a></p>
<h1 id="EPOLL"><a href="#EPOLL" class="headerlink" title="EPOLL"></a>EPOLL</h1><p><a href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw">https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw</a></p>
<h1 id="stringstream-代替-sprintf"><a href="#stringstream-代替-sprintf" class="headerlink" title="stringstream 代替 sprintf"></a>stringstream 代替 sprintf</h1><p><a href="https://www.cnblogs.com/yuandaozhe/p/10659159.html">https://www.cnblogs.com/yuandaozhe/p/10659159.html</a><br><a href="https://blog.csdn.net/jllongbell/article/details/79092891">https://blog.csdn.net/jllongbell/article/details/79092891</a></p>
<p>peer - 必应词典<br>美[pɪr]英[pɪə(r)]<br>n.同辈；同龄人；身份（或地位）相同的人；（英国）贵族成员<br>v.仔细看；端详<br>网络凝视；对等；同等的人<br>变形复数：peers；现在分词：peering；过去式：peered；<br>例句The company says the problem has to do with its ‘supernodes’–a crucial part of its peer-to-peer networking system.</p>
<p>communications layer - 必应词典<br>网络通信层</p>
<p>僵尸线程查看不到<br>进程可以 <default></default></p>
<h2 id="manpage"><a href="#manpage" class="headerlink" title="manpage"></a>manpage</h2><h3 id="accept-1"><a href="#accept-1" class="headerlink" title="accept"></a>accept</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DESCRIPTION</span><br><span class="line">       The accept() <span class="keyword">function</span> shall extract the first connection on the queue of pending connections, create a new socket with the same socket <span class="built_in">type</span> protocol and  address  family</span><br><span class="line">       as the specified socket, and allocate a new file descriptor <span class="keyword">for</span> that socket.</span><br><span class="line">      accept会抓取队列中第一个连接（已经ESTABLISEHED的），用（和sockfd指向的socket）一样的协议和地址类型来创建一个新的socket，并且为该socket分配一个新的socket。</span><br><span class="line"></span><br><span class="line">       The accept() <span class="keyword">function</span> takes the following arguments：</span><br><span class="line">       socket      Specifies a socket that was created with socket(), has been bound to an address with <span class="built_in">bind</span>(), and has issued a successful call to listen().</span><br><span class="line">       sockfd：已经<span class="built_in">bind</span>和listen过的监听套接字。</span><br><span class="line"></span><br><span class="line">       address     Either a null pointer, or a pointer to a sockaddr structure <span class="built_in">where</span> the address of the connecting socket shall be returned.</span><br><span class="line">        address：NULL / 用于接收客户端socket的sockaddr_in</span><br><span class="line"></span><br><span class="line">       address_len Either  a  null pointer, <span class="keyword">if</span> address is a null pointer, or a pointer to a socklen_t object <span class="built_in">which</span> on input specifies the length of the supplied sockaddr structure, and on output specifies the length of the stored address.</span><br><span class="line"></span><br><span class="line">       If address is not a null pointer, the address of the peer <span class="keyword">for</span> the accepted connection shall be stored <span class="keyword">in</span> the sockaddr structure pointed to by address, and the length  of</span><br><span class="line">       this address shall be stored <span class="keyword">in</span> the object pointed to by address_len.</span><br><span class="line"></span><br><span class="line">       If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address shall be truncated.</span><br><span class="line"></span><br><span class="line">       If the protocol permits connections by unbound clients, and the peer is not bound, <span class="keyword">then</span> the value stored <span class="keyword">in</span> the object pointed to by address is unspecified.</span><br><span class="line"></span><br><span class="line">      意思就是：在连接的监听队列为空并且O_NONBLOCK 没有置位的情况下，accpet是阻塞的。如果监听队列为空，但是O_NONBLOCK 置位的情况下，accpet会立即返回。</span><br><span class="line"></span><br><span class="line">       If  the listen queue is empty of connection requests and O_NONBLOCK is not <span class="built_in">set</span> on the file descriptor <span class="keyword">for</span> the socket, accept() shall block until a connection is present.</span><br><span class="line">       If the listen() queue is empty of connection requests and O_NONBLOCK is <span class="built_in">set</span> on the file descriptor <span class="keyword">for</span> the socket, accept() shall fail  and  <span class="built_in">set</span>  errno  to  [EAGAIN]  or  [EWOULDBLOCK].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> accept创建的套接字本身不能接收更多的连接。（只能和一个客户端的套接字建立连接），原先的监听套接字保持open，并且可以接收更多的连接。</span><br><span class="line"></span><br><span class="line">       The accepted socket cannot itself accept more connections. The original socket remains open and can accept more connections.</span><br><span class="line"></span><br><span class="line">RETURN VALUE</span><br><span class="line">       Upon successful completion, accept() shall <span class="built_in">return</span> the non-negative file descriptor of the accepted socket.  Otherwise, −1 shall be returned and errno <span class="built_in">set</span> to indicate the error.</span><br></pre></td></tr></table></figure>



<p><a href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw">https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw</a></p>
<p><img src="/2021/12/07/Linux-socket/2021-12-20-12-52-39.png"></p>
<ul>
<li>对端关闭也会触发 EPOLLIN类型事件？ 实践是这样<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.	创建一个epoll句柄，参数size用来告诉内核监听的文件描述符的个数，跟内存大小有关。</span><br><span class="line">	<span class="comment">#include &lt;sys/epoll.h&gt;</span></span><br><span class="line">	int epoll_create(int size)		size：监听数目</span><br><span class="line">2.	控制某个epoll监控的文件描述符上的事件：注册、修改、删除。</span><br><span class="line">	<span class="comment">#include &lt;sys/epoll.h&gt;</span></span><br><span class="line">	int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</span><br><span class="line">		epfd：	为epoll_creat的句柄</span><br><span class="line">		op：		表示动作，用3个宏来表示：</span><br><span class="line">			EPOLL_CTL_ADD (注册新的fd到epfd)，</span><br><span class="line">			EPOLL_CTL_MOD (修改已经注册的fd的监听事件)，</span><br><span class="line">			EPOLL_CTL_DEL (从epfd删除一个fd)；</span><br><span class="line">		event：	告诉内核需要监听的事件</span><br><span class="line"></span><br><span class="line">		struct epoll_event &#123;</span><br><span class="line">			__uint32_t events; /* Epoll events */</span><br><span class="line">			epoll_data_t data; /* User data variable */</span><br><span class="line">		&#125;;</span><br><span class="line">		typedef union epoll_data &#123;</span><br><span class="line">			void *ptr;</span><br><span class="line">			int fd;</span><br><span class="line">			uint32_t u32;</span><br><span class="line">			uint64_t u64;</span><br><span class="line">		&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">		EPOLLIN ：	表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</span><br><span class="line">		EPOLLOUT：	表示对应的文件描述符可以写</span><br><span class="line">		EPOLLPRI：	表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span><br><span class="line">		EPOLLERR：	表示对应的文件描述符发生错误</span><br><span class="line">		EPOLLHUP：	表示对应的文件描述符被挂断；</span><br><span class="line">		EPOLLET： 	将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</span><br><span class="line">		EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br><span class="line">3.	等待所监控文件描述符上有事件的产生，类似于select()调用。</span><br><span class="line">	<span class="comment">#include &lt;sys/epoll.h&gt;</span></span><br><span class="line">	int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout)</span><br><span class="line">		events：		用来存内核得到事件的集合，</span><br><span class="line">		maxevents：	告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，</span><br><span class="line">		timeout：	是超时时间</span><br><span class="line">			-1：	阻塞</span><br><span class="line">			0：	立即返回，非阻塞</span><br><span class="line">			&gt;0：	指定毫秒</span><br><span class="line">		返回值：	成功返回有多少文件描述符就绪，时间到时返回0，出错返回-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.1 ET模式为什么要设置在非阻塞模式下工作</span><br><span class="line">    因为ET模式下的读写需要一直读或写直到出错（对于读，当读到的实际字节数小于请求字节数时就可以停止），而如果你的文件描述符如果不是非阻塞的，那这个一直读或一直写势必会在最后一次阻塞。这样就不能在阻塞在epoll_wait上了，造成其他文件描述符的任务饿死。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll lt / et</span></span><br><span class="line"><span class="comment">// read 总结见博客笔记</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> backlog = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENT_NUMBER = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非阻塞IO（无数据也即刻返回 不阻塞） 为了配合非阻塞IO 才有了select epoll这些（同时监听多个文件描述符） 当某个文集描述符发生相应事件了 才通知去对去操作相应文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>(fd,F_GETFL); <span class="comment">//  获取fd的状态标志</span></span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;   <span class="comment">//  设置非阻塞标志</span></span><br><span class="line">    <span class="built_in">fcntl</span>(fd,F_SETFL,new_option);   <span class="comment">//  设置状态标志</span></span><br><span class="line">    <span class="keyword">return</span> old_option;  <span class="comment">//  f返回旧状态标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  注册事件fd到事件表epfd（LF/ET）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> fd,<span class="keyword">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    &#123;</span><br><span class="line">        event.events |= EPOLLET;    <span class="comment">//  边沿触发</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,fd,&amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd); <span class="comment">//  设置非阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  LT模式工作流程 （水平触发）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt_work</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event events[],<span class="keyword">int</span> ev_num,<span class="keyword">int</span> lfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_addr;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=ev_num;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = events[i].data.fd; <span class="comment">//  sockfd：发生事件的fd</span></span><br><span class="line">        <span class="keyword">if</span>(sockfd==lfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> connfd = <span class="built_in">accept</span>(lfd,(sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">            <span class="built_in">addfd</span>(epfd,connfd,<span class="literal">false</span>);   <span class="comment">//  LT模式 水平触发 之后从这个connfd读数据时,只要有数据没读完就会重复触发      </span></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;client is connected&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">         <span class="comment">// 只要socket读缓存中还有未读出的数据，这个事件就会重复触发。因此lt是多次触发来读完数据</span></span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) <span class="comment">//  非阻塞IO的读事件</span></span><br><span class="line">        &#123;<span class="comment">//  只要socket读缓存中还有未读出的数据，这段代码就会被重复触发。</span></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;events trigger once&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">            <span class="built_in">memset</span>(buf,<span class="number">0</span>,BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">int</span> r_len = <span class="built_in">recv</span>(sockfd,buf,BUFFER_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(r_len==<span class="number">0</span>)    <span class="comment">//  关闭</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;a client is closed&quot;</span>&lt;&lt;std::endl; <span class="comment">//  关闭也属于EPOLLIN？确实会检测到</span></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);  <span class="comment">//  移除注册的事件</span></span><br><span class="line">                <span class="built_in">close</span>(sockfd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(r_len==<span class="number">-1</span>)  <span class="comment">//  此时-1 不可能是事件未发生，只可能是函数出错，因为epoll监听到了该事件发生。</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cerr&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;sth else happened&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et_work</span><span class="params">(<span class="keyword">int</span> epfd,struct epoll_event events[],<span class="keyword">int</span> ev_num,<span class="keyword">int</span> lfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=ev_num;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span>(sockfd==lfd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_addr;</span><br><span class="line">            <span class="keyword">int</span> connfd = <span class="built_in">accept</span>(lfd,(sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">            <span class="built_in">addfd</span>(epfd,connfd,<span class="literal">true</span>);    <span class="comment">//  et模式 边沿触发 读取数据时必须一次读完（因为之后不会再触发）</span></span><br><span class="line">            <span class="comment">//  不会循环触发同一事件，因此对于每个事件 events trigger once 的次数只有一次，数据会在这一次里循环读完</span></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;client is connected&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)</span><br><span class="line">        &#123;   <span class="comment">//  ET模式下，哪怕socket读缓存里有未读出的数据，也不会对同一fd重复触发事件</span></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;events trigger once&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span> buf);   <span class="comment">//  别忘了清0</span></span><br><span class="line">                <span class="comment">//  read 总结见博客笔记</span></span><br><span class="line">                <span class="keyword">int</span> r_len = <span class="built_in">recv</span>(sockfd,buf,BUFFER_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(r_len&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//  该sockfd的数据已经读完。因此不必关闭该socket 只是数据读尽了 对端并没有断开</span></span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK)    </span><br><span class="line">                    &#123;</span><br><span class="line">                        std::cout&lt;&lt;<span class="string">&quot;read later &quot;</span>&lt;&lt;std::endl;   </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//  发生error</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        std::cerr&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;</span><br><span class="line">                        <span class="built_in">close</span>(sockfd);</span><br><span class="line">                        <span class="keyword">break</span>;  <span class="comment">//  发生error 不读这个sockfd了</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(r_len==<span class="number">0</span>)   <span class="comment">//  对端已经关闭连接    关闭连接也会触发 EPOLLIN</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">close</span>(sockfd);</span><br><span class="line">                    std::cout&lt;&lt;<span class="string">&quot;client is closed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    std::cout&lt;&lt;<span class="string">&quot;get &quot;</span>&lt;&lt;r_len&lt;&lt;<span class="string">&quot; bytes &quot;</span>&lt;&lt;<span class="string">&quot;words &quot;</span>&lt;&lt;buf&lt;&lt;std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;sth else happened&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  头脑简单 这应该是阻塞IO的读取方法</span></span><br><span class="line"><span class="comment">// int r_len = 0;</span></span><br><span class="line"><span class="comment">// while((r_len = recv(connfd,buf,BUFFER_SIZE-1,0))&gt;0)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     memset(buf,&#x27;\0&#x27;,sizeof buf);</span></span><br><span class="line"><span class="comment">//     std::cout&lt;&lt;buf&lt;&lt;std::endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;usage : &quot;</span>&lt;&lt;<span class="built_in">basename</span>(argv[<span class="number">0</span>])&lt;&lt;<span class="string">&quot; ip port &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET,ip,&amp;serv_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lfd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lfd!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>(lfd,(sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  以上 建立监听socket 等待连接请求</span></span><br><span class="line">    <span class="comment">//  以下 （通过epoll）监听lfd 接收请求 并 监听connfd 读取数据 </span></span><br><span class="line">    <span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>(MAX_EVENT_NUMBER);</span><br><span class="line">    <span class="built_in">assert</span>(epfd!=<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">addfd</span>(epfd,lfd,<span class="literal">true</span>);   <span class="comment">//  注册事件</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ev_num = <span class="built_in">epoll_wait</span>(epfd,events,MAX_EVENT_NUMBER,<span class="number">-1</span>);  <span class="comment">//  同时监听事件表上的所有I/O事件。阻塞监听</span></span><br><span class="line">        <span class="keyword">if</span>(ev_num&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr&lt;&lt;<span class="string">&quot;epoll failure&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// lt_work(epfd,events,ev_num,lfd);</span></span><br><span class="line">        <span class="built_in">et_work</span>(epfd,events,ev_num,lfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- epoll </span><br><span class="line">  - ET</span><br><span class="line">  - ONESHOT</span><br><span class="line">  - serv_epoll_f.cpp</span><br><span class="line"><span class="comment">// xd你好。想请问个问题。EPOLLONESHOT模式中，有两个客户端同时向同一端口发送数据的话，那么服务器处理的时候还是会用两个线程来处理呀，这不还是多个线程在同一socket上操作了吗。</span></span><br><span class="line"><span class="comment">//  想错了阿 呆b。这也不是同一socket了阿。这是多个socket了阿。沙b</span></span><br><span class="line"><span class="comment">//  再说服务器不就是要并行处理多个客户端连接么。</span></span><br><span class="line"><span class="comment">//  EPOLLONESHOT 是避免多个线程处理同一个socket。</span></span><br><span class="line"><span class="comment">//  如一个线程在处理A scoket的数据时，A socket又有数据可读，</span></span><br><span class="line"><span class="comment">//  如果没用EPOLLONESHOT，那么就会触发事件，使得产生另一个线程去读该A socket的数据，使得多个线程操作同一socket</span></span><br><span class="line"><span class="comment">//  如果用了，就不会触发，直到原线程读完数据并重置EPOLLONESHOT事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> backlog = <span class="number">5</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENT_NUMBER = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; fds; <span class="comment">//  fds.first：epollfd  fds    </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>(fd,F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd,F_SETFL,new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  EPOLLONESHOT原因：防止一个socket上的某一事件触发多次。</span></span><br><span class="line"><span class="comment">//（如一个线程在处理某个socket上的数据时，该socket又有新数据可读，此时另一个线程被唤醒去读取这些数据。这样就会出现两个线程同时操作同一个socket）</span></span><br><span class="line"><span class="comment">//  监听socket 显然不需要担心这个问题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> fd,<span class="keyword">bool</span> ifos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET;   <span class="comment">//  epoll in | epoll et</span></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    <span class="keyword">if</span>(ifos)    <span class="comment">// ifoneshot</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;!&quot;</span>&lt;&lt;fd&lt;&lt;std::endl;</span><br><span class="line">        event.events |= EPOLLONESHOT;   <span class="comment">//  EPOLL ONESHOT 重置之前只能触发一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,fd,&amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">(<span class="keyword">int</span> epfd,<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">    event.data.fd = sockfd;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;event);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">et_worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> epfd = <span class="keyword">static_cast</span>&lt;fds*&gt;(arg)-&gt;first;</span><br><span class="line">    <span class="keyword">int</span> sockfd = <span class="keyword">static_cast</span>&lt;fds*&gt;(arg)-&gt;second;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span> buf);</span><br><span class="line">        <span class="keyword">int</span> r_len = <span class="built_in">recv</span>(sockfd,buf,BUFFER_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(r_len==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( errno==EAGAIN || errno==EWOULDBLOCK )   <span class="comment">// 已经读尽对方数据 （仅仅是读完数据的话当然不需要关闭连接socket 只是读完数据了 又不是以后不会通过他交流对面socket了</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;read later&quot;</span>&lt;&lt;std::endl;     <span class="comment">//  ET模式下 下次可以触发&quot;</span></span><br><span class="line">                <span class="built_in">reset_oneshot</span>(epfd,sockfd); <span class="comment">//  重置事件（因为注册时oneshot过） 以便于下次还可以被触发</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//  发生错误   </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">close</span>(sockfd);</span><br><span class="line">                std::cerr&lt;&lt;<span class="string">&quot;recv error&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">                std::cerr&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(r_len==<span class="number">0</span>)   <span class="comment">//  对端关闭 也会触发EPOLLIN</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;client is closed&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_DEL,sockfd,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">close</span>(sockfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   <span class="comment">// 处理完数据之后再读 最后从 if(EAGAIN || WOULDBLOCK)那里离开循环</span></span><br><span class="line">            std::cout&lt;&lt;<span class="string">&quot;get &quot;</span>&lt;&lt;r_len&lt;&lt;<span class="string">&quot; bytes &quot;</span>&lt;&lt;buf&lt;&lt;std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">5</span>);   <span class="comment">//  模拟数据处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;end thread receiving data on fd &quot;</span>&lt;&lt;sockfd&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>); <span class="comment">//  之后再说吧 没有这么简单应该  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;usage : &quot;</span>&lt;&lt;<span class="built_in">basename</span>(argv[<span class="number">0</span>])&lt;&lt;<span class="string">&quot; ip port &quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET,ip,&amp;serv_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lfd = <span class="built_in">socket</span>(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lfd!=<span class="number">-1</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>(lfd,(sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span> serv_addr);</span><br><span class="line">    <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd,backlog);</span><br><span class="line">    <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(epfd!=<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">addfd</span>(epfd,lfd,<span class="literal">false</span>); <span class="comment">//  监听socket不能oneshot (那样岂不是只能够响应一次，或者没响应一次就得重置)</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ev_num = <span class="built_in">epoll_wait</span>(epfd,events,MAX_EVENT_NUMBER,<span class="number">-1</span>);       <span class="comment">//  IO复用函数为阻塞</span></span><br><span class="line">        std::cout&lt;&lt;ev_num&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">if</span>(ev_num==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr&lt;&lt;<span class="string">&quot;epoll error&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            std::cerr&lt;&lt;<span class="built_in">strerror</span>(errno)&lt;&lt;std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=ev_num;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span>(sockfd==lfd)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliet_addr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> cliet_len = <span class="keyword">sizeof</span> cliet_len;</span><br><span class="line">                <span class="keyword">int</span> connfd = <span class="built_in">accept</span>(lfd,(sockaddr*)&amp;cliet_addr,&amp;cliet_len);</span><br><span class="line">                <span class="built_in">addfd</span>(epfd,connfd,<span class="literal">true</span>);</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;client is connected&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)</span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">//  准备好要向线程传递的参数</span></span><br><span class="line">                fds fds_for_new_worker;</span><br><span class="line">                fds_for_new_worker.first = epfd;</span><br><span class="line">                fds_for_new_worker.second = sockfd;</span><br><span class="line">                <span class="keyword">pthread_t</span> thread;</span><br><span class="line">                <span class="built_in">pthread_create</span>(&amp;thread,<span class="literal">NULL</span>,et_worker,(<span class="keyword">void</span>*)&amp;fds_for_new_worker);  <span class="comment">//  话说不会被悄悄销毁么。。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="string">&quot;sth else happened&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/linux_network/TCP_IP$ telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">12345</span></span><br><span class="line">Trying <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">Connected to <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss</span><br><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line"> <span class="comment">//  并没有触发epoll_wait，没有产生新的线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/linux_network/TCP_IP$ ./serv_f_epoll.out <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">12345</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">client is connected</span><br><span class="line"><span class="number">1</span></span><br><span class="line">get <span class="number">9</span> bytes sssssssss</span><br><span class="line">get <span class="number">9</span> bytes sssssssss</span><br><span class="line">get <span class="number">9</span> bytes sssssssss</span><br><span class="line">get <span class="number">9</span> bytes sssssssss</span><br><span class="line">get <span class="number">9</span> bytes sssssssss</span><br><span class="line">get <span class="number">9</span> bytes sssssssss</span><br><span class="line">get <span class="number">9</span> bytes sssssss</span><br><span class="line"></span><br><span class="line">get <span class="number">9</span> bytes aaaaaaaaa</span><br><span class="line">get <span class="number">9</span> bytes aaaaaaaaa</span><br><span class="line">get <span class="number">9</span> bytes aaaaaaaaa</span><br><span class="line">get <span class="number">9</span> bytes aaaaaaaaa</span><br><span class="line">get <span class="number">9</span> bytes aaaaaaaaa</span><br><span class="line">get <span class="number">9</span> bytes aaaaaaaaa</span><br><span class="line">get <span class="number">6</span> bytes aaaa</span><br><span class="line"></span><br><span class="line">read later</span><br><span class="line">end thread receiving data on fd <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  并没有触发epoll_wait，没有产生新的线程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>udp端口测试<br><a href="https://www.cnblogs.com/leocorn/p/11697437.html#:~:text=UDP%E7%AB%AF%E5%8F%A3%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95%EF%BC%9A%201.%E6%B5%8B%E8%AF%95%E7%9B%AE%E6%A0%87%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%EF%BC%88%E5%89%8D%E6%8F%90%E6%98%AF%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%90%AF%E5%8A%A8%E4%BA%86%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3%2C%E4%B8%94%E6%9C%AC%E6%9C%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E7%95%85%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89%3A%20nc%20-vuz%20x.x.x.x%20xxxx%202.%E5%90%91UDP%E7%AB%AF%E5%8F%A3%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%3A%20nc,3.%E9%80%9A%E8%BF%87%E6%8A%93%E5%8C%85%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%EF%BC%8C%E6%8E%A5%E6%94%B6UDP%E7%AB%AF%E5%8F%A3%E6%8A%93%E5%8C%85%3A%20tcpdump%20-i%20eth0%20-s%200%20port%201814">https://www.cnblogs.com/leocorn/p/11697437.html#:~:text=UDP%E7%AB%AF%E5%8F%A3%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95%EF%BC%9A%201.%E6%B5%8B%E8%AF%95%E7%9B%AE%E6%A0%87%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%EF%BC%88%E5%89%8D%E6%8F%90%E6%98%AF%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%90%AF%E5%8A%A8%E4%BA%86%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3%2C%E4%B8%94%E6%9C%AC%E6%9C%BA%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9C%E9%80%9A%E7%95%85%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%89%3A%20nc%20-vuz%20x.x.x.x%20xxxx%202.%E5%90%91UDP%E7%AB%AF%E5%8F%A3%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%3A%20nc,3.%E9%80%9A%E8%BF%87%E6%8A%93%E5%8C%85%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85%EF%BC%8C%E6%8E%A5%E6%94%B6UDP%E7%AB%AF%E5%8F%A3%E6%8A%93%E5%8C%85%3A%20tcpdump%20-i%20eth0%20-s%200%20port%201814</a></li>
</ul>
<ul>
<li>socketpair 创建双向管道</li>
<li><a href="https://blog.csdn.net/weixin_40039738/article/details/81095013">socketpair介绍</a></li>
</ul>
<p>虚拟机的ip会改变<br><a href="https://blog.csdn.net/u013810234/article/details/120360337">https://blog.csdn.net/u013810234/article/details/120360337</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux I/O</title>
    <url>/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<p>Unix I/O</p>
<span id="more"></span>


<ul>
<li>参考 APUE，牛客讲义</li>
</ul>
<h1 id="Unix基础知识"><a href="#Unix基础知识" class="headerlink" title="Unix基础知识"></a>Unix基础知识</h1><ul>
<li><p><strong>系统调用</strong></p>
<ul>
<li>写文件 ，即对磁盘操作。从用户空间进入内核空间，借助驱动，驱动磁盘工作。库函数没有办法直接使用驱动，应该通过系统函数来使用驱动完成对磁盘的操作。<br><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-21-19-38-48.png"></li>
</ul>
</li>
<li><p><strong>预读入 缓输出</strong></p>
<ul>
<li><code>read  write : unbuffered I/O</code>。不带（用户区）缓冲的<code>I/O</code>。内核处有内核级别的缓冲区，默认大小4096B。 </li>
<li>为什么<code>write(fd,const char *,n);</code>比<code>fputc</code>慢。如图<br><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-21-19-43-36.png"></li>
<li>在上图中的磁盘和<code>kernal</code>之间，采取预读入缓输出机制<ul>
<li>即从磁盘往<code>kernal</code>读东西的时候，一次读4096个字节，避免之后读取时多次与硬盘交互。</li>
<li>从<code>kernal</code>向磁盘写东西的时候，一次写4096个，避免多次与磁盘交互。 </li>
</ul>
</li>
</ul>
</li>
<li><p>所以</p>
<ul>
<li>即使学了系统调用，能使用库函数的地方，优先使用库函数    </li>
<li>那为什么要学系统函数，因为只用库函数可能会有逻辑上的障碍。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>阻塞与非阻塞</strong></p>
<ul>
<li>是所读文件的性质，不是<code>read write</code>的性质</li>
<li>读常规文件不会阻塞；读网络会阻塞</li>
<li>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</li>
<li>现在明确一下阻塞<code>（Block）</code>这个概念。当进程调用一个阻塞的系统函数时，该进程被置于睡眠（<code>Sleep</code>）状态，这时内核调度其它进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用 <code>sleep</code> 指定的睡眠时间到了）它才有可能继续运行。与睡眠状态相对的是运行（<code>Running</code>）状态，在 <code>Linux</code> 内核中，处于运行状态的进程分为两种情况：<ul>
<li>正在被调度执行。<code>CPU</code> 处于该进程的上下文环境中，程序计数器（<code>eip</code>）里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，正在读写该进程的地址空间。</li>
<li>就绪状态：该进程不需要等待什么事件发生，随时都可以执行，但 <code>CPU</code> 暂时还在执行另一个进程，所以该进程在一个就绪队列中等待被内核调度。系统中可能同时有多个就绪的进程，那么该调度谁执行呢？内核的调度算法是基于优先级和时间片的，而且会根据每个进程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到机会执行，同时要兼顾用户体验，不能让和用户交互的进程响应太慢</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>每一个进程都有如下结构</strong><br><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-24-20-09-47.png"></p>
</li>
</ul>
<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-24-21-20-02.png"></p>
<h2 id="UNIX：文件相关数据结构"><a href="#UNIX：文件相关数据结构" class="headerlink" title="UNIX：文件相关数据结构"></a>UNIX：文件相关数据结构</h2><ul>
<li><p>每个进程在进程表都有成员变量 <code>file_struct *file</code> 指向文件描述符表</p>
<ul>
<li>进程表即 PCB进程控制块 <code>task_struct</code></li>
</ul>
</li>
<li><p>与每个fd相关联的是</p>
<ul>
<li>文件描述符标志</li>
<li>指向一个文件表项<code>（struct file&#123;&#125;）</code>的指针</li>
</ul>
</li>
<li><p>内核为所有打开文件维持一张文件表。每个文件表包含：</p>
<ul>
<li>文件状态标志<ul>
<li>读，写，添写，同步，非阻塞等</li>
</ul>
</li>
<li>当前文件偏移量</li>
<li>指向该文件v节点表项的指针</li>
</ul>
</li>
<li><p>每个<strong>打开</strong>文件都有一个<code>v</code>节点结构<code>v-node</code>。<code>v</code>节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，<code>v</code>节点还包含了i节点<code>（i-node）</code>。这些信息是在打开文件时从磁盘读入内存的。所以，文件的所有相关信息都是随时可用的。如，<code>i-node</code>包含了文件所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。</p>
</li>
<li><p>打开文件时的数据结构<br><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-24-08-04-42.png"></p>
</li>
<li><p>注：Linux没有使用<code>v</code>节点。而是使用通用i节点结构。虽然实现略有不同，但在概念上<code>v</code>节点与<code>i</code>节点是一样的。两这都指向文件系统特有的<code>i</code>节点结构。</p>
</li>
</ul>
<p><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-24-08-05-36.png"></p>
<ul>
<li><p>上图也说明了为什么多个进程可以打开同一文件：</p>
<ul>
<li>打开文件的每个进程都获得各自的一个文件表项，但对于给定的文件只有一个<code>v</code>节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使得每个进程都有它自己的对该文件的当前偏移量。</li>
</ul>
</li>
<li><p>下图是还没打开文件就存在的<br><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-23-20-52-47.png"><br><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-23-20-57-42.png"></p>
</li>
<li><p>每个<code>i</code>节点中都有一个链接计数（对应<code>stat</code>结构中的<code>nlink_t</code>)，其值是指向该i节点的目录项。链接计数减少为0时，才可删除该文件，即释放该i节点指向的数据块。所以，删除目录项就做<code>unlink</code>而非<code>delete</code>。</p>
</li>
<li><p><code>i</code>节点中包含文件所有信息：文件类型，文件访问权限，文件长度，指向文件数据块的指针等。<code>stat</code>结构中大多信息来自i节点。只有文件名和i节点编号放在目录块中。<code>i</code>节点编号数据类型<code>：ino_t</code></p>
</li>
<li><p>为文件重命名时：文件内容并未移动，只要构造一个指向该文件的新目录项，并删除老目录项。</p>
</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li><code>stderr</code>是写到哪里？为什么和<code>stdout</code>一样也是显示在终端上？<ul>
<li>每当运行一个程序时，所有<code>shell</code>都为其打开三个文件描述符，即标准输入<code>STDIN_FILENO 0</code>，标准输出<code>STDOUT_FILENO 1</code> ，标准错误<code>STDERR_FILENO 2</code>。如果不做特殊处理，则这这3个文件描述符都连接到终端。</li>
</ul>
</li>
<li>困惑，在程序中这样创建了一个本不存在的文件，那么在本程序中对他的读写权限是？？？已经确定第一项改成<code>O_RDWR</code>一定可以读写<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;./test_mmap3.txt&quot;</span>,O_RDONLY|O_CREAT|O_TRUNC,<span class="number">0664</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="一些IO函数"><a href="#一些IO函数" class="headerlink" title="一些IO函数"></a>一些IO函数</h2><h3 id="read"><a href="#read" class="headerlink" title="read"></a><code>read</code></h3><ul>
<li><code>ssize_t read(int fd,void *buf,size_t count);</code></li>
<li><strong><code>return</code>情况讨论</strong><ul>
<li>0：<ul>
<li><code>socket</code>：对方断开连接，此时我端应关闭<code>connfd</code></li>
<li>非<code>socket</code>（即正常读文件）：读到文件末尾</li>
</ul>
</li>
<li>-1：<ul>
<li><code>errno == EAGAIN || errno == EWOULDBLOCK</code>。<ul>
<li>(非阻塞I/O) 此时在读一个设备文件/网络<code>(socket)</code>文件，且文件无数据。</li>
</ul>
</li>
<li>（阻塞I/O)若在读一个正常文件，则就是出错。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="fcntl-（file-control）"><a href="#fcntl-（file-control）" class="headerlink" title="fcntl （file control）"></a><code>fcntl （file control）</code></h3><ul>
<li><code>int fcntl(int fd,int cmd,...);</code></li>
<li>提供了对文件描述符的各种控制操作<ul>
<li><code>int fcntl(fd,F_GETFL)</code>：返回<code>fd</code>的状态标志。（状态标志是啥来着，是stat返回的那个吗）</li>
<li><code>int fcntl(fd,F_SETFL,option)</code>：用<code>option</code>设置<code>fd</code>的状态标志</li>
</ul>
</li>
<li>网络编程中，常用来将一个文件描述符设置为非阻塞。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_option = fcntl(fd,F_GETFL); <span class="comment">// 获取文件描述符旧的状态标志</span></span><br><span class="line">  <span class="keyword">int</span> new_option = old_option | O_NONBLOACK;  <span class="comment">//  设置非阻塞标志</span></span><br><span class="line">  fcntl(fd,F_SETFL,new_option);</span><br><span class="line">  <span class="keyword">return</span> old_option;  <span class="comment">//  返回该fd的旧状态标志，以便后续恢复该状态标志。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a><code>open</code></h3><ul>
<li>作用：打开已有文件/创建新文件</li>
<li><code>打开：int open(const char *pathname, int flags);</code></li>
<li><code>创建：int open(const char *pathname, int flags, mode_t mode);</code></li>
<li>例子<ul>
<li><code>int fd = open(&quot;xxx&quot;,O_RDWR|O_TRUNC|O_CREAT,0664);</code> <ul>
<li>若文件存在，以读写且截断方式打开</li>
<li>若文件不存在，以0664权限创建<h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a><code>lseek</code></h3></li>
</ul>
</li>
</ul>
</li>
<li>作用：移动文件指针，仅仅移动文件指针，不进行IO操作</li>
<li>文件空洞不要求在磁盘上占用存储区。但是如果在超出文件尾端时写了，就会占用。</li>
<li><code>off_t lseek(int fd,off_t offset,int whence)</code><ul>
<li><code>offset</code>是偏移量，<code>whence</code>是偏移量的基准位置</li>
<li><code>whence</code> <ul>
<li><code>SEEK_SET</code></li>
<li><code>SEEK_END</code></li>
<li><code>SEEK_CUR</code></li>
</ul>
</li>
</ul>
</li>
<li><code>RETURN VALUE    Upon  successful completion, lseek() returns the resulting offset location as measured in bytes from the beginning of the file.  On error, the value (off_t) -1 is returned and errno is set to    indicate the error.</code><ul>
<li>成功</li>
<li>返回从文件最开始的位置 到 文件<code>whence</code>（何处）向后偏移<code>offset</code>个字节的距离。（单位字节）</li>
<li>失败</li>
<li>返回-1</li>
</ul>
</li>
<li>应用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件扩容10字节</span></span><br><span class="line"> lseek(fd,<span class="number">9</span>,SEEK_END);   <span class="comment">//  将文件指针从SEEK_END向后移动9个字节</span></span><br><span class="line"> write(fd,<span class="string">&quot;\0&quot;</span>,<span class="number">1</span>);   <span class="comment">//  再写一个 </span></span><br><span class="line"> <span class="comment">// 等价于</span></span><br><span class="line"> ftruncate(fd,<span class="number">10</span>);</span><br><span class="line"> <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END); <span class="comment">//  返回从文件起始到 SEEK_END再向后偏移0字节的大小，即文件大小</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a><code>unlink</code></h3><ul>
<li><code>int unlink (const char* pathname)</code></li>
<li>功能：删除目录块<code>dentry</code>（让文件具备了被释放的条件）</li>
<li>当一个文件的硬链接计数减少至0时，该文件的数据块会被操作系统择机释放。</li>
<li><code>unlink</code>特征：解除对一个文件的链接时，如果文件的硬链接计数减小到0，无目录块dentry对应，但该文件i节点指向的数据块不会被立刻释放，而是等到所有打开该文件的进程关闭该文件，系统才会挑时间将他释放。</li>
<li><code>int ret = unlink(&quot;xx&quot;);</code></li>
</ul>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a><code>dup</code></h3><ul>
<li>保存文件描述符</li>
<li><code>int dup(int oldfd);</code><ul>
<li><code>oldfd：</code>已经打开的旧的描述符。</li>
<li><code>success: return a new fd</code>，新文件描述符指向旧文件描述符指向的文件。 </li>
<li>失败，-1 并设置 <code>errno</code></li>
</ul>
</li>
</ul>
<h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a><code>dup2</code></h3><ul>
<li>拷贝文件描述符，重定向文件描述符指向</li>
<li><code>int dup2(int oldfd,int newfd);</code><ul>
<li>将<code>oldfd</code>拷贝给<code>newfd</code>，使得下次操作<code>newfd</code>，实际上是对<code>oldfd</code>所指向的文件进行操作</li>
<li><code>success</code><ul>
<li><code>return a new fd</code>，如果oldfd有效，则返回的文件描述符与oldfd指向同一文件</li>
</ul>
</li>
<li><code>fail</code><ul>
<li><code>oldfd</code>无效，则失败，关闭<code>newfd</code>。返回-1，同时设置<code>errno</code>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="strace-命令"><a href="#strace-命令" class="headerlink" title="strace 命令"></a>strace 命令</h3><ul>
<li>shell 中使用strace 命令跟踪程序执行，查看调用的系统函数。</li>
</ul>
<h3 id="manpage"><a href="#manpage" class="headerlink" title="manpage"></a>manpage</h3><blockquote>
<p><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2022-05-10-21-19-24.png"></p>
</blockquote>
<h3 id="stat-lstat"><a href="#stat-lstat" class="headerlink" title="stat lstat"></a><code>stat lstat</code></h3><ul>
<li><a href="https://cloud.tencent.com/developer/article/1726535">stat补充</a></li>
<li><a href="https://blog.csdn.net/afootball/article/details/107406311">stat补充</a></li>
<li>查询文件信息，传入文件路径，信息保存在<code>struct stat</code>中传出</li>
<li><code>#include &lt;sys/stat.h&gt;</code></li>
<li><code>int stat(const char *filename,struct stat *statbuf)</code></li>
<li><code>int lstat(const char *filename,struct stat *statbuf)</code><ul>
<li><code>filename</code> ：文件路径+名称</li>
<li><strong><code>struct stat* statbuf</code>：结构体地址。文件信息将保存在这里。</strong></li>
<li>成功 <code>0</code> 失败 <code>-1</code></li>
<li><code>lstat</code>会获取软链接指向的文件的信息，<code>stat</code>会穿透软链接<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//      int fd = open(&quot;../rev.c&quot;,O_RDONLY|O_CREAT|O_TRUNC,0664);        //  有 则只读打开；没有，则以0664&amp;umask权限创建 </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span> </span><br><span class="line">        <span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>],&amp;sb);<span class="comment">// stat 穿透符号链接（软链接）lstat：不穿透符号链接 </span></span><br><span class="line">         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size = %ld\t&quot;</span>,sb.st_size); </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(sb.st_mode)) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a regular\n&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sb.st_mode)) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a directory\n&quot;</span>);    </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./stat_shc.out test01.txt</span><br><span class="line">size = <span class="number">0</span>	it<span class="number">&#x27;</span>s a regular</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./stat_shc.out ..</span><br><span class="line">size = <span class="number">4096</span>	it<span class="number">&#x27;</span>s a directory</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line">      <span class="keyword">mode_t</span> st_mode;       <span class="comment">//文件对应的模式，文件，目录等</span></span><br><span class="line">      <span class="keyword">ino_t</span> st_ino;         <span class="comment">//i-node节点号</span></span><br><span class="line">      <span class="keyword">dev_t</span> st_dev;         <span class="comment">//文件所在设备的ID</span></span><br><span class="line">      <span class="keyword">dev_t</span> st_rdev;       <span class="comment">//特殊设备号码</span></span><br><span class="line">      <span class="keyword">nlink_t</span> st_nlink;    <span class="comment">//文件的连接数</span></span><br><span class="line">      <span class="keyword">uid_t</span> st_uid;        <span class="comment">//文件所有者</span></span><br><span class="line">      <span class="keyword">gid_t</span> st_gid;        <span class="comment">//文件所有者对应的组</span></span><br><span class="line">      <span class="keyword">off_t</span> st_size;       <span class="comment">//普通文件，对应的文件字节数</span></span><br><span class="line">      <span class="keyword">time_t</span> st_atime;     <span class="comment">//文件最后被访问的时间</span></span><br><span class="line">      <span class="keyword">time_t</span> st_mtime;     <span class="comment">//文件内容最后被修改的时间</span></span><br><span class="line">      <span class="keyword">time_t</span> st_ctime;      <span class="comment">//文件状态（属性）改变时间 </span></span><br><span class="line">      <span class="keyword">blksize_t</span> st_blksize;    <span class="comment">//文件内容对应的块大小</span></span><br><span class="line">      <span class="keyword">blkcnt_t</span> st_blocks;    <span class="comment">//文件内容对应的块数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="模拟ls-l-fileName"><a href="#模拟ls-l-fileName" class="headerlink" title="模拟ls -l fileName"></a>模拟<code>ls -l fileName</code></h3><p><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-24-08-45-45.png"></p>
<ul>
<li><p><strong><code>st_mode</code></strong></p>
<ul>
<li><p><strong><code>mode_t st_mode</code></strong>   —-&gt;  <strong><code>mode_t : unsigned int</code></strong></p>
</li>
<li><p><code>st_mode</code>中<code>[0,15]</code>位的二进制数起作用</p>
</li>
<li><p>如何求出文件类型 ?</p>
<ul>
<li><p><code>statbuf.st_mode &amp; S_IFMT</code><br>去除了<code>[11,0]</code>的表征其他性质的位(变成了<code>0</code>)<br>；将<code>[15,12]</code>位所有位为1的位都保留了下来。其他位都变成了<code>0</code></p>
</li>
<li><p>因此现在的<code>[15,0]</code>位所组成的值再与这些特征值比较 就可以得出该文件的类型（容易得知<code>[11,0]</code>一定均为<code>0</code>)<br><img src="/2021/11/05/Linux-%E6%96%87%E4%BB%B6IO/2021-11-24-09-04-54.png"></p>
</li>
<li><p>文件类型特征值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">S_IFSOCK 0140000 套接字</span><br><span class="line">S_IFLNK 0120000 符号链接（软链接）</span><br><span class="line">S_IFREG 0100000 普通文件</span><br><span class="line">S_IFBLK 0060000 块设备</span><br><span class="line">S_IFDIR 0040000 目录</span><br><span class="line">S_IFCHR 0020000 字符设备</span><br><span class="line">S_IFIFO 0010000 管道</span><br><span class="line">S_IFMT 0170000 掩码</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>权限特征值(<code>[9,0]</code>)</p>
<ul>
<li><code>usr</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S_IRUSR <span class="number">00400</span></span><br><span class="line">S_IWUSR <span class="number">00200</span></span><br><span class="line">S_IXUSR <span class="number">00100</span></span><br><span class="line">S_IRWXU <span class="number">00700</span></span><br></pre></td></tr></table></figure></li>
<li><code>group</code><ul>
<li>换成<code>S_I*GRP</code>即可</li>
</ul>
</li>
<li><code>other</code><ul>
<li>换成<code>S_I*OTH</code>即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>模拟代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/stat_learn$ gcc ls-l.c -o ls</span><br><span class="line">henry@henry:~/code/learn/stat_learn$ ./ls -l a.txt</span><br><span class="line">-rw-r--r-- 1d henry henry 10 Sat Oct 16 16:21:29 2021 a.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pwd.h&gt;</span>     <span class="comment">//  struct passwd *getpwuid(uid_t uid);     uid_t :unsigned int</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;grp.h&gt;</span>     <span class="comment">//  struct group *getgrgid(gid_t gid);</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mock ls -l filename</span></span><br><span class="line"><span class="comment">// ls -l a.txt</span></span><br><span class="line"><span class="comment">// -rw-r--r-- 1 henry henry 10 10月 16 16:21 a.txt</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argvs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  判断输入参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;=<span class="number">2</span>) <span class="comment">//argvs[0] : ./ls.out  ; argvs[1] : ./-l  ;  argvs[2] : File name at the same level</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s -l filename\n&quot;</span>,argvs[<span class="number">0</span>]);   <span class="comment">//  the name of ./ls.out + -l + filename</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取文件信息 文件信息存储在struct stat类型结构体 stub中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stb</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> res = stat(argvs[<span class="number">2</span>],&amp;stb);  <span class="comment">// argvs[1] </span></span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat get the information of the file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取文件类型 和 user group other的读写权限</span></span><br><span class="line">    <span class="comment">//  获取文件类型</span></span><br><span class="line">    <span class="keyword">char</span> info[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;     <span class="comment">// info : file class and the permissions</span></span><br><span class="line">    <span class="keyword">int</span> m = stb.st_mode &amp; S_IFMT;   </span><br><span class="line">    <span class="keyword">switch</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK:  <span class="comment">// IF : is file </span></span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取user group other的读写执行权限</span></span><br><span class="line">    <span class="comment">// USR : user</span></span><br><span class="line">    info[<span class="number">1</span>] = stb.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is read</span></span><br><span class="line">    info[<span class="number">2</span>] = stb.st_mode &amp; S_IWUSR ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is write</span></span><br><span class="line">    info[<span class="number">3</span>] = stb.st_mode &amp; S_IXUSR ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is x </span></span><br><span class="line">    <span class="comment">// info[3] = stb.st_mode &amp; S_IRWXU ? &#x27;1&#x27; : &#x27;0&#x27;;    // is read write x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GRP : group person</span></span><br><span class="line">    info[<span class="number">4</span>] = stb.st_mode &amp; S_IRGRP ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">5</span>] = stb.st_mode &amp; S_IWGRP ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">6</span>] = stb.st_mode &amp; S_IXGRP ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OTH : others </span></span><br><span class="line">    info[<span class="number">7</span>] = stb.st_mode &amp; S_IROTH ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">8</span>] = stb.st_mode &amp; S_IWOTH ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">9</span>] = stb.st_mode &amp; S_IXOTH ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  硬链接数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> linknum = stb.st_nlink;   <span class="comment">//  hard link</span></span><br><span class="line">    <span class="comment">//  user name</span></span><br><span class="line">    <span class="keyword">char</span> *fileUsr = getpwuid(stb.st_uid)-&gt;pw_name;    </span><br><span class="line">    <span class="comment">//  group name</span></span><br><span class="line">    <span class="keyword">char</span> *fileGrp = getgrgid(stb.st_gid)-&gt;gr_name;    </span><br><span class="line">    <span class="comment">//  文件大小</span></span><br><span class="line">    <span class="keyword">long</span> fileSize = stb.st_size;</span><br><span class="line">    <span class="comment">//  创建时间</span></span><br><span class="line">    <span class="comment">//  st_time:the time since 1970 ; ctime:convert the time to local time</span></span><br><span class="line">    <span class="keyword">char</span> *time = ctime(&amp;stb.st_mtime);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  去掉\n</span></span><br><span class="line">    <span class="keyword">char</span> time_buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//  strncpy不会自动补&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">strncpy</span>(time_buf,time,<span class="built_in">strlen</span>(time)<span class="number">-1</span>);  </span><br><span class="line">    time_buf[<span class="built_in">strlen</span>(time)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  sprintf写入buf</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s %lud %s %s %ld %s %s&quot;</span>,info,linknum,fileUsr,fileGrp,fileSize,time_buf,argvs[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- **`extern struct passwd *getpwuid(uid_t uid)`**</span></span><br><span class="line"><span class="comment">  - `uid_t uid`</span></span><br><span class="line"><span class="comment">    - `uid_t :unsigned int`</span></span><br><span class="line"><span class="comment">    - `uid: user id` </span></span><br><span class="line"><span class="comment">  - `passwd`</span></span><br><span class="line"><span class="comment">  The passwd structure.  </span></span><br><span class="line"><span class="comment">  struct passwd</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    char *pw_name;		/* Username.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_passwd;		<span class="comment">/* Password.  */</span></span><br><span class="line">    <span class="keyword">__uid_t</span> pw_uid;		<span class="comment">/* User ID.  */</span></span><br><span class="line">    <span class="keyword">__gid_t</span> pw_gid;		<span class="comment">/* Group ID.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_gecos;		<span class="comment">/* Real name.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_dir;			<span class="comment">/* Home directory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_shell;		<span class="comment">/* Shell program.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  - <span class="keyword">uid_t</span> uid从哪里来？</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stab</span></span></span><br><span class="line"><span class="class">      //   <span class="title">int</span> <span class="title">stat</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">pathname</span>, <span class="keyword">struct</span> <span class="title">stat</span> *<span class="title">statbuf</span>);</span></span><br><span class="line">  stat(文件名,stab);</span><br><span class="line">  <span class="comment">//stab.st_uid即为getpwuid所需要的参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> * <span class="title">pp</span> =</span> getpwuid(stab.st_uid);</span><br><span class="line">  <span class="keyword">char</span> * userName = pp -&gt; pw_name; </span><br><span class="line">  </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="manpage阅读"><a href="#manpage阅读" class="headerlink" title="manpage阅读"></a>manpage阅读</h2><ul>
<li><p><code>stat</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AME</span><br><span class="line">       <span class="built_in">stat</span>, fstat, lstat, fstatat - get file status</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line">       <span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line">       <span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">       int <span class="built_in">stat</span>(const char *pathname, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line">       int fstat(int fd, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line">       int lstat(const char *pathname, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line"></span><br><span class="line">       <span class="comment">#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */</span></span><br><span class="line">       <span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line">       int fstatat(int dirfd, const char *pathname, struct <span class="built_in">stat</span> *statbuf,</span><br><span class="line">                   int flags);</span><br><span class="line"></span><br><span class="line">   Feature Test Macro Requirements <span class="keyword">for</span> glibc (see feature_test_macros(7)):</span><br><span class="line"></span><br><span class="line">       lstat():</span><br><span class="line">           /* glibc 2.19 and earlier */ _BSD_SOURCE</span><br><span class="line">               || /* Since glibc 2.20 */ _DEFAULT_SOURCE</span><br><span class="line">               || _XOPEN_SOURCE &gt;= 500</span><br><span class="line">               || /* Since glibc 2.10: */ _POSIX_C_SOURCE &gt;= 200112L</span><br><span class="line"></span><br><span class="line">       fstatat():</span><br><span class="line">           Since glibc 2.10:</span><br><span class="line">               _POSIX_C_SOURCE &gt;= 200809L</span><br><span class="line">           Before glibc 2.10:</span><br><span class="line">               _ATFILE_SOURCE</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       These  <span class="built_in">functions</span>  <span class="built_in">return</span> information about a file, <span class="keyword">in</span> the buffer pointed to by statbuf.  No permissions are required on the file itself, but—<span class="keyword">in</span> the <span class="keyword">case</span> of <span class="built_in">stat</span>(), fstatat(), and lstat()—exe‐</span><br><span class="line">       cute (search) permission is required on all of the directories <span class="keyword">in</span> pathname that lead to the file.</span><br><span class="line"></span><br><span class="line">       <span class="built_in">stat</span>() and fstatat() retrieve information about the file pointed to by pathname; the differences <span class="keyword">for</span> fstatat() are described below.</span><br><span class="line"></span><br><span class="line">       lstat() is identical to <span class="built_in">stat</span>(), except that <span class="keyword">if</span> pathname is a symbolic link, <span class="keyword">then</span> it returns information about the link itself, not the file that it refers to.</span><br><span class="line"></span><br><span class="line">       fstat() is identical to <span class="built_in">stat</span>(), except that the file about <span class="built_in">which</span> information is to be retrieved is specified by the file descriptor fd.</span><br><span class="line">  The <span class="built_in">stat</span> structure</span><br><span class="line">       All of these system calls <span class="built_in">return</span> a <span class="built_in">stat</span> structure, <span class="built_in">which</span> contains the following fields:</span><br><span class="line"></span><br><span class="line">           struct <span class="built_in">stat</span> &#123;</span><br><span class="line">               dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">               ino_t     st_ino;         /* Inode number */</span><br><span class="line">               mode_t    st_mode;        /* File <span class="built_in">type</span> and mode */</span><br><span class="line">               nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">               uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">               gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">               dev_t     st_rdev;        /* Device ID (<span class="keyword">if</span> special file) */</span><br><span class="line">               off_t     st_size;        /* Total size, <span class="keyword">in</span> bytes */</span><br><span class="line">               blksize_t st_blksize;     /* Block size <span class="keyword">for</span> filesystem I/O */</span><br><span class="line">               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line"></span><br><span class="line">               /* Since Linux 2.6, the kernel supports nanosecond</span><br><span class="line">                  precision <span class="keyword">for</span> the following timestamp fields.</span><br><span class="line">                  For the details before Linux 2.6, see NOTES. */</span><br><span class="line"></span><br><span class="line">               struct timespec st_atim;  /* Time of last access */</span><br><span class="line">               struct timespec st_mtim;  /* Time of last modification */</span><br><span class="line">               struct timespec st_ctim;  /* Time of last status change */</span><br><span class="line"></span><br><span class="line">           <span class="comment">#define st_atime st_atim.tv_sec      /* Backward compatibility */</span></span><br><span class="line">           <span class="comment">#define st_mtime st_mtim.tv_sec</span></span><br><span class="line">           <span class="comment">#define st_ctime st_ctim.tv_sec</span></span><br><span class="line">           &#125;;</span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, zero is returned.  On error, -1 is returned, and errno is <span class="built_in">set</span> appropriately.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>unlink</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UNLINK(2)                                                                              Linux Programmer<span class="string">&#x27;s Manual                                                                             UNLINK(2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       unlink, unlinkat - delete a name and possibly the file it refers to</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int unlink(const char *pathname);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       #include &lt;fcntl.h&gt;           /* Definition of AT_* constants */</span></span><br><span class="line"><span class="string">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int unlinkat(int dirfd, const char *pathname, int flags);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       unlinkat():</span></span><br><span class="line"><span class="string">           Since glibc 2.10:</span></span><br><span class="line"><span class="string">               _POSIX_C_SOURCE &gt;= 200809L</span></span><br><span class="line"><span class="string">           Before glibc 2.10:</span></span><br><span class="line"><span class="string">               _ATFILE_SOURCE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">       unlink()  deletes  a  name from the filesystem.  If that name was the last link to a file and no processes have the file open, the file is deleted and the space it was using is made available</span></span><br><span class="line"><span class="string">       for reuse.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name was the last link to a file but any processes still have the file open, the file will remain in existence until the last file descriptor referring to it is closed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name referred to a symbolic link, the link is removed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name referred to a socket, FIFO, or device, the name for it is removed but processes which have the object open may continue to use it.</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-线程同步</title>
    <url>/2021/12/04/Linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>电脑坏了，复习时直接看APUE和讲义吧。。。<br>毁灭吧赶紧的。。虚拟机卡的要死</p>
<span id="more"></span>



<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="互斥量（互斥锁）"><a href="#互斥量（互斥锁）" class="headerlink" title="互斥量（互斥锁）"></a>互斥量（互斥锁）</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><code>pthread_mutex_t</code>类型</li>
<li>建议锁，不强制</li>
<li>在访问共享资源前对互斥量进行设置（加锁），访问完成后释放互斥量（解锁）。使得同一时间只有一个线程访问共享资源。</li>
<li><code>pthread_mutex_t</code><ul>
<li>互斥量用<code>pthread_mutex_t</code>类型表示</li>
<li>本质：结构体</li>
<li>使用时简化看为0，1。加锁即–，解锁即++。</li>
</ul>
</li>
<li>使用互斥量之前，必须对它进行初始化。<ul>
<li>静态初始化：<code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code></li>
<li>动态初始化：<code>pthread_mutex_init(&amp;mutex,NULL)</code></li>
</ul>
</li>
</ul>
<h3 id="控制原语"><a href="#控制原语" class="headerlink" title="控制原语"></a>控制原语</h3><h4 id="pthread-mutex-init"><a href="#pthread-mutex-init" class="headerlink" title="pthread_mutex_init"></a><code>pthread_mutex_init</code></h4><ul>
<li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr)</code></li>
<li>初始化一把互斥锁</li>
<li>mutex：要初始化的互斥锁</li>
<li>attr：互斥锁属性。默认属性为<code>attr=NULL</code></li>
</ul>
<h4 id="pthread-mutex-destroy"><a href="#pthread-mutex-destroy" class="headerlink" title="pthread_mutex_destroy"></a><code>pthread_mutex_destroy</code></h4><ul>
<li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex)</code></li>
<li>销毁互斥锁，以释放其占用的内存资源<ul>
<li>如果动态分配互斥量，如通过<code>malloc</code>，则在释放内存前也必须调用<code>pthread_mutex_destroy</code>。</li>
</ul>
</li>
</ul>
<h4 id="pthread-mutex-lock"><a href="#pthread-mutex-lock" class="headerlink" title="pthread_mutex_lock"></a><code>pthread_mutex_lock</code></h4><h4 id="pthread-mutex-unlock"><a href="#pthread-mutex-unlock" class="headerlink" title="pthread_mutex_unlock"></a><code>pthread_mutex_unlock</code></h4><ul>
<li>对互斥量进行加锁，需要调用<code>pthread_mutex_lock</code>。如果互斥量已经上锁，调用线程将阻塞直到互斥量被解锁。对互斥量解锁，需要调用<code>pthread_mutex_unlock</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(pthread_mutex *mutex)</span></span>;   <span class="comment">//  --mutex</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(pthread_mutex *mutex)</span></span>; <span class="comment">//  ++mutex</span></span><br><span class="line"><span class="comment">//  成功0 失败返回错误编号</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="pthread-mutex-trylock"><a href="#pthread-mutex-trylock" class="headerlink" title="pthread_mutex_trylock"></a><code>pthread_mutex_trylock</code></h4><ul>
<li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex)</code></li>
<li>成功0 失败返回错误编号</li>
<li>尝试加锁<ul>
<li>如果调用时互斥量mutex还没有被上锁，那么当前线程会锁住该互斥量，返回0。</li>
<li>如果调用时互斥量mutex已经被上锁，那么trylock调用失败，不能锁住互斥量，返回EBUSY</li>
</ul>
</li>
</ul>
<h4 id="pthread-mutex-timedlock"><a href="#pthread-mutex-timedlock" class="headerlink" title="pthread_mutex_timedlock"></a><code>pthread_mutex_timedlock</code></h4><ul>
<li><code>int pthread_mutex_timedlock(pthread_mutex_t *restrict mute,const struct timespec *restrict tsptr)</code></li>
<li>指定阻塞等待时间<code>s / ns</code></li>
</ul>
<ul>
<li>以上6个函数的返回值都是：成功返回 0， 失败返回错误号。</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>控制互斥量加锁的顺序来避免死锁</li>
<li>可以先释放已经占有的锁，然后过一段时间再尝试。<ul>
<li>可以使用<code>pthread_mutex_trylock</code>接口避免死锁。</li>
<li>如果已经占有某些锁且pthread_mutex_trylock返回0调用成功，那么就可以前进。但是，如果不能获取锁，可以先释放已经占有的锁，做好清理工作，然后过一段时间再尝试。</li>
</ul>
</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul>
<li>读共享，写独占。</li>
</ul>
<h3 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h3><ul>
<li><code>pthread_rwlock_t</code></li>
</ul>
<h3 id="控制原语-1"><a href="#控制原语-1" class="headerlink" title="控制原语"></a>控制原语</h3><h4 id="pthread-rwlock-init"><a href="#pthread-rwlock-init" class="headerlink" title="pthread_rwlock_init"></a>pthread_rwlock_init</h4><ul>
<li><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);</code></li>
<li>attr： 表读写锁属性，通常使用默认属性，传 NULL 即可</li>
</ul>
<h4 id="pthread-rwlock-destroy"><a href="#pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_destroy"></a>pthread_rwlock_destroy</h4><ul>
<li><code>int pthread_rwlock_destroy(pthread_rwlock_t * restrict rwlock)</code></li>
<li>销毁读写锁</li>
</ul>
<h4 id="pthread-rwlock-rdlock"><a href="#pthread-rwlock-rdlock" class="headerlink" title="pthread_rwlock_rdlock"></a>pthread_rwlock_rdlock</h4><ul>
<li><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);</code></li>
</ul>
<h4 id="pthread-rwlock-wrlock"><a href="#pthread-rwlock-wrlock" class="headerlink" title="pthread_rwlock_wrlock"></a>pthread_rwlock_wrlock</h4><ul>
<li><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code></li>
</ul>
<h4 id="pthread-rwlock-tryrdlock"><a href="#pthread-rwlock-tryrdlock" class="headerlink" title="pthread_rwlock_tryrdlock"></a><code>pthread_rwlock_tryrdlock</code></h4><h4 id="pthread-rwlock-trywlock"><a href="#pthread-rwlock-trywlock" class="headerlink" title="pthread_rwlock_trywlock"></a><code>pthread_rwlock_trywlock</code></h4><h4 id="pthread-rwlock-unlock"><a href="#pthread-rwlock-unlock" class="headerlink" title="pthread_rwlock_unlock"></a><code>pthread_rwlock_unlock</code></h4><ul>
<li>以上7个函数：成功返回0，失败返回错误编号<br>解决死锁的方法：</li>
<li>线程当拿不到另一个资源时，放弃现有资源。。</li>
<li>两个线程改变拿资源的顺序，先获取同一个资源，再获取另一个资源</li>
</ul>
<p>锁的粒度越小越好<br>只有操作共享资源的阶段才枷锁</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//  资源</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span>* <span class="title">head</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  静态初始化</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;    <span class="comment">//  互斥锁</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;    <span class="comment">//  条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  消费者区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">bk</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  上锁 pthread_mutex_lock</span></span><br><span class="line">        pthread_mutex_lock(&amp;lock);  <span class="comment">//  在pthread_cond_wait()之前，锁应当被加上</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  条件等待 pthread_cond_wait</span></span><br><span class="line">        <span class="comment">// 多个消费者时，如果是if的话，可能离开wait后，资源区仍然没有数据（当资源区有一个资源时，消费者同时被唤醒，结果一个消费者先将其消费。使得当这个消费者消费完释放锁时，另一个被唤醒的消费者拿到了锁，结果以为还有资源，但是没有资源。</span></span><br><span class="line">        <span class="comment">// 所以要用while</span></span><br><span class="line">        <span class="keyword">while</span>(head==<span class="literal">NULL</span>) <span class="comment">//  链表为空   不为空时意味着资源区有资源，直接消费即可。为空时需要等待生产者生产。</span></span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;cond,&amp;lock);</span><br><span class="line">            <span class="comment">//  (1) 释放绑定在当前线程上的lock锁</span></span><br><span class="line">            <span class="comment">//  (2) 阻塞等待cond变量符合条件。（即等待另一个线程的pthread_cond_signal(&amp;cond))</span></span><br><span class="line">            <span class="comment">//  (3) 前两个步骤结束后，wait返回，给当前线程上lock锁。如果没有得到锁，会阻塞等待。</span></span><br><span class="line">            <span class="comment">//  拿到锁之后，然后才从block变成runnable状态，受cpu调度，继续执行</span></span><br><span class="line">            <span class="comment">//  判断empty（）有没有可以处理的资源，有了往下走，没有又开始cond.wait(lock)</span></span><br><span class="line">            <span class="comment">//  为什么pthread_wait()要对互斥锁先解锁再上锁？因为阻塞期间拿不到资源，所以要解锁。（上个锁也没用，锁啥阿）而被唤醒后（可以）要使用共享数据，所以要解锁。</span></span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;--------------i %lu consume %d-------------\n&quot;</span>,pthread_self(),head-&gt;val);  <span class="comment">//  吃掉头部</span></span><br><span class="line">        bk = head;</span><br><span class="line">        head = head-&gt;next;         <span class="comment">// 走到下一个(因为前面while(head==NULL)) 所以必然可以</span></span><br><span class="line">        <span class="built_in">free</span>(bk);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  释放锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;lock);  </span><br><span class="line">        sleep(rand()%<span class="number">3</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生产者区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer_fun</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">p_msg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//  生产者开始生产</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  拿到互斥锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="comment">//  生产    资源放在堆中  头插法</span></span><br><span class="line">        p_msg = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct msg));     <span class="comment">//  malloc从堆中获得空间，全局变量在静态存储区中   </span></span><br><span class="line">        p_msg-&gt;val = rand()%<span class="number">100</span>+<span class="number">1</span>;</span><br><span class="line">        p_msg-&gt;next = head;</span><br><span class="line">        head = p_msg;    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i porduce %d\n&quot;</span>,p_msg-&gt;val);</span><br><span class="line">        <span class="comment">//  生产完，释放锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  生产者已经生产出资源，唤醒等待在条件变量cond上的线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);   <span class="comment">//  即 相当于 在告知消费者 资源区又 has_data了            </span></span><br><span class="line">        <span class="comment">//  模拟 消费者争夺cpu的机会</span></span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">err_thread</span><span class="params">(<span class="keyword">int</span> ret,<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s : %s\n&quot;</span>,str,strerror(ret));</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">//  不用exit！</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">pthread_t</span> tid_consumer,tid_producer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  生产者线程</span></span><br><span class="line">    ret = pthread_create(&amp;tid_producer,<span class="literal">NULL</span>,producer_fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    <span class="comment">//  消费者线程(多个)</span></span><br><span class="line">    ret = pthread_create(&amp;tid_consumer,<span class="literal">NULL</span>,consumer_fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = pthread_create(&amp;tid_consumer,<span class="literal">NULL</span>,consumer_fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ret = pthread_create(&amp;tid_consumer,<span class="literal">NULL</span>,consumer_fun,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">        err_thread(ret,<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// while(1);    回收线程</span></span><br><span class="line">    pthread_join(tid_consumer,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid_producer,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-线程</title>
    <url>/2021/12/03/Linux-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>Linux线程（未完）<br>因为电脑又坏了。。。这才半个多月好吧。。。。</p>
<span id="more"></span>
<ul>
<li>参考APUE，黑马，牛客。</li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>线程间共享<ul>
<li>bss。全局变量？、</li>
</ul>
</li>
<li>线程间不共享</li>
</ul>
<h2 id="控制原语"><a href="#控制原语" class="headerlink" title="控制原语"></a>控制原语</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="pthread-ceate"><a href="#pthread-ceate" class="headerlink" title="pthread_ceate"></a><code>pthread_ceate</code></h4><ul>
<li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg)</code></li>
<li><code>pthread_t *thread</code>：传出参数，表新创建的子线程 id</li>
<li><code>const pthread_attr_t *attr</code>：线程属性。传 NULL 表使用默认属性。</li>
<li><code>void *(*start_routine) (void *)</code>：新线程的线程体。</li>
<li><code>void *arg</code>：线程体的参数。没有的话，传<code>NULL</code><ul>
<li>如果有多个参数，需要将他们放入结构体，然后把结构体地址作为<code>arg</code>参数传入。</li>
</ul>
</li>
<li>返回值：成功：0</li>
<li>失败：直接返回错误码，而非设置<code>errno</code></li>
</ul>
<h4 id="pthread-t-pthread-self-void"><a href="#pthread-t-pthread-self-void" class="headerlink" title="pthread_t pthread_self(void);"></a><code>pthread_t pthread_self(void);</code></h4><ul>
<li><p>获取线程<code>ID</code>。其作用对应进程中 <code>getpid()</code> 函数。</p>
</li>
<li><p>返回值：成功：0； </p>
</li>
<li><p>线程 <code>ID</code>：<code>pthread_t</code></p>
<ul>
<li><code>typedef unsigned long int pthread_t;</code></li>
</ul>
</li>
<li><p>线程 <code>ID </code>是进程内部，识别标志。(不同进程的线程<code>ID</code>可能相同)</p>
</li>
<li><p>检查出错</p>
<ul>
<li><code>fprintf(stderr, &quot;xxx error: %s\n&quot;, strerror(ret));</code></li>
<li>因为线程直接返回错误号，而不是单独设置errno</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                         void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printids</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = getpid();</span><br><span class="line">        <span class="keyword">pthread_t</span> tid = pthread_self();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%lu\n&quot;</span>,s,pid,tid);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printids(<span class="string">&quot;new thread:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> err = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        printids(<span class="string">&quot;main thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./pthread_create_shc.out </span><br><span class="line"><span class="keyword">new</span> thread:	<span class="number">3892</span>	<span class="number">139853047412480</span></span><br><span class="line">main thread	<span class="number">3892</span>	<span class="number">139853055936320</span></span><br></pre></td></tr></table></figure>
<ul>
<li>处理主线程和新线程之间关系<ul>
<li>主线程休眠，防止新线程还没机会运行整个进程就结束了。</li>
<li>新线程获取<code>ID</code><ul>
<li>通过<code>pthread_self()</code>来获取自己的线程ID，</li>
<li>或者从线程的启动例程中以参数形式接收。</li>
<li>而不是利用<code>pthread_create</code>的第一个参数从共享内存（全局变量<code>tid</code>）读取。<ul>
<li>因为那样不安全。如果新线程在主线程的<code>pthread_create</code>返回前就运行了，那么读到的全局变量<code>tid</code>就是一个还没初始化的数。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg)</code></li>
<li>最后一个参数是传给新线程函数体<code>start_routine</code>的参数</li>
<li>注意<code>arg</code>可能会在主线程中发生改变。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以 int* -&gt; void* -&gt; int* -&gt;提取int</span></span><br><span class="line"><span class="comment">//  因为传进i的地址 i会在主线城中改变</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  32位 int 4 Byte  指针 4 Byte</span></span><br><span class="line"><span class="comment">//     int -&gt; *  ok 不会丢失数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  64位 int 4 Byte  指针 8 Byte</span></span><br><span class="line"><span class="comment">//     int -&gt; *  ok 不会丢失数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="comment">// int i = *((int*)arg);    wrong！</span></span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am the %dth thread , pid = %d , tid = %lu\n&quot;</span>,i,getpid(),pthread_self());  <span class="comment">//pthread_self 返回当前线程ID</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//  这就是线程的退出码吧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i!=<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不可以 int* -&gt; void* -&gt; int 因为传进i的地址 i会在主线城中改变</span></span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_function,(<span class="keyword">void</span>*)i);   </span><br><span class="line">        <span class="keyword">if</span>( ret!=<span class="number">0</span>)</span><br><span class="line">            sys_err(<span class="string">&quot;pthread error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main : i  = %d , pid = %d , tid = %ld\n&quot;</span>,i,getpid(),pthread_self());</span><br><span class="line">    pthread_exit ((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正解</span></span><br><span class="line">i am the <span class="number">0</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684367210240</span></span><br><span class="line">i am the <span class="number">1</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684358817536</span></span><br><span class="line">i am the <span class="number">2</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684350424832</span></span><br><span class="line">i am the <span class="number">3</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684342032128</span></span><br><span class="line">i am the <span class="number">4</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684333639424</span></span><br><span class="line">Main : i  = <span class="number">5</span> , pid = <span class="number">4916</span> , tid = <span class="number">140684375734080</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><ul>
<li>进程中的任意线程调用<code>exit</code>，那么整个进程都会终止。即，如果默认的动作是终止线程，那么发送到线程的信号就会终止整个进程</li>
<li>单个线程退出方式<ul>
<li>线程可以简单的从启动例程中返回，返回值是线程的退出码</li>
<li>线程可以被同一进程的其他线程取消</li>
<li>线程调用<code>pthread_exit</code></li>
</ul>
</li>
</ul>
<h4 id="void-pthread-exit-void-rval-ptr"><a href="#void-pthread-exit-void-rval-ptr" class="headerlink" title="void pthread_exit(void *rval_ptr)"></a><code>void pthread_exit(void *rval_ptr)</code></h4><ul>
<li><code>rval_ptr</code>：表示线程退出状态，通常传 <code>NULL</code></li>
<li><code>pthread_exit</code> 或者 <code>return</code> 返回的指针所指向的内存单元必须是全局的或者是用 <code>malloc</code> 分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</li>
</ul>
<h4 id="int-pthread-join-pthread-t-thread-void-rval-ptr"><a href="#int-pthread-join-pthread-t-thread-void-rval-ptr" class="headerlink" title="int pthread_join(pthread_t thread, void **rval_ptr);"></a><code>int pthread_join(pthread_t thread, void **rval_ptr);</code></h4><ul>
<li>对比记忆<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程中：main 返回值、exit 参数--&gt;int；等待子进程结束 wait 函数参数--&gt;int *</span><br><span class="line">线程中：线程主函数返回值、pthread_exit--&gt;void *；等待线程结束 pthread_join 函数参数--&gt;void **</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>调用线程将一直阻塞，直到指定线程调用<code>pthread_exit</code>、从启动例程中返回或者被取消。</li>
<li>终止线程而不退出整个进程的三种方式<ul>
<li>如果调用<code>pthread_exit</code>，那么<code>rval_ptr</code>就包含<code>pthread_exit</code>送入的参数。</li>
<li>如果线程简单的从它的启动例程<code>return</code>返回，<code>rval_ptr</code>就包含返回码。(非主函数的<code>return</code>)<ul>
<li>在主线程<code>main</code>中不应当调用<code>return</code>而应当用<code>pthread_exit</code>，因为主线程退出会使得整个进程都退出。</li>
</ul>
</li>
<li>如果线程被其他线程调用的<code>pthread_cancel</code>取消，由<code>rval_ptr</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code></li>
</ul>
</li>
<li>如果对线程返回值不感兴趣，<code>rval_ptr</code>就设置为<code>NULL</code></li>
<li>还可以通过<code>pthread_join</code>设置线程分离。这种情况下，调用<code>pthread_join</code>可以等待指定的线程终止，但不获取线程的终止状态。</li>
<li>线程中不存在父子关系，只有新线程和主线程之分。任何一个线程得到另一个线程的<code>pid</code>之后都可以去<code>join</code></li>
<li>代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *err,<span class="keyword">const</span> <span class="keyword">int</span> ret)</span></span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s error: %s\n&quot;</span>, err,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="keyword">int</span> a; </span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">256</span>]; </span><br><span class="line">&#125;;       </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">pf</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct foo)); </span><br><span class="line">        pf-&gt;a = <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">strcpy</span>(pf-&gt;name,<span class="string">&quot;shc&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*) pf; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">pf</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct foo)); </span><br><span class="line">        pf-&gt;a = <span class="number">2</span>; </span><br><span class="line">        <span class="built_in">strcpy</span>(pf-&gt;name,<span class="string">&quot;ssp&quot;</span>); </span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)pf); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="keyword">pthread_t</span> tid1,tid2; </span><br><span class="line">        <span class="keyword">int</span> err = pthread_create(&amp;tid1,<span class="literal">NULL</span>,tfn1,<span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>)  </span><br><span class="line">                sys_err(<span class="string">&quot;pthread_create&quot;</span>,err); </span><br><span class="line">        err = pthread_create(&amp;tid2,<span class="literal">NULL</span>,tfn2,<span class="literal">NULL</span>);      </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">void</span> *pret1,*pret2; </span><br><span class="line">        err = pthread_join(tid1,&amp;pret1);        <span class="comment">// &amp;pret1 即为 void ** pthread_join改变pret1的内容，即改变了pret1的指向。 </span></span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>) </span><br><span class="line">                sys_err(<span class="string">&quot;pthread_join&quot;</span>,err); </span><br><span class="line">        err = pthread_join(tid2,&amp;pret2); </span><br><span class="line">         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>,((struct foo*)pret1)-&gt;a,((struct foo*)pret1)-&gt;name); </span><br><span class="line">                 </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>,((struct foo*)pret2)-&gt;a,((struct foo*)pret2)-&gt;name);    </span><br><span class="line"> </span><br><span class="line">        pthread_exit ((<span class="keyword">void</span>*)<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./pthread_join_shc.out </span><br><span class="line">1 shc</span><br><span class="line">2 ssp</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>以下日后补充</li>
</ul>
<h4 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a><code>pthread_cancel</code></h4><ul>
<li><code>int pthread_cancel(pthread_t tid);</code></li>
<li>请求取消同一进程中的其他进程。类似于进程中的kill      </li>
<li>默认情况下，pthread_cancel函数会使得tid标识的现成的行为表现如同调用了参数为<code>PTHREAD_CANCELED</code>的pthread_exit参数。但是线程可以选择忽略取消或者控制如何取消。</li>
<li>pthread_cancel不等待线程终止，仅仅提出请求。</li>
<li>线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个**取消点(检查点)**。<ul>
<li><blockquote>
<p>类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。</p>
</blockquote>
</li>
<li><blockquote>
<p>取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用 creat，open，pause，close，read，write….. 。执行命令 man 7 pthreads 可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</p>
</blockquote>
</li>
<li><blockquote>
<p>可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用 pthread_testcancel函数自行设置一个取消点。</p>
</blockquote>
</li>
<li><blockquote>
<p>被取消的线程， 退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是-1。可在头文件pthread.h中找到它的定义：#define PTHREAD_CANCELED ((void *) -1)。因此当我们对一个已经被取消的线程使用 pthread_join回收时，得到的返回值为-1。</p>
</blockquote>
</li>
</ul>
</li>
<li>日后补充</li>
</ul>
<h3 id="线程分离-（博客园，牛客）"><a href="#线程分离-（博客园，牛客）" class="headerlink" title="线程分离 （博客园，牛客）"></a>线程分离 （博客园，牛客）</h3><h4 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h4><ul>
<li><code>int pthread_detach(pthread_t thread)</code> </li>
<li>线程分离状态：<ul>
<li>指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。</li>
<li>进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。</li>
<li>一般情况下，线程终止后，其终止状态一直保留到其它线程调用 pthread_join 获取它的状态为止。但是线程也可以被置为 detach 状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。</li>
<li>不能对一个已经处于 detach 状态的线程调pthread_join，这样的调用将返回 EINVAL 错误。也就是说，如果已经对一个线程调用了 pthread_detach 就不能再调用 pthread_join 了</li>
</ul>
</li>
<li>日后补充，等电脑修好的。</li>
</ul>
<h4 id="pthread-attr-t"><a href="#pthread-attr-t" class="headerlink" title="pthread_attr_t"></a>pthread_attr_t</h4><ul>
<li>线程属性结构体<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">int</span>                  detachstate;     <span class="comment">//线程的分离状态</span></span><br><span class="line">        <span class="keyword">int</span>                  schedpolicy;     <span class="comment">//线程调度策略</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>   <span class="title">schedparam</span>;</span>      <span class="comment">//线程的调度参数</span></span><br><span class="line">        <span class="keyword">int</span>                  inheritsched;    <span class="comment">//线程的继承性</span></span><br><span class="line">        <span class="keyword">int</span>                  scope;           <span class="comment">//线程的作用域</span></span><br><span class="line">        <span class="keyword">size_t</span>               guardsize;       <span class="comment">//线程栈末尾的警戒缓冲区大小</span></span><br><span class="line">        <span class="keyword">int</span>                  stackaddr_set;   <span class="comment">//线程的栈设置</span></span><br><span class="line">        <span class="keyword">void</span> *               stackaddr;       <span class="comment">//线程栈的位置</span></span><br><span class="line">        <span class="keyword">size_t</span>               stacksize;       <span class="comment">//线程栈的大小</span></span><br><span class="line">&#125; <span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>主要结构体成员：<ul>
<li>线程分离状态     </li>
<li>线程栈大小（默认平均分配）</li>
<li>线程栈警戒缓冲区大小（位于栈末尾）</li>
</ul>
</li>
<li>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级别。</li>
</ul>
</li>
<li>对于pthread_attr_t属性值，须初始化，且须使用相关函数进行操作。<code>pthread_attr_init</code> —<code>设置线程属性</code>—&gt; <code>pthread_create</code> -&gt; <code>pthread_attr_destory</code>。不初始化的话在创建线程时会发生错误。</li>
<li>线程的分离状态决定一个线程以什么样的方式来终止自己。</li>
<li>默认情况下线程创建是非分离状态：这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</li>
<li>分离线程：它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。所以如果我们在创建线程时就知道不需要了解线程的终止状态，则可以pthread_attr_t结构中的detachstate线程属性，让线程以分离状态启动。</li>
<li><code>int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate);</code></li>
<li><code>int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a、获取线程分离状态属性</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line">    返回值：若是成功返回<span class="number">0</span>,否则返回错误的编号</span><br><span class="line">    形  参：</span><br><span class="line">            attr          指向一个线程属性的指针</span><br><span class="line">            detachstate   保存返回的分离状态属性</span><br><span class="line">    说  明：获取线程分离状态属性</span><br><span class="line">    头文件：<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">    </span><br><span class="line">b、修改线程分离状态属性</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line">    返回值：若是成功返回<span class="number">0</span>,否则返回错误的编号</span><br><span class="line">    形  参：</span><br><span class="line">            attr        指向一个线程属性的指针</span><br><span class="line">            detachstat  有两个取值</span><br><span class="line">                        PTHREAD_CREATE_DETACHED(分离)</span><br><span class="line">                        PTHREAD_CREATE_JOINABLE（非分离）</span><br><span class="line">    说  明：Posix线程中的线程属性<span class="keyword">pthread_attr_t</span>主要包括scope属性、detach属性、堆栈地址、堆栈大小、优先级。</span><br><span class="line">    头文件：<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: pid = %d , tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;new die&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *err,<span class="keyword">int</span> ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s : %s\n&quot;</span>,err,strerror(ret));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  线程属性结构体变量</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  初始化线程属性</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;pthread_init error&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  设置线程分离状态</span></span><br><span class="line">    ret = pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;pthread_attr_setdetachstate error&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  创建线程    </span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    ret = pthread_create(&amp;tid,&amp;attr,tfn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;pthread_create error&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  销毁线程属性</span></span><br><span class="line">        <span class="comment">//  attr就是给pthread_create使用的。pthread_create调用结束之后，attr的属性值就设置到tid的线程数据结构中去了，不再需要attr。（传attr的地址应该是为了轻便，不是为了动态使用attr，毕竟传一整个结构体累死人了）</span></span><br><span class="line">    ret = pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span>(ret!=<span class="number">0</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;pthread_attr_destory  error&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main : pid = %d , tid = %lu\n&quot;</span>,getpid(),pthread_self());</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main die\n&quot;</span>);</span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// detach - 必应词典</span></span><br><span class="line"><span class="comment">// 美[dɪˈtætʃ]英[dɪ&#x27;tætʃ]</span></span><br><span class="line"><span class="comment">// v.脱离；拆卸；离开；挣脱</span></span><br><span class="line"><span class="comment">// 网络分离；分开；派遣</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="线程-进程"><a href="#线程-进程" class="headerlink" title="线程/进程"></a>线程/进程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pthread_create() &lt;----&gt; fork();</span><br><span class="line">pthread_self()   &lt;----&gt; getpid();</span><br><span class="line">pthread_exit()   &lt;----&gt; exit(); / return </span><br><span class="line">pthread_join()   &lt;----&gt; wait()/waitpid()</span><br><span class="line">pthread_cancel() &lt;----&gt; kill()</span><br><span class="line">pthread_detach() &lt;----&gt; signal(SIGCHLD,SIG_ING)</span><br></pre></td></tr></table></figure>




<blockquote>
<h3 id="线程注意事项"><a href="#线程注意事项" class="headerlink" title="线程注意事项"></a>线程注意事项</h3></blockquote>
<ul>
<li>线程使用注意事项 <ul>
<li>主线程退出其他线程不退出，主线程应调用 pthread_exit</li>
<li>避免僵尸线程<ul>
<li>pthread_join</li>
<li>pthread_detach</li>
<li>pthread_create </li>
</ul>
</li>
<li>被 join 线程可能在 join 函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</li>
<li>malloc 和 mmap 申请的内存可以被其他线程释放</li>
<li>应避免在多线程模型中调用 fork。 除非，马上 exec，子进程中只有调用 fork 的线程存在，其他线程在子进程中均 pthread_exit</li>
</ul>
</li>
</ul>
<ul>
<li><code>restrict</code><ul>
<li>C语言中的一种类型限定符（Type Qualifiers），用于告诉编译器，对象已经被指针所引用，不能通过除该指针外所有其他直接或间接的方式修改该对象的内容。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-进程2-进程通信</title>
    <url>/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/</url>
    <content><![CDATA[<p>Linux进程通信</p>
<span id="more"></span>


<ul>
<li>参考 APUE，牛客讲义</li>
</ul>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>半双工<ul>
<li>半双工通信是指可以双向流动，但不能同时。</li>
</ul>
</li>
<li><strong>常见<code>IPC</code>方法</strong><ul>
<li>管道（无名）<code>pipe：</code>血缘</li>
<li>管道（有名）<code>fifo：</code>非血缘<ul>
<li>管道：内核借助消息队列实现，因此数据只能读一次</li>
</ul>
</li>
<li>信号</li>
<li><code>mmap</code>（存储映射<code>I/O</code>）：非血缘<ul>
<li>速度快，数据可以反复读取。</li>
</ul>
</li>
<li>本地套接字：稳定</li>
</ul>
</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>伪文件（不占磁盘空间）</li>
<li>两个文件描述符<code>（r/w）</code></li>
<li>数据从写端流入，读端流出</li>
<li>管道缓冲区大小 4096<ul>
<li><code>ulimit -a</code></li>
<li><code>pipe size            (512 bytes, -p) 8</code></li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>环形队列</li>
<li>内核缓冲区</li>
</ul>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul>
<li>优点：简单</li>
<li>数据不能反复读</li>
<li>单向通信（半双工）</li>
<li>只能用于有公共祖先的进程间。（父子，兄弟）</li>
</ul>
<h3 id="读写行为"><a href="#读写行为" class="headerlink" title="读写行为"></a>读写行为</h3><ul>
<li>读管道<ul>
<li>管道中有数据，<code>read</code>返回实际读到字节数</li>
<li>管道中无数据<ul>
<li>有写端，则<code>read</code>阻塞等待写端写入</li>
<li>无写端，<code>read</code>返回0（读到文件尾）。</li>
</ul>
</li>
</ul>
</li>
<li>写管道<ul>
<li>管道无读端，异常。<code>SIGPIPE</code>信号</li>
<li>管道有读端<ul>
<li>未满，直接写，返回写入字节个数</li>
<li>已满，阻塞等待<code>read</code>把数据读走。</li>
</ul>
</li>
</ul>
</li>
<li>管道若设置为非阻塞，则当某一线程在管道一端read读不到数据时，立刻返回-1，不会阻塞在那里。且errno=EAGAIN。</li>
</ul>
<h3 id="int-pipe-int-pipefd-2"><a href="#int-pipe-int-pipefd-2" class="headerlink" title="int pipe(int pipefd[2]);"></a><code>int pipe(int pipefd[2]);</code></h3><ul>
<li><code>return</code><ul>
<li><code>r/w</code> 两个文件描述符。无需 <code>open</code>，但需手动 <code>close</code>。</li>
<li><code>fd[0] &lt;-&gt; read , fd[1] &lt;-&gt; write</code></li>
<li>向管道文件读写数据其实是在读写内核缓冲区</li>
<li>成功0，失败-1，设置erron</li>
</ul>
</li>
<li>使用<ul>
<li>父进程<code>pipe</code>，得管道，以及<code>fd[0],fd[1]</code></li>
<li>父进程<code>fork</code>，子进程复制父进程文件描述表，共享文件描述符关联的文件结构体，故子进程也有<code>fd[0],fd[1]</code>指向相应文件。（自己猜的，不知道对错）</li>
<li>父进程关闭读，进行写；子进程关闭写，进行读。管道环形队列实现，保证数据单线流动。</li>
</ul>
</li>
<li>问题<ul>
<li>读时共享，写时复制。所以不会父进程读端的关闭不会造成子进程读端的关闭。同理，子进程写端的关闭也不会造成父进程写端的关闭。故不会发生错误。</li>
<li><blockquote>
<p>子进程复制父进程的数据段，BSS段，代码段，堆空间，栈空间，文件描述符，但是对于文件描述符关联的内核文件表项（即struct file结构体）则是采用共享的方式</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/2021-11-29-13-41-57.png"><br><img src="/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/2021-11-29-13-21-24.png"></p>
<ul>
<li>基本用法（父子）（兄弟同理）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">pipe</span>(fd);</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">0</span>]);   <span class="comment">//  关闭 父读</span></span><br><span class="line">                <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">&quot;hello\n&quot;</span>,<span class="keyword">sizeof</span> <span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">1</span>]);   <span class="comment">//  关闭 父写</span></span><br><span class="line">                <span class="built_in">waitpid</span>(pid,<span class="literal">NULL</span>,<span class="number">0</span>);    <span class="comment">//  阻塞回收子进程      </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">1</span>]);   <span class="comment">//  关闭 子写</span></span><br><span class="line">                <span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">0</span>]);   <span class="comment">//  关闭 子读</span></span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./pipe_1.out </span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>父子进程实现<code>ls | wc -l</code>，xd同理（记得关闭不适用管道的进程的r/w端）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *err)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程实现 ls ；子进程利用父进程ls的结果使用wc命令；子进程命令结果输送到终端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">pipe</span>(fd);</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">0</span>]);   <span class="comment">//   父进程关闭读段,但是子进程的读端没有关闭，使得数据单向流动</span></span><br><span class="line">                <span class="built_in">dup2</span>(fd[<span class="number">1</span>],STDOUT_FILENO);      <span class="comment">//  向终端的输出stdout 重定向 到管道的写端fd[1]</span></span><br><span class="line">                <span class="built_in">execlp</span>(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-ahl&quot;</span>,<span class="literal">NULL</span>);  <span class="comment">//  execlp(可执行文件名字,命令参数,NULL);       这里依靠execlp 执行程序结束后隐式的关闭副进程写</span></span><br><span class="line">端，下同理</span><br><span class="line">                <span class="comment">//  execlp后面的代码只有在execlp失败了才会走到 所以不用wait了</span></span><br><span class="line">                <span class="built_in">sys_err</span>(<span class="string">&quot;exclp error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">1</span>]);   <span class="comment">//   关闭子进程写端</span></span><br><span class="line">                <span class="built_in">dup2</span>(fd[<span class="number">0</span>],STDIN_FILENO);       <span class="comment">//  从终端读入stdin 重定向为 从管道读端读入fd[0]</span></span><br><span class="line">                <span class="built_in">execlp</span>(<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);    <span class="comment">//   execlp</span></span><br><span class="line">                <span class="built_in">sys_err</span>(<span class="string">&quot;execlp error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   简记 dup2(a,b) 将文件描述符a拷贝给b        之后对b做的事情就相当于对a做的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./pipe_shc.out </span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="有名管道FIFO"><a href="#有名管道FIFO" class="headerlink" title="有名管道FIFO"></a>有名管道FIFO</h2><ul>
<li><p><code>FIFO</code> 常被称为命名管道，以区分管道<code>(pipe)</code>。管道<code>(pipe)</code>只能用于“有血缘关系”的进程间。但通过 <code>FIFO</code>，不相关的进程也能交换数据。</p>
</li>
<li><p><code>FIFO </code>是 <code>Linux</code> 基础文件类型中的一种。但，<code>FIFO</code> 文件在磁盘上没有数据块（所以没有大小），仅仅用来标识内核中一条通道。各进程可以打开这个文件进行 <code>read/write</code>，实际上是在读写内核通道，这样就实现了进程间通信。</p>
</li>
<li><p>真有意思，<code>fifo</code>作为文件系统中的一种文件，内容居然存在于内存。使用<code>fifo</code>的进程退出后，<code>fifo</code>文件将继续保存在文件系统中以便后续使用。</p>
</li>
<li><p>创建</p>
<ul>
<li>命令：<code>mkfifo</code></li>
<li>函数：<code>int mkfifo(const char *pathname, mode_t mode);</code></li>
</ul>
</li>
<li><p>打开</p>
<ul>
<li>读端：<code>int fd1 = open(&quot;./fifo2&quot;,O_RDONLY);</code></li>
<li>写端：<code>int fd1 = open(&quot;./fifo2&quot;,O_WRONLY);</code></li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>以<code>O_RDONLY</code>且没有<code>O_NONBLOCK</code>打开一个<code>fifo</code>时，会阻塞等待指导有一个进程对<code>fifo</code>执行写打开。</li>
<li>所以当一个进程需要对<code>fifo</code>写读时，一般使用<code>O_RDWR</code></li>
<li>迷惑：程序里用<code>mkfifo</code>创建一个管道时，对管道的默认权限好像不可以写。</li>
<li>似乎不是重点？日后用到再补充。<br><img src="/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/2021-11-29-15-49-03.png"></li>
</ul>
</li>
<li><p><code>fifo_shc1</code>写，<code>fifo_shc2</code>读</p>
<ul>
<li><p><code>fifo_shc1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//  这个权限很迷，貌似不可以写</span></span><br><span class="line"><span class="comment">//      int fd1 = mkfifo(&quot;./fifo2&quot;,0664);</span></span><br><span class="line">        <span class="keyword">int</span> fd1 = open(<span class="string">&quot;./fifo2&quot;</span>,O_RDWR);</span><br><span class="line">        <span class="keyword">int</span> fd2 = open(<span class="string">&quot;./waitpid_shc.c&quot;</span>,O_RDONLY);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">int</span> len = read(fd2,buf,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,len);</span><br><span class="line">                write(fd1,<span class="string">&quot;hhhhhhhh&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;hhhhhhhh&quot;</span>));</span><br><span class="line">                <span class="comment">//  只有第一次读的时候有len!=0 一次数据就读完了。需要用lseek移动文件指针。</span></span><br><span class="line">                <span class="keyword">if</span>(len) </span><br><span class="line">                &#123;</span><br><span class="line">                        write(fd1,buf,len);</span><br><span class="line">                        write(STDOUT_FILENO,buf,len);</span><br><span class="line">                &#125;</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line">        close(fd2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>fifo_shc2</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SADSADADSADASDS\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/home/shc/code/revier/fifo2&quot;</span>,O_RDWR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;KKKK\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd1==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open wrong&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;???\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;??\n&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> len = read(fd1,buf,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                write(STDOUT_FILENO,buf,len);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,len);</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SADSADADSADASDS</span><br><span class="line">KKKK</span><br><span class="line">???</span><br><span class="line">??</span><br><span class="line">hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh56</span><br><span class="line">??</span><br><span class="line">hhhhhhhh8</span><br><span class="line">??</span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/wait.h&gt;</span></span><br><span class="line">...若干文件内容 只读了一次就读完了</span><br><span class="line">hhhhhhhh783</span><br><span class="line">??</span><br><span class="line">hhhhhhhh8</span><br><span class="line">??</span><br><span class="line">hhhhhhhhhhhhhhhh16</span><br><span class="line">??</span><br><span class="line">hhhhhhhh8</span><br><span class="line">??</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="存储映射I-O-mmap"><a href="#存储映射I-O-mmap" class="headerlink" title="存储映射I/O mmap"></a><code>存储映射I/O mmap</code></h2><h3 id="void-mmap-void-addr-size-t-length-int-prot-int-flags-int-fd-off-t-offset"><a href="#void-mmap-void-addr-size-t-length-int-prot-int-flags-int-fd-off-t-offset" class="headerlink" title="void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);"></a><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></h3><ul>
<li><p>存储映射（<code>memory-mapped I/O</code>）能将一个磁盘文件映射到存储空间的一个缓冲区上，于是，当从缓冲区读取数据时，就相当于读文件中的相应字节。与此类似，将数据写入缓冲区时，相应字节就自动写入文件。这样，就可以在不用<code>read，write</code>的情况下，执行<code>I/O</code>。（<code>mmap</code>将文件映射到用户区，所以可以使用C库函数，在用户区进行读写，不必进入内核，因而省去了使用<code>read/write</code>）</p>
</li>
<li><p>所以用mmap好处：可以用对指针进行操作的库函数；且是我知道的所有这些进程间通信方式中最快的。</p>
</li>
<li><p>父子进程共享</p>
<ul>
<li> <code>mmap</code>映射区</li>
<li>文件描述符（打开的文件结构体）</li>
</ul>
</li>
<li><p>上图！<br><img src="/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/2021-11-29-22-54-41.png"></p>
</li>
<li><p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p>
<ul>
<li><code>addr</code>：指定映射存储区的起始地址。通常NULL，系统自动分配</li>
<li><code>length</code>：映射的字节数，即指定存储映射区大小。&lt;=文件实际大小</li>
<li><code>prot</code>：映射存储区的读写属性<ul>
<li><code>PROT_READ</code>：映射区可读</li>
<li><code>PROT_WRITE</code>：映射区可写</li>
<li><code>PROT_EXEC</code>：映射区可执行</li>
<li><code>PROT_NON</code>E：映射区不可访问</li>
</ul>
</li>
<li><code>flags</code>：标注映射存储区的属性。<ul>
<li><code>MAP_SHARED</code>：对存储映射区的修改会反应到物理磁盘上</li>
<li><code>MAP_PRIVATE</code></li>
<li><code>MAP_ANONYMOUS / MAP_ANON</code>：匿名</li>
</ul>
</li>
<li><code>fd</code>：用于创建存储映射区的文件的文件描述符</li>
<li><code>offset</code>：要映射字节在文件中的起始偏移量。应是4K的整数倍，一般为0。</li>
</ul>
</li>
<li><p><code>return</code></p>
<ul>
<li>成功：映射区的首地址</li>
<li>失败：<code>return MAP_FAILED(void*(-1);   + errno</code></li>
</ul>
</li>
<li><p><strong>注意</strong>（黑马）</p>
<ul>
<li> 用于创建映射区的文件（<code>fd</code>）大小为 0，实际指定非0大小创建映射区<code>（length）</code>，出 “总线错误 <code>SIGBUS</code>”。</li>
<li> 用于创建映射区的文件<code>（fd）</code>大小为 0，实际制定0大小创建映射区<code>（length）</code>， 出 “无效参数 <code>Invalid</code>”。</li>
<li> 用于创建存储映射区的文件读写属性为，只读<code>（open时的mode）</code>。存储映射区属性<code>（prot）</code>为 读、写<code>（PROT_READ|PROT_WRITE）</code>。 出 “无效参数”</li>
<li> 创建映射区的过程中，隐含着一次对映射文件的读操作。因此<code>mmap</code>创建映射区，必定需要<code>read</code>权限。</li>
<li> 当访问权限<code>（flags）</code>指定为 “共享”<code>MAP_SHARED</code>是， <code>mmap</code>的<code>（prot）</code>读写权限，应该 <code>&lt;=</code>文件的open权限。只写不行。</li>
<li> 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。文件描述符<code>fd</code>，在<code>mmap</code>创建存储映射区完成即可关闭。后续访问文件，用地址（即mmap返回的）指针访问。</li>
<li><code> offset</code> 必须是 <code>4096</code>的整数倍。（<code>MMU</code> 映射的最小单位 <code>4k</code> ）</li>
<li> 对申请的映射区内存，不能越界访问</li>
<li> <code>munmap</code>用于释放的 址，必须是<code>mmap</code>申请返回的地址。</li>
<li> 映射区访问权限<code>flags</code>为 “私有”<code>MAP_PRIVATE</code>, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘</li>
<li> 映射区访问权限<code>flags</code>为 “私有”<code>MAP_PRIVATE</code>, 只需要<code>open</code>文件时，有读权限，用于创建映射区即可。</li>
<li><code> munmap</code> 传入的地址一定是 <code>mmap</code> 的返回地址。坚决杜绝指针<code>++</code>操作</li>
<li> <code>mmap</code> 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ul>
</li>
<li><p><code>mmap</code>保险调用</p>
<ul>
<li><code>fd = open(&quot; &quot;,O_RDWR);</code></li>
<li><code>mmap(NULL,文件大小,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">      #include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">自理:</span></span><br><span class="line"><span class="comment">    通过mmap映射 可以不进行read write，只用地址指针就对磁盘文件进行读写I/O操作。</span></span><br><span class="line"><span class="comment">    mmap将文件映射到用户区，所以可以使用C库函数，在用户区进行读写，不必进入内核，因而省去了使用read/write</span></span><br><span class="line"><span class="comment">      void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span></span><br><span class="line"><span class="comment">      int munmap(void *addr, size_t length);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;perror(str); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./test_mmap3.txt&quot;</span>,O_RDONLY|O_CREAT|O_TRUNC,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>) sys_err(<span class="string">&quot;open erorr&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ftruncate(fd,<span class="number">100</span>);  <span class="comment">//  需要写权限。</span></span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END); <span class="comment">//  返回从文件起始到 SEEK_END再向后便宜0字节的大小，即文件大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  建立存储映射区</span></span><br><span class="line">    <span class="keyword">char</span> *p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">if</span>(p==MAP_FAILED)   sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">//  建立完之后即可关闭文件描述符！</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello void *mmap(void* addr , size_t length,int prot,int flags,int fd,off_t offset);\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------%s-----------------\n&quot;</span>,p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  释放</span></span><br><span class="line">    <span class="keyword">int</span> ret = munmap(p,len);  </span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>) sys_err(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件扩容100字节</span></span><br><span class="line"><span class="comment">// lseek(fd,99,SEEK_END);   //  将文件指针从SEEK_END向后移动9个字节</span></span><br><span class="line"><span class="comment">// write(fd,&quot;\0&quot;,1);   //  再写一个 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>父子进程使用 <code>mmap</code> 进程间通信：</p>
<ul>
<li>父进程 先 创建映射区。 <code>open (O_RDWR)</code> <code>mmap(MAP_SHARED)</code>;</li>
<li>指定 <code>MAP_SHARED</code> 权限</li>
<li><code>fork()</code> 创建子进程。</li>
<li>一个进程读， 另外一个进程写。</li>
</ul>
</li>
<li><p>无血缘关系进程间 <code>mmap</code> 通信（<strong>重点</strong>）                  </p>
<ul>
<li>两个进程 打开同一个文件，创建映射区。</li>
<li>指定<code>flags</code> 为 <code>MAP_SHARED。</code></li>
<li>一个进程写入，另外一个进程读出。</li>
<li>不同于<code>fifo</code>，<code>mmap</code>存储映射区中的数据可以重复读取。</li>
</ul>
</li>
<li><p>匿名映射<code>flags</code>：只能用于血缘关系进程间通信。</p>
<ul>
<li>即不需要创建临时文件</li>
<li><code>Linux</code>下<ul>
<li><code>int *p = (int *)mmap(NULL,大小, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code><ul>
<li><code>length</code>：任意</li>
<li><code>flags：MAP_ANONYMOUS/MAP_ANON</code></li>
<li><code>fd</code>：-1</li>
</ul>
</li>
</ul>
</li>
<li><code>Unix</code>下<ul>
<li><code>fd = open(&quot;/dev/zero&quot;, O_RDWR);</code></li>
<li><code> p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用<code>mmap</code>进行父子关系进程通信代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = open(<span class="string">&quot;temp&quot;</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ftruncate(fd, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span></span><br><span class="line">    p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;		<span class="comment">//注意:不是p == NULL</span></span><br><span class="line">        perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);					<span class="comment">//映射区建立完毕,即可关闭文件</span></span><br><span class="line"></span><br><span class="line">    pid = fork();				<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      *p = <span class="number">7000</span>;               <span class="comment">// 写共享内存</span></span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, *p = %d, var = %d\n&quot;</span>, *p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, *p = %d, var = %d\n&quot;</span>, *p, var);     <span class="comment">// 读共享内存</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);				<span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>mmap</code>进行非血缘关系进程通信代码。</p>
<ul>
<li>结构<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ tree .</span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   ├── student.h</span><br><span class="line">│   └── sys_err.h</span><br><span class="line">└── src</span><br><span class="line">    ├── mmap_shc.c</span><br><span class="line">    ├── mmap_shc.out</span><br><span class="line">    ├── mmap_shc_read.c</span><br><span class="line">    ├── mmap_shc_read.out</span><br><span class="line">    ├── mmap_shc_write.c</span><br><span class="line">    ├── mmap_shc_write.out</span><br><span class="line">    ├── sys_err.c</span><br><span class="line"><span class="comment">//命令</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ gcc mmap_shc_read.c sys_err.c -o mmap_shc_raed.out -Iinclude -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体结构及头文件</span></span><br><span class="line"><span class="comment">// sys_err.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(name);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_err.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(name);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>写<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR|O_TRUNC|O_CREAT,<span class="number">0664</span>);</span><br><span class="line">    ftruncate(fd,<span class="keyword">sizeof</span> (struct student));</span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    unlink(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  建立存储映射区，p指向那那段地方</span></span><br><span class="line">    <span class="comment">//                         存储映射区首地址    映射区长度   对存储映射区权限   是否反应到真实磁盘上 fd 起始偏移量  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> =</span> (struct student*)mmap(<span class="literal">NULL</span>,len,PROT_WRITE|PROT_READ,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==MAP_FAILED) sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  建立完映射区后即可关闭文件</span></span><br><span class="line">    close(fd);  <span class="comment">//  之后就是通过p对内存做事情 不需要文件描述符了 因此关闭</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">student</span> =</span> &#123;<span class="number">1</span>,<span class="string">&quot;shc&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;student,<span class="keyword">sizeof</span> student);</span><br><span class="line">        ++student.id;</span><br><span class="line">        usleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    munmap(p,<span class="keyword">sizeof</span> student); <span class="comment">//  释放映射区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>读<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    unlink(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//  建立</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> =</span> (struct student *)mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==MAP_FAILED) sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>,p-&gt;id,p-&gt;name);</span><br><span class="line">        usleep(<span class="number">2000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  释放</span></span><br><span class="line">    munmap(p,<span class="keyword">sizeof</span> student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./mmap_shc_write.out temp</span><br><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./mmap_shc_read.out temp</span><br><span class="line">22 shc</span><br><span class="line">24 shc</span><br><span class="line">26 shc</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>匿名映射代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">懒得写了，下次一定</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-命令常识</title>
    <url>/2021/11/05/Linux%E5%91%BD%E4%BB%A4%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<ul>
<li><a href="https://www.zhihu.com/question/28300645">docker</a><ul>
<li><a href="https://www.zhihu.com/question/28300645/answer/585166942">https://www.zhihu.com/question/28300645/answer/585166942</a></li>
<li><a href="https://www.zhihu.com/question/28300645/answer/2488146755">https://www.zhihu.com/question/28300645/answer/2488146755</a></li>
</ul>
</li>
<li>du disk usage<ul>
<li><a href="http://c.biancheng.net/linux/du.html">http://c.biancheng.net/linux/du.html</a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">为什么 du 和 ls 输出的值不同</span><br><span class="line">如果我告诉你说 du 和 ls 针对同一个文件，展示的大小是不一样的，你会不会很惊讶呢？</span><br><span class="line"></span><br><span class="line">下面我们就用一个活生生的例子，先把这个“奇观”给大家展示出来。</span><br><span class="line"><span class="comment">#有一个文件, 里面只输入了a、b两个英文字母</span></span><br><span class="line">[roc@roclinux ruanjian]$ cat myword</span><br><span class="line">ab</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用下面的方法, 我们可以把文件中的控制字符也展示出来, 发现除了a、b外还包括了一个结尾符</span></span><br><span class="line">[roc@roclinux ruanjian]$ sed -n l myword</span><br><span class="line">ab$</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用ls来查看大小, 发现展示的是3字节</span></span><br><span class="line">[roc@roclinux ruanjian]$ ls -l myword</span><br><span class="line">-rw-rw-r-- 1 roc roc 3 2月  18 15:53 myword</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用du来查看大小, 竟然展示的是4KB字节</span></span><br><span class="line">[roc@roclinux ruanjian]$ du myword</span><br><span class="line">4       myword</span><br><span class="line"></span><br><span class="line">du 命令的作者也太粗心了吧，竟然连字母个数都数不清么？冤枉啊！其实，du 和 ls 在展示文件大小时，是存在着本质区别的：</span><br><span class="line">du 展示的是磁盘空间占用量。</span><br><span class="line">ls 展示的是文件内容的大小。</span><br><span class="line"></span><br><span class="line">可能这两句话还不足以让你理解两者的区别，我们举一个形象的例子。中秋节时，中国人走亲访友时都会购买月饼礼盒，月饼的体积可以认为是文件内容大小，而加上包装礼盒的总体积可以认为是磁盘空间使用量。</span><br><span class="line"></span><br><span class="line">那么，在 Linux 的世界里，每个文件也要有包装么？要想解答这个问题，我们就要简单介绍下 Linux 文件系统的原理了。文件系统进驻磁盘之初，就会将磁盘按照固定数据块（block）大小进行分隔切块，通常情况下每一个固定数据块大小会被设定为 4096bytes，也就是 4KB。</span><br><span class="line"></span><br><span class="line">与此同时，大部分文件系统规定：</span><br><span class="line">一个数据块中最多存放一个文件的内容，当没存满时，剩余的空间不得被其他文件使用。</span><br><span class="line">当一个文件的内容较大时，则可以存储到多个数据块中。</span><br><span class="line"></span><br><span class="line">讲到这里，相信你应该有所领悟了，正是因为这样的管理规则，使得 du 和 ls 在大小展示上出现了差异。</span><br><span class="line"></span><br><span class="line">我们再回过头来看一下刚才那个例子：</span><br><span class="line"><span class="comment">#有一个文件, 里面只输入了a、b两个英文字母</span></span><br><span class="line">[roc@roclinux ruanjian]$ cat myword</span><br><span class="line">ab</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用这个方法, 我们可以把文件里的控制字符也展示出来, 发现除了a、b外还包括了一个结尾符。</span></span><br><span class="line">[roc@roclinux ruanjian]$ sed -n l myword</span><br><span class="line">ab$</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用ls来查看大小, 发现展示的是3字节</span></span><br><span class="line">[roc@roclinux ruanjian]$ ls -l myword</span><br><span class="line">-rw-rw-r-- 1 roc roc 3 2月  18 15:53 myword</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用du来查看大小, 发现竟然展示的是4KB</span></span><br><span class="line">[roc@roclinux ruanjian]$ du myword</span><br><span class="line">4       myword</span><br><span class="line"></span><br><span class="line">文件 myword 中只有三个字符，两个可见字符（ab）和一个控制字符（$），因此，这个文件的内容大小就是 3bytes，但是限于 Linux 文件系统的限制，它需要占用一个数据块来存储这个文件，因此这个文件实际占用的磁盘空间就是 4KB 了。</span><br><span class="line"></span><br><span class="line">这种情况使得 du 往往会比 ls 展示的文件大小要大一些。但是，还存在一种情况，那就是 du 展示的数值比 ls 展示的数值要小，这种现象，你知道原因么？</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>unix时间戳<br><a href="https://www.jianshu.com/p/8ff0ec67e34b">https://www.jianshu.com/p/8ff0ec67e34b</a><br><a href="https://cloud.tencent.com/developer/article/1021486?from=15425">https://cloud.tencent.com/developer/article/1021486?from=15425</a></li>
</ul>
<ul>
<li><p>查看内存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># free -m</span></span><br><span class="line">                  total       used    free   shared   buffers    cached</span><br><span class="line">Mem:           725        666      59           0       132         287</span><br><span class="line">-/+ buffers/cache:     245     479</span><br><span class="line">Swap:           996            0     996</span><br><span class="line"></span><br><span class="line">第一行显示的是各个列的列表头信息，各自的含义如下所示：</span><br><span class="line">total 是总内存数；</span><br><span class="line">used 是已经使用的内存数；</span><br><span class="line">free 是空闲的内存数；</span><br><span class="line">shared 是多个进程共享的内存总数；</span><br><span class="line">buffers 是缓冲内存数；</span><br><span class="line">cached 是缓存内存数。</span><br><span class="line"></span><br><span class="line">Mem 一行指的是内存的使用情况；-/buffers/cache 的内存数，相当于第一行的 used-buffers-cached。+/buffers/cache 的内存数，相当于第一行的 free+buffers+cached；Swap 一行指的就是 swap 分区的使用情况。</span><br><span class="line"></span><br><span class="line">可以看到，系统的物理内存为 725 MB，已经使用了 666 MB，空闲 59 MB。而 swap 分区总大小为 996 MB，目前尚未使用。</span><br><span class="line">关注微信公众号「站长严长生」，在手机上阅读所有教程，随时随地都能学习。本公众号由C语言中文网站长运营，每日更新，坚持原创，敢说真话，凡事有态度。</span><br></pre></td></tr></table></figure></li>
<li><p>查看磁盘剩余空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df</span><br><span class="line">df 以磁盘分区为单位查看文件系统，可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</span><br><span class="line"></span><br><span class="line">例如，我们使用df -h命令来查看磁盘信息， -h 选项为根据大小适当显示：</span><br><span class="line"></span><br><span class="line">显示内容参数说明：</span><br><span class="line"></span><br><span class="line">Filesystem：文件系统</span><br><span class="line">Size： 分区大小</span><br><span class="line">Used： 已使用容量</span><br><span class="line">Avail： 还可以使用的容量</span><br><span class="line">Use%： 已用百分比</span><br><span class="line">Mounted on： 挂载点　</span><br><span class="line">相关命令：</span><br><span class="line"></span><br><span class="line">df -hl：查看磁盘剩余空间</span><br><span class="line">df -h：查看每个根路径的分区大小</span><br><span class="line">du -sh [目录名]：返回该目录的大小</span><br><span class="line">du -sm [文件夹]：返回该文件夹总M数</span><br><span class="line">du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹）</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><a href="https://cloud.tencent.com/developer/article/1404921">解压缩文件</a><ul>
<li><a href="https://www.cnblogs.com/TheGCC/p/14228439.html">打包、压缩</a></li>
</ul>
</li>
</ul>
<ul>
<li><p><code>od -c 文件</code></p>
<ul>
<li><code>od</code> 观察文件实际内容</li>
<li><code>-c</code>以字符方式打印文件内容</li>
</ul>
</li>
<li><p><code>ln -s</code></p>
<ul>
<li><code>ln -s a b</code>：为a创建一个软连接b</li>
<li>创建软链接，又称<code>(symbolic link)</code>符号链接。建议采用绝对路径。</li>
<li><code>shc@shc-virtual-machine:~/code/revier$ ln -s test02.txt ./symbolic_link_test02</code></li>
</ul>
</li>
<li><p><code>ln</code> </p>
<ul>
<li>创建硬链接。</li>
<li><code>shc@shc-virtual-machine:~/code/revier$ ln test01.txt ./test01_hard</code></li>
</ul>
</li>
<li><p>sysctl</p>
<ul>
<li><a href="https://ipcmen.com/sysctl">https://ipcmen.com/sysctl</a></li>
</ul>
</li>
<li><p>manpage</p>
<ul>
<li><img src="/2021/11/05/Linux%E5%91%BD%E4%BB%A4%E5%B8%B8%E8%AF%86/2021-12-16-21-51-05.png"></li>
</ul>
</li>
<li><p>Byte b Mbps</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B：Byte</span><br><span class="line">b：bit</span><br><span class="line">1GB = 1024 MB ; 1MB = 1024 KB = 1024 * 1024 B = 1024 * 1024 * 8 b</span><br><span class="line"></span><br><span class="line">Mbps：Million bits per second；</span><br><span class="line">Mbps=Mbit/s 即兆比特每秒</span><br><span class="line">b：bit而非Byte</span><br><span class="line">1 Mbps = 1024 Kbps = 1024 * 1024 bps</span><br><span class="line">= 128 KBps = 128 KB/s</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>setUID </li>
<li><a href="https://blog.csdn.net/wxbmelisky/article/details/51649343">https://blog.csdn.net/wxbmelisky/article/details/51649343</a></li>
<li><a href="https://www.cnblogs.com/bwangel23/p/4225818.html">https://www.cnblogs.com/bwangel23/p/4225818.html</a><br><img src="/2021/11/05/Linux%E5%91%BD%E4%BB%A4%E5%B8%B8%E8%AF%86/2021-11-24-08-45-45.png"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:/$ ll /etc/shadow</span><br><span class="line">-rw-r----- 1 root shadow 1366 11月  2 18:56 /etc/shadow</span><br><span class="line">shc@shc-virtual-machine:/$ ll /usr/bin/passwd </span><br><span class="line">-rwsr-xr-x 1 root root 59640 3月  23  2019 /usr/bin/passwd*</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>文件夹大小 4096<br><a href="https://www.jianshu.com/p/6bf9d715ce2f">https://www.jianshu.com/p/6bf9d715ce2f</a></li>
</ul>
<hr>
<ul>
<li>进程状态 stat列<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">状态	定义</span><br><span class="line">R	Running.运行中</span><br><span class="line">S	Interruptible Sleep.等待调用</span><br><span class="line">D	Uninterruptible Sleep.等待磁盘IO</span><br><span class="line">T	Stoped.暂停或者跟踪状态</span><br><span class="line">X	Dead.即将被撤销</span><br><span class="line">Z	Zombie.进程已经结束，仅映像名留存，所谓的僵尸进程</span><br><span class="line">W	Paging.内存交换</span><br><span class="line">N	优先级低的进程</span><br><span class="line">&lt;	优先级高的进程</span><br><span class="line">s	进程的领导者</span><br><span class="line">L	锁定状态</span><br><span class="line">l	多线程状态</span><br><span class="line">+	前台进程</span><br><span class="line">而我们最常见的三种状态就是R，S，D。ps命令支持三种使用的语法格式：</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="http://blog.chinaunix.net/uid-20548989-id-2533161.html">struct timeval结构体以及gettimeofday函数</a></p>
<hr>
<ul>
<li>动态库常识<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux下生成和使用动态库的步骤如下：</span><br><span class="line"></span><br><span class="line">1,编写源文件。</span><br><span class="line">2,将一个或几个源文件编译链接，生成共享库。</span><br><span class="line">3,通过 -L&lt;path&gt; -lxxx 的gcc选项链接生成的libxxx.so。</span><br><span class="line">4,把libxxx.so放入链接库的标准路径，或指定 LD_LIBRARY_PATH，才能运行链接了libxxx.so的程序。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">一， 生成动态库</span><br><span class="line"></span><br><span class="line">1）test.c文件</span><br><span class="line"></span><br><span class="line">#include &quot;test.h&quot;</span><br><span class="line"> </span><br><span class="line">void itoa(int *num)</span><br><span class="line">&#123;</span><br><span class="line">    if(*num&gt;=65&amp;&amp;*num&lt;=88)</span><br><span class="line">    &#123;</span><br><span class="line">        *num=*num - 65+&#x27;a&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2）头文件</span><br><span class="line"></span><br><span class="line">#ifndef __ITOA_H_</span><br><span class="line">#define __ITOA_H_</span><br><span class="line"> </span><br><span class="line">extern void itoa(int *); </span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">二，编译生成动态库</span><br><span class="line"></span><br><span class="line">gcc test.c  -fPIC -shared -o libtest.so</span><br><span class="line"></span><br><span class="line">-o 参数指定生成libtest.so ;此为动态库，Linux下格式为libxxx.so ；xxx 是后面你要调用的库名</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">三，使用动态库</span><br><span class="line"></span><br><span class="line">1）自己写个测试main.c  用来测试库中的函数</span><br><span class="line"> </span><br><span class="line">2）使用gcc main.c -L. -ltest 生成a.out</span><br><span class="line"></span><br><span class="line">-L. ：-L参数是指定库的位置，注意此处有个&#x27;.&#x27; 表示当前路径</span><br><span class="line"></span><br><span class="line">-l ：其中-ltest表示要链接libtest.so   </span><br><span class="line"></span><br><span class="line">四，运行</span><br><span class="line"></span><br><span class="line">1）运行 ./a.out 会得到以下的错误提示。</span><br><span class="line"></span><br><span class="line">./a.out: error while loading shared libraries: libtest.so: cannot open shared object file: No such file or directory</span><br><span class="line"></span><br><span class="line">提示：找不到libtest.so。</span><br><span class="line"></span><br><span class="line">2）找不到库的原因</span><br><span class="line"></span><br><span class="line">Linux是通过 /etc/ld.so.cache 文件搜寻要链接的动态库的。</span><br><span class="line"></span><br><span class="line">而 /etc/ld.so.cache 是 ldconfig 程序读取 /etc/ld.so.conf 文件生成的。</span><br><span class="line">（注意， /etc/ld.so.conf 中并不必包含 /lib 和 /usr/lib，ldconfig程序会自动搜索这两个目录）</span><br><span class="line"></span><br><span class="line">所以把 libtest.so 所在的路径添加到 /etc/ld.so.conf 中</span><br><span class="line"></span><br><span class="line">再以root权限运行 ldconfig 程序更新ld.so.cache</span><br><span class="line"></span><br><span class="line">a.out运行时，就可以找到 libtest.so。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3）使用临时解决的方法</span><br><span class="line"></span><br><span class="line">但作为一个简单的测试例子，让我们改动系统的东西，似乎不太合适。</span><br><span class="line"></span><br><span class="line">还有另一种简单的方法，就是为a.out指定 LD_LIBRARY_PATH。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">LD_LIBRARY_PATH=../a.out    或者  export LD_LIBRARY_PATH=.  再执行./a.out</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">程序就能正常运行了。LD_LIBRARY_PATH=. 是告诉 a.out，先在当前路径寻找链接的动态库。</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「___Eirc」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/u013625451/article/details/78856127</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>文件类型<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux文件类型说明</span><br><span class="line">文件类型	说明</span><br><span class="line">b	块设备，是一些提供系统存取数据的接口设备，例如硬盘。</span><br><span class="line">c	字符设备，是一些串行端口的接口设备，例如键盘、鼠标、打印机、tty终端。</span><br><span class="line">d	目录，类似于Windows的文件夹。</span><br><span class="line">l	链接文件，类似于Windows的快捷方式。</span><br><span class="line">s	套接字文件（socket），用于进程之间的通信。</span><br><span class="line">-	文件，分纯文本文件（ASCII）和二进制文件（binary）。</span><br><span class="line">命令	说明</span><br><span class="line">file filename	查看文件类型</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「逍遥X」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/renfeigui0/article/details/99478291</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>netstat</li>
</ul>
<p>Netstat 简介<br>Netstat 是一款命令行工具，可用于列出系统上所有的网络套接字连接情况，包括 tcp, udp 以及 unix 套接字，另外它还能列出处于监听状态（即等待接入请求）的套接字。如果你想确认系统上的 Web 服务有没有起来，你可以查看80端口有没有打开。以上功能使 netstat 成为网管和系统管理员的必备利器。在这篇教程中，我会列出几个例子，教大家如何使用 netstat 去查找网络连接信息和系统开启的端口号。</p>
<p>以下的简单介绍来自 netstat 的 man 手册：</p>
<p>netstat - 打印网络连接、路由表、连接的数据统计、伪装连接以及广播域成员。</p>
<ol>
<li>列出所有连接<br>第一个要介绍的，是最简单的命令：列出所有当前的连接。使用 -a 选项即可。</li>
</ol>
<p>$ netstat -a</p>
<p>Active Internet connections (servers and established)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br>tcp        0      0 enlightened:domain      <em>:</em>                     LISTEN<br>tcp        0      0 localhost:ipp           <em>:</em>                     LISTEN<br>tcp        0      0 enlightened.local:54750 li240-5.members.li:http ESTABLISHED<br>tcp        0      0 enlightened.local:49980 del01s07-in-f14.1:https ESTABLISHED<br>tcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN<br>udp        0      0 enlightened:domain      <em>:</em><br>udp        0      0 <em>:bootpc                <em>:</em><br>udp        0      0 enlightened.local:ntp   <em>:</em><br>udp        0      0 localhost:ntp           <em>:</em><br>udp        0      0 <em>:ntp                   <em>:</em><br>udp        0      0 <em>:58570                 <em>:</em><br>udp        0      0 <em>:mdns                  <em>:</em><br>udp        0      0 <em>:49459                 <em>:</em><br>udp6       0      0 fe80::216:36ff:fef8:ntp [::]:</em><br>udp6       0      0 ip6-localhost:ntp       [::]:</em><br>udp6       0      0 [::]:ntp                [::]:</em><br>udp6       0      0 [::]:mdns               [::]:</em><br>udp6       0      0 [::]:63811              [::]:</em><br>udp6       0      0 [::]:54952              [::]:*<br>Active UNIX domain sockets (servers and established)<br>Proto RefCnt Flags       Type       State         I-Node   Path<br>unix  2      [ ACC ]     STREAM     LISTENING     12403    @/tmp/dbus-IDgfj3UGXX<br>unix  2      [ ACC ]     STREAM     LISTENING     40202    @/dbus-vfs-daemon/socket-6nUC6CCx<br>上述命令列出 tcp, udp 和 unix 协议下所有套接字的所有连接。然而这些信息还不够详细，管理员往往需要查看某个协议或端口的具体连接情况。</p>
<ol start="2">
<li>只列出 TCP 或 UDP 协议的连接<br>使用 -t 选项列出 TCP 协议的连接：</li>
</ol>
<p>$ netstat -at<br>Active Internet connections (servers and established)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br>tcp        0      0 enlightened:domain      <em>:</em>                     LISTEN<br>tcp        0      0 localhost:ipp           <em>:</em>                     LISTEN<br>tcp        0      0 enlightened.local:36310 del01s07-in-f24.1:https ESTABLISHED<br>tcp        0      0 enlightened.local:45038 a96-17-181-10.depl:http ESTABLISHED<br>tcp        0      0 enlightened.local:37892 ABTS-North-Static-:http ESTABLISHED<br>…..<br>使用 -u 选项列出 UDP 协议的连接：</p>
<p>$ netstat -au<br>Active Internet connections (servers and established)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br>udp        0      0 <em>:34660                 <em>:</em><br>udp        0      0 enlightened:domain      <em>:</em><br>udp        0      0 <em>:bootpc                <em>:</em><br>udp        0      0 enlightened.local:ntp   <em>:</em><br>udp        0      0 localhost:ntp           <em>:</em><br>udp        0      0 <em>:ntp                   <em>:</em><br>udp6       0      0 fe80::216:36ff:fef8:ntp [::]:</em><br>udp6       0      0 ip6-localhost:ntp       [::]:</em><br>udp6       0      0 [::]:ntp                [::]:</em><br>上面同时显示了 IPv4 和 IPv6 的连接。</p>
<ol start="3">
<li>禁用反向域名解析，加快查询速度<br>默认情况下 netstat 会通过反向域名解析技术查找每个 IP 地址对应的主机名。这会降低查找速度。如果你觉得 IP 地址已经足够，而没有必要知道主机名，就使用 -n 选项禁用域名解析功能。</li>
</ol>
<p>$ netstat -ant<br>Active Internet connections (servers and established)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br>tcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN<br>tcp        0      0 192.168.1.2:49058       173.255.230.5:80        ESTABLISHED<br>tcp        0      0 192.168.1.2:33324       173.194.36.117:443      ESTABLISHED<br>tcp6       0      0 ::1:631                 :::*                    LISTEN<br>上述命令列出所有 TCP 协议的连接，没有使用域名解析技术。So easy ? 非常好。</p>
<ol start="4">
<li>只列出监听中的连接<br>任何网络服务的后台进程都会打开一个端口，用于监听接入的请求。这些正在监听的套接字也和连接的套接字一样，也能被 netstat 列出来。使用 -l 选项列出正在监听的套接字。</li>
</ol>
<p>$ netstat -tnl<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br>tcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN<br>tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN<br>tcp6       0      0 ::1:631                 :::*                    LISTEN<br>现在我们可以看到处于监听状态的 TCP 端口和连接。如果你查看所有监听端口，去掉 -t 选项。如果你只想查看 UDP 端口，使用 -u 选项，代替 -t 选项。</p>
<p>注意：不要使用 -a 选项，否则 netstat 会列出所有连接，而不仅仅是监听端口。</p>
<ol start="5">
<li>获取进程名、进程号以及用户 ID<br>查看端口和连接的信息时，能查看到它们对应的进程名和进程号对系统管理员来说是非常有帮助的。举个栗子，Apache 的 httpd 服务开启80端口，如果你要查看 http 服务是否已经启动，或者 http 服务是由 apache 还是 nginx 启动的，这时候你可以看看进程名。</li>
</ol>
<p>使用 -p 选项查看进程信息。</p>
<p>~$ sudo netstat -nlpt<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name<br>tcp        0      0 127.0.1.1:53            0.0.0.0:*               LISTEN      1144/dnsmasq<br>tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      661/cupsd<br>tcp6       0      0 ::1:631                 :::*                    LISTEN      661/cupsd<br>使用 -p 选项时，netstat 必须运行在 root 权限之下，不然它就不能得到运行在 root 权限下的进程名，而很多服务包括 http 和 ftp 都运行在 root 权限之下。</p>
<p>相比进程名和进程号而言，查看进程的拥有者会更有用。使用 -ep 选项可以同时查看进程名和用户名。</p>
<p>$ sudo netstat -ltpe<br>Active Internet connections (only servers)<br>Proto Recv-Q Send-Q Local Address           Foreign Address         State       User       Inode       PID/Program name<br>tcp        0      0 enlightened:domain      <em>:</em>                     LISTEN      root       11090       1144/dnsmasq<br>tcp        0      0 localhost:ipp           <em>:</em>                     LISTEN      root       9755        661/cupsd<br>tcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN      root       9754        661/cupsd<br>上面列出 TCP 协议下的监听套接字，同时显示进程信息和一些额外信息。</p>
<p>这些额外的信息包括用户名和进程的索引节点号。这个命令对网管来说很有用。</p>
<p>注意 - 假如你将 -n 和 -e 选项一起使用，User 列的属性就是用户的 ID 号，而不是用户名。</p>
<ol start="6">
<li>打印统计数据<br>netstat 可以打印出网络统计数据，包括某个协议下的收发包数量。</li>
</ol>
<p>下面列出所有网络包的统计情况：</p>
<p>$ netstat -s<br>Ip:<br>    32797 total packets received<br>    0 forwarded<br>    0 incoming packets discarded<br>    32795 incoming packets delivered<br>    29115 requests sent out<br>    60 outgoing packets dropped<br>Icmp:<br>    125 ICMP messages received<br>    0 input ICMP message failed.<br>    ICMP input histogram:<br>        destination unreachable: 125<br>    125 ICMP messages sent<br>    0 ICMP messages failed<br>    ICMP output histogram:<br>        destination unreachable: 125<br>… OUTPUT TRUNCATED …<br>如果想只打印出 TCP 或 UDP 协议的统计数据，只要加上对应的选项（-t 和 -u）即可，so easy。</p>
<ol start="7">
<li>显示内核路由信息<br>使用 -r 选项打印内核路由信息。打印出来的信息与 route 命令输出的信息一样。我们也可以使用 -n 选项禁止域名解析。</li>
</ol>
<p>$ netstat -rn<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface<br>0.0.0.0         192.168.1.1     0.0.0.0         UG        0 0          0 eth0<br>192.168.1.0     0.0.0.0         255.255.255.0   U         0 0          0 eth0<br>8. 打印网络接口<br>netstat 也能打印网络接口信息，-i 选项就是为这个功能而生。</p>
<p>$ netstat -i<br>Kernel Interface table<br>Iface   MTU Met   RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg<br>eth0       1500 0     31611      0      0 0         27503      0      0      0 BMRU<br>lo        65536 0      2913      0      0 0          2913      0      0      0 LRU<br>上面输出的信息比较原始。我们将 -e 选项和 -i 选项搭配使用，可以输出用户友好的信息。</p>
<p>$ netstat -ie<br>Kernel Interface table<br>eth0      Link encap:Ethernet  HWaddr 00:16:36:f8:b2:64<br>          inet addr:192.168.1.2  Bcast:192.168.1.255  Mask:255.255.255.0<br>          inet6 addr: fe80::216:36ff:fef8:b264/64 Scope:Link<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:31682 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:27573 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000<br>          RX bytes:29637117 (29.6 MB)  TX bytes:4590583 (4.5 MB)<br>          Interrupt:18 Memory:da000000-da020000 </p>
<p>lo        Link encap:Local Loopback<br>          inet addr:127.0.0.1  Mask:255.0.0.0<br>          inet6 addr: ::1/128 Scope:Host<br>          UP LOOPBACK RUNNING  MTU:65536  Metric:1<br>          RX packets:2921 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:2921 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:0<br>          RX bytes:305297 (305.2 KB)  TX bytes:305297 (305.2 KB)<br>上面的输出信息与 ifconfig 输出的信息一样。</p>
<ol start="9">
<li>netstat 持续输出<br>我们可以使用 netstat 的 -c 选项持续输出信息。</li>
</ol>
<p>$ netstat -ct<br>这个命令可持续输出 TCP 协议信息。</p>
<ol start="10">
<li>显示多播组信息<br>选项 -g 会输出 IPv4 和 IPv6 的多播组信息。</li>
</ol>
<p>$ netstat -g<br>IPv6/IPv4 Group Memberships<br>Interface       RefCnt Group</p>
<hr>
<p>lo              1      all-systems.mcast.net<br>eth0            1      224.0.0.251<br>eth0            1      all-systems.mcast.net<br>lo              1      ip6-allnodes<br>lo              1      ff01::1<br>eth0            1      ff02::fb<br>eth0            1      ff02::1:fff8:b264<br>eth0            1      ip6-allnodes<br>eth0            1      ff01::1<br>wlan0           1      ip6-allnodes<br>wlan0           1      ff01::1<br>更多用法<br>目前为止我们列出了 netstat 的基本用法，现在让我们一起来 geek 吧～</p>
<p>打印 active 状态的连接<br>active 状态的套接字连接用 “ESTABLISHED” 字段表示，所以我们可以使用 grep 命令获得 active 状态的连接：</p>
<p>$ netstat -atnp | grep ESTA<br>(Not all processes could be identified, non-owned process info<br> will not be shown, you would have to be root to see it all.)<br>tcp        0      0 192.168.1.2:49156       173.255.230.5:80        ESTABLISHED 1691/chrome<br>tcp        0      0 192.168.1.2:33324       173.194.36.117:443      ESTABLISHED 1691/chrome<br>配合 watch 命令监视 active 状态的连接：</p>
<p>$ watch -d -n0 “netstat -atnp | grep ESTA”<br>查看服务是否在运行<br>如果你想看看 http,smtp 或 ntp 服务是否在运行，使用 grep。</p>
<p>$ sudo netstat -aple | grep ntp<br>udp        0      0 enlightened.local:ntp   <em>:</em>                                 root       17430       1789/ntpd<br>udp        0      0 localhost:ntp           <em>:</em>                                 root       17429       1789/ntpd<br>udp        0      0 <em>:ntp                   <em>:</em>                                 root       17422       1789/ntpd<br>udp6       0      0 fe80::216:36ff:fef8:ntp [::]:</em>                              root       17432       1789/ntpd<br>udp6       0      0 ip6-localhost:ntp       [::]:*                              root       17431       1789/ntpd<br>udp6       0      0 [::]:ntp                [::]:*                              root       17423       1789/ntpd<br>unix  2      [ ]         DGRAM                    17418    1789/ntpd<br>从这里可以看到 ntp 服务正在运行。使用 grep 命令你可以查看 http 或 smtp 或其它任何你想查看的服务。</p>
<p>好了，netstat 的大部分功能都介绍过了，如果你想知道 netstat 更高级的功能，阅读它的手册吧（man netstat）。</p>
<p>欢迎在下面留下你的反馈和建议。</p>
<p><a href="https://linux.cn/article-2434-1.html">https://linux.cn/article-2434-1.html</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">激活Internet连接 (服务器和已建立连接的)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 localhost:domain        0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 localhost:ipp           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     </span><br><span class="line">udp        0      0 0.0.0.0:mdns            0.0.0.0:*                          </span><br><span class="line">udp        0      0 localhost:domain        0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:bootpc          0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:ipp             0.0.0.0:*                          </span><br><span class="line">udp        0      0 0.0.0.0:60427           0.0.0.0:*                          </span><br><span class="line">udp6       0      0 [::]:mdns               [::]:*                             </span><br><span class="line">udp6       0      0 [::]:42160              [::]:*                             </span><br><span class="line">raw6       0      0 [::]:ipv6-icmp          [::]:*                  7          </span><br><span class="line">活跃的UNIX域套接字 (服务器和已建立连接的)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node   路径</span><br><span class="line">unix  2      [ ACC ]     流        LISTENING     53732    @/tmp/.ICE-unix/1652</span><br><span class="line">unix  2      [ ]         数据报                52832    /run/user/1000/systemd/notify</span><br><span class="line">unix  2      [ ]         数据报                46115    /run/user/121/systemd/notify</span><br><span class="line">unix  2      [ ACC ]     SEQPACKET  LISTENING     25942    /run/udev/control</span><br><span class="line">unix  2      [ ACC ]     流        LISTENING     55388    @/tmp/dbus-Y8PWhluE</span><br><span class="line">unix  2      [ ACC ]     流        LISTENING     52835    /run/user/1000/systemd/private</span><br><span class="line">unix  2      [ ACC ]     流        LISTENING     46118    /run/user/121/systemd/priva</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~$ netstat -t</span><br><span class="line">激活Internet连接 (w/o 服务器)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">shc@shc-virtual-machine:~$ netstat -at</span><br><span class="line">激活Internet连接 (服务器和已建立连接的)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 localhost:domain        0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 localhost:ipp           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 ip6-localhost:ipp       [::]:*                  LISTEN     </span><br><span class="line">shc@shc-virtual-machine:~$ netstat -atn</span><br><span class="line">激活Internet连接 (服务器和已建立连接的)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN     </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li><a href="https://www.jianshu.com/p/943b90150c10">Linux ps命令</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux-ps命令学习</span><br><span class="line"></span><br><span class="line">骑着乌龟去看海</span><br><span class="line">0.73</span><br><span class="line">2018.05.27 21:00:19</span><br><span class="line">字数 2,117</span><br><span class="line">阅读 9,216</span><br><span class="line">由于ps命令涉及的内容比较多一些，这里单独使用一篇文章来介绍使用。使用的系统是：CentOS 7.4.17.08。</span><br><span class="line"></span><br><span class="line">  ps命令是Process Status的缩写，用来列出系统中当前运行的进程。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。ps命令所列出的进行是当前进程的快照，也就是并不是动态的，而是执行该命令时那一时刻进行的状态。而经常和ps一起结合使用的杀死进程的是kill命令。</span><br><span class="line">  在我们的学习中我们知道，Linux的进程状态一般分为几种：</span><br><span class="line"></span><br><span class="line">R(TASK_RUNNING，可执行状态)，这个进程是可运行的——要么它正在运行，要么在运行队列中等待运行；</span><br><span class="line">S(TASK_INTERRUPTIBLE，中断状态)，这个状态的进程因为等待某事件的发生（比如等待socket连接、等待信号量等）而被挂起，然后当这些事件发生或完成后，对应的等待队列中的一个或多个进程将被唤醒。</span><br><span class="line">D(TASK_UNINTERRUPTIBLE，不可中断状态)，在进程接收到信号时，不会被唤醒变成可运行的。除了这一点，该状态和TASK_INTERRUPTIBLE其他部分完全一样，这个状态通常用于进程必须不间断等待或者事件发生的频率很快，并且无法用kill命令关闭处于TASK_UNINTERRUPTIBLE状态的进程。</span><br><span class="line">T(TASK_STOPPED或TASK_TRACED，暂停状态或跟踪状态)，该状态表示该进程已经停止执行，并且不具有再次执行的条件。向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。而当进程正在被跟踪时，它处于TASK_TRACED状态。</span><br><span class="line">Z(TASK_DEAD或EXIT_ZOMBIE，退出状态)，进程在退出的过程中，处于TASK_DEAD状态，如果它的父进程没有收到SIGCHLD信号，故未调用wait（如wait4、waitid）处理函数等待子进程结束，又没有显式忽略该信号，它就一直保持EXIT_ZOMBIE状态。只要父进程不退出，这个EXIT_ZOMBIE状态的子进程就一直存在，这也就是所谓的&quot;僵尸&quot;进程。</span><br><span class="line">X(TASK_DEAD - EXIT_DEAD，退出状态)，进程即将被销毁。EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。</span><br><span class="line">而PS对应上的状态码大致如下：</span><br><span class="line"></span><br><span class="line">状态	定义</span><br><span class="line">R	Running.运行中</span><br><span class="line">S	Interruptible Sleep.等待调用</span><br><span class="line">D	Uninterruptible Sleep.等待磁盘IO</span><br><span class="line">T	Stoped.暂停或者跟踪状态</span><br><span class="line">X	Dead.即将被撤销</span><br><span class="line">Z	Zombie.进程已经结束，仅映像名留存，所谓的僵尸进程</span><br><span class="line">W	Paging.内存交换</span><br><span class="line">N	优先级低的进程</span><br><span class="line">&lt;	优先级高的进程</span><br><span class="line">s	进程的领导者</span><br><span class="line">L	锁定状态</span><br><span class="line">l	多线程状态</span><br><span class="line">+	前台进程</span><br><span class="line">而我们最常见的三种状态就是R，S，D。ps命令支持三种使用的语法格式：</span><br><span class="line"></span><br><span class="line">UNIX 风格，选项可以组合在一起，并且选项前必须有“-”连字符；</span><br><span class="line">BSD 风格，选项可以组合在一起，但是选项前不能有“-”连字符；</span><br><span class="line">GNU 风格的选项，选项前有两个“-”连字符；</span><br><span class="line">接下来我们来看一下PS命令常用的参数：</span><br><span class="line"></span><br><span class="line">ps -a  显示所有终端下执行的进程，包含其他用户的进程</span><br><span class="line">ps -A  显示所有进程</span><br><span class="line">ps -e  和-A功能一样</span><br><span class="line">ps -H  显示树状结构，表示程序间的相互关系</span><br><span class="line">ps -f  全格式显示进程</span><br><span class="line"></span><br><span class="line">ps a   显示当前终端下执行的进程</span><br><span class="line">ps c   显示进程的真实名称</span><br><span class="line">ps e   列出程序所使用的环境变量</span><br><span class="line">ps f   用ASCII字符显示树状结构，表达程序间的相互关系</span><br><span class="line">ps x   显示所有进程，无论是否运行在终端上</span><br><span class="line">ps u   显示用户相关的进程或者与用户相关的属性</span><br><span class="line">ps r   只显示正在运行的进程</span><br><span class="line">这里，我们只简单列出了几个常用的命令，由于ps作为一个最古老的展示线程相关的命令，所拥有的参数特别多，并且加不加-也有很大的区别，所以接下来我们结合工作中常用的命令来学习它的参数。而我们也可以通过man ps来学习ps所有的命令：</span><br><span class="line"></span><br><span class="line">不加参数执行ps命令：展示当前终端中运行的进程情况，很少使用。</span><br><span class="line">[mrzhang@192 ~]$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 2648 pts/0    00:00:01 bash</span><br><span class="line"> 8669 pts/0    00:00:00 ps</span><br><span class="line">默认展示了4列信息：</span><br><span class="line"></span><br><span class="line">PID: 运行着的命令(CMD)的进程编号</span><br><span class="line">TTY: 命令所运行的位置（终端）</span><br><span class="line">TIME: 运行着的该命令所占用的CPU处理时间</span><br><span class="line">CMD: 该进程所运行的命令</span><br><span class="line">显示所有当前的进程：使用 -a 参数，-a 代表 all。同时加上x参数会显示没有控制终端的进程，x参数表示显示所有进程，无论是否运行在终端上。</span><br><span class="line">[mrzhang@192 ~]$ ps -ax</span><br><span class="line">该命令返回的结果会很长，为了方便查看，我们可以结合less命令和管道来使用：</span><br><span class="line"></span><br><span class="line">[mrzhang@192 ~]$ ps -ax | less</span><br><span class="line">根据用户过滤进程：在需要查看特定用户进程的情况下，我们可以使用 -u 参数。比如我们要查询某个用户下的进程：</span><br><span class="line">[mrzhang@192 ~]$ ps -u zhang</span><br><span class="line">通过CPU和内存使用来过滤进程：也许你想看下当前时间点那个进程占用的资源最多，这种情况下，我们可以通过使用-aux命令来显示全面的信息：</span><br><span class="line">[mrzhang@192 ~]$ ps -aux | less</span><br><span class="line">默认的结果是没有排序的，这时候可以通过--sort参数来排序：</span><br><span class="line"></span><br><span class="line">[mrzhang@192 ~]$ ps -aux --sort -%cpu | less</span><br><span class="line"></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">mrzhang   2011  3.6  3.1 2368492 121944 ?      Sl   21:01   0:12 /usr/bin/gnome-shell</span><br><span class="line">mrzhang   2572  3.2  5.5 2146148 211300 ?      Sl   21:02   0:09 /usr/lib64/firefox/firefox</span><br><span class="line">root      1519  1.2  1.1 286208 45584 tty1     Ssl+ 21:01   0:04 /usr/bin/X :0 -background none -noreset -audit 4 </span><br><span class="line">看一下返回的几列信息：</span><br><span class="line"></span><br><span class="line">USER，用户名称；</span><br><span class="line">PID，进程号；</span><br><span class="line">%CPU，该进程所占用CPU百分比；</span><br><span class="line">%MEM，该进程所占用内存百分比；</span><br><span class="line">VSZ，进程所占用的虚拟内存大小；</span><br><span class="line">RSS，进程所占用的实际内存大小；</span><br><span class="line">TTY，该进程运行在哪个终端上面，若与终端无关，则显示 ?；</span><br><span class="line">STAT，进程状态；</span><br><span class="line">START，进程启动时间；</span><br><span class="line">TIME，进程实际占用CPU的时间；</span><br><span class="line">COMMAND，该进程对应的执行程序；</span><br><span class="line">  ps命令的排序格式是：--sort=[+|-] key，key表示某一列的名称，+表示升序排序，而-表示降序排序，比如按CPU降序排列：ps aux --sort=-%cpu，按照内存来进行降序排序：$ ps -aux --sort -%mem | less，我们还可以借助管道只显示前5条记录结果，也就是内存占有率最高的前5个进程：</span><br><span class="line"></span><br><span class="line">[mrzhang@192 ~]$ ps -aux --sort %mem | head -n 5</span><br><span class="line">而ps排序的方式还有另一种：ps+sort，通过设置sort的参数来进行排序，例如：</span><br><span class="line"></span><br><span class="line">[mrzhang@192 ~]$ ps -eo rss,args |  sort -k 1 -r -n | less</span><br><span class="line">该方式的一些参数如下：</span><br><span class="line"></span><br><span class="line">-f  忽略大小写的差异，例如 A 与 a 视为编码相同；</span><br><span class="line">-b  忽略最前面的空格符部分；</span><br><span class="line">-M  以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</span><br><span class="line">-n  使用『纯数字』进行排序(默认是以文字型态来排序的)；</span><br><span class="line">-r  反向排序；</span><br><span class="line">-u  就是 uniq ，相同的数据中，仅出现一行代表；</span><br><span class="line">-t  分隔符，默认是用 [tab] 键来分隔；</span><br><span class="line">-k  以那个区间 (field) 来进行排序的意思</span><br><span class="line">这种方式就不多说了，感兴趣的可以参考：https://blog.csdn.net/lmy4710/article/details/8680763</span><br><span class="line"></span><br><span class="line">根据进程名和PID来过滤，通过使用-C参数，后面跟上进程名，比如像显示一个名称是getty的进程的信息，可以使用：</span><br><span class="line">[mrzhang@192 ~]$ ps -C bash</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 2686 pts/0    00:00:00 bash</span><br><span class="line">根据进程查看线程，如果我们像知道特定线程的进程，可以使用-L参数，后面加上对应的进程的PID：</span><br><span class="line">[mrzhang@192 ~]$ ps -L 2011</span><br><span class="line">  PID   LWP TTY      STAT   TIME COMMAND</span><br><span class="line"> 2011  2011 ?        Sl     0:25 /usr/bin/gnome-shell</span><br><span class="line"> 2011  2012 ?        Sl     0:00 /usr/bin/gnome-shell</span><br><span class="line"> 2011  2014 ?        Sl     0:00 /usr/bin/gnome-shell</span><br><span class="line"> 2011  2015 ?        Sl     0:00 /usr/bin/gnome-shell</span><br><span class="line"> 2011  2028 ?        Sl     0:00 /usr/bin/gnome-shell</span><br><span class="line"> 2011  2029 ?        Sl     0:00 /usr/bin/gnome-shell</span><br><span class="line">树形显示进程，可以通过参数f来实现：ps -axf，也可以使用pstree命令；</span><br><span class="line">[mrzhang@192 ~]$ ps -axf </span><br><span class="line"> 1773 ?        Sl     0:00  \_ gdm-session-worker [pam/gdm-password]</span><br><span class="line"> 1791 ?        Ssl    0:00      \_ /usr/libexec/gnome-session-binary --session g</span><br><span class="line"> 1965 ?        Ss     0:00          \_ /usr/bin/ssh-agent /bin/sh -c exec -l /bi</span><br><span class="line"> 2011 ?        Sl     0:29          \_ /usr/bin/gnome-shell</span><br><span class="line"> 2031 ?        Sl     0:00          |   \_ ibus-daemon --xim --panel disable</span><br><span class="line"> 2036 ?        Sl     0:00          |       \_ /usr/libexec/ibus-dconf</span><br><span class="line"> 2267 ?        Sl     0:00          |       \_ /usr/libexec/ibus-engine-simple</span><br><span class="line"> 2162 ?        Sl     0:03          \_ /usr/libexec/gnome-settings-daemon</span><br><span class="line">查看登入服务器的其他用户信息，可以使用：$ ps -eo pid,user,args，-e表示显示所有进程信息，o用于参数控制输出，pid,user,args是相应的用户的展示信息。</span><br><span class="line">使用ps命令来实时监控进程的状态，一般情况下ps命令的结果是静态的，也就是命令执行时的状态，不过我们可以通过watch命令和ps命令一起来实现。比如我们想通过CPU或者内存的使用率来筛选前10条进程，并且每1秒刷新一次：</span><br><span class="line">[mrzhang@192 ~]$ watch -n 1 &#x27;ps -aux --sort -%mem | head 10&#x27;</span><br><span class="line">Every 1.0s: ps -aux --sort -%mem | head -n 10</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">mrzhang   2011  3.6  3.1 2368492 121944 ?      Sl   21:01   0:12 /usr/bin/gnome-shell</span><br><span class="line">mrzhang   2572  3.2  5.5 2146148 211300 ?      Sl   21:02   0:09 /usr/lib64/firefox/firefox</span><br><span class="line">root      1519  1.2  1.1 286208 45584 tty1     Ssl+ 21:01   0:04 /usr/bin/X :0 -background none -noreset -audit 4 </span><br><span class="line">...省略</span><br><span class="line">这里，我们可以充分利用ps命令的一些参数，实现自定义显示我们所需要的一些字段等，比如我们只想查看某一个用户的信息：</span><br><span class="line"></span><br><span class="line">[mrzhang@192 ~]$ watch -n 1 &#x27;ps  -U mrzhang u --sort -%mem | head 10&#x27;</span><br><span class="line">Every 1.0s: ps  -U mrzhang u --sort -%mem | head -n 10</span><br><span class="line">...</span><br><span class="line">我们还可以配合grep查找命令来进行查找一些特定的线程，比如我们要根据我们的服务名来查找对应的进程：</span><br><span class="line">[mrzhang@192 ~]$ ps -aux | grep 服务名</span><br><span class="line">把进程显示出来，并打印到相应文件中：</span><br><span class="line">[mrzhang@192 ~]$ ps -aux &gt; ps001.txt</span><br><span class="line">备注</span><br><span class="line">  ps的命令十分强大，参数也十分多，这里我们只了解了一些常用的操作所涉及到的命令，其实还有许多命令，我们可以通过man ps来了解并学习。</span><br><span class="line"></span><br><span class="line">本文参考自：10个重要的Linux ps命令实战</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">56 篇文章22 订阅</span><br><span class="line">订阅专栏</span><br><span class="line">在linux下使用“ls -l”或者“ls -al”或者“ll”命令查看文件及目录详情时，shell中会显示出好几列的信息。平时也没怎么注意过，今天忽然心血来潮想了解一下，于是整理了这篇博客，以供参考：</span><br><span class="line"></span><br><span class="line">首先给出一张典型的显示结果：</span><br><span class="line"></span><br><span class="line">下面对其中的每一列进行详细的分析：</span><br><span class="line"></span><br><span class="line">一、文件类型</span><br><span class="line"></span><br><span class="line">表示该文件的类型：</span><br><span class="line"></span><br><span class="line">“-”表示普通文件；</span><br><span class="line">“d”表示目录；</span><br><span class="line">“l”表示链接文件；</span><br><span class="line">“p”表示管理文件；</span><br><span class="line">“b”表示块设备文件；</span><br><span class="line">“c”表示字符设备文件；</span><br><span class="line">“s”表示套接字文件；</span><br><span class="line">二、文件属性</span><br><span class="line"></span><br><span class="line">以back_init文件为例，其属性可分为三段：[rwx][rwx][r-x]，其中：</span><br><span class="line"></span><br><span class="line">第一段表示文件创建者/所有者对该文件所具有的权限，第二段表示创建者/所有者所在的组的其他用户所具有的权限，第三段表示其他组的其他用户所具有的权限。</span><br><span class="line"></span><br><span class="line">r（Read，读取权限）：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。</span><br><span class="line">w（Write，写入权限）：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</span><br><span class="line">x（eXecute，执行权限）：对文件而言，具有执行文件的权限；对目录来说，该用户具有进入目录的权限。</span><br><span class="line">另外，这里还有2个很特殊的属性，平时不怎么常见，这里也顺带解释一下：</span><br><span class="line"></span><br><span class="line">s或S（SUID,Set UID）：可执行的文件搭配这个权限，便能得到特权，任意存取该文件的所有者能使用的全部系统资源。请注意具备SUID权限的文件，黑客经常利用这种权限，以SUID配上root帐号拥有者，无声无息地在系统中开扇后门，供日后进出使用。</span><br><span class="line">t或T（Sticky）：/tmp和 /var/tmp目录供所有用户暂时存取文件，亦即每位用户皆拥有完整的权限进入该目录，去浏览、删除和移动文件。</span><br><span class="line">综合起来可得，对于back_init文件，其创建者/所有者具有可读可写可执行的权限，其创建者/所有者所在的组的其他用户具有可读可写可执行的权限，其他组的其他用户则具有可读可执行但不可写的权限。</span><br><span class="line"></span><br><span class="line">三、目录/链接个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于目录文件，表示它的第一级子目录的个数。注意此处看到的值要减2才等于该目录下的子目录的实际个数。</span><br><span class="line"></span><br><span class="line">比如这里的include目录下，其实是没有子目录的，所以应该是0，但是它这里却显示2，这是因为要加上.目录和..目录。在linux下，.目录表示当前目录，..目录表示上一级目录。</span><br><span class="line"></span><br><span class="line">这也可以解释上图中第一行的.目录下的3和第二行..目录下的26。因为当前目录下有一个include目录，所以加上.目录和..目录这2个目录就等于3，所以第一行会显示3。而上一级目录共有24个目录，加上上一级目录的.目录和..目录这2个目录，所以这里的第二行显示的是26。</span><br><span class="line"></span><br><span class="line">对于其他文件，表示指向它的链接文件的个数。</span><br><span class="line"></span><br><span class="line">四、所有者及组</span><br><span class="line"></span><br><span class="line">表示该文件的所有者/创建者（owner）及其所在的组（group）。</span><br><span class="line"></span><br><span class="line">五、文件大小</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果是文件，则表示该文件的大小，单位为字节。</span><br><span class="line">如果是目录，则表示该目录符所占的大小，并不表示该目录下所有文件的大小。</span><br><span class="line"></span><br><span class="line">六、修改日期</span><br><span class="line"></span><br><span class="line">该文件最后修改的日期时间。</span><br><span class="line"></span><br><span class="line">七、文件名称</span><br><span class="line"></span><br><span class="line">文件名，无需多说。</span><br><span class="line"></span><br><span class="line">八、字体颜色</span><br><span class="line"></span><br><span class="line">在大多数的linux shell窗口中，还能用颜色来区分不同文件的属性：</span><br><span class="line"></span><br><span class="line">灰白色表示普通文件；</span><br><span class="line">亮绿色表示可执行文件；</span><br><span class="line">亮红色表示压缩文件；</span><br><span class="line">灰蓝色表示目录；</span><br><span class="line">亮蓝色表示链接文件；</span><br><span class="line">亮黄色表示设备文件；</span><br><span class="line">当然，这里需要使用系统缺省的配色方案。如果你自定义了shell的配色方案，则有可能与上面的定义不一致。</span><br><span class="line"></span><br><span class="line">最后还要说明一点的是，可以看到上述的图片中，back_init文件的后面还带了一个星号（*），这也是linux系统下用于标记可执行文件的另外一种方式。也就是说，凡是文件名后面带了一个星号（*）的，都是在说明这是一个可执行文件。</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「leon1741」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/LEON1741/article/details/82386520</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：修改参数 启用 syncookies 防止SYN攻击</span><br><span class="line">echo 1 &gt; /proc/sys/net/ipv4&gt;tcp_syncookies</span><br><span class="line">“echo &gt;”和“echo &gt;&gt;”的区别</span><br><span class="line">&gt; 输出重定向</span><br><span class="line"></span><br><span class="line">&gt;&gt; 输出追加重定向</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">echo hello A</span><br><span class="line"></span><br><span class="line">将字符串hello A输出到屏幕</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">echo hello A &gt; tmp.txt</span><br><span class="line"></span><br><span class="line">将字符串输出重定向，当前目录没有tmp.txt，则创建tmp.txt，并将字符串输出到tmp.txt文件中</span><br><span class="line"></span><br><span class="line">tmp.txt内容：hello A</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">echo hello B &gt; tmp.txt</span><br><span class="line"></span><br><span class="line">将字符串输出重定向， 当前目录存在tmp.txt，则将tmp.txt内容替换成输出的字符串</span><br><span class="line"></span><br><span class="line">tmp.txt内容：hello B</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">echo hello C &gt;&gt; tmp.txt</span><br><span class="line"></span><br><span class="line">将字符串输出追加重定向，当前目录存在tmp.txt，则将tmp.txt的内容后面追加输出的字符串</span><br><span class="line"></span><br><span class="line">tmp.txt内容：hello B hello C</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-进程(1)</title>
    <url>/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>Linux进程</p>
<span id="more"></span>


<ul>
<li>参考 APUE，牛客讲义</li>
</ul>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ul>
<li>每个进程都会对应虚拟一个<strong>虚拟地址空间</strong><ul>
<li><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-11-45.png"></li>
</ul>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>程序<ul>
<li>编译好的二进制文件</li>
<li>死的，只占用磁盘空间</li>
</ul>
</li>
<li>进程<ul>
<li>活的，运行的程序，占用内存，cpu的系统资源。</li>
</ul>
</li>
<li>并发<code>(concurrency)</code><ul>
<li>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上（用户感觉）具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
</li>
<li>并行<code>(parallel)</code><ul>
<li>指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-25-21-10-16.png"></li>
</ul>
</li>
<li>单道程序设计<ul>
<li>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上极其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</li>
</ul>
</li>
<li>多道程序设计<ul>
<li>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</li>
<li>时钟中断即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</li>
<li>在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li>
<li>实质上，并发是宏观并行，微观串行。</li>
</ul>
</li>
<li><code>cpu</code><ul>
<li>预读器</li>
<li>译码器</li>
<li>算术逻辑单元</li>
<li><code>MMU</code><ul>
<li>虚拟物理内存映射</li>
<li><code>page 4K??</code></li>
<li>设置内存访问级别</li>
</ul>
</li>
</ul>
</li>
<li><code>PCB</code>进程控制块<ul>
<li>每个进程在<code>kernal</code>中都有一个进程控制块<code>PCB</code>来维护进程相关的信息。<code>Linux</code>的进程控制块是<code>struct task_struct</code>结构体</li>
<li><code>struct task_struct</code>主要内容<ul>
<li>**.<code>pid</code>.**：即进程<code>id</code>。类型为<code>C</code>中的<code>pid_t</code></li>
<li><strong>进程状态</strong>：就绪，运行，挂起（阻塞），停止</li>
<li>进程切换时需要保存和恢复一些cpu寄存器</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端信息</li>
<li><strong>当前目录位置</strong>（不同目录下（shell进程的目录位置不同）的ls结果不同）</li>
<li>umask掩码<ul>
<li>不同进程不同</li>
</ul>
</li>
<li><strong>文件描述表</strong>，包括很多指向file结构体的指针</li>
<li><strong>信号</strong>相关的信息</li>
<li><strong>用户id，组id</strong></li>
<li>会话和进程组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul>
<li>操作系统中用来指定运行环境的一些参数</li>
<li>是跟着进程走的<ul>
<li>本质：字符串</li>
<li>有统一格式：<code>name=value</code></li>
<li>值用来描述进程环境信息 </li>
</ul>
</li>
<li>常用<ul>
<li>PATH<ul>
<li>可执行文件搜索路径</li>
</ul>
</li>
<li>SHELL<ul>
<li>指定当前所使用的命令解析器</li>
</ul>
</li>
<li>TERM<ul>
<li>当前终端类型</li>
</ul>
</li>
<li>HOME<ul>
<li>用户主目录</li>
</ul>
</li>
</ul>
</li>
<li>存储形式<ul>
<li><code>extern char **environ</code></li>
<li>字符指针数组</li>
<li><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-29-13-22-15.png"><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-10-45-58.png"></li>
</ul>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="pid-t-fork-void"><a href="#pid-t-fork-void" class="headerlink" title="pid_t fork(void);"></a><code>pid_t fork(void);</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>#include&lt;sys/types.h&gt;</code></li>
<li><code>#include&lt;unistd.h&gt;</code></li>
<li>创建子进程<ul>
<li>父子进程内容相同（用户区和内核区）相互独立</li>
<li><code>fork</code>在父进程返回一次<code>pid_t</code> ，在子进程返回一次<code>pid_t</code></li>
<li>成功：父进程返回子进程<code>pid_t</code>，子进程返回0</li>
<li>失败：父进程返回-1</li>
</ul>
</li>
<li>父子进程之间的关系：<ul>
<li>区别：<ul>
<li>fork函数的返回值</li>
<li>pcb进程控制块中的数据</li>
<li>进程创建时间</li>
<li>当前进程的<code>id，pid</code></li>
<li>当前进程的父进程的<code>id pid</code></li>
<li>信号集</li>
</ul>
</li>
<li>共同点<ul>
<li>data段，text段，堆，栈，环境变量，全局变量，宿主目录位置，进程工作目录位置，信号处理方式</li>
</ul>
</li>
<li>不同点<ul>
<li>进程<code>id</code>、返回值、各自的父进程、进程创建时间、闹钟、未决信号集。</li>
</ul>
</li>
<li>父子进程共享<ul>
<li><code>mmap</code>映射区(都有什么。。。)</li>
<li>文件描述符（打开的文件结构体）</li>
</ul>
</li>
</ul>
</li>
<li>特别的，<code>fork</code>之后父进程先执行还是子进程先执行不确定，取决于内核所使用的调度算法</li>
</ul>
<blockquote>
<p>子进程会复制父进程的几乎所有信息：子进程复制父进程用户空间所有数据；子进程复制父进程内核空间PCB中绝大多数数据；<br>子进程复制父进程的数据段，BSS段，代码段，堆空间，栈空间，文件描述符，但是对于文件描述符关联的内核文件表项（即struct file结构体）则是采用共享的方式</p>
</blockquote>
<ul>
<li>有点乱，等我学操作系统再研究吧。。</li>
</ul>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a><strong>写时拷贝</strong></h3><ul>
<li><strong>读时共享，写时复制</strong></li>
</ul>
<h3 id="pid-t-getpid-void"><a href="#pid-t-getpid-void" class="headerlink" title="pid_t getpid(void)"></a><code>pid_t getpid(void)</code></h3><ul>
<li>返回当前进程<code>id</code></li>
</ul>
<h3 id="pid-t-getppid-void"><a href="#pid-t-getppid-void" class="headerlink" title="pid_t getppid(void)"></a><code>pid_t getppid(void)</code></h3><ul>
<li>返回父进程<code>id</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">// 实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">// 写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">// 内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">// 只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">// 也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">// 注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">// fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">// */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="争夺cpu模型"><a href="#争夺cpu模型" class="headerlink" title="争夺cpu模型"></a>争夺cpu模型</h3><p><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-16-46.png"><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-17-05.png"><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-19-52.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i!=<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent process id = %d\tthe parent parent process id = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process id = %d\tthe parent process id = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./fork_shc.out </span><br><span class="line">child process id = <span class="number">3221</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">child process id = <span class="number">3220</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">parent process id = <span class="number">3219</span>	the parent parent process id = <span class="number">2852</span></span><br><span class="line">child process id = <span class="number">3222</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">child process id = <span class="number">3223</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ child process id = <span class="number">3224</span>	the parent process id = <span class="number">2344</span></span><br></pre></td></tr></table></figure>


<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><ul>
<li><code>exec</code> 让子进程去执行其他程序</li>
<li><code>a./out</code>的父进程是<code>bash</code> 那么<code>bash</code>是如何做到开辟一个子进程去执行我们写的代码？就是用<code>exec</code>函数族</li>
<li><code>exec</code> 函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通<br>常我们直接在 <code>exec</code> 函数调用后直接调用 <code>perror()</code>和 <code>exit()</code>，无需 <code>if</code> 判断</li>
<li>调用<code>exec</code>并不创建新进程，所以前后的进程ID并未改变，<code>exec</code>只是用磁盘山东个一个新程序代替了当前进程的正文段，数据段，堆段，和栈段。</li>
<li>调用系统提供的，用<code>execlp</code></li>
<li>调用自己写的，用<code>execl</code><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-59-37.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">l (list) 命令行参数列表</span></span><br><span class="line"><span class="comment">p (path) 搜素 file 时使用 path 变量</span></span><br><span class="line"><span class="comment">v (vector) 使用命令行参数数组</span></span><br><span class="line"><span class="comment">e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运</span></span><br><span class="line"><span class="comment">行的环境变量</span></span><br><span class="line"><span class="comment">事实上，只有 execve 是真正的系统调用，其它五个函数最终都调用 execve，所以 execve</span></span><br><span class="line"><span class="comment">在 man 手册第 2 节，其它函数在 man 手册第 3 节。这些函数之间的关系如下图所示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-29-13-22-03.png"></li>
</ul>
<h3 id="execl-const-char-path-const-char-arg"><a href="#execl-const-char-path-const-char-arg" class="headerlink" title="execl(const char *path,const char *arg, ...)"></a><code>execl(const char *path,const char *arg, ...)</code></h3><ul>
<li>第一个参数是：可执行文件的路径；</li>
<li>第二个参数是：可执行程序的程序名，</li>
<li>其余参数是命令函的参数，通常最后一个参数是一个空指针NULL(用来表示命令行数组的结尾).<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>) <span class="comment">//  父进程 调用fork失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)  <span class="comment">//  父进程调用fork成功 返回子进程pid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process , pid = %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-a&quot;,&quot;-h&quot;,&quot;-l&quot;,NULL);</span></span><br><span class="line">        <span class="comment">// execlp(&quot;date&quot;,&quot;date&quot;,NULL);</span></span><br><span class="line">        <span class="comment">// execl(&quot;./a.out&quot;,&quot;./a.out&quot;,NULL);</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>没加<code>sleep(1)</code>有可能会发生如下</li>
<li>本进程的子进程没有抢过本进程，本进程<code>(printf i am parent)</code>结束后（即该段程序变成的进程结束后），父进程<code>bash</code>先抢夺到<code>cpu</code>，先执行出<code>henry@henry:~/code/learn/exec_learn$</code>，然后再到<code>child process</code>执行<code>ls</code><ul>
<li>父进程结束后，<code>bash</code>就会去回收这个父进程<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/exec_learn$ gcc fork_exec.c -o fork_exec.out</span><br><span class="line">henry@henry:~/code/learn/exec_learn$ ./fork_exec.out </span><br><span class="line">i am parent process , pid = 3389</span><br><span class="line">henry@henry:~/code/learn/exec_learn$ 总用量 24K</span><br><span class="line">drwxrwxr-x 2 henry henry 4.0K 10月 20 12:23 .</span><br><span class="line">drwxr-xr-x 7 henry henry 4.0K 10月 20 12:16 ..</span><br><span class="line">-rw-rw-r-- 1 henry henry  424 10月 20 12:23 fork_exec.c</span><br><span class="line">-rwxrwxr-x 1 henry henry 8.4K 10月 20 12:23 fork_exec.out</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>加上<code>sleep(1)</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/exec_learn$ ./fork_exec.out </span><br><span class="line">总用量 24K</span><br><span class="line">drwxrwxr-x 2 henry henry 4.0K 10月 20 12:22 .</span><br><span class="line">drwxr-xr-x 7 henry henry 4.0K 10月 20 12:16 ..</span><br><span class="line">-rw-rw-r-- 1 henry henry  424 10月 20 12:23 fork_exec.c</span><br><span class="line">-rwxrwxr-x 1 henry henry 8.5K 10月 20 12:22 fork_exec.out</span><br><span class="line">i am parent process , pid = 3370</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><ul>
<li>父进程先终止，其子进程被送进<code>init</code>孤儿院</li>
<li>在一个进程终止时，内核逐渐检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程<code>ID</code>就更改为<code>1</code>（<code>init</code>的<code>pid</code>）。这种方法保证了每个进程有一个父进程</li>
</ul>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><ul>
<li>进程终止时，用户区的内容就已经被释放。</li>
<li>子进程比父进程先终止，那么父进程如何在做相应检查时得到子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程获取保存了一定量的信息，所以当终止进程的父进程调用wait或者waitpid是可以获取这些信息的。（信息包括进程ID，进程终止状态，以及进程使用CPU时间总量等）。<strong>内核</strong>可以释放终止进程所使用的所有存储区，关闭其所有打开文件。</li>
<li>一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程成为僵尸进程。</li>
<li><strong>所以！死去进程之所以会有残留资源（信息），就是为了告诉父进程他是怎么死的。而我们对残留信息采用wait或者直接丢弃的做法，都代表我们已经不再使用该子进程，系统在这之后就会释放这些残留资源。</strong></li>
<li><strong>所以！wait的作用只是去获取子进程死亡的状态，释放资源的动作是由系统做的。</strong></li>
<li><code>ps</code>中僵尸进程打印为<code>z</code></li>
</ul>
<h3 id="僵尸进程解决方法："><a href="#僵尸进程解决方法：" class="headerlink" title="僵尸进程解决方法："></a><strong>僵尸进程解决方法：</strong></h3><ul>
<li>父进程对子进程<code>wait</code>（而非<code>kill</code>），因为此进程已经死了。<ul>
<li><code>wait</code>获取死去进程的信息后，系统知道这些进程对于用户来说已经彻底没有用了，于是乎释放那些信息。</li>
<li><code>waitpid</code>可以通过参数<code>WNOHANG</code>使父进程不阻塞立即返回。</li>
</ul>
</li>
<li>如果父进程很忙可以通过<code>signal</code>注册<code>SIGCHLD</code>信号，在处理函数中对相应进程进行<code>wait</code>。（下一章有代码）</li>
<li>杀死产生僵尸进程的父进程，这样这些僵尸进程就变成了孤儿进程，进而被<code>init</code>进程接管，进而被回收。</li>
<li>在子进程死亡发送<code>SIGCHLD</code>信号时，直接采用<strong>忽略</strong>的做法。<code>signal(SIGCHLD,SIG_IGN)</code>。忽略这个信号，这也是一种代表了我们对子进程死亡的处理态度。我们不关心他的死法。而系统也懂了我们不关心，故直接释放资源。不会造成僵尸进程的诞生。</li>
<li>通过两次调用<code>fork</code>。父进程首先调用<code>fork</code>创建一个子进程后<code>waitpid</code>等待该子进程退出。子进程在进程体中调用<code>fork</code>创建孙进程，然后子进程再退出。这样操作完后，子进程会被父进程回收。而对于那个孙进程而言，其父进程已经退出。故其会被<code>init</code>进程接管。故不会成为僵尸进程</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li>一个由<code>init</code>收养的进程终止时是否会变成一个僵尸进程？<ul>
<li>不会。<code>init</code>被编写成，无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数取得其终止状态，这样也就防止了系统中塞满僵尸进程的情况。</li>
</ul>
</li>
<li><code>init的子进程</code><ul>
<li><code>init</code>产生的</li>
<li><code>init</code>收养的。</li>
</ul>
</li>
</ul>
<h2 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait/waitpid"></a><code>wait/waitpid</code></h2><h3 id="pid-t-wait-int-statloc"><a href="#pid-t-wait-int-statloc" class="headerlink" title="pid_t wait(int *statloc);"></a><code>pid_t wait(int *statloc);</code></h3><hr>
<ul>
<li>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块<code>PCB</code>的信息（包括进程号、退出状态、运行时间等）。我们需要对这些信息进行处理，以告知系统我们已经彻底结束对这个进程的利用。</li>
</ul>
<h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a><strong>纠错</strong></h3><ul>
<li><p><code>wait</code>函数作用</p>
<ul>
<li>阻塞等待子进程退出。（这时候应该会让出<code>cpu</code>资源吧？？）</li>
<li>当一个子进程终止时，<code>wait</code>去获取整个终止子进程的终止信息，取得该子进程的终止状态则立即返回。</li>
<li>如果他没有任何子进程，则立即出错返回。</li>
</ul>
</li>
<li><p>当调用<code>wait</code>获取信息后，<strong>系统</strong>就会释放内核中的残留信息。（这些信息就是为了让<code>wait</code>去获取的，<code>wait</code>获取完之后，这些东西自然就可以释放掉）。</p>
</li>
<li><p><strong>所以释放残留资源这一步，不是wait函数做的，而是系统做的！！！</strong></p>
<ul>
<li><strong>那么多博客都tm以讹传讹。害死人。</strong></li>
</ul>
</li>
<li><p><strong>看啊</strong></p>
<ul>
<li><code>description</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">**In the <span class="keyword">case</span> of a terminated child, performing a wait allows the system to release</span><br><span class="line">   the resources associated with the child; <span class="keyword">if</span> a wait is <span class="keyword">not</span> performed, then the terminated child remains in  a  <span class="string">&quot;zombie&quot;</span>  state**</span><br><span class="line">   (see NOTES below).</span><br></pre></td></tr></table></figure></li>
<li><code>notes</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT flag is set for SIGCHLD (see</span><br><span class="line">   sigaction(2)), then children that terminate do not become zombies and a call to wait() or  waitpid()  will  block  until  all</span><br><span class="line">   children  have terminated, and then fail with errno set to ECHILD. </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>看manpage去</p>
</li>
</ul>
<hr>
<ul>
<li><code>pid_t wait(int *statloc);</code></li>
<li><code>int *statloc</code>：保存退出状态。保存的就是子进程结束时return的值。</li>
<li><code>return</code><ul>
<li>成功回收：返回回收的进程的<code>pid</code>号</li>
<li>出错：调用<code>wait</code>的当前进程并没有任何子进程。则返回<code>-1</code>。</li>
</ul>
</li>
<li><code>waitpid</code>相较于<code>wait</code>可以选择是否阻塞，以及回收特定的某一个子进程</li>
<li>一次 <code>wait</code> 或 <code>waitpid</code> 调用只能清理一个子进程</li>
<li><code>wait</code>等价于<code>waitpid(-1, &amp;wstatus, 0);</code></li>
</ul>
<ul>
<li>宏函数判断终止原因。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WIFEXITED（status）宏判断为真 表示程序正常退出</span><br><span class="line">WEXITSTATUS(status)上一个宏判断为真 则返回状态值  <span class="comment">//也就是在获取子进程最后return的值。</span></span><br><span class="line">WIFSIGNALED(status) 宏判断为真 表示程序异常退出</span><br><span class="line">WTERMSIG(status) 上一个判断为真，则返回状态值 <span class="comment">//也就是在获取子进程最后return的值。</span></span><br><span class="line">WIFSTOPPED(status)：子进程被停止，返回真</span><br><span class="line">WSTOPSIG(status)：返回停止子进程的信号值 <span class="comment">//也就是在获取子进程最后return的值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">pid_t</span> target_pid;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">                                target_pid = pid; <span class="comment">//  注意用pid 不是getpid()</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">int</span> statloc;    <span class="comment">//  接收进程退出状态</span></span><br><span class="line">                <span class="keyword">pid_t</span> wpid = waitpid(target_pid,&amp;statloc,<span class="number">0</span>);    <span class="comment">//  阻塞回收 成功：返回进程id，错误：返回-1（一般是子进程不存在）</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;i am the parent process , wait for the child process id = %d\n&quot;</span>,wpid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;i am the child process id = %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./waitpid_shc.out </span><br><span class="line">i am the child process id = <span class="number">4306</span></span><br><span class="line">i am the child process id = <span class="number">4307</span></span><br><span class="line">i am the child process id = <span class="number">4309</span></span><br><span class="line">i am the child process id = <span class="number">4310</span></span><br><span class="line">i am the child process id = <span class="number">4308</span></span><br><span class="line">i am the parent process , wait <span class="keyword">for</span> the child process id = <span class="number">4308</span>  <span class="comment">//  回收i=2进程</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pid-t-waitpid-pid-t-pid-int-statloc-int-options"><a href="#pid-t-waitpid-pid-t-pid-int-statloc-int-options" class="headerlink" title="pid_t waitpid(pid_t pid,int *statloc,int options);"></a><code>pid_t waitpid(pid_t pid,int *statloc,int options);</code></h3><ul>
<li><p>传入参数</p>
<ul>
<li><code>pid_t pid</code><ul>
<li><code>&gt;0 </code>指定进程号</li>
<li><code>=-1</code> 回收任意子进程，相当于<code>wait</code>。<code>waitpid(-1,&amp;status,0) &lt;-&gt; wait(&amp;status);</code></li>
<li><code>=0</code> 回收和当前调用<code>waitpid</code>的进程的一个组的所有子进程（一般同一进程<code>fork</code>出的子进程默认同一组）</li>
<li><code>&lt;-1</code> 回收指定进程组的任意子进程</li>
</ul>
</li>
<li><code>int *statloc</code><ul>
<li>保存退出状态</li>
<li>我也不太懂怎么就能保存状态。应该是通过位图吧</li>
</ul>
</li>
<li><code>options</code><ul>
<li>0：阻塞</li>
<li><code>WNOHANG</code>：非阻塞，没有子进程结束，立即返回</li>
<li><code>WUNTRACED</code>：如果子进程由于被停止产生的 SIGCHLD，waitpid 则立即返回</li>
<li><code>WCONTINUED</code>：如果子进程由于被 <code>SIGCONT</code> 唤醒而产生的 <code>SIGCHLD</code>，<code>waitpid</code> 则立即返回</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><p><code>return</code></p>
<ul>
<li>成功回收：返回回收的进程的<code>pid</code>号</li>
<li>出错：调用<code>waitpid</code>的当前进程并没有任何子进程。则返回<code>-1</code>。（有正在运行的子进程也叫有子进程）</li>
<li>如果使用了<code>WNOHANG</code>非阻塞参数，且没有子进程已经终止、可以回收，那么就返回<code>0</code>.</li>
</ul>
</li>
<li><p>回收指定进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> target_pid;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">			sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">				target_pid = pid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> statloc;	<span class="comment">//  接收进程退出状态</span></span><br><span class="line">		<span class="keyword">pid_t</span> wpid = waitpid(target_pid,&amp;statloc,<span class="number">0</span>);	<span class="comment">//  阻塞回收 成功：返回进程id，错误：返回-1（一般是子进程不存在）</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			sys_err(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;i am the parent process , wait for the child process id = %d\n&quot;</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am the child process id = %d\n&quot;</span>,getpid());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i am the child process id = <span class="number">4538</span></span><br><span class="line">i am the child process id = <span class="number">4539</span></span><br><span class="line">i am the child process id = <span class="number">4541</span></span><br><span class="line">i am the child process id = <span class="number">4540</span></span><br><span class="line">i am the child process id = <span class="number">4542</span></span><br><span class="line">i am the parent process , wait <span class="keyword">for</span> the child process id = <span class="number">4540</span></span><br></pre></td></tr></table></figure></li>
<li><p>回收所有进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> wpid  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// while((wpid=waitpid(-1,NULL,0)!=-1))</span></span><br><span class="line">                <span class="comment">//         printf(&quot;i wait the child id = %d hhhh\n&quot;,wpid);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//  这样循环使用WNOHANG 的 waitpid的效果和上面直接使用 阻塞的 waitpid的效果一样（我认为）</span></span><br><span class="line">               <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))!=<span class="number">-1</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                        <span class="comment">//  非阻塞 且没有结束的子进程时 返回0</span></span><br><span class="line">                        <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;i wait the child id = %d\n&quot;</span>,wpid);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                usleep(<span class="number">1</span>);      <span class="comment">//  父进程睡眠 让出cpu  </span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; parent die\n &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;i am the %d th child process id = %d\n&quot;</span>,i,getpid());</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// i am the 0 th child process id = 4407</span></span><br><span class="line"><span class="comment">// i am the 1 th child process id = 4408</span></span><br><span class="line"><span class="comment">// i am the 3 th child process id = 4410</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i am the 2 th child process id = 4409</span></span><br><span class="line"><span class="comment">// i am the 4 th child process id = 4411</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">//  parent die</span></span><br><span class="line"></span><br><span class="line">i am the <span class="number">1</span> th child process id = <span class="number">4381</span></span><br><span class="line">i am the <span class="number">0</span> th child process id = <span class="number">4380</span></span><br><span class="line">i am the <span class="number">3</span> th child process id = <span class="number">4383</span></span><br><span class="line">i wait the child id = <span class="number">4380</span></span><br><span class="line">i wait the child id = <span class="number">4381</span></span><br><span class="line">i am the <span class="number">2</span> th child process id = <span class="number">4382</span></span><br><span class="line">i am the <span class="number">4</span> th child process id = <span class="number">4384</span></span><br><span class="line">i wait the child id = <span class="number">4382</span></span><br><span class="line">i wait the child id = <span class="number">4383</span></span><br><span class="line">i wait the child id = <span class="number">4384</span></span><br><span class="line"> parent die</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关于wait函数只是负责获取终止状态，而不负责回收资源的代码"><a href="#关于wait函数只是负责获取终止状态，而不负责回收资源的代码" class="headerlink" title="关于wait函数只是负责获取终止状态，而不负责回收资源的代码"></a><strong>关于wait函数只是负责获取终止状态，而不负责回收资源的代码</strong></h2><ul>
<li>所以那在处理死去的进程时，如果不需要获取这个死去进程的信息，就不需要<code>wait</code>。直接<code>signal(SIGCHLD，SIG_IGN)</code>就可以让这个死去的子进程被释放残留资源从而不变成僵尸进程<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	signal(SIGCHLD,SIG_IGN);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; i am parent \n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am %d child\n&quot;</span>,i);</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d die\n&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps ajx也没有僵尸进程</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./test01_wait.out </span><br><span class="line">i am <span class="number">0</span> child</span><br><span class="line">i am <span class="number">1</span> child</span><br><span class="line"> i am parent </span><br><span class="line">i am <span class="number">2</span> child</span><br><span class="line">i am <span class="number">3</span> child</span><br><span class="line">i am <span class="number">4</span> child</span><br><span class="line"><span class="number">0</span> die</span><br><span class="line"><span class="number">1</span> die</span><br><span class="line"><span class="number">2</span> die</span><br><span class="line"><span class="number">3</span> die</span><br><span class="line"><span class="number">4</span> die</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="两次fork实验"><a href="#两次fork实验" class="headerlink" title="两次fork实验"></a>两次fork实验</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *err,<span class="keyword">const</span> <span class="keyword">int</span> ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%s error : %s\n&quot;</span>,err,strerror(ret));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>)</span><br><span class="line">		sys_err(<span class="string">&quot;fork&quot;</span>,pid);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)	<span class="comment">//   子进程再创建进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>)</span><br><span class="line">			sys_err(<span class="string">&quot;fork&quot;</span>, pid);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;		<span class="comment">//  子进程退出</span></span><br><span class="line">			write(STDOUT_FILENO,<span class="string">&quot;parent die\n&quot;</span>,<span class="keyword">sizeof</span> <span class="string">&quot;parent die\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//  孙进程运行	在其父进程死亡后他会被init进程接管</span></span><br><span class="line">		&#123;</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,getppid());</span><br><span class="line">			sleep(<span class="number">5</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;sson die\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	<span class="comment">//  父进程等待回收子进程</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> status;</span><br><span class="line">		waitpid(pid,&amp;status,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   PPID    PID   PGID    SID TTY       TPGID STAT   UID   TIME COMMAND</span><br><span class="line">    0      1      1      1 ?            -1 Ss       0   0:02 /sbin/init splash</span><br><span class="line">    1   2222   2222   2222 ?            -1 Ss    1000   0:00 /lib/systemd/systemd --user</span><br><span class="line">    1   2222   2222   2222 ?            -1 Ss    1000   0:00 /lib/systemd/systemd --user</span><br><span class="line">	2913   3859   3859   2913 pts/0      3859 R+    1000   0:03 ./zombie_fork.out	//  父父进程</span><br><span class="line">    2222   3861   3859   2913 pts/0      3859 S+    1000   0:00 ./zombie_fork.out	//  孙进程	子进程已经被回收</span><br><span class="line">shc@shc-virtual-machine:~/code/linux_internet$ ./zombie_fork.out </span><br><span class="line">parent die</span><br><span class="line">2222</span><br><span class="line">sson die</span><br><span class="line">^C</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="子进程返回值补充"><a href="#子进程返回值补充" class="headerlink" title="子进程返回值补充"></a>子进程返回值补充</h2><ul>
<li>子进程结束时返回<code>int</code>值，父进程可以选择用<code>wait(&amp;status)</code>去接收<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) &#123;sleep(<span class="number">10</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="comment">// kill(pid,SIGINT);</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFEXITED(status),WEXITSTATUS(status));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFSIGNALED(status),WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./<span class="keyword">try</span>.out </span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span></span><br><span class="line"><span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) &#123;sleep(<span class="number">10</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    kill(pid,SIGINT);</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFEXITED(status),WEXITSTATUS(status));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFSIGNALED(status),WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./<span class="keyword">try</span>.out </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span>       <span class="number">0</span></span><br><span class="line"><span class="number">1</span>       <span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) &#123;<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFEXITED(status),WEXITSTATUS(status));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFSIGNALED(status),WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./<span class="keyword">try</span>.out </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure>


<h2 id="manpage阅读"><a href="#manpage阅读" class="headerlink" title="manpage阅读"></a>manpage阅读</h2><ul>
<li><code>wait</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WAIT(2)                    Linux Programmer&#x27;s </span><br><span class="line">  SYNOPSIS</span><br><span class="line">        #include &lt;sys/types.h&gt;</span><br><span class="line">        #include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">        pid_t wait(int *wstatus);</span><br><span class="line">        pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">        int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</span><br><span class="line"></span><br><span class="line">  DESCRIPTION</span><br><span class="line">        All  of these system calls are used to wait for state changes in a child of the calling process, and obtain information about</span><br><span class="line">        the child whose state has changed.  A state change is considered to be: the child terminated; the child was stopped by a sig‐</span><br><span class="line">        nal; or the child was resumed by a signal.  **In the case of a terminated child, performing a wait allows the system to release</span><br><span class="line">        the resources associated with the child; if a wait is not performed, then the terminated child remains in  a  &quot;zombie&quot;  state**</span><br><span class="line">        (see NOTES below).</span><br><span class="line"></span><br><span class="line">        If  a  child  has  already  changed  state,  then these calls return immediately.  Otherwise, they block until either a child</span><br><span class="line">        changes state or a signal handler interrupts the call (assuming that system calls are not automatically restarted  using  the</span><br><span class="line">        SA_RESTART  flag of sigaction(2)).  In the remainder of this page, a child whose state has changed and which has not yet been</span><br><span class="line">        waited upon by one of these system calls is termed waitable.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  NOTES</span><br><span class="line">        A  child  that terminates, but has not been waited for becomes a &quot;zombie&quot;.  The kernel maintains a minimal set of information</span><br><span class="line">        about the zombie process (PID, termination status, resource usage information) in order to allow the parent to later  perform</span><br><span class="line">        a wait to obtain information about the child.  As long as a zombie is not removed from the system via a wait, it will consume</span><br><span class="line">        a slot in the kernel process table, and if this table fills, it will not be possible to create further processes.  If a  par‐</span><br><span class="line">        ent process terminates, then its &quot;zombie&quot; children (if any) are adopted by init(1), (or by the nearest &quot;subreaper&quot; process as</span><br><span class="line">        defined through the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation); init(1) automatically performs a  wait  to  remove</span><br><span class="line">        the zombies.</span><br><span class="line"></span><br><span class="line">        POSIX.1-2001  specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT flag is set for SIGCHLD (see</span><br><span class="line">        sigaction(2)), then children that terminate do not become zombies and a call to wait() or  waitpid()  will  block  until  all</span><br><span class="line">        children  have terminated, and then fail with errno set to ECHILD.  (The original POSIX standard left the behavior of setting</span><br><span class="line">        SIGCHLD to SIG_IGN unspecified.  Note that even though the default disposition of SIGCHLD is &quot;ignore&quot;, explicitly setting the</span><br><span class="line">        disposition to SIG_IGN results in different treatment of zombie process children.)</span><br><span class="line"></span><br><span class="line">        Linux  2.6  conforms  to the POSIX requirements.  However, Linux 2.4 (and earlier) does not: if a wait() or waitpid() call is</span><br><span class="line">        made while SIGCHLD is being ignored, the call behaves just as though SIGCHLD were not being ignored, that is, the call blocks</span><br><span class="line">        until the next child terminates and then returns the process ID and status of that child.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a href="https://haileshe.club/video/lujiao-16.html">https://haileshe.club/video/lujiao-16.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ReStart</title>
    <url>/2021/11/04/ReStart/</url>
    <content><![CDATA[<p><img src="/2021/11/04/ReStart/2021-11-04-22-11-58.png"></p>
<h1 id="重新搭建的小窝"><a href="#重新搭建的小窝" class="headerlink" title="重新搭建的小窝"></a>重新搭建的小窝</h1><ul>
<li><code>Dell</code>的硬盘坏掉了，来来回回修了快一个月</li>
<li>什么环境都没得了，幸好笔记还都在</li>
<li>虽然怕麻烦，不过重建一个自己的新窝还是很开心的。</li>
<li>继续记录吧。</li>
</ul>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习杂记(预习)</title>
    <url>/2022/05/04/MySQL%E5%AD%A6%E4%B9%A0%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>MySQL client和 MySQL server的区别<ul>
<li><code>用户登录MySQL Client &lt;---&gt; MySQL Server &lt;---&gt; MySQL数据库（一种文件）</code></li>
<li>Client 面向用户；Server 面向数据库。   </li>
<li>用户登录Client，通过Client向Server发送请求。</li>
<li>Server接收Client发送的请求，并根据请求，通过相应接口操作MySQL数据库（一种文件）。然后将得到的结果作为响应返回给Client。</li>
</ul>
</li>
<li>所以所谓的”MySQL”一般就是包括上面两个东西。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP杂记(预习)</title>
    <url>/2022/02/22/TCP/</url>
    <content><![CDATA[<h1 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h1><ul>
<li><p><strong>什么是TCP连接</strong></p>
<ul>
<li>⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗⼝⼤⼩称为连接。</li>
<li><strong>Socket：ip地址+端口号</strong></li>
<li><strong>序列号：解决乱序问题</strong></li>
<li><strong>窗口：流量控制</strong></li>
</ul>
</li>
<li><p>TCP四元组可以唯一确定一个TCP连接</p>
<ul>
<li>源ip地址</li>
<li>源port</li>
<li>目的ip地址</li>
<li>目的port</li>
</ul>
</li>
<li><p>TCP头部<br><img src="/2022/02/22/TCP/2022-02-24-10-14-28.png"></p>
</li>
<li><p>ACK：TCP报文中，当ACK=1时，ack才有效。TCP规定，在连接建立后的所有报文中，ACK都置为1。（也就是说如果正常的话，除了第一个请求建立连接的SYN报文之外，其余的ACK均=1）</p>
<h1 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h1></li>
<li><p><strong>三次握手建立连接</strong></p>
<ul>
<li><img src="/2022/02/22/TCP/2022-02-22-09-23-35.png"></li>
</ul>
</li>
<li><p><strong>普通数据传输</strong></p>
<ul>
<li><img src="/2022/02/22/TCP/2022-02-22-10-13-24.png"></li>
</ul>
</li>
<li><p>序列号这种东西本来是给数据准备的，每个字节占一个序列号，来防止乱序。但是SYN报文和ACK+SYN报文虽然不可以携带数据，但是也消耗一个序号。ACK报文可以携带数据，不携带则不消耗序列号。</p>
</li>
<li><p><strong>序列号作用：</strong></p>
<ul>
<li>可以去除重复接受的数据。</li>
<li>使得接收方可以按序接收。</li>
<li>可以标识发出去的数据包中，那些是对方已经收到的。（对于发送方来说，接受方回应的ACK报文的ack序列号之前的选好的数据包就是对方已经收到的）</li>
</ul>
</li>
<li><p><strong>ACK报文不消耗序列号</strong><br><a href="https://www.zhihu.com/question/24792770">https://www.zhihu.com/question/24792770</a></p>
</li>
</ul>
<h2 id="为什么三次握手？（三次握手让双方具有接收发送的能力，那么为什么三次握手才可以初始化socket，序列号，窗口大小并建立TCP连接？）"><a href="#为什么三次握手？（三次握手让双方具有接收发送的能力，那么为什么三次握手才可以初始化socket，序列号，窗口大小并建立TCP连接？）" class="headerlink" title="为什么三次握手？（三次握手让双方具有接收发送的能力，那么为什么三次握手才可以初始化socket，序列号，窗口大小并建立TCP连接？）"></a><strong>为什么三次握手？</strong>（三次握手让双方具有接收发送的能力，那么为什么三次握手才可以初始化socket，序列号，窗口大小并建立TCP连接？）</h2><ul>
<li><p>两次握手时，Server端不知道自己发送的SYN+ACK报文是否被收到，所以每收到一个SYN就只能先分配资源主动建立连接。</p>
</li>
<li><p><strong>三次握手可以阻止重复历史连接的初始化造成混乱（主要原因）</strong>。</p>
<ul>
<li><strong>自己</strong>：第三次握手是为了判断接受的SYN+ACK报文是否是回应历史连接请求的。（通过SYN+ACK报文中的ack序列号，看是否与本方的seq相等）</li>
<li><strong>图解</strong></li>
<li>网络拥堵时，Client发出的一个旧的SYN报文比新的SYN报文先到达。</li>
<li>Server端对旧的SYN报文做出SYN+ACK报文应答，给Client端。</li>
<li>Client端发现接收到的ack序列号和自己期望收到的ack序列号不同。故判断出这是历史连接。（序列号过期或者超时）</li>
<li>于是Client端向Server端发送RST报文，表示终止连接。</li>
<li>如果是两次握手，就没法判断是否是历史连接。（Client）在第二次握手时，（Client）有足够的上下文来判断是否是历史连接。<ul>
<li>是，则发送RST报文，终止连接</li>
<li>不是，则发送ACK报文，建立连接。</li>
</ul>
</li>
<li><img src="/2022/02/22/TCP/2022-02-24-11-18-30.png"></li>
</ul>
</li>
<li><p><strong>三次握手可以同步化序列号</strong></p>
<ul>
<li><strong>自己</strong>：Client第三次握手是为了回应第二次握手Server端发来的ACK+SYN报文（带有Seq），即为了确定收到序列号。</li>
<li><strong>图解</strong>：序列号在 TCP 连接中占据着⾮常重要的作⽤，所以当客户端发送携带「初始序列号」的 SYN 报⽂的时候，需要服务端回⼀个 ACK 应答报⽂，表示客户端的 SYN 报⽂已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样⼀来⼀回，才能确保双⽅的初始序列号能被可靠的同步。</li>
<li>四次握⼿其实也能够可靠的同步双⽅的初始化序号，但由于第⼆步和第三步可以优化成⼀步，所以就成了「三次握⼿」</li>
<li><img src="/2022/02/22/TCP/2022-02-24-11-00-58.png"></li>
</ul>
</li>
<li><p><strong>三次握手可以避免资源浪费</strong></p>
<ul>
<li><strong>图解</strong></li>
<li>由于没有第三次握⼿，服务器不清楚客户端是否收到了⾃⼰发送的建⽴连接的 ACK 确认信号，所以每收到⼀个 SYN 就只能先主动建⽴⼀个连接，这会造成什么情况呢？</li>
<li>TCP连接建立之后，Client不回应ACK报文，Server主动建立连接，在两次握手消息滞留情况下，会重复接收无用请求连接SYN报文，重复分配资源。</li>
<li><img src="/2022/02/22/TCP/2022-02-24-11-38-59.png"></li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>TCP 建⽴连接时，通过三次握⼿能防⽌历史连接的建⽴，能减少双⽅不必要的资源开销，能帮助双⽅同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。</li>
<li>不使⽤「两次握⼿」和「四次握⼿」的原因：<ul>
<li>「两次握⼿」：无法防止历史连接建立，无法同步序列号，无法避免资源浪费。</li>
<li>「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。</li>
</ul>
</li>
</ul>
<h2 id="为什么客户端和服务端的初始序列号-ISN-是不相同的？？？？"><a href="#为什么客户端和服务端的初始序列号-ISN-是不相同的？？？？" class="headerlink" title="为什么客户端和服务端的初始序列号 ISN 是不相同的？？？？??"></a>为什么客户端和服务端的初始序列号 ISN 是不相同的？？？？??</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/ZQ51SmLopj-4OPhNkSL8Fw">https://mp.weixin.qq.com/s/ZQ51SmLopj-4OPhNkSL8Fw</a></li>
<li>还是有一点点不懂。在本文举的例子中，因为网络拥堵而延后收到的数据包的序列号是否在服务端的接收窗口内的这件事情，似乎是与前后两次TCP连接中，客户端初始化的ISN是否相同有关，而和客户端的ISN与服务端的ISN是否相同无关。mo-[委屈]（如第二幅TCP三次握手的图中，被延迟的数据包的seq=101，这个seq是根据客户端最开始随机初始化的ISN得出的（100+1），然后第第二次建立连接时，服务端接收窗口的”501~600“中的501，也是由客户端一开始随机初始化的ISN得出的（500+1 = 501）；而101不在这个范围内，因此不会被接收。所以这不是和前后两次客户端随机初始化的ISN是否相同有关吗。mo-[委屈]）</li>
</ul>
<h2 id="既然-IP-层会分⽚，为什么-TCP-层还需要-MSS-呢？"><a href="#既然-IP-层会分⽚，为什么-TCP-层还需要-MSS-呢？" class="headerlink" title="既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？??"></a>既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？??</h2><ul>
<li>有点不懂</li>
<li><img src="/2022/02/22/TCP/2022-02-24-16-50-15.png"></li>
<li>MTU: 最大传输单元是Maxitum Transmission Unit的简写，是OSI五层网络模型中链路层(datalink layer)对一次可以发送的最大数据的限制。<br><img src="/2022/02/22/TCP/2022-03-02-09-18-24.png"></li>
</ul>
<h2 id="关于ping"><a href="#关于ping" class="headerlink" title="关于ping"></a>关于ping</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/45110873">ping</a></li>
</ul>
<h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl</a></li>
</ul>
<h2 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h2><hr>
<p>当前web和web-like应用中一般都是在三次握手后开始数据传输（第三次可以开始传输），相比于UDP，多了一个RTT的时延，即使当前很多应用使用长连接来处理这种情况，但是仍然由一定比例的短连接，这额外多出的一个RTT仍然对应用的时延有非常大的影响。TFO就是在这种背景下面提出来的。<br>TFO(TCP fast open)是TCP协议的experimental update，它允许服务器和客户端在连接建立握手阶段交换数据，从而使应用节省了一个RTT的时延。但是TFO会引起一些问题，因此协议要求TCP实现必须默认禁止TFO。需要在某个服务端口上启用TFO功能的时候需要应用程序显示启用。</p>
<ul>
<li>聊天记录 ip层不分片 因为TCP的mss小于ip层的mtu<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">小林:</span><br><span class="line">我也不懂，难道数数不是123？难道是124？</span><br><span class="line"></span><br><span class="line">sunny:</span><br><span class="line">哈哈，我回答3个后，他就问我服务器回应syn和ack是两个包里的还是一个包里的，把我唬住了</span><br><span class="line"></span><br><span class="line">sunny:</span><br><span class="line">还没复习计网呢</span><br><span class="line"></span><br><span class="line">Dezy:</span><br><span class="line">拆包看看</span><br><span class="line"></span><br><span class="line">Dezy:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dezy:</span><br><span class="line">最近刚粗略的看完计网，感觉上，我觉得是在一个包的</span><br><span class="line"></span><br><span class="line">小林:</span><br><span class="line">肯定在一个包啊，不然为什么叫三次握手</span><br><span class="line"></span><br><span class="line">小林:</span><br><span class="line">[动画表情]</span><br><span class="line"></span><br><span class="line">Monster:</span><br><span class="line">emmmmm</span><br><span class="line"></span><br><span class="line">Monster:</span><br><span class="line">但是发送的时候是以流发送的。。。</span><br><span class="line"></span><br><span class="line">Monster:</span><br><span class="line">最后拆到的信息是成一信息的。。</span><br><span class="line"></span><br><span class="line">Dezy:</span><br><span class="line">对于tcp来说，是流，但是对于ip来说不是</span><br><span class="line"></span><br><span class="line">Monster:</span><br><span class="line">嗯呢</span><br><span class="line"></span><br><span class="line">Monster:</span><br><span class="line">但是发送的时候，会进行切片的吧</span><br><span class="line"></span><br><span class="line">小林:</span><br><span class="line">这个是在数据传输阶段，握手的时候不是流数据</span><br><span class="line"></span><br><span class="line">duduSmida:</span><br><span class="line">发送应该就是豹纹吧</span><br><span class="line"></span><br><span class="line">Dezy:</span><br><span class="line">应用层通过socket到传输层，传输层进行一次分割，如果切的太大，ip还会再分</span><br><span class="line"></span><br><span class="line">duduSmida:</span><br><span class="line">报文</span><br><span class="line"></span><br><span class="line">小林:</span><br><span class="line">tcp报文不会在ip分片</span><br><span class="line"></span><br><span class="line">duduSmida:</span><br><span class="line">tcp进行了整合 以流的形式进行分片send 或整合接收？</span><br><span class="line"></span><br><span class="line">Dezy:</span><br><span class="line">学到了</span><br><span class="line"></span><br><span class="line">Monster:</span><br><span class="line">学到了</span><br><span class="line"></span><br><span class="line">duduSmida:</span><br><span class="line">老林的文章有提过 ip层不会重传 所以ip分片后有片丢失只能全包重传 所以是不现实的</span><br><span class="line"></span><br><span class="line">duduSmida:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">不到叫啥名:</span><br><span class="line">[图片]</span><br><span class="line"></span><br><span class="line">小林:</span><br><span class="line">优秀</span><br><span class="line"></span><br><span class="line">Phil:</span><br><span class="line">UDP才会在IP分片，TCP不会</span><br><span class="line"></span><br><span class="line">Dezy:</span><br><span class="line">不是说超过网络层的分包大小，网络层也会进行拆分么</span><br><span class="line"></span><br><span class="line">Dezy:</span><br><span class="line">哦哦，这样啊</span><br><span class="line"></span><br><span class="line">小林:</span><br><span class="line">tcp比较特殊，tcp层自己有个最大报文的大小（mss），超过了mss，就会直接在tcp层切片，mss的大小是小于mtu的，所以tcp切片后的包，到ip层就不会被切片了</span><br><span class="line"></span><br><span class="line">Phil:</span><br><span class="line">[动画表情]</span><br><span class="line"></span><br><span class="line">远山呜莫:</span><br><span class="line">就是说tcp保证在ip层不会被切片的意思？</span><br><span class="line"></span><br><span class="line">duduSmida:</span><br><span class="line">网络链路中有些节点的mtu如果特别小怎么办 </span><br><span class="line"></span><br><span class="line">小林:</span><br><span class="line">如果ip包头设置了不允许切片，那传到mtu特别小的节点后，该节点就会回icmp报文，如果ip包头设置了允许切片，那传到mtu特别小的节点后，就自然分片，由下一个节点的ip组装成报文。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><ul>
<li>ARP：Address Resolution Protocol      地址解析协议。由IP知MAC<ul>
<li>它是将32bit的IP地址解析成48bit的MAC地址。当一台机器向另外一台机器发生数据时，需要知道对端网卡的硬件地址(48 bit的MAC地址)，才能将数据在硬件之间进行交互</li>
</ul>
</li>
<li>RARP：Reserve Address Resolution Protocol 逆地址解析协议 由MAX请求IP分配<ul>
<li>反向地址转换协议就是将 局域网中某个 主机的 物理地址转换为 IP地址</li>
</ul>
</li>
<li>DHCP：dynamic host configuration protocol 动态主机配置协议<ul>
<li>为客户端动态获取IP地址</li>
</ul>
</li>
</ul>
<p>路由器不会转发广播包<br>广播包只会在一个局域网内广播</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">受限的广播地址：255.255.255.255。</span><br><span class="line"></span><br><span class="line">该地址用于主机配置过程中IP数据报的目的地址。</span><br><span class="line"></span><br><span class="line">此时，主机可能还不知道它所在网络的网络掩码，甚至连它的IP地址也不知道。在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中。</span><br><span class="line">  </span><br><span class="line">255.255.255.255255.255.255.255是一个特殊的广播地址，意味着所有的主机，</span><br><span class="line">有同学会好奇地问，是否是指互联网上所有主机？</span><br><span class="line">No！因为255.255.255.255传播范围非常有限，</span><br><span class="line">到了广播域的边界（网关）会自动终结，</span><br><span class="line">如果把广播比作谣言，那么网关是什么呢？“谣言止于智者”中的智者！</span><br></pre></td></tr></table></figure>


<p>C10问题</p>
<p><a href="https://www.zhihu.com/question/267097519">https://www.zhihu.com/question/267097519</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/134312674">路由器科普</a></p>
<p><a href="https://www.zhihu.com/question/381339068/answer/1109050175">ip是否可以告诉别人</a></p>
<p><a href="https://www.zhihu.com/question/20210025">TCP 没有粘包！</a><br><img src="/2022/02/22/TCP/2022-03-21-16-02-04.png"></p>
<ul>
<li>面向连接就是中的连接就是三次握手！三次握手就叫连接。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>c++_11特性概述</title>
    <url>/2022/05/06/c++11_%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="C-11-标准相关的内容-总结一下"><a href="#C-11-标准相关的内容-总结一下" class="headerlink" title="C++11 标准相关的内容 总结一下"></a>C++11 标准相关的内容 总结一下</h1><h2 id="一：关键字和语法"><a href="#一：关键字和语法" class="headerlink" title="一：关键字和语法"></a>一：关键字和语法</h2><p>auto：可以根据右值，推导出右值的类型，然后左边变量的类型也就已知了<br>nullptr：给指针专用（能够和整数进行区别） #define NULL 0<br>foreach：可以遍历数组，容器等<br>for(Type val : container) =&gt; 底层就是通过指针或者迭代器来实现的<br>{<br>    cout&lt;&lt;val&lt;&lt;” “;<br>}<br>右值引用：move移动语义函数和forward类型完美转发函数<br>模板的一个新特性：typename… A  表示可变参（类型参数）</p>
<h2 id="二：绑定器和函数对象"><a href="#二：绑定器和函数对象" class="headerlink" title="二：绑定器和函数对象"></a>二：绑定器和函数对象</h2><p>function：函数对象<br>bind：绑定器  bind1st和bind2nd+二元函数对象 =》 一元函数对象<br>lambda表达式</p>
<h2 id="三：智能指针"><a href="#三：智能指针" class="headerlink" title="三：智能指针"></a>三：智能指针</h2><p>shared_ptr和weak_ptr</p>
<h2 id="四：容器"><a href="#四：容器" class="headerlink" title="四：容器"></a>四：容器</h2><p>set和map：红黑树 O(lgn)<br>unordered_set和unordered_map：哈希表 O(1)<br>array：数组   vector<br>forward_list：前向链表   list</p>
<h2 id="五：C-语言级别支持的多线程编程"><a href="#五：C-语言级别支持的多线程编程" class="headerlink" title="五：C++语言级别支持的多线程编程"></a>五：C++语言级别支持的多线程编程</h2><p>window：createThread<br>linux：pthread_create<br>clone</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>OOP复习</title>
    <url>/2022/04/01/c++_OOP%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<ul>
<li>一个类实例化出来的对象各自拥有成员变量，共享成员方法。</li>
<li>类的成员方法一经编译，所有的方法参数，都会加上一个this指针，接收调用该方法的对象的地址<h2 id="OOP语言的四大特征"><a href="#OOP语言的四大特征" class="headerlink" title="OOP语言的四大特征"></a>OOP语言的四大特征</h2></li>
<li>抽象、封装/隐藏、继承、多态</li>
</ul>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h3><ul>
<li>对象的内存大小只和成员变量有关。与成员方法无关。</li>
<li>如何查看内存</li>
</ul>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><ul>
<li><p>为什么内存对齐</p>
<ul>
<li>硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐。</li>
<li>提高CPU内存访问速度（减少访问内存的<strong>IO次数</strong>)，一般处理器的内存存取粒度都是N的整数倍，假如访问N大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率。</li>
</ul>
</li>
<li><p>VS查看内存</p>
<ul>
<li><code>cl ConsoleApplication2.cpp /d1reportSingleClassLayoutTest</code></li>
</ul>
</li>
<li><p>类和结构体内存对齐规则</p>
<ul>
<li>第一个成员地址和结构体地址相同</li>
<li><strong>按照成员的声明顺序，依次安排内存</strong>，其<strong>偏移量为成员大小的整数倍</strong>，0看做任何成员的整数倍，最后结构体的大小为<strong>最大成员</strong>的整数倍。</li>
<li>因此，要按照类中<strong>最大类型长度来</strong>对齐</li>
<li><a href="https://blog.csdn.net/weixin_40853073/article/details/81451792?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&utm_relevant_index=2">博客1</a><a href="https://blog.csdn.net/qq_44619252/article/details/123496176">博客2</a></li>
</ul>
</li>
<li><p>例1<br><img src="/2022/04/01/c++_OOP%E5%A4%8D%E4%B9%A0/2022-04-03-23-41-02.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ConsoleApplication2.<span class="function">cpp</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Test      <span class="title">size</span><span class="params">(<span class="number">40</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | name</span></span><br><span class="line"><span class="function"><span class="number">20</span>      | x</span></span><br><span class="line"><span class="function"><span class="number">24</span>      | c</span></span><br><span class="line"><span class="function">        | &lt;alignment member&gt; (size=</span><span class="number">7</span>)</span><br><span class="line"><span class="number">32</span>      | salary</span><br><span class="line">        +---</span><br></pre></td></tr></table></figure></li>
<li><p>例2<br><img src="/2022/04/01/c++_OOP%E5%A4%8D%E4%B9%A0/2022-04-03-23-40-29.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">	<span class="keyword">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>() &#123; cout &lt;&lt; <span class="string">&quot;CTest()  &quot;</span>&lt;&lt;<span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">CTest</span>()&#123; cout &lt;&lt; <span class="string">&quot;~CTest()  &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">class Test      <span class="title">size</span><span class="params">(<span class="number">48</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | name</span></span><br><span class="line"><span class="function"><span class="number">20</span>      | x</span></span><br><span class="line"><span class="function"><span class="number">24</span>      | c</span></span><br><span class="line"><span class="function">        | &lt;alignment member&gt; (size=</span><span class="number">3</span>)</span><br><span class="line"><span class="number">28</span>      | y</span><br><span class="line"><span class="number">32</span>      | d</span><br><span class="line">        | &lt;alignment member&gt; (size=<span class="number">7</span>)</span><br><span class="line"><span class="number">40</span>      | salary</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line"><span class="function">class CTest     <span class="title">size</span><span class="params">(<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function">        +---</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="构造、析构"><a href="#构造、析构" class="headerlink" title="构造、析构"></a>构造、析构</h2><ul>
<li><strong>先构造的后析构。后构造的先析构。</strong></li>
<li>不建议自己调用析构函数</li>
<li>调用析构函数后，那块内存就不是这个对象的了</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">CTest</span>() &#123; cout &lt;&lt; <span class="string">&quot;CTest()  &quot;</span>&lt;&lt;<span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">CTest</span>()&#123; cout &lt;&lt; <span class="string">&quot;~CTest()  &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CTest t1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CTest t2;</span><br><span class="line">	CTest t3;</span><br><span class="line">    CTest *t4 = <span class="keyword">new</span> <span class="built_in">CTest</span>();    <span class="comment">//  不会自动释放</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./testa.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">CTest</span><span class="params">()</span>  0x56542d1ba131 <span class="comment">//  .data/.bss 全局变量 </span></span></span><br><span class="line"><span class="function"><span class="title">CTest</span><span class="params">()</span>  0x7ffe260aad8e <span class="comment">//  栈上的</span></span></span><br><span class="line"><span class="function"><span class="title">CTest</span><span class="params">()</span>  0x7ffe260aad8f</span></span><br><span class="line"><span class="function"><span class="title">CTest</span><span class="params">()</span>  0x56542d8db280 <span class="comment">//  堆上的</span></span></span><br><span class="line"><span class="function">~<span class="title">CTest</span><span class="params">()</span>  0x7ffe260aad8f</span></span><br><span class="line"><span class="function">~<span class="title">CTest</span><span class="params">()</span>  0x7ffe260aad8e</span></span><br><span class="line"><span class="function">~<span class="title">CTest</span><span class="params">()</span>  0x56542d1ba131</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/01/c++_OOP%E5%A4%8D%E4%B9%A0/2022-04-01-11-24-43.png"></p>
<h2 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h2><h3 id="static成员变量"><a href="#static成员变量" class="headerlink" title="static成员变量"></a>static成员变量</h3><ul>
<li><strong>static成员变量一定要在类外定义并初始化</strong></li>
<li>static成员变量不属于对象，不在栈上。在数据段上(.data/.bss)<h3 id="static成员方法"><a href="#static成员方法" class="headerlink" title="static成员方法"></a>static成员方法</h3></li>
<li>普通成员方法 编译时参数列表会产生一个<strong>this指针</strong>，而static成员方法不产生<strong>形参this指针</strong>。因此，static成员方法不依赖于对象。</li>
<li>static成员方法可以访问私有成员变量，但是不能访问非static成员。（非static成员属于对象而非类，需要依赖于this指针；而static成员方法没有this指针）</li>
</ul>
<h2 id="指向类成员的指针"><a href="#指向类成员的指针" class="headerlink" title="指向类成员的指针"></a>指向类成员的指针</h2><h3 id="指向成员变量的指针"><a href="#指向成员变量的指针" class="headerlink" title="指向成员变量的指针"></a>指向成员变量的指针</h3><h4 id="普通成员"><a href="#普通成员" class="headerlink" title="普通成员"></a>普通成员</h4><ul>
<li>加上<strong>Test作用域</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = &amp;Test::m_a;</span><br><span class="line">编译前就error：<span class="keyword">int</span> Test:: *类型不能用于初始化 <span class="keyword">int</span>* 实体</span><br></pre></td></tr></table></figure></li>
<li><strong>加上对象</strong></li>
<li>m_a是依赖于对象的。不是属于类的。因此不能让指针直接修改这个字段。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_a;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_b;     <span class="comment">//  仅仅是一个声明，需要在类外进行定义。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Test::m_b;      <span class="comment">//  static成员 必须在类外定义/初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Test:: *p = &amp;Test::m_a  <span class="comment">//  ok</span></span><br><span class="line">*p = <span class="number">20</span>;    <span class="comment">//  error </span></span><br></pre></td></tr></table></figure></li>
<li>所以必须<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test t1;</span><br><span class="line"><span class="keyword">int</span> Test::* p = &amp;Test::m_a;</span><br><span class="line">t1.*p = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; t1.*p &lt;&lt; endl;	<span class="comment">//  20 </span></span><br><span class="line"></span><br><span class="line">   Test* t2 = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">t2-&gt;*p = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; t2-&gt;*p &lt;&lt; endl; <span class="comment">//  10</span></span><br></pre></td></tr></table></figure>
<h4 id="static成员-1"><a href="#static成员-1" class="headerlink" title="static成员"></a>static成员</h4></li>
<li>不依赖于对象<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p2 = &amp;Test::m_b;</span><br><span class="line">*p2 = <span class="number">9</span>;</span><br><span class="line">cout &lt;&lt; *p2 &lt;&lt; endl;    <span class="comment">//  9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="指向成员方法的指针"><a href="#指向成员方法的指针" class="headerlink" title="指向成员方法的指针"></a>指向成员方法的指针</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> m_a;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_b;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Test::m_b;</span><br></pre></td></tr></table></figure>
<h4 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test t;</span><br><span class="line"><span class="comment">//  void (*p)() = &amp;Test::func1;</span></span><br><span class="line"><span class="comment">//  void (Test::*)()&quot; 类型的值不能用于初始化 &quot;void (*)()&quot; 类型的实体</span></span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (Test::*p)() = &amp;Test::func1;</span><br><span class="line">(t.*p)();</span><br></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*p2)() = &amp;Test::func2;</span><br><span class="line">(*p2)();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>bind、function机制</title>
    <url>/2022/03/18/c++_bind%E3%80%81function%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>bind和function 极常用！！</li>
<li>bind1st：operator()的第一个形参绑定成一个确定的值</li>
<li>bind2nd：operator()的第二个形参绑定成一个确定的值</li>
<li>c++11从boost库引入了bind绑定器和function函数对象机制</li>
<li>lambda表达式：底层依赖函数对象的机制实现</li>
</ul>
<h2 id="bind1st、bind2nd（弃用）。bind更好用"><a href="#bind1st、bind2nd（弃用）。bind更好用" class="headerlink" title="bind1st、bind2nd（弃用）。bind更好用"></a>bind1st、bind2nd（弃用）。bind更好用</h2><ul>
<li>绑定器+二元函数对象 -&gt; 一元函数对象<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span> ; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">showContainer</span>(vec);</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()); <span class="comment">// 默认小到大排序</span></span><br><span class="line">	<span class="built_in">showContainer</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找第一个小于70的数字</span></span><br><span class="line">	<span class="comment">// operator()(const T &amp;val)</span></span><br><span class="line">	<span class="comment">// greater   a &gt; b</span></span><br><span class="line">	<span class="comment">// less      a &lt; b</span></span><br><span class="line">	<span class="comment">// 绑定器 + 二元函数对象 =》 一元函数对象</span></span><br><span class="line">	<span class="comment">// bind1st: + greater bool operator()(70, const _Ty&amp; _Right)</span></span><br><span class="line">	<span class="comment">// bind2nd: + less bool operator()(const _Ty&amp; _Left, 70)</span></span><br><span class="line">	<span class="keyword">auto</span> it1 = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">		<span class="built_in">bind1st</span>(less&lt;<span class="keyword">int</span>&gt;(), <span class="number">70</span>));</span><br><span class="line">    cout&lt;&lt;*it1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">28</span> <span class="number">21</span> <span class="number">82</span> <span class="number">75</span> <span class="number">89</span> <span class="number">90</span> <span class="number">7</span> <span class="number">4</span> <span class="number">82</span> <span class="number">79</span> <span class="number">57</span> <span class="number">31</span> <span class="number">41</span> <span class="number">91</span> <span class="number">58</span> <span class="number">38</span> <span class="number">74</span> <span class="number">63</span> <span class="number">63</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">9</span> <span class="number">21</span> <span class="number">28</span> <span class="number">31</span> <span class="number">38</span> <span class="number">41</span> <span class="number">57</span> <span class="number">58</span> <span class="number">63</span> <span class="number">63</span> <span class="number">74</span> <span class="number">75</span> <span class="number">79</span> <span class="number">82</span> <span class="number">82</span> <span class="number">89</span> <span class="number">90</span> <span class="number">91</span></span><br><span class="line"><span class="number">74</span></span><br></pre></td></tr></table></figure>


<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>bind1st底层原理<ul>
<li>bind1st -&gt; _bind1st<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by dell on 2022/3/18.</span></span><br><span class="line"><span class="comment">// 手写bind1st、bind2nd、my_find_if</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showContainer</span><span class="params">(Container &amp; con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  Container作为一个模板类型参数，当编译器遇到Container::mem这样的代码时，他不会知道mem是一个类型成员还是一个static数据成员，</span></span><br><span class="line">    <span class="comment">//  直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。</span></span><br><span class="line">    <span class="comment">//  默认情况下，C++假定通过作用域运算符::访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显示告诉编译器改名字是一个=类型。我们通过使用typename来实现这一点。</span></span><br><span class="line">    <span class="comment">//  typename：明确指出iterator是一个类型而非static数据成员。</span></span><br><span class="line">    <span class="keyword">typename</span> Container::iterator iter = con.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;iter!=con.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数模板怎么匹配的？？？Iterator和谁匹配？？</span></span><br><span class="line"><span class="comment">//  函数模板可以进行类型推演：根据我们传入的实参，可以把模板类型推演出来</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_find_if</span><span class="params">(Iterator first,Iterator last,Compare cmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( ; first!=last;++first)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">cmp</span>(*first))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  重载()，真正的一元函数对象</span></span><br><span class="line"><span class="comment">//  封装，真正做事情的还是那个二元函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">mybind1st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _mybind1st(Compare cmp,<span class="keyword">const</span> T&amp; t):_cmp(cmp),_val(t)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> T&amp; second)</span>     <span class="comment">//  要传入的参数（非绑定参数）</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _cmp(_val,second);        <span class="comment">//  绑定了第一个参数的二元函数</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Compare _cmp;      <span class="comment">//  二元函数</span></span><br><span class="line">    T _val;              <span class="comment">//  绑定的那个参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数模板：封装了一元对象的产生。</span></span><br><span class="line"><span class="comment">//  就是个中转站。传入函数和要绑定的参数。返回绑定完的一元函数对象。</span></span><br><span class="line"><span class="comment">//  函数模板作用：让用户无需指明类，直接传参数即可。如果直接用_mybind1st的话，则需要自己指明模板参数类型</span></span><br><span class="line"><span class="comment">//  使用函数模板：好处是可以进行类型推演。根据我们传入的实参，可以把模板类型推演出来。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Compare,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">_mybind1st&lt;Compare,T&gt; <span class="title">mybind1st</span><span class="params">(Compare cmp,<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _mybind1st&lt;Compare,T&gt;(cmp,val);      <span class="comment">//  生成一元函数对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">showContainer</span>(v);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">showContainer</span>(v);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator iter = <span class="built_in">my_find_if</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(), <span class="built_in">mybind1st</span>(greater&lt;<span class="keyword">int</span>&gt;(),<span class="number">70</span>));</span><br><span class="line">    cout&lt;&lt;*iter&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">58</span> <span class="number">82</span> <span class="number">80</span> <span class="number">86</span> <span class="number">74</span> <span class="number">69</span> <span class="number">79</span> <span class="number">22</span> <span class="number">68</span> <span class="number">60</span></span><br><span class="line"><span class="number">86</span> <span class="number">82</span> <span class="number">80</span> <span class="number">79</span> <span class="number">74</span> <span class="number">69</span> <span class="number">68</span> <span class="number">60</span> <span class="number">58</span> <span class="number">22</span></span><br><span class="line"><span class="number">86</span> <span class="number">82</span> <span class="number">80</span> <span class="number">79</span> <span class="number">74</span> <span class="number">69</span> <span class="number">68</span> <span class="number">60</span> <span class="number">58</span> <span class="number">22</span></span><br><span class="line"><span class="number">69</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><h3 id="用途：建立函数表"><a href="#用途：建立函数表" class="headerlink" title="用途：建立函数表"></a>用途：建立函数表</h3><ul>
<li>把所用的函数、绑定器、函数对象、lambda表达式的类型表达起来，否则绑定器和lambda表达式只能存在于语句之中，在其他语句还要重写绑定器和lambda表达式。</li>
<li>作用：建立函数表。switch不满足开闭原则，我们建立<code>map&lt;int,function&lt;void(void)&gt;&gt;</code>函数表来替代<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doShow</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;查看所有书籍&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBorrow</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;借书&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doBack</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;还书&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果用函数指针如 void(*)(void)    则second只能接受普通的全局函数。不能接受函数对象（如bind绑定器返回的函数对象；如函数对象类（仿函数）的对象）</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,function&lt;<span class="keyword">void</span>(<span class="keyword">void</span>)&gt;&gt; actionMap;</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>,doShow));</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,doBack&#125;);</span><br><span class="line">    actionMap.<span class="built_in">insert</span>(&#123;<span class="number">3</span>,doBorrow&#125;);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> choice;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;choice is&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;choice;</span><br><span class="line">        <span class="keyword">if</span>(actionMap.<span class="built_in">find</span>(choice)!=actionMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            actionMap[choice]();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;no choice&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>“渔夫在无法捕鱼时，就会修补他的网，在这段看似停滞不前的日子里，你可以休息但不要什么都不做”</p>
<h3 id="完全特例化和部分特例化"><a href="#完全特例化和部分特例化" class="headerlink" title="完全特例化和部分特例化"></a>完全特例化和部分特例化</h3><ul>
<li><p>必须先有个泛化的，然后才能有部分和全部特例化</p>
</li>
<li><p>泛化、特例化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  泛化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>     &#123;</span>    &#125;</span><br><span class="line"><span class="comment">//  就相当于 template&lt;typename T&gt; class B&lt;T&gt;&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&lt;</span><span class="built_in">R</span>(A)&gt;   &#123;   &#125;</span><br><span class="line"><span class="comment">//  class A&lt;内容&gt; &lt;&gt;中的内容，就是这个类在实例化时，&lt;&gt;钟要填入的东西的类型！</span></span><br><span class="line"><span class="comment">//  通过我们填入的东西，解析出R、A这两个模板参数分别是什么</span></span><br><span class="line"><span class="comment">//  如 B&lt;int(int)&gt; b(show) 就是 R：int 。A：int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; cout&lt;&lt;a&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 完全特例化和部分特例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  针对指针提供的部分特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>Ty*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&lt;Ty*&gt;&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对函数指针(有返回值，两个形参变量）提供的部分特例化</span></span><br><span class="line"><span class="comment">//  这三个合起来共同定义了一个类型 R(*)(A1,A2)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="built_in">R</span>(*)(A1,A2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&lt;R(*)(A1,A2)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  针对char*提供的完全特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="keyword">char</span>*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&lt;char*&gt;&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  针对函数提供的部分特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty,<span class="keyword">typename</span> R1,<span class="keyword">typename</span> R2&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="built_in">Ty</span>(R1,R2)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>()&#123;cout&lt;&lt;<span class="string">&quot;class Vector&lt;Ty(R1,R2)&gt;&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    Vector&lt;<span class="keyword">int</span>*&gt; v2;</span><br><span class="line">    Vector&lt;<span class="keyword">char</span>*&gt; v3;</span><br><span class="line">    Vector&lt;<span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; v4;</span><br><span class="line">    Vector&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; v5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">E:\Code\CLionCode\project02\cmake-build-debug\project02.exe</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span>Ty*&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="keyword">char</span>*&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="built_in">R</span>(*)(A1,A2)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;</span><span class="built_in">Ty</span>(R1,R2)&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://www.jianshu.com/p/f6904c7bdd31">typeid坑</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc就是那样的，只输出类型名的第一个字符，要输出完整的名字可以这样：</span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;typeinfo&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cxxabi.h&gt; //使用abi</span></span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">abi::__cxa_demangle(typeid(int).name(),0,0,0 )&lt;&lt;endl;</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="模板实参推演"><a href="#模板实参推演" class="headerlink" title="模板实参推演"></a>模板实参推演</h3><ul>
<li>非常非常强大的功能</li>
<li>将一个大类型（一个函数模板参数） 使用多个模板参数 拆分成多个小类型。便于使用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模板的实参推演 =》基本概念很简单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  T包含了所有的大的类型，返回值，所有形参的类型都取出来。</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(t).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将类型拆开 即将上面的 函数指针类型T 拆成 返回类型R  参数类型A1 A2组成的</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(R(*a)(A1,A2))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(R).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(A1).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(A2).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//              返回值     类类型     参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> T,<span class="keyword">typename</span> A1,<span class="keyword">typename</span> A2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">(R(T::*t)(A1,A2))</span>     <span class="comment">//  T:: 。怎么写，看typeid.name()就知道了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(R).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(A1).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;abi::__cxa_demangle(<span class="built_in"><span class="keyword">typeid</span></span>(A2).<span class="built_in">name</span>(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> )&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(sum);</span><br><span class="line">    <span class="built_in">func2</span>(sum);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">func</span>(&amp;Test::sum);</span><br><span class="line">    <span class="built_in">func3</span>(&amp;Test::sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="params">(Test::*)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function">Test</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="function底层原理"><a href="#function底层原理" class="headerlink" title="function底层原理"></a>function底层原理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * function 底层原理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  得有泛化，才能有部分/全部特例化！！！</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myfunction</span>&#123;</span>&#125;; <span class="comment">//  默认泛化的是:class Myfunction&lt;Ty&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span>... A&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myfunction</span>&lt;</span><span class="built_in">R</span>(A...)&gt;       <span class="comment">//  void(void) ; int(int,int)... 这里就是我们用户在使用这个类时，&lt;&gt;所放的东西</span></span><br><span class="line">        <span class="comment">//  通过class Myfunction&lt;内容&gt; 内容，和实例化时Myfunction&lt;int(int,int)&gt;以及传入的实参，来解析出这个类的模板参数都是什么</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> PFUNC = <span class="built_in">R</span>(*)(A...);</span><br><span class="line">    <span class="built_in">Myfunction</span>(PFUNC pfunc):_pfunc(pfunc)&#123;&#125;</span><br><span class="line">    <span class="function">R <span class="title">operator</span><span class="params">()</span><span class="params">(A... args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _pfunc(args...);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PFUNC _pfunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;show&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Myfunction&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>&gt; <span class="title">f2</span><span class="params">(sum)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sum</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Myfunction&lt;<span class="title">void</span><span class="params">(<span class="keyword">void</span>)</span>&gt; <span class="title">f</span><span class="params">(show)</span></span>;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// terminal</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">show</span><br></pre></td></tr></table></figure>


<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="bind例子"><a href="#bind例子" class="headerlink" title="bind例子"></a>bind例子</h3><ul>
<li><strong>bind参数？</strong></li>
<li><code>std::bind(待绑定的函数对象/函数指针/成员函数指针,参数绑定值1,参数绑定值2,...,参数绑定值n);</code></li>
<li>参数一：函数对象/函数指针。（如果是临时对象的话，则不需要取地址）</li>
<li>其余参数：函数列表中的参数</li>
<li>如果有不想绑定的参数，那么需要用<code>placeholder::_x</code> 来占位，不能略过！！</li>
<li><a href="https://www.jianshu.com/p/f191e88dcc80">hh1</a> ；<a href="https://www.cnblogs.com/sixue/p/4013766.html#:~:text=bind%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA,%E7%9A%84%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E3%80%82">hh2</a><blockquote>
<p>bind的第一个参数是待绑定的函数对象或者函数指针,之后跟随多个参数以设定待绑定函数的参数绑定方式。待绑定函数有多少个参数,则bind后便需要多少个参数以一一声明其参数的绑定方法.当参数绑定为某一固定值时,则其对应参数绑定值可以使一个变量或常量.当需要将参数与绑定所生成的函数对象的某个参数相关联时,则需要用到在标准中预定义的几个常量_1、_2、_3等.这些常量声明在std::placeholders命名空间内.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt; f = <span class="built_in">bind</span>(greater&lt;<span class="keyword">int</span>&gt;(),placeholders::_1,<span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>(<span class="number">4</span>)&lt;&lt;endl;       <span class="comment">//  1</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>(<span class="number">1</span>)&lt;&lt;endl;       <span class="comment">//  0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a + b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> string &amp;str)</span></span>&#123;cout&lt;&lt;str&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  bind()返回函数对象</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">bind</span>(sum,<span class="number">10</span>,<span class="number">20</span>)()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">bind</span>(&amp;Test::sum,<span class="built_in">Test</span>(),<span class="number">10</span>,<span class="number">90</span>)()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  参数占位符</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">bind</span>(sum,placeholders::_1,placeholders::_2)(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如何保留下bind返回的函数对象？（如果不能保留下来，那么就只能一条语句用一次bind，很无语就）</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">void</span>)&gt; f = <span class="built_in">bind</span>(show,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind-和-function-实现简易线程池"><a href="#bind-和-function-实现简易线程池" class="headerlink" title="bind 和 function 实现简易线程池"></a>bind 和 function 实现简易线程池</h3><p><img src="/2022/03/18/c++_bind%E3%80%81function%E6%9C%BA%E5%88%B6/2022-03-19-18-54-00.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Thread 封装了线程函数，并承担了生成新线程的任务（要将函数装入线程来启动）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FUNC = function&lt;<span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>)&gt;;      <span class="comment">//  命名 function返回的函数对象类型为 void(int)</span></span><br><span class="line">    <span class="built_in">Thread</span>(FUNC func,<span class="keyword">int</span> id):_func(func),_id(id)&#123;&#125;;        <span class="comment">//  传入线程函数  注意线程函数必须是个C线程函数。也即不</span></span><br><span class="line">    <span class="function">thread <span class="title">start</span><span class="params">()</span>      <span class="comment">// 返回启动的线程</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(_func,_id)</span></span>;    <span class="comment">//  启动线程</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FUNC _func;</span><br><span class="line">    <span class="keyword">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadPool</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(Thread *t:_pool)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPool</span><span class="params">(<span class="keyword">int</span> sz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i)</span><br><span class="line">        &#123;    <span class="comment">//  bind返回函数对象                 bind (函数地址,函数列表参数1 this，函数列表参数2 未知参数、用placeholder占位);</span></span><br><span class="line">                                            <span class="comment">// (类成员函数在编译时，会生成this指针在参数列表首位）</span></span><br><span class="line">            _pool.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Thread</span>(<span class="built_in">bind</span>(&amp;ThreadPool::runInThread,<span class="keyword">this</span>,placeholders::_1),i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _handler.<span class="built_in">push_back</span>(_pool[i]-&gt;<span class="built_in">start</span>());  <span class="comment">// start 返回启动的线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _handler[i].<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">runInThread</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;runInthread id = &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Thread*&gt; _pool;      <span class="comment">//  容器内的指针所指向的内存 需要我们手动释放</span></span><br><span class="line">    vector&lt;thread&gt; _handler;    <span class="comment">//  存放所有启动的线程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool tp;</span><br><span class="line">    tp.<span class="built_in">startPool</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runInthread id = runInthread id = <span class="number">3</span></span><br><span class="line">runInthread id = <span class="number">6</span></span><br><span class="line">runInthread id = <span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">runInthread id = <span class="number">8</span></span><br><span class="line">runInthread id = <span class="number">4</span></span><br><span class="line">runInthread id = <span class="number">7</span></span><br><span class="line">runInthread id = <span class="number">2</span></span><br><span class="line">runInthread id = <span class="number">9</span></span><br><span class="line">runInthread id = <span class="number">1</span></span><br></pre></td></tr></table></figure>


<h2 id="lambda表达式（很强大）"><a href="#lambda表达式（很强大）" class="headerlink" title="lambda表达式（很强大）"></a>lambda表达式（很强大）</h2><ul>
<li>生成函数对象的新方式</li>
<li><strong>[捕获外部变量](形参列表)-&gt;返回值{操作代码}</strong></li>
<li>如果返回值=void，那么”-&gt;void”可以省略</li>
<li>[捕获外部变量]<ul>
<li> <strong>[]</strong>:表示不捕获任何外部变量</li>
<li> <strong>[=]</strong>:以传值的方式捕获外部的所有变量</li>
<li> <strong>[&amp;]</strong>:以传引用的方式捕获外部的所有变量</li>
<li> <strong>[this]</strong>:捕获外部this指针</li>
<li> <strong>[=,&amp;a]</strong>:以传值的方式捕获外部的所有变量，但以传引用的方式捕获a变量</li>
<li> <strong>[a,b]</strong>:以值传递的方式捕获外部变量a和b</li>
<li> <strong>[a,&amp;b]</strong>:a以传值的方式捕获，b以传引用的方式捕获<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by dell on 2022/3/20.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数对象升级 -&gt; lambda表达式</span></span><br><span class="line"><span class="comment"> * 函数对象缺点：</span></span><br><span class="line"><span class="comment"> * 使用在泛型算法参数传递，比较/自定义操作，优先级队列，智能指针删除器</span></span><br><span class="line"><span class="comment"> * lambda语法：</span></span><br><span class="line"><span class="comment"> * [捕获外部变量](形参列表)-&gt;返回值&#123;操作代码&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果返回值=void，那么&quot;-&gt;void&quot;可以省略</span></span><br><span class="line"><span class="comment"> * [捕获外部变量]</span></span><br><span class="line"><span class="comment"> * []:表示不捕获任何外部变量</span></span><br><span class="line"><span class="comment"> * [=]:以传值的方式捕获外部的所有变量</span></span><br><span class="line"><span class="comment"> * [&amp;]:以传引用的方式捕获外部的所有变量</span></span><br><span class="line"><span class="comment"> * [this]:捕获外部this指针</span></span><br><span class="line"><span class="comment"> * [=,&amp;a]:以传值的方式捕获外部的所有变量，但以传引用的方式捕获a变量</span></span><br><span class="line"><span class="comment"> * [a,b]:以值传递的方式捕获外部变量a和b</span></span><br><span class="line"><span class="comment"> * [a,&amp;b]:a以传值的方式捕获，b以传引用的方式捕获</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line">class TestLambda</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestLambda</span>()&#123;&#125;</span><br><span class="line">    T <span class="built_in"><span class="keyword">operator</span></span>()(T a,T b) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  lambda生成函数对象传入泛型算法！这样就不用再去记忆greater，less。也不用bind绑定器绑定greater/less生成函数对象</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),</span><br><span class="line">         [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a)-&gt;<span class="keyword">void</span>&#123;cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator iter = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="keyword">int</span> a)-&gt;<span class="keyword">bool</span>&#123;<span class="keyword">return</span> a&lt;<span class="number">70</span>;&#125;);</span><br><span class="line">    vec.<span class="built_in">insert</span>(iter,<span class="number">70</span>);</span><br><span class="line">    for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a)-&gt;<span class="keyword">void</span>&#123;cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    TestLambda&lt;&gt; t;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">t</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  lambda表达式生成函数对象，替代我们写的模板函数对象类（冗余代码）</span></span><br><span class="line">    <span class="keyword">auto</span> t2 = [](<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">t2</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">4</span>,y = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">auto</span> t3 = [x,y] () <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> t = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = t;</span><br><span class="line"><span class="comment">//        如果没加mutable的话</span></span><br><span class="line"><span class="comment">//        Cannot assign to a variable captured by copy in a non-mutable lambda</span></span><br><span class="line"><span class="comment">//        不能在非可变lambda里修改按值捕获的变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">t3</span>();</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t4 = [&amp;x,&amp;y] () &#123;</span><br><span class="line">        <span class="keyword">int</span> t = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = t;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">t4</span>();</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Lambda原理"><a href="#Lambda原理" class="headerlink" title="Lambda原理"></a>Lambda原理</h3><ul>
<li>应该用什么类型来接收lamdba表达式返回的函数对象？/ 如何跨语句使用lambda表达式<ul>
<li>当然是<code>function</code></li>
</ul>
</li>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、函数表</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt;&gt; f;</span><br><span class="line">f[<span class="number">0</span>] = [](<span class="keyword">int</span> a ,<span class="keyword">int</span> b)-&gt;<span class="keyword">int</span>&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line">cout&lt;&lt;f[<span class="number">0</span>](<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、删除器</span><br><span class="line"><span class="comment">//  智能指针自定义删除器</span></span><br><span class="line">unique_ptr&lt;FILE*,function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE*)&gt;&gt; <span class="built_in">up1</span>(</span><br><span class="line">        (<span class="built_in">fopen</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)),</span><br><span class="line">        [](FILE* pf)-&gt;<span class="keyword">void</span>&#123; <span class="built_in">fclose</span>(pf);&#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 容器比较规则</span><br><span class="line"><span class="comment">//  灵活设定规则。并且可以对同一种对象进行不同规则比较</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="keyword">int</span> a):<span class="built_in">m_a</span>(a)&#123;&#125;</span><br><span class="line"><span class="comment">//    bool operator&lt; (const Data&amp; rd) const   //  如果自定义的话，必须是const函数。因为容器默认调用的比较函数对象的参数列表会用常量引用。而常量引用对象只能调用常量函数</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        return m_a&lt;rd.m_a;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  采用function 配合 lambda表达式</span></span><br><span class="line">    <span class="comment">//  更加灵活的定义比较规则。不用在类内内置&lt;号或者&gt;号。</span></span><br><span class="line">    <span class="keyword">using</span> FUNC = function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">const</span> Data&amp; rd1,<span class="keyword">const</span> Data&amp; rd2)&gt;;</span><br><span class="line">    priority_queue&lt;Data,vector&lt;Data&gt;,FUNC&gt; <span class="built_in">q</span>(</span><br><span class="line">            [](<span class="keyword">const</span> Data&amp; rd1,<span class="keyword">const</span> Data&amp; rd2)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rd1.<span class="built_in">getData</span>() &lt; rd2.<span class="built_in">getData</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">10</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Data</span>(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Sequence = vector&lt;_Tp&gt;,</span><br><span class="line">    <span class="keyword">typename</span> _Compare  = less&lt;<span class="keyword">typename</span> _Sequence::value_type&gt; &gt;</span><br><span class="line">class priority_queue&#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span>	_Sequence::value_type		value_type;</span><br><span class="line">    <span class="built_in">priority_queue</span>()</span><br><span class="line">	: <span class="built_in">c</span>(), <span class="built_in">comp</span>() &#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span></span></span><br><span class="line"><span class="function">    <span class="title">priority_queue</span><span class="params">(<span class="keyword">const</span> _Compare&amp; __x, _Sequence&amp;&amp; __s = _Sequence())</span></span></span><br><span class="line"><span class="function">    : c(std::move(__s)), comp(__x)</span></span><br><span class="line"><span class="function">    &#123;</span> std::<span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//  See queue::c for notes on these names.</span></span><br><span class="line">    _Sequence  c;</span><br><span class="line">    _Compare   comp;        <span class="comment">//  _comp为函数对象 _Compare为函数对象类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  less源码：所以自定义&lt;必须为const函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">less</span> :</span> <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">_GLIBCXX14_CONSTEXPR</span></span><br><span class="line"><span class="function">    <span class="keyword">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/33040213">reinterpret_cast</a></p>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p><a href="https://www.cnblogs.com/moodlxs/p/10111609.html">C++11 std::ref使用场景</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库连接池</title>
    <url>/2022/05/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>为了提高MySQL数据库（基于C/S设计）的访问瓶颈<ul>
<li>除了在服务器端增加缓存服务器缓（redis）存常用的数据之外。（减少磁盘IO）</li>
<li>还可以增加连接池，来提高MySQL Server的访问效率，在高并发情况下，大量的<br>TCP三次握手、MySQL Server连接认证、MySQL Server关闭连接回收资源和TCP四次挥手所耗费的性能时间也是很明显的，增加连接池就是为了减少这一部分的性能损耗。 </li>
</ul>
</li>
<li>本项目就是为了在C/C++项目中，提高MySQL Server的访问效率，实现基于C++代码的数据库连接池模块。</li>
</ul>
<h2 id="ConnectionPool"><a href="#ConnectionPool" class="headerlink" title="ConnectionPool"></a>ConnectionPool</h2><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><ul>
<li>这里的MySQL数据库编程直接采用oracle公司提供的MySQL C/C++客户端开发包，在VS上需要进行相应的头文件和库文件的配置，如下：<ul>
<li>头文件目录。<ul>
<li>右键项目 - C/C++ - 常规 - 附加包含目录，填写mysql.h头文件的路径</li>
</ul>
</li>
<li>库目录。<ul>
<li>右键项目 - 链接器 - 常规 - 附加库目录，填写libmysql.lib的路径</li>
</ul>
</li>
<li>静态库名字<ul>
<li>右键项目 - 链接器 - 输入 - 附加依赖项，填写libmysql.lib库的名字</li>
</ul>
</li>
<li>动态库<ul>
<li>把libmysql.dll动态链接库（Linux下后缀名是.so库）放在工程目录下</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="功能点"><a href="#功能点" class="headerlink" title="功能点"></a>功能点</h3><blockquote>
<p><img src="/2022/05/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/2022-05-04-11-49-07.png"></p>
</blockquote>
<ul>
<li>连接池一般包含了数据库连接所用的ip地址、port端口号、用户名和密码以及其它的性能参数，例如初始连接量，最大连接量，最大空闲时间、连接超时时间等，该项目是基于C++语言实现的连接池，主要也是实现以上几个所有连接池都支持的通用基础功能。</li>
<li>初始连接量（initSize）<ul>
<li>表示连接池事先会和MySQL Server创建initSize个数的connection连接，当应用发起MySQL访问时，不用再创建和MySQL Server新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放connection，而是把当前connection再归还到连接池当中。</li>
</ul>
</li>
<li>最大连接量（maxSize）<ul>
<li>当并发访问MySQL Server的请求增多时，初始连接量已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是新创建的连接数量上限是maxSize，不能无限制的创建连接，因为每一个连接都会占用一个socket资源，一般连接池和服务器程序是部署在一台主机上的，如果连接池占用过多的socket资源，那么服务器就不能接收太多的客户端请求了。当这些连接使用完成后，再次归还到连接池当中来维护</li>
</ul>
</li>
<li>最大空闲时间（maxIdleTime）<ul>
<li>当访问MySQL的并发请求多了以后，连接池里面的连接数量会动态<br>增加，上限是maxSize个，当这些连接用完再次归还到连接池当中。如果在指定的maxIdleTime里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连接量initSize个连接就可以了</li>
</ul>
</li>
<li>连接超时时间（connectionTimeout）<ul>
<li>当MySQL的并发请求量过大，连接池中的连接数量已经到达<br>maxSize了，而此时没有空闲的连接可供使用，那么此时应用从连接池获取连接无法成功，它通过阻塞的方式获取连接的时间如果超过connectionTimeout时间，那么获取连接失败，无法访问数据库。</li>
</ul>
</li>
<li>该项目主要实现上述的连接池四大基本功能</li>
</ul>
<h3 id="功能实现设计"><a href="#功能实现设计" class="headerlink" title="功能实现设计"></a>功能实现设计</h3><ul>
<li>ConnectionPool.cpp和ConnectionPool.h：连接池代码实现</li>
<li>Connection.cpp和Connection.h：数据库操作代码、增删改查代码实现</li>
<li>连接池主要包含了以下功能点：<ul>
<li>连接池只需要一个实例，所以ConnectionPool以单例模式进行设计</li>
<li>从ConnectionPool中可以获取和MySQL的连接Connection</li>
<li>空闲连接Connection全部维护在一个线程安全的Connection队列中，使用线程互斥锁保证队列的线程安全</li>
<li>如果Connection队列为空，还需要再获取连接，此时需要动态创建连接，上限数量是maxSize</li>
<li>队列中空闲连接时间超过maxIdleTime的就要被释放掉，只保留初始的initSize个连接就可以了，这个功能点肯定需要放在独立的线程中去做</li>
<li>如果Connection队列为空，而此时连接的数量已达上限maxSize，那么等待connectionTimeout时间<ul>
<li>如果还获取不到空闲的连接，那么获取连接失败，此处从Connection队列获取空闲连接，可以使用带s超时时间的mutex互斥锁来实现连接超时时间</li>
</ul>
</li>
<li>用户获取的连接用shared_ptr智能指针来管理，用lambda表达式定制连接释放的功能（不真正释放连接，而是把连接归还到连接池中）</li>
<li>连接的生产和连接的消费采用生产者-消费者线程模型来设计，使用了线程间的同步通信机制条件变量和互斥锁</li>
</ul>
</li>
</ul>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><ul>
<li><p>没用连接池<br><img src="/2022/05/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/2022-05-07-13-34-28.png"></p>
</li>
<li><p>用连接池<br><img src="/2022/05/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/2022-05-07-13-34-13.png"></p>
</li>
<li><p>connectionPool：管理连接的发起、存储、调用<br><img src="/2022/05/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/2022-05-06-23-25-27.png"></p>
</li>
<li><p>connection：具体连接的操作：增删改查等<br><img src="/2022/05/04/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/2022-05-06-23-25-53.png"></p>
</li>
</ul>
<h2 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h2><table>
<thead>
<tr>
<th>连接量</th>
<th>无连接池</th>
<th>有连接池</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>单线程 / 四线程</td>
<td>单线程 / 四线程</td>
</tr>
<tr>
<td>1000</td>
<td>3676ms / 3850ms</td>
<td>809ms / 410ms</td>
</tr>
<tr>
<td>5000</td>
<td>70142ms / 19898ms</td>
<td>3391ms /1478ms</td>
</tr>
<tr>
<td>10000</td>
<td>140369ms / 41888ms</td>
<td>6756ms / 2716ms</td>
</tr>
</tbody></table>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul>
<li>了解MySQL数据库编程、熟练单例模式、queue队列容器、C++11多线程编程、线程互斥、线程同步通信、unique_lock、基于CAS的原子整形、智能指针shared_ptr、lambda表达式、生产者-消费者线程模型。</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>测试代码中没有用到生产者线程<ul>
<li>因为空闲连接队列始终不为空，所以没有唤醒生产者线程的机会。</li>
<li>为什么空闲连接队列不为空？因为for循环，每个连接的生命周期就是一个循环内，过了这个循环，这个连接的生命周期就没了。我们重写了shared_ptr的析构器，析构器里做得事情是把连接放回连接池queue。所以连接池始终不为空。始终用的是一开始的那initSize个连接。</li>
</ul>
</li>
<li>那么生产者线程害有必要吗？<ul>
<li>很有必要。因为实际连接中，一个用户很有可能对这个连接进行长时间增删改查操作，所以放不回连接池。所以需要生产者造新线程，放入连接池。</li>
</ul>
</li>
</ul>
<ul>
<li>vector里面放裸指针导致内存泄漏<ul>
<li>无法在一开始定义时就在queu中放shared_ptr，因为我们在返还给用户时需要删除器是放回pool的queue；而在pool生命周期结束时我们需要的是delete这些Connection指针。只能在定义智能指针时设定删除器，无法后来改变。</li>
<li>所以只能在pool的析构函数里delete掉queue中的裸指针。</li>
</ul>
</li>
</ul>
<ul>
<li>共享资源queue的连接增加减少操作<ul>
<li>queue<ul>
<li>加入空闲连接：<ul>
<li>初始化</li>
<li>pool的生产者线程：生产空闲连接</li>
<li>client拿到的连接已过作用域/生命周期</li>
</ul>
</li>
<li>减少空闲连接：<ul>
<li>getConnection消费者线程：拿出空闲连接给用户</li>
<li>scann扫描线程：拿出多余空闲连接释放</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>为什么多线程就比单线程快？因为cpu是多核？</strong><ul>
<li>首先多线程还是有必要的：为了让用户体验好，不然第100个用户要等到前面99个用户都处理完才能做事。</li>
<li>为什么总体时间也变短了？是因为多核吗。</li>
</ul>
</li>
</ul>
<ul>
<li>线程分离后<ul>
<li>主线程main结束后，分离的线程也立刻结束</li>
<li>但是我记得APUE上好像没明确说。待验证。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">windows c++跨平台库</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;running&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(work)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">5000</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line">==============================================</span><br><span class="line">linux C</span><br><span class="line"><span class="keyword">void</span> *<span class="built_in">work</span>(<span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;running&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> id;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id,<span class="literal">NULL</span>,work,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./test.out </span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line">running</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul>
<li><a href="https://github.com/Cstardust/ConnectionPool/edit/main/README.md">仓库地址</a></li>
<li>CommonConnectionPool.h<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _COMMONCONNECTIONPOOL_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _COMMONCONNECTIONPOOL_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::<span class="keyword">atomic_int</span>;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"><span class="keyword">using</span> std::mutex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 线程池</span></span><br><span class="line"><span class="comment">* 单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonConnectionPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//  static函数：为了在还没有对象时就可调用</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> CommonConnectionPool* <span class="title">getCommonConnectionPool</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//  消费者线程</span></span><br><span class="line">	<span class="comment">//  给外部提供接口，从连接池重获取一个可用的空闲连接 </span></span><br><span class="line">	<span class="comment">//  我们需要重定义shared_ptr的析构器</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Connection&gt; <span class="title">getConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">CommonConnectionPool</span>(<span class="keyword">const</span> CommonConnectionPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	CommonConnectionPool&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CommonConnectionPool&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	~<span class="built_in">CommonConnectionPool</span>() &#123;	<span class="comment">//  释放资源</span></span><br><span class="line">		<span class="keyword">while</span> (!_connectionQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			Connection * p = _connectionQueue.<span class="built_in">front</span>();</span><br><span class="line">			<span class="keyword">delete</span> p;</span><br><span class="line">			_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//  构造函数私有</span></span><br><span class="line">	<span class="built_in">CommonConnectionPool</span>();		</span><br><span class="line">	<span class="comment">//  加载配置文件</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">loadConfigFile</span><span class="params">()</span></span>;		</span><br><span class="line">	<span class="comment">//  生产者线程</span></span><br><span class="line">	<span class="comment">//  运行在独立的线程中，专门负责生产新连接</span></span><br><span class="line">	<span class="comment">//  设置为成员函数而非全局函数的好处：可以方便的访问连接池中的成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">produceConnectionTask</span><span class="params">()</span></span>;	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  定时检测线程</span></span><br><span class="line">	<span class="comment">//  定时检测并释放空闲连接</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">scannConnectionTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  mysql信息</span></span><br><span class="line">	string _ip;					<span class="comment">//  mysql server ip</span></span><br><span class="line">	<span class="keyword">unsigned</span>  _port;			<span class="comment">//  mysql server port</span></span><br><span class="line">	string _name;				<span class="comment">//  mysql server 登录用户名</span></span><br><span class="line">	string _password;			<span class="comment">//  mysql server 登录密码</span></span><br><span class="line">	string _dbname;				<span class="comment">//  要访问的数据库名称</span></span><br><span class="line">	<span class="comment">//  配置连接池</span></span><br><span class="line">	<span class="keyword">int</span> _initSize;				<span class="comment">//  连接池的初始连接量    </span></span><br><span class="line">	<span class="keyword">int</span> _maxSize;				<span class="comment">//  连接池空闲连接的最大连接量	       1024个  queue里最多只能有1024个空闲连接。</span></span><br><span class="line">	<span class="keyword">int</span> _maxIdleTime;			<span class="comment">//  连接池中空闲连接的最大空闲时间	   60s  (在queue里待的最长时间）超过则释放。scan线程里用到。本压测代码不会触发。</span></span><br><span class="line">	<span class="keyword">int</span> _connectionTimeout;		<span class="comment">//  用户从连接池获取连接的超时时间     100ms  超时后则放弃获取连接。在getConnection线程里用到。本压测代码不会被触发。	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  连接池自己的成员</span></span><br><span class="line">	queue&lt;Connection*&gt; _connectionQueue;	<span class="comment">//  存储mysql连接的队列</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">atomic_int</span> _cntOfconns;	    <span class="comment">//  连接数目</span></span><br><span class="line">	condition_variable _cv;					<span class="comment">//  条件变量 （应用生产者消费者模型）</span></span><br><span class="line">	mutex _queueMtx;						<span class="comment">//  锁</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !_COMMONCONNECTIONPOOL_H_</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>CommonConnectionPool.cpp<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;CommonConnectionPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  atomic_int reuse_cnt = 0;</span></span><br><span class="line"><span class="comment">//  atomic_int produce_cnt = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">CommonConnectionPool* <span class="title">CommonConnectionPool::getCommonConnectionPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> CommonConnectionPool pool;</span><br><span class="line">	<span class="keyword">return</span> &amp;pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CommonConnectionPool::loadConfigFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//  以下应该可以用c++的文件流替换。整体写完再改</span></span><br><span class="line">	FILE* pf = <span class="built_in">fopen</span>(<span class="string">&quot;mysql.ini&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (pf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">		<span class="built_in">LOG</span>(<span class="string">&quot;mysql.ini file is not existed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">feof</span>(pf))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> line[<span class="number">512</span>];</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fgets</span>(line, <span class="number">512</span>, pf) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">string <span class="title">str</span><span class="params">(line)</span></span>;</span><br><span class="line">		<span class="keyword">int</span> idx = str.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span> (idx == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// username=root</span></span><br><span class="line">		<span class="keyword">int</span> end_idx = str.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>,idx);	<span class="comment">//  find(char,pos)。从pos开始招char</span></span><br><span class="line">		<span class="keyword">if</span> (end_idx == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="function">string <span class="title">key</span><span class="params">(str.substr(<span class="number">0</span>, idx))</span></span>;		<span class="comment">//  substr(pos,len)。从pos开始，截取长度为len的字符串</span></span><br><span class="line">		<span class="function">string <span class="title">val</span><span class="params">(str.substr(idx + <span class="number">1</span>, end_idx - <span class="number">1</span> - (idx + <span class="number">1</span>) + <span class="number">1</span>))</span></span>;</span><br><span class="line">		<span class="comment">//  以下是否可以用bind function替换？ 待研究</span></span><br><span class="line">		<span class="keyword">if</span> (key == <span class="string">&quot;ip&quot;</span>) &#123;</span><br><span class="line">			_ip = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&quot;port&quot;</span>) &#123;</span><br><span class="line">			_port = <span class="built_in">atoi</span>(val.<span class="built_in">c_str</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&quot;username&quot;</span>) &#123;</span><br><span class="line">			_name = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&quot;password&quot;</span>) &#123;</span><br><span class="line">			_password = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&quot;dbname&quot;</span>) &#123;</span><br><span class="line">			_dbname = val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&quot;initSize&quot;</span>) &#123;</span><br><span class="line">			_initSize = <span class="built_in">atoi</span>(val.<span class="built_in">c_str</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&quot;maxSize&quot;</span>) &#123;</span><br><span class="line">			_maxSize = <span class="built_in">atoi</span>(val.<span class="built_in">c_str</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&quot;maxIdleTime&quot;</span>) &#123;</span><br><span class="line">			_maxIdleTime = <span class="built_in">atoi</span>(val.<span class="built_in">c_str</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (key == <span class="string">&quot;maxConnectionTimeout&quot;</span>) &#123;</span><br><span class="line">			_connectionTimeout = <span class="built_in">atoi</span>(val.<span class="built_in">c_str</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  初始化</span></span><br><span class="line">CommonConnectionPool::<span class="built_in">CommonConnectionPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  加载配置</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">loadConfigFile</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;		<span class="comment">//   throw吧</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  创建初始数量的连接</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _initSize; ++i) &#123;</span><br><span class="line">		Connection* p = <span class="keyword">new</span> <span class="built_in">Connection</span>();</span><br><span class="line">		p-&gt;<span class="built_in">connect</span>(_ip, _port,_name, _password, _dbname);</span><br><span class="line">		_connectionQueue.<span class="built_in">push</span>(p);	<span class="comment">//  空闲连接加入队列</span></span><br><span class="line">		p-&gt;<span class="built_in">refreshAliveTime</span>();		<span class="comment">//  更新时间</span></span><br><span class="line">		++_cntOfconns;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  启动一个新的线程，作为连接的生产者。</span></span><br><span class="line">	<span class="comment">//  因为是成员函数，所以要传一个this</span></span><br><span class="line">	<span class="function">thread <span class="title">produce</span><span class="params">(&amp;CommonConnectionPool::produceConnectionTask, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">	produce.<span class="built_in">detach</span>();	<span class="comment">//  线程分离 </span></span><br><span class="line">	<span class="comment">//  扫描线程</span></span><br><span class="line">	<span class="function">thread <span class="title">scanner</span><span class="params">(&amp;CommonConnectionPool::scannConnectionTask, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">	scanner.<span class="built_in">detach</span>();	<span class="comment">//  线程分离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  生产者-消费者模型 </span></span><br><span class="line"><span class="comment">//  生产Connection。在队列不为空时不占cpu</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CommonConnectionPool::produceConnectionTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//  上锁</span></span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">uni_lck</span><span class="params">(_queueMtx)</span></span>;</span><br><span class="line">		<span class="comment">//  为空时再生产 其余时候阻塞 不占cpu</span></span><br><span class="line">		<span class="keyword">while</span> (!_connectionQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			_cv.<span class="built_in">wait</span>(uni_lck);			<span class="comment">//  1.释放锁 2.阻塞等待条件变量 3.条件变量符合后被唤醒 再次lock</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (_cntOfconns &lt; _maxSize) &#123;</span><br><span class="line">			<span class="comment">//  生产</span></span><br><span class="line">			Connection* pc = <span class="keyword">new</span> <span class="built_in">Connection</span>();</span><br><span class="line">			<span class="keyword">if</span> (!pc-&gt;<span class="built_in">connect</span>(_ip, _port, _name, _password, _dbname)) &#123;</span><br><span class="line">				<span class="built_in">LOG</span>(<span class="string">&quot;MySQL connection failed&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			++_cntOfconns;</span><br><span class="line">			_connectionQueue.<span class="built_in">push</span>(pc);</span><br><span class="line">			pc-&gt;<span class="built_in">refreshAliveTime</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//  cout&lt;&lt;&quot;produce_cnt &quot;&lt;&lt;produce_cnt++&lt;&lt;endl;</span></span><br><span class="line">		<span class="comment">//  唤醒其他阻塞在条件变量上的线程（消费者线程）</span></span><br><span class="line">		_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  消费者线程</span></span><br><span class="line"><span class="comment">//  给外部提供接口，从连接池中获取一个可用的空闲连接</span></span><br><span class="line"><span class="function">shared_ptr&lt;Connection&gt; <span class="title">CommonConnectionPool::getConnection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//  上锁</span></span><br><span class="line">	<span class="function">unique_lock&lt;mutex&gt; <span class="title">uni_lck</span><span class="params">(_queueMtx)</span></span>;</span><br><span class="line">	<span class="comment">//  等待</span></span><br><span class="line">	<span class="keyword">while</span> (_connectionQueue.<span class="built_in">empty</span>()) &#123;	<span class="comment">//  有可能两个消费者同时在等待条件变量，然后生产者生产了一个。有一个消费者先拿到，另一个没拿到。但是这种情况另一个虽然没拿到，可是生产者仍有能力再生产。所以要while循环。</span></span><br><span class="line">		<span class="comment">//  为空、通知生产</span></span><br><span class="line">		 _cv.<span class="built_in">notify_all</span>();</span><br><span class="line">		<span class="comment">//  等待_connectionTimeout ms</span></span><br><span class="line">		cv_status st = _cv.<span class="built_in">wait_for</span>(uni_lck,chrono::<span class="built_in">milliseconds</span>(_connectionTimeout));</span><br><span class="line">		<span class="keyword">if</span> (st == cv_status::timeout &amp;&amp; _connectionQueue.<span class="built_in">empty</span>()) &#123;		<span class="comment">//  超时且队列为空，则无法再获取新连接</span></span><br><span class="line">			<span class="built_in">LOG</span>(<span class="string">&quot;获取空闲连接超时，获取连接失败！&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  消费 返回给用户一个封装好的Connection智能指针。</span></span><br><span class="line">	<span class="comment">//  shared_ptr智能指针析构时，connection就被close掉了</span></span><br><span class="line">	<span class="comment">//  我们需要重定义shared_ptr释放资源的方式 使用lambda表达式</span></span><br><span class="line">	<span class="function">shared_ptr&lt;Connection&gt; <span class="title">sp</span><span class="params">(_connectionQueue.front(), [&amp;](Connection* pcon)-&gt;<span class="keyword">void</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="comment">//  cout&lt;&lt;&quot;reuse_cnt &quot;&lt;&lt;++reuse_cnt &lt;&lt; endl;</span></span></span></span><br><span class="line"><span class="params"><span class="function">			lock_guard&lt;mutex&gt; guard(_queueMtx);		<span class="comment">//  线程安全</span></span></span></span><br><span class="line"><span class="params"><span class="function">			_connectionQueue.push(pcon);</span></span></span><br><span class="line"><span class="params"><span class="function">			pcon-&gt;refreshAliveTime();</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line">	_connectionQueue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  队列为空，则通知生产</span></span><br><span class="line">	<span class="keyword">if</span> (_connectionQueue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  返回</span></span><br><span class="line">	<span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CommonConnectionPool::scannConnectionTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//  定时检查</span></span><br><span class="line">		this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(_maxIdleTime));	<span class="comment">//  60s</span></span><br><span class="line">		<span class="comment">//  扫描队列 释放资源</span></span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(_queueMtx)</span></span>;</span><br><span class="line">		<span class="keyword">while</span> (!(_connectionQueue.<span class="built_in">empty</span>()) &amp;&amp; _connectionQueue.<span class="built_in">size</span>()&gt;_initSize) &#123;</span><br><span class="line">			Connection* pt = _connectionQueue.<span class="built_in">front</span>();</span><br><span class="line">			<span class="keyword">if</span> (pt-&gt;<span class="built_in">getAliveTime</span>() &lt;= _maxIdleTime*<span class="number">1000</span>)	<span class="comment">//  靠前的没过期 那么靠后的也一定没过期</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			_connectionQueue.<span class="built_in">pop</span>();	<span class="comment">//  弹出</span></span><br><span class="line">			--_cntOfconns;			<span class="comment">//  队列数量--</span></span><br><span class="line">			<span class="keyword">delete</span> pt;				<span class="comment">//  关闭连接</span></span><br><span class="line">			<span class="built_in">LOG</span>(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 线程分离</span></span><br><span class="line"><span class="comment">* 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而</span></span><br><span class="line"><span class="comment">直接自己自动释放。网络、多线程服务器常用。</span></span><br><span class="line"><span class="comment">进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资</span></span><br><span class="line"><span class="comment">源仍存于系统中，导致内核认为该进程仍存在</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>Connection.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _CONNECTION_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CONNECTION_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;public.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据库操作类。负责与MySQL数据库进行交互。如连接Server，以及操作数据库文件。</span></span><br><span class="line"><span class="comment">//  Connection封装了MySQL第三方库提供的原生接口.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Connection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 初始化数据库连接</span></span><br><span class="line">	<span class="built_in">Connection</span>();</span><br><span class="line">	<span class="comment">// 释放数据库连接资源</span></span><br><span class="line">	~<span class="built_in">Connection</span>();</span><br><span class="line">	<span class="comment">// 连接数据库</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(string ip,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">unsigned</span> <span class="keyword">short</span> port, </span></span></span><br><span class="line"><span class="params"><span class="function">		string user, </span></span></span><br><span class="line"><span class="params"><span class="function">		string password,</span></span></span><br><span class="line"><span class="params"><span class="function">		string dbname)</span></span>;</span><br><span class="line">	<span class="comment">// 更新操作 insert、delete、update</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">(string sql)</span></span>;</span><br><span class="line">	<span class="comment">// 查询操作 select</span></span><br><span class="line">	<span class="function">MYSQL_RES* <span class="title">query</span><span class="params">(string sql)</span></span>;</span><br><span class="line">	<span class="comment">//  更新起始时间 ms为单位</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">refreshAliveTime</span><span class="params">()</span> </span>&#123; _alivetime = <span class="built_in">clock</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">clock_t</span> <span class="title">getAliveTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">clock</span>() -_alivetime;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL* _conn;			<span class="comment">//  表示和MySQL Server的一条连接</span></span><br><span class="line">	<span class="keyword">clock_t</span> _alivetime;		<span class="comment">//  记录进入空闲状态后的起始时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  mysql.h 里都是函数和结构体、变量的声明</span></span><br><span class="line"><span class="comment">//  函数的实现我们见不到，被封在动态库里了。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>Connection.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Connection.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据库连接</span></span><br><span class="line">Connection::<span class="built_in">Connection</span>()</span><br><span class="line">&#123;</span><br><span class="line">	_conn = <span class="built_in">mysql_init</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放数据库连接资源</span></span><br><span class="line">Connection::~<span class="built_in">Connection</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">LOG</span>(<span class="string">&quot;~Connection&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (_conn != <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="built_in">mysql_close</span>(_conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line"><span class="comment">//  讲MySQL* _conn连接到MySQL server上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Connection::connect</span><span class="params">(string ip, <span class="keyword">unsigned</span> <span class="keyword">short</span> port, string user, string password,string dbname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MYSQL* p = <span class="built_in">mysql_real_connect</span>(_conn, ip.<span class="built_in">c_str</span>(), user.<span class="built_in">c_str</span>(),</span><br><span class="line">		password.<span class="built_in">c_str</span>(), dbname.<span class="built_in">c_str</span>(), port, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> p != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新操作 insert、delete、update</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Connection::update</span><span class="params">(string sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">LOG</span>(<span class="string">&quot;更新失败:&quot;</span> + sql);</span><br><span class="line">		cout &lt;&lt; <span class="built_in">mysql_errno</span>(_conn) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">mysql_error</span>(_conn) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询操作 select</span></span><br><span class="line"><span class="function">MYSQL_RES* <span class="title">Connection::query</span><span class="params">(string sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">mysql_query</span>(_conn, sql.<span class="built_in">c_str</span>()))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">LOG</span>(<span class="string">&quot;查询失败:&quot;</span> + sql);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mysql_use_result</span>(_conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>main.cpp</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Connection.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;CommonConnectionPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn / <span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Connection conn;</span><br><span class="line">		<span class="keyword">char</span> sql[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into user(name,age,sex) values(&#x27;%s&#x27;,%d,&#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">			<span class="string">&quot;zhang san&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>);</span><br><span class="line">		conn.<span class="built_in">connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">13306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;C361456shc&quot;</span>, <span class="string">&quot;chat&quot;</span>);</span><br><span class="line">		conn.<span class="built_in">update</span>(sql);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//  CommonConnectionPool* p = CommonConnectionPool::getCommonConnectionPool();</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	//  添加测试MySQL第三方库接口</span></span><br><span class="line"><span class="comment">	Connection conn;</span></span><br><span class="line"><span class="comment">	char sql[1024];</span></span><br><span class="line"><span class="comment">	sprintf(sql, &quot;insert into user(name,age,sex) values(&#x27;%s&#x27;,%d,&#x27;%s&#x27;)&quot;, </span></span><br><span class="line"><span class="comment">		&quot;zhang san&quot;, 20, &quot;female&quot;);</span></span><br><span class="line"><span class="comment">	conn.connect(&quot;127.0.0.1&quot;, 13306, &quot;root&quot;, &quot;C361456shc&quot;,&quot;chat&quot;);</span></span><br><span class="line"><span class="comment">	conn.update(sql);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="keyword">clock_t</span> bg = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		Connection conn;</span><br><span class="line">		<span class="keyword">char</span> sql[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into user(name,age,sex) values(&#x27;%s&#x27;,%d,&#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">			<span class="string">&quot;zhang san&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>);</span><br><span class="line">		conn.<span class="built_in">connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">13306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;C361456shc&quot;</span>, <span class="string">&quot;chat&quot;</span>);</span><br><span class="line">		conn.<span class="built_in">update</span>(sql);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">clock_t</span> ed = <span class="built_in">clock</span>();</span><br><span class="line">	cout &lt;&lt; (ed - bg) &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">clock_t</span> bg = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="comment">//  加载配置文件、创建initSize连接、开启生产者线程、开启扫描线程</span></span><br><span class="line">	CommonConnectionPool *p = CommonConnectionPool::<span class="built_in">getCommonConnectionPool</span>();	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> sql[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">sprintf</span>(sql, <span class="string">&quot;insert into user(name,age,sex) values(&#x27;%s&#x27;,%d,&#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">			<span class="string">&quot;zhang san&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>);</span><br><span class="line">		<span class="comment">//  从连接池pool中获取连接connection</span></span><br><span class="line">		shared_ptr&lt;Connection&gt; sp = p-&gt;<span class="built_in">getConnection</span>();</span><br><span class="line">		<span class="comment">//  对connection进行操作</span></span><br><span class="line">		sp-&gt;<span class="built_in">connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">13306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;C361456shc&quot;</span>, <span class="string">&quot;chat&quot;</span>);</span><br><span class="line">		sp-&gt;<span class="built_in">update</span>(sql);</span><br><span class="line">		<span class="comment">//  一轮结束之后，sp就会调用删除器，把这个Connection*放回pool的queue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">clock_t</span> ed = <span class="built_in">clock</span>();</span><br><span class="line">	cout &lt;&lt; (ed - bg) &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	 Connection conn;</span><br><span class="line">	 conn.<span class="built_in">connect</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">13306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;C361456shc&quot;</span>, <span class="string">&quot;chat&quot;</span>);</span><br><span class="line">	<span class="keyword">clock_t</span> bg = <span class="built_in">clock</span>();</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(work)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(work)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t3</span><span class="params">(work)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t4</span><span class="params">(work)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	t3.<span class="built_in">join</span>();</span><br><span class="line">	t4.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">clock_t</span> ed = <span class="built_in">clock</span>();</span><br><span class="line">	std::cout &lt;&lt; (ed - bg) &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">clock_t</span> bg = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">	CommonConnectionPool* p = CommonConnectionPool::<span class="built_in">getCommonConnectionPool</span>();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span>;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn / <span class="number">4</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">		&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">char</span> sql[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">			sprintf(sql, <span class="string">&quot;insert into user(name,age,sex) values(&#x27;%s&#x27;,%d,&#x27;%s&#x27;)&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="string">&quot;zhang san&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			shared_ptr&lt;Connection&gt; sp = p-&gt;getConnection();</span></span></span><br><span class="line"><span class="params"><span class="function">			sp-&gt;connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">13306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;C361456shc&quot;</span>, <span class="string">&quot;chat&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			sp-&gt;update(sql);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn / <span class="number">4</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">		&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">char</span> sql[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">			sprintf(sql, <span class="string">&quot;insert into user(name,age,sex) values(&#x27;%s&#x27;,%d,&#x27;%s&#x27;)&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="string">&quot;zhang san&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			shared_ptr&lt;Connection&gt; sp = p-&gt;getConnection();</span></span></span><br><span class="line"><span class="params"><span class="function">			sp-&gt;connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">13306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;C361456shc&quot;</span>, <span class="string">&quot;chat&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			sp-&gt;update(sql);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t3</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn / <span class="number">4</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">		&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">char</span> sql[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">			sprintf(sql, <span class="string">&quot;insert into user(name,age,sex) values(&#x27;%s&#x27;,%d,&#x27;%s&#x27;)&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="string">&quot;zhang san&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			shared_ptr&lt;Connection&gt; sp = p-&gt;getConnection();</span></span></span><br><span class="line"><span class="params"><span class="function">			sp-&gt;connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">13306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;C361456shc&quot;</span>, <span class="string">&quot;chat&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			sp-&gt;update(sql);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">t4</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn / <span class="number">4</span>; ++i)</span></span></span><br><span class="line"><span class="params"><span class="function">		&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="keyword">char</span> sql[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">			sprintf(sql, <span class="string">&quot;insert into user(name,age,sex) values(&#x27;%s&#x27;,%d,&#x27;%s&#x27;)&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="string">&quot;zhang san&quot;</span>, <span class="number">20</span>, <span class="string">&quot;female&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			shared_ptr&lt;Connection&gt; sp = p-&gt;getConnection();</span></span></span><br><span class="line"><span class="params"><span class="function">			sp-&gt;connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">13306</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;C361456shc&quot;</span>, <span class="string">&quot;chat&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">			sp-&gt;update(sql);</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">		&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	t3.<span class="built_in">join</span>();</span><br><span class="line">	t4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">clock_t</span> ed = <span class="built_in">clock</span>();</span><br><span class="line">	cout &lt;&lt; (ed - bg) &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>数据库编程</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11汇总</title>
    <url>/2022/03/21/c++11_%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88792621?spm=1001.2014.3001.5502">参考博客</a></li>
<li><a href="https://paul.pub/cpp-concurrency/#id-%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD">优秀教程</a></li>
</ul>
<ul>
<li><code>thread(window: createThread / Linux:pthread_create)、mutex、condition_variable</code></li>
<li><code>lock_guard、unique_lock</code><ul>
<li><code>lock_guard</code> - <code>scoped_ptr</code>：左右拷贝构造，左右赋值函数都被delete</li>
<li><code>unique_lock</code> - <code>unique_ptr</code>：左拷贝构造和左赋值被delete，但有针对右值的拷贝构造和delete</li>
<li>两个类的析构函数都是unlock锁。不是把锁内存给释放了。</li>
<li>通过对lock和unlock进行一次薄的封装，实现自动unlock的功能。</li>
</ul>
</li>
<li><code>atomic</code> 原子类型 基于CAS操作的原子模型 线程安全</li>
<li><code>sleep for</code></li>
<li><code>join、detach</code><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2></li>
<li>涉及到线程互斥的操作。主要用的就是：**<code>std::mutex mtx</code>以及<code>lock_guard&lt;mutex&gt; mtx;</code>**</li>
</ul>
<h2 id="线程间的互斥-卖票"><a href="#线程间的互斥-卖票" class="headerlink" title="线程间的互斥 - 卖票"></a>线程间的互斥 - 卖票</h2><ul>
<li><strong>静态条件</strong>：随着cpu调度线程的顺序不同，会产生不同结果<ul>
<li>称为<strong>临界区代码段</strong></li>
</ul>
</li>
<li><strong>解决方法</strong>：<ul>
<li>每次进入临界区代码段时，要保证<strong>原子操作</strong>，所以用<strong>互斥锁mutex</strong> 或者 <strong>轻量级的无锁机制</strong></li>
</ul>
</li>
<li>Linux下，thread底层调用pthread_mutex_t<ul>
<li><code>strace ./a.out mutex -&gt; pthread_mutex_t</code></li>
</ul>
</li>
<li>线程间的互斥 ——》 互斥锁mutex ——》lock_guard封装mutex</li>
<li>为什么锁 + 双重判断<ul>
<li><img src="/2022/03/21/c++11_%E5%A4%9A%E7%BA%BF%E7%A8%8B/2022-03-21-21-55-43.png"></li>
</ul>
</li>
<li>–cnt过程<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov eax,cnt;    <span class="comment">//  移入寄存器eax</span></span><br><span class="line">sub eax,<span class="number">1</span>;      <span class="comment">//  在寄存器eax中计算</span></span><br><span class="line">mov cnt,eax     <span class="comment">//  讲计算结果放回cnt</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="/2022/03/21/c++11_%E5%A4%9A%E7%BA%BF%E7%A8%8B/2022-05-06-09-29-49.png"></p>
</blockquote>
</li>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::mutex;       <span class="comment">//  全局的一把互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">100</span>;</span><br><span class="line">mutex mutx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sell_tickets</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cnt&gt;<span class="number">0</span>)    <span class="comment">//  锁 + 双重判断cnt   </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// mutx.lock();</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  即使下面的代码段return了，也会保证可以释放掉锁，防止死锁问题的发生。</span></span><br><span class="line">            <span class="comment">//  临界区代码段 -》原子操作 -》线程间互斥操作 -》mutex</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutx)</span></span>; <span class="comment">//  在离开其所在作用于之后，会自动释放这个锁</span></span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;<span class="number">0</span>)       <span class="comment">//  双重锁</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;sell the &quot;</span>&lt;&lt;cnt&lt;&lt;<span class="string">&quot;th ticket&quot;</span>&lt;&lt;endl;</span><br><span class="line">                --cnt;      <span class="comment">//  mov eax,cnt</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// mutx.unlock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;thread&gt; tlist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tlist.<span class="built_in">push_back</span>(<span class="built_in">thread</span>(sell_tickets,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(list&lt;thread&gt;::iterator iter = tlist.<span class="built_in">begin</span>();iter!=tlist.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        iter-&gt;<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线程间的同步通信"><a href="#线程间的同步通信" class="headerlink" title="线程间的同步通信"></a>线程间的同步通信</h2><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><ul>
<li>理解：线程二要做的事情依赖于线程一做的事情的结果。而互斥并不依赖，互斥是只要两个线程不同时进入临界区即可。<h3 id="生产者、消费者模型"><a href="#生产者、消费者模型" class="headerlink" title="生产者、消费者模型"></a>生产者、消费者模型</h3><h4 id="互斥和通信的区别"><a href="#互斥和通信的区别" class="headerlink" title="互斥和通信的区别"></a>互斥和通信的区别</h4></li>
<li>互斥只是两/多个线程不同时进入同一代码块，没有其他信息的沟通</li>
<li>通信是在互斥的基础上，两/多个线程不进入统一代码块。并且，运行完的线程还会根据自己运行的的结果/信息，去通知另一个线程是否可以开始工作。</li>
<li>如果只互斥，但是不通信的话<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mtx; <span class="comment">// 定义互斥锁，做线程间的互斥操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="comment">// 生产物品</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>; <span class="comment">// scoped_ptr</span></span><br><span class="line">		que.<span class="built_in">push</span>(val);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;生产者 生产:&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;号物品&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">// 消费物品</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>; <span class="comment">// scoped_ptr</span></span><br><span class="line">		<span class="keyword">int</span> val = que.<span class="built_in">front</span>();</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		cv.<span class="built_in">notify_all</span>(); <span class="comment">// 通知其它线程我消费完了，赶紧生产吧</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;消费者 消费:&quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;号物品&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> val;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(Queue *que)</span> <span class="comment">// 生产者线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		que-&gt;<span class="built_in">put</span>(i);</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Queue *que)</span> <span class="comment">// 消费者线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		que-&gt;<span class="built_in">get</span>();</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Queue que; <span class="comment">// 两个线程共享的队列</span></span><br><span class="line"></span><br><span class="line">	<span class="function">std::thread <span class="title">t1</span><span class="params">(producer, &amp;que)</span></span>;</span><br><span class="line">	<span class="function">std::thread <span class="title">t2</span><span class="params">(consumer, &amp;que)</span></span>;</span><br><span class="line"></span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  0、625就是因为此时queue为空（按理来说应该会有段错误，但是可能由于queue是实现的原因，这里没有；换成list，就会发生段错误）</span></span><br><span class="line">producer produce: <span class="number">1</span></span><br><span class="line">consumer consumes: <span class="number">1</span></span><br><span class="line">consumer consumes: <span class="number">625</span></span><br><span class="line">producer produce: <span class="number">2</span></span><br><span class="line">producer produce: <span class="number">3</span></span><br><span class="line">consumer consumes: <span class="number">3</span></span><br><span class="line">consumer consumes: <span class="number">625</span></span><br><span class="line">producer produce: <span class="number">4</span></span><br><span class="line">consumer consumes: <span class="number">0</span></span><br><span class="line">producer produce: <span class="number">5</span></span><br><span class="line">consumer consumes: <span class="number">0</span></span><br><span class="line">producer produce: <span class="number">6</span></span><br><span class="line">consumer consumes: <span class="number">0</span></span><br><span class="line">producer produce: <span class="number">7</span></span><br><span class="line">producer produce: <span class="number">8</span></span><br><span class="line">consumer consumes: <span class="number">8</span></span><br><span class="line">producer produce: <span class="number">9</span></span><br><span class="line">consumer consumes: <span class="number">9</span></span><br><span class="line">consumer consumes: <span class="number">0</span></span><br><span class="line">producer produce: <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h4><ul>
<li><p>目的：生产者生产一个物品，通知消费者消费一个；消费完了，消费者再通知生产者生产</p>
<ul>
<li>实现生产一个就消费一个的效果。（也有可能生产多个消耗多个吧）</li>
</ul>
</li>
<li><p>使用<strong>条件变量</strong>（信号量也能实现通信）</p>
</li>
<li><p><strong>pthread_cond_wait</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;lock);</span><br><span class="line"><span class="comment">//  (1) 释放绑定在当前线程上的lock锁</span></span><br><span class="line"><span class="comment">//  (2) 阻塞等待cond变量符合条件。（即等待另一个线程的pthread_cond_signal(&amp;cond))</span></span><br><span class="line"><span class="comment">//  (3) 前两个步骤结束后，wait返回，给当前线程上lock锁。如果没有得到锁，会阻塞等待。</span></span><br></pre></td></tr></table></figure></li>
<li><p>模型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">//  互斥锁。做线程间互斥操作</span></span><br><span class="line">std::condition_variable cv;     <span class="comment">//  条件变量。做线程间同步通信操作</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        lock_guard&lt;std::mutex&gt; lock(mtx );</span></span><br><span class="line">        <span class="function">unique_lock&lt;std::mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  queue empty</span></span><br><span class="line">            <span class="comment">//  生产者应该通知消费者区消费，消费完了，再继续生产</span></span><br><span class="line">            <span class="comment">//  wait：生产者线程</span></span><br><span class="line">            <span class="comment">//  # 1进入等待状态（等待条件变量通知） # 2 把mtx互斥锁释放掉</span></span><br><span class="line">            <span class="comment">//  防止锁在外面被释放</span></span><br><span class="line">            cv.<span class="built_in">wait</span>(ul);</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(idx);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * notify_one：通知1个</span></span><br><span class="line"><span class="comment">         * notify_all：通知所有</span></span><br><span class="line"><span class="comment">         * 其他线程得到通知，从</span></span><br><span class="line"><span class="comment">         * **等待状态 =》阻塞状态 =》获取互斥锁才能继续执行**</span></span><br><span class="line"><span class="comment">         * 等待：等待条件变量</span></span><br><span class="line"><span class="comment">         * 阻塞：等待锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>();    <span class="comment">//  唤醒其他所有线程</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;producer produce: &quot;</span>&lt;&lt;idx&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        lock_guard&lt;std::mutex&gt; lock(mtx);</span></span><br><span class="line">        <span class="function">unique_lock&lt;std::mutex&gt; <span class="title">ul</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;this_thread::<span class="built_in">get_id</span>()&lt;&lt;endl;</span><br><span class="line">            <span class="comment">//  wait：消费者线程</span></span><br><span class="line">            <span class="comment">//  # 1 进入等待状态（等待条件变量）</span></span><br><span class="line">            <span class="comment">//  # 2 释放mtx</span></span><br><span class="line">            cv.<span class="built_in">wait</span>(ul);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();    <span class="comment">//  通知其他线程我消费完了，赶紧生产吧</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;consumer consumes: &quot;</span>&lt;&lt;val&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  临界资源</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Producer</span><span class="params">(Queue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;<span class="built_in">put</span>(i);</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Consumer</span><span class="params">(Queue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;<span class="built_in">get</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(Producer,&amp;q)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(Consumer,&amp;q)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t3</span><span class="params">(Consumer,&amp;q)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t3.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">producer produce: <span class="number">1</span></span><br><span class="line">consumer consumes: <span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">producer produce: <span class="number">2</span></span><br><span class="line">consumer consumes: <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">producer produce: <span class="number">3</span></span><br><span class="line">consumer consumes: <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">producer produce: <span class="number">4</span></span><br><span class="line">consumer consumes: <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">...</span><br><span class="line">producer produce: <span class="number">100</span></span><br><span class="line">consumer consumes: <span class="number">100</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li>会不会出现消费者释放<code>mtx</code>锁被消费者抢到？发生了怎么办？<ul>
<li>当然会发生，不过没关系，如果此时<code>queue.empty</code>的话会被困在<code>while</code>里，阻塞在<code>cv.wait</code>。（我们写<code>while</code>就是为了防止这种情况。）（那个释放锁的消费者线程也是因为空而在<code>cv.wait</code>处释放的）</li>
<li>如果非空的话，就会接着消耗产品。</li>
</ul>
</li>
<li>会不会生产者线程<code>notify</code>唤醒<code>cv.wait</code>的生产者线程？消费者<code>notify</code>唤醒<code>cv.wait</code>消费者线程？<ul>
<li>无所谓，因为都会被<code>while</code>的判断条件困住。</li>
</ul>
</li>
<li>为什么用<code>unique_lock?</code><ul>
<li>因为<code>wait</code>函数参数要求传递<code>unique_lock</code>的引用</li>
<li><code>void wait(unique_lock&lt;mutex&gt;&amp; __lock) noexcept;</code></li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>std::mutex &lt;-&gt; pthread_mutx_t</code></li>
<li><code>std::condition_variable &lt;-&gt; pthread_cond_t</code></li>
<li>锁：<code>lock_guard</code>和<code>unique_lock</code>（封装<code>mutex</code>，管理<code>lock</code>和<code>unlock</code>）</li>
<li>条件变量：<code>condition_variable</code> <code>wait</code>和<code>notify_all</code>方法<h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2></li>
<li>通过对<code>lock</code>和<code>unlock</code>进行一次薄的封装，实现自动<code>unlock</code>的功能。</li>
<li><code>std::lock_guard</code>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁。 </li>
<li>类似于<code>scoped_ptr</code>。拷贝构造和赋值函数都被删除，只能在简单的互斥代码段下使用，不可能用于函数传值参（因为会发生拷贝构造）和返回值，（当然传递左值引用和指针是ok的）。</li>
<li><code>lock_guard</code> - <code>scoped_ptr</code>：左右拷贝构造，左右赋值函数都被<code>delete</code></li>
<li>为什么要用智能指针管理锁而非人为<code>lock、unlock</code>锁？为了防止我们写的代码有bug，没有走到人为<code>unlock</code>释放锁的那一步。所以通过<code>lock_guard</code>，就是一个<code>scoped_pt</code>r的管理<code>mutex</code>版本。它已经帮我们写好了（删除器）在析构函数中：<ul>
<li>有可能会在<code>lock()</code>和<code>unlock()</code>之间掷出异常，此时<code>mutx</code>还没解锁，后续再想使用，就是死锁（或者把函数声明<code>成noexcept</code>）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Mutex&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">lock_guard</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Mutex mutex_type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; __m)</span> : _M_device(__m)</span></span><br><span class="line"><span class="function">    &#123;</span> _M_device.<span class="built_in">lock</span>(); &#125;     <span class="comment">//  上锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">lock_guard</span>(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>) <span class="keyword">noexcept</span> : _M_device(__m)</span><br><span class="line">    &#123; &#125; <span class="comment">// calling thread owns mutex</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">lock_guard</span>()             <span class="comment">//  解锁</span></span><br><span class="line">    &#123; _M_device.<span class="built_in">unlock</span>(); &#125;       <span class="comment">//  离开作用域时就unlock解锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  拷贝构造和赋值函数 delete</span></span><br><span class="line">  <span class="comment">//  也意味着lock_guard只能用于比较简单的情况，不能同于函数传参</span></span><br><span class="line">    <span class="built_in">lock_guard</span>(<span class="keyword">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    lock_guard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    mutex_type&amp;  _M_device;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>  <img src="/2022/03/21/c++11_%E5%A4%9A%E7%BA%BF%E7%A8%8B/2022-03-23-08-57-35.png"></p>
<h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><ul>
<li><code>std::unique_lock</code>，与 <code>Mutex RAII</code> 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。 </li>
<li>通过对<code>lock</code>和<code>unlock</code>进行一次薄的封装，实现自动<code>unlock</code>的功能。</li>
<li><code>unique_lock</code>源码<ul>
<li><code>unique_lock</code> - <code>unique_ptr</code>：左拷贝构造和左赋值被<code>delete</code>，但有针对右值的拷贝构造和赋值</li>
<li>这也意味着，可以以右值形式作为参数传递和返回。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Mutex&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_lock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Mutex mutex_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_lock</span>(<span class="keyword">const</span> unique_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    unique_lock&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> unique_lock&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique_lock</span>(unique_lock&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">    : _M_device(__u._M_device), _M_owns(__u._M_owns)</span><br><span class="line">    &#123;</span><br><span class="line">        __u._M_device = <span class="number">0</span>;</span><br><span class="line">        __u._M_owns = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>构造函数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//  只举两个</span></span><br><span class="line">   <span class="built_in">unique_lock</span>() <span class="keyword">noexcept</span></span><br><span class="line">       : _M_device(<span class="number">0</span>), _M_owns(<span class="literal">false</span>)</span><br><span class="line">       &#123; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">unique_lock</span><span class="params">(mutex_type&amp; __m)</span></span></span><br><span class="line"><span class="function">   : _M_device(std::__addressof(__m)), _M_owns(false)</span></span><br><span class="line"><span class="function">   &#123;</span></span><br><span class="line">       <span class="built_in">lock</span>();         <span class="comment">//  上锁    </span></span><br><span class="line">       _M_owns = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// lock():	    _</span></span><br><span class="line">   <span class="comment">//     M_device-&gt;lock();</span></span><br><span class="line"><span class="comment">//    _M_owns = true;</span></span><br></pre></td></tr></table></figure></li>
<li>成员<ul>
<li>指向锁的指针。（为了-&gt;lock()和-&gt;unlock())<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">mutex_type*	_M_device;</span><br><span class="line"><span class="keyword">bool</span>		_M_owns;        <span class="comment">//  该锁是否上已经锁</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>析构。负责释放锁。<ul>
<li>如果lock的话，那么释放锁。并没有销毁锁<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">unique_lock</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_M_owns)</span><br><span class="line">  <span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><ul>
<li>通过硬件实现原子操作，不用锁（太重）</li>
<li>不同线程栈不同，但是堆和数据段共享。（全局变量在数据段上）（数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域）</li>
<li>而对于共享的变量，多线程会进行缓存。所以应该加上volatile。意思：防止多线程对其进行缓存。使得各线程访问的都是原始变量的值。<ul>
<li>volatile防止了多线程对对共享变量进行缓存，保证了每次数据都是从原始内存拿，而不是有一定安全性风险的寄存器。</li>
</ul>
</li>
<li>为什么会有缓存？：线程好不容易占一次cpu，还要从内存取数据再跑到cpu</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span> <span class="comment">// 包含了很多原子类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++11 </span></span><br><span class="line"><span class="comment">窗口卖票   int count=100;</span></span><br><span class="line"><span class="comment">lock_guard&lt;std::mutex&gt; guard(mtx);</span></span><br><span class="line"><span class="comment">count++;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lock_guard&lt;std::mutex&gt; guard(mtx);</span></span><br><span class="line"><span class="comment">count--;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">互斥锁是比较重的，临界区代码做的事情稍稍复杂，多</span></span><br><span class="line"><span class="comment">系统理论：CAS来保证上面++ --操作的原子特性就足够了， 无锁操作</span></span><br><span class="line"><span class="comment">        exchange/swap    无锁队列 =&gt; CAS来实现的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">volatile</span> std::<span class="keyword">atomic_bool</span> isReady = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">volatile</span> std::<span class="keyword">atomic_int</span> mycount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!isReady)</span><br><span class="line">	&#123;</span><br><span class="line">		std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 线程出让当前的CPU时间片，等待下一次调度</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		mycount++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;std::thread&gt; tlist;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		tlist.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(task));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">	isReady = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (std::thread &amp;t : tlist)</span><br><span class="line">	&#123;</span><br><span class="line">		t.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mycount:&quot;</span> &lt;&lt; mycount &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>new_delete</title>
    <url>/2022/04/04/c++_new-delete/</url>
    <content><![CDATA[<h2 id="new、malloc区别。free、delete区别"><a href="#new、malloc区别。free、delete区别" class="headerlink" title="new、malloc区别。free、delete区别"></a>new、malloc区别。free、delete区别</h2><ul>
<li>malloc free 称为C的库函数</li>
<li>new delete 称作运算符<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>();</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">==================================</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(...);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="malloc和new的区别？"><a href="#malloc和new的区别？" class="headerlink" title="malloc和new的区别？"></a>malloc和new的区别？</h3><ul>
<li><code>new</code>调用<code>operator new</code>，<code>operator new</code>调用<code>malloc</code></li>
<li>malloc按<strong>字节</strong>开辟内存的；new开辟内存时需要<strong>指定类型</strong> new int[10]；所以malloc开辟内存返回的都是void*  </li>
<li>malloc只负责开辟空间，new不仅仅有malloc的功能，可以进行数据的初始化<code>new int(20);   new int[20]();</code> </li>
<li>malloc开辟内存失败返回nullptr指针；new抛出的是bad_alloc类型的异常<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) cout &lt;&lt; <span class="string">&quot;wrong&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span>* pp = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc&amp; e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  int *pp = new int[20];  在堆上开辟后不会初始化</span></span><br><span class="line"><span class="keyword">int</span> *pp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>]();    <span class="comment">// 在堆上开辟后会初始化</span></span><br><span class="line"><span class="keyword">delete</span> []pp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h3><ul>
<li>先分配<code>memory</code>，再调用<code>ctor</code>（构造函数）</li>
<li><code>Complex* pc = new Complex(1,2);</code></li>
<li>编译器转化为<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="keyword">sizeof</span> Complex); <span class="comment">//分配内存 operator new 内部调用malloc(n)</span></span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);       <span class="comment">//强转</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);              <span class="comment">//构造 Complex::(pc,1,2); pc即为this</span></span><br></pre></td></tr></table></figure>
<h4 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h4></li>
<li>operator new仅仅负责开辟内存，在内存上写什么、任何与对象内容有关系的事情都与operator new无关<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">//  按Byte</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="有几种new"><a href="#有几种new" class="headerlink" title="有几种new"></a>有几种new</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//  定位new 在指定内存上构造对象</span></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="built_in"><span class="keyword">new</span></span> (&amp;data) <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;data&lt;&lt;endl; <span class="comment">//  5</span></span><br></pre></td></tr></table></figure>


<h3 id="free和delete的区别？"><a href="#free和delete的区别？" class="headerlink" title="free和delete的区别？"></a>free和delete的区别？</h3><ul>
<li>delete调用operator delete，operator delete 调用free</li>
<li>delete (int*)p: 调用析构函数；再free(p)</li>
</ul>
<p>new和delete能混用吗？C++为什么区分单个元素和数组的内存分配和释放呢？<br>new delete<br>new[] delete[]<br>对于普通的编译器内置类型 new/delete[]   new[]/delete</p>
<p>自定义的类类型，有析构函数，为了调用正确的析构函数，那么开辟对象数组的时候，<br>会多开辟4个字节，记录对象的个数</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a><strong>delete</strong></h3><ul>
<li>先调用<code>dtor</code>，再释放内存<code>memory</code></li>
<li><code>Complex *pc = new Complex(1,2);</code><br><code>delete pc</code></li>
<li>编译器转化为<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Complex::~<span class="built_in">Complex</span>(pc);  <span class="comment">//dtor 调用析构函数是为了释放（基类、派生类）成员指针管理的内存，而不会释放本对象本身占据的内存。</span></span><br><span class="line"><span class="comment">//  如果本对象是栈上的，那么离开作用域后会自动调用析构函数 ，然后释放内存（也就是说析构函数何释放本对象内存是两回事）。很可惜，new出来的对象在堆上，得手动调用operator delete释放。（所以要保证pc指向得位置是对的（虚基类里就不对））</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;    <span class="comment">//释放memory 内部调用 free(pc)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="operator-delete"><a href="#operator-delete" class="headerlink" title="operator delete"></a>operator delete</h4><ul>
<li>operator delete仅仅负责释放内存，在内存上析构什么对象、任何与对象内容有关系的事情都与operator new无关。之前就已经做完了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="new-delete-new-delete"><a href="#new-delete-new-delete" class="headerlink" title="new[] delete[] ; new delete"></a>new[] delete[] ; new delete</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * new：</span></span><br><span class="line"><span class="comment"> * void *mem = operator new(size);</span></span><br><span class="line"><span class="comment"> * p = static_case&lt;&gt;(mem);</span></span><br><span class="line"><span class="comment"> * p-&gt;crot();;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * delete:</span></span><br><span class="line"><span class="comment"> * p-&gt;dtor;</span></span><br><span class="line"><span class="comment"> * operator delete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator new : &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete : &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator new[] &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete[] &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>new[] delete[]正常使用</li>
<li>new[]<ul>
<li>除了开辟对象内存之外，还会在栈顶方向(p-8)开辟一块内存用于记录对象个数。</li>
<li>用于释放数组时，得知需要调用几个对象的析构函数</li>
<li>delete时会从那块内存(p-8)开始释放</li>
</ul>
</li>
<li>delete[]<ul>
<li>会从对象栈顶方向4/8bytes开始。也会把那块内存的数据当作要析构的对象个数<br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-28-22.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test* p2 = <span class="keyword">new</span> Test[<span class="number">5</span>]; </span><br><span class="line"><span class="comment">//  除了开辟对象内存之外，还会在栈顶方向(p-8)开辟一块内存用于记录对象个数。</span></span><br><span class="line"><span class="comment">//  delete时也会连带释放那块内存(p-8)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2:&quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] p2; <span class="comment">// Test[0]对象析构， 直接free(p2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>[] <span class="number">0000021E55300</span>DF0</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">p2:<span class="number">0000021E55300</span>DF8</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[] <span class="number">0000021E55300</span>DF0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>new delete<br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-33-46.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test* p1 = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 : &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> : <span class="number">000001</span>A1BF04D6B0</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">p1 : <span class="number">000001</span>A1BF04D6B0</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span> : <span class="number">000001</span>A1BF04D6B0</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>new delete[]混用后果<br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-21-28.png"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> data = <span class="number">10</span>) &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test* p1 = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">delete</span>[]p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> : <span class="number">000001</span>D8BC681C50</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">p1 : <span class="number">000001</span>D8BC681C50</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>() ...死循环</span><br></pre></td></tr></table></figure>
<ul>
<li>new[] delete<ul>
<li>只会调用一个对象的析构函数，并且用于记录对象个数的内存没有被释放<br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-35-26.png"><br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-38-47.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Test* p2 = <span class="keyword">new</span> Test[<span class="number">5</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2:&quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p2; <span class="comment">// Test[0]对象析构， 直接free(p2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>[] <span class="number">00000299</span>D1C59BA0</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">p2:<span class="number">00000299</span>D1C59BA8</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span> : <span class="number">00000299</span>D1C59BA8</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><ul>
<li>简单来说：将对象所占的内存提前开辟出来，放到一个池子里面（链表维护），当需要构造对象的时候，就从池子里面取出内存来在那上面构造。<br><img src="/2022/04/04/c++_new-delete/2022-04-04-15-51-16.png"></li>
</ul>
<h4 id="链式队列-内置对象池"><a href="#链式队列-内置对象池" class="headerlink" title="链式队列 + 内置对象池"></a>链式队列 + 内置对象池</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  对象池 链式队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _front = _rear = <span class="keyword">new</span> <span class="built_in">QueueItem</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        QueueItem *cur = _front , *ne=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ne = cur-&gt;_next;</span><br><span class="line">            <span class="keyword">delete</span> cur; <span class="comment">//  delete 时 会调用QueueItem类内重载的operator delete。while会将这些节点全部加入内存池。不过没释放。</span></span><br><span class="line">            cur = ne;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _rear-&gt;_next = <span class="keyword">new</span> <span class="built_in">QueueItem</span>(val);   <span class="comment">//  产生节点</span></span><br><span class="line">        _rear = _rear-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        QueueItem *first = _front-&gt;_next;</span><br><span class="line">        _front-&gt;_next = first-&gt;_next;</span><br><span class="line">        <span class="keyword">delete</span> first;</span><br><span class="line">        <span class="keyword">if</span>(_front-&gt;_next==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _rear = _front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> _front-&gt;_next-&gt;_data;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _front==_rear;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * new :    operator new ; 强转 ; 构造函数 ; 返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//  给QueueItem提供内存管理 operator new ; operator delete</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueItem</span>    //  内置节点类型</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">QueueItem</span>(T data = <span class="built_in">T</span>() , QueueItem *next=<span class="literal">nullptr</span>)</span><br><span class="line">            :_data(data),_next(next)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  编译器会自动处理为static</span></span><br><span class="line">        <span class="comment">//  对象池为空时，再造一个对象池。（这个对象池的节点和前一个对象池的节点不是割裂的。之后会通过pop()(_next)连上的</span></span><br><span class="line">        <span class="comment">//  对象池不为空时，从对象池里取对象。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span>     <span class="comment">//   size没有用，只是为了构成重载</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_itemPool==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="comment">//  分配足够大内存 用作空闲池</span></span><br><span class="line">                _itemPool = (QueueItem*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QueueItem)*POOL_ITEM_SIZE);</span><br><span class="line">                QueueItem *p = _itemPool;</span><br><span class="line">                <span class="comment">//  虽然还没构造这个QueueItem对象，不过QueueItem类型指针指向那里，就认为那里的内存存储的数据是QueueItem对象。p也就认为相应位置存在着一个相应成员</span></span><br><span class="line">                <span class="comment">//  operator new之后才调用ctor构造函数。构造函数的作用也就是给相应位置的内存存入相应数据。并没有开辟内存的作用</span></span><br><span class="line">                <span class="comment">//  p指向的内存已经被申请来，不用担心会被程序的其他指令要求占用</span></span><br><span class="line">                <span class="keyword">for</span>(;p&lt;_itemPool + POOL_ITEM_SIZE - <span class="number">1</span>;++p)</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;_next = p+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;_next = <span class="literal">nullptr</span>; <span class="comment">//  最后一个空闲节点的下一位置 为空 代表空闲池耗尽。走到nullptr就意味着我们要造新池子。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  现在要从这堆空闲内存取出一个 取出链表头部的</span></span><br><span class="line">            QueueItem *p = _itemPool;</span><br><span class="line">            _itemPool = _itemPool-&gt;_next;</span><br><span class="line">            <span class="keyword">return</span> p;   <span class="comment">//  接下来要通过p在p指向的内存上调用构造函数 （此时p的_next会被改变，不再指向下一个空闲节点，无所谓。本来就该这样。此时p应该在链式队列的链表上。而非对象池的链表上）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  管理已经无用的内存块 将其放入空闲内存链表中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;ptr&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">//  头插法 加入对象池。而非释放这块内存。</span></span><br><span class="line">            QueueItem *p = <span class="keyword">static_cast</span>&lt;QueueItem*&gt;(ptr);</span><br><span class="line">            p-&gt;_next = _itemPool-&gt;_next;</span><br><span class="line">            _itemPool-&gt;_next = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T _data;</span><br><span class="line">        QueueItem *_next;</span><br><span class="line">        <span class="keyword">static</span> QueueItem *_itemPool;  <span class="comment">//  指向内存池的首个节点（即第一块空闲内存）</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> POOL_ITEM_SIZE = <span class="number">10000</span>;    <span class="comment">//  新标准 static常量可以类内初始化。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    QueueItem *_front;  <span class="comment">//  头节点（无意义）</span></span><br><span class="line">    QueueItem *_rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//  模板名 + 参数名 才是类型 所以是Queue&lt;T&gt;::</span></span><br><span class="line"><span class="keyword">typename</span> Queue&lt;T&gt;:: QueueItem*</span><br><span class="line">Queue&lt;T&gt;::QueueItem::_itemPool = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">20</span>);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;q.<span class="built_in">empty</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  !</span></span><br><span class="line"><span class="comment">//  1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新标准：静态常量可以在类里面初始化，不用在外面初始化。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>函数对象</title>
    <url>/2022/05/06/c++_%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><ul>
<li>一个类，重载了<code>operator()</code>小括号运算符。如<code>class xx&#123;bool operator()(int a,int b);&#125;</code>。把这个类的对象称为函数对象或者仿函数。</li>
<li>函数对象好处（代替函数指针）：<ul>
<li>通过函数对象调用<code>operator()</code>，可以省略函数的调用开销，比通过函数指针调用函数（不能够<code>inline</code>内联调用）效率高</li>
<li>因为函数对象是用类生成的，所以可以添加相关的成员变量，用来记录函数对象使用时更多的信息</li>
</ul>
</li>
<li><code>sort(vec.begin(),vec.end(),greater&lt;int&gt;())</code><ul>
<li>传入函数对象：<code>greater&lt;int&gt;()</code>。</li>
</ul>
</li>
<li><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;</code><ul>
<li>传入函数对象的类类型<code>:less&lt;int&gt;</code>，将来会在<code>priority_queue</code>的类中造函数对象<code>less&lt;int&gt; comp</code>;<h2 id="仿函数和函数指针对比"><a href="#仿函数和函数指针对比" class="headerlink" title="仿函数和函数指针对比"></a>仿函数和函数指针对比</h2></li>
</ul>
</li>
<li>函数对象示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Compare：函数对象的类类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Compare&gt;  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare cmp)</span>    <span class="comment">//  cmp是个函数对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(a,b);    <span class="comment">//  通过函数对象 调用的是operator()(a,b);</span></span><br><span class="line">    <span class="comment">//  内联inline！</span></span><br><span class="line">    <span class="comment">//  因为cmp是函数对象。也就是()是类内的函数。那么这个函数就是内联的.</span></span><br><span class="line">    <span class="comment">//  因为通过对象调用，那么</span></span><br><span class="line">    <span class="comment">//  编译器看到指定模板参数类型调用compare时，会实例化compare模板函数，而在这时Compare类型已经指定。也就是说对象cmp确定是什么类型的了。</span></span><br><span class="line">    <span class="comment">//  那么我们就可以知道调用哪个函数了。那么编译器就可以将他内联了，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  mygreater类的对象称为 仿函数 / 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mygreater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span></span>&#123;  <span class="comment">//  二元函数对象</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  myless类的对象称为 仿函数 / 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myless</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;myless&lt;<span class="keyword">int</span>&gt;()(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;   <span class="comment">//  myless&lt;int&gt;()：仿函数 / 函数对象</span></span><br><span class="line">	cout&lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,myless&lt;<span class="keyword">int</span>&gt;()) &lt;&lt;endl;  <span class="comment">//  传入函数对象</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;compare&lt;int,myless&lt;int&gt;&gt;(1,2,myless&lt;int&gt;())&lt;&lt;endl; </span></span><br><span class="line">    <span class="comment">//  &lt;myless&lt;int&gt;&gt; 显示传入函数对象的类型 </span></span><br><span class="line">    <span class="comment">//  (myless&lt;int&gt;()) 传入函数对象 </span></span><br><span class="line">	<span class="comment">//  myless&lt;int&gt;：模板名 + 类型参数列表 = 类名。这是myless&lt;int&gt;()这个对象的类类型。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>函数指针示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Compare 函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare cmp)</span>	<span class="comment">//  cmp是一个函数指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(a,b);    <span class="comment">//  通过函数指针调用</span></span><br><span class="line">    <span class="comment">//  通过函数指针调用缺点：！！！</span></span><br><span class="line">    <span class="comment">//  无法inline、开销大！因为有函数调用的开销！</span></span><br><span class="line">    <span class="comment">//  为什么无法内联？</span></span><br><span class="line">    <span class="comment">//  内联是在编译时期做的。而这里我们通过函数指针调用，是在运行时调用，在运行时传入地址，通过地址调用。</span></span><br><span class="line">    <span class="comment">//  而在编译时，编译器当然不知道调用的是那个函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  这俩不是仿函数，是函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">greater</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myless</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;myless&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;   	   <span class="comment">//  myless&lt;int&gt;:函数指针。</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,myless&lt;<span class="keyword">int</span>&gt;)&lt;&lt;endl;  <span class="comment">//  myless&lt;int&gt;的类型是一个函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="STL示例"><a href="#STL示例" class="headerlink" title="STL示例"></a>STL示例</h2><ul>
<li>STL模板参数指定函数对象类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;,</span></span><br><span class="line"><span class="comment">	   typename _Compare  = less&lt;typename _Sequence::value_type&gt; &gt;</span></span><br><span class="line"><span class="comment">    class priority_queue</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    protected:</span></span><br><span class="line"><span class="comment">      //  See queue::c for notes on these names.</span></span><br><span class="line"><span class="comment">      _Sequence  c;</span></span><br><span class="line"><span class="comment">      _Compare   comp;	用类型_Compare定义了一个函数对象</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int&gt; q;  //  使用默认底层容器类型vector&lt;int&gt; 使用默认仿函数类型_Compare = less&lt;..&gt;</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int,vector&lt;int&gt;&gt; q;  //  使用默认 _Compare模板参数类型</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)    q.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++_const</title>
    <url>/2021/08/29/c++_const/</url>
    <content><![CDATA[<h1 id="const-reference-const-reference"><a href="#const-reference-const-reference" class="headerlink" title="const reference , const , reference"></a><strong>const reference , const , reference</strong></h1><h2 id="常量左值引用可以绑定在非常量，字面值等"><a href="#常量左值引用可以绑定在非常量，字面值等" class="headerlink" title="常量左值引用可以绑定在非常量，字面值等"></a><strong>常量左值引用可以绑定在非常量，字面值等</strong></h2><ul>
<li><p>引用的类型必须和其所引用的类型一致</p>
</li>
<li><p>例外：const引用可以绑定非常量的对象，字面值，甚至是一般表达式 <code>const int &amp;r = 88</code></p>
</li>
<li><p>为什么可以这样呢？</p>
<ul>
<li><p>首先，我们需要知道当常量引用被绑定到另一种类型上时，发生了什么</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> v = <span class="number">6.6</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r = v;</span><br><span class="line"><span class="comment">//    编译器为了确保让r绑定一个整数，将上述代码变成如下 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> temp = v;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;r = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------同理-----------------------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = <span class="number">8</span>; </span><br><span class="line"><span class="comment">//---&gt; </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = temp;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，r绑定了一个临时量对象<br><strong>临时量对象</strong>：当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名对象。</p>
</li>
<li><p>若r不是const，则执行了上述初始化过程之后。因为r不是常量，就意味着允许对r进行赋值，这样就会改变r所引用的对象的值。但是！在这时！r所引用的变量是临时量对象temp，而非最开始的变量v；而<strong>我们改变r的值是意图改变v的值</strong>，故行为目的与预期不符。</p>
</li>
<li><p>所以c++就把将<strong>非const引用变量绑定到非常量对象，字面值，不同类型的对象</strong>行为定义为非法；而<strong>const引用</strong>则可以绑定到非常量对象，字面值，不同类型对象上。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="关于const-amp-refernce使用"><a href="#关于const-amp-refernce使用" class="headerlink" title="关于const&amp;refernce使用"></a><strong>关于const&amp;refernce使用</strong></h2><ul>
<li>引用（const引用） 一般用于函数传参 。    </li>
<li>引用的底层就是指针</li>
<li>关于<strong>const成员函数</strong>：<ul>
<li>不会改变数据内容的成员函数，马上加上const。</li>
<li>原因：常对象只能调用常函数，非常对象可以调用常函数和非常函数<ul>
<li>所以像一些<code>print(),show(),getXxx()...</code>这些不会改变数据内容的函数，应加上const，不然常对象无法调用他们 </li>
</ul>
</li>
<li>const成员函数和非const成员函数构成重载</li>
</ul>
</li>
<li><strong>传参</strong>：<code>pass by value is be to replaced by pass by reference(to const)</code>(当然如果碰到需要传字符（就一个字节)的话，也可以传字符（指针四个字节））</li>
<li>（const）reference 作为函数参数比（const）pointer好在哪里？<ul>
<li>代码更简洁<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r = <span class="number">6</span>;</span><br><span class="line">    cout&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *r = <span class="number">6</span>;   </span><br><span class="line">    cout&lt;&lt;*r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>学术界不说<code>by pointer</code> 即使用的是指针 我们也说<code>by reference</code></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++基础复习</title>
    <url>/2022/03/29/c++_%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="默认形参默认值"><a href="#默认形参默认值" class="headerlink" title="默认形参默认值"></a>默认形参默认值</h2><ul>
<li>由右向左</li>
<li>定义处可以给形参默认值，声明处也可以给形参默认值</li>
<li>形参给默认值时，不管是定义处还是声明处，（同一形参只能给一次）<strong>只能给一次</strong></li>
<li><strong>提高效率</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y = <span class="number">40</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  1.  传入变量</span></span><br><span class="line"><span class="built_in">sum</span>(a,b);</span><br><span class="line"></span><br><span class="line">mov eax , dword ptr[ebp<span class="number">-8</span>]</span><br><span class="line">push eax</span><br><span class="line">mov eax , dword ptr[ebp<span class="number">-4</span>]</span><br><span class="line">push eax</span><br><span class="line">call sum</span><br><span class="line"></span><br><span class="line"><span class="comment">//  2.  传入立即数 直接push立即数</span></span><br><span class="line"><span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">push <span class="number">14</span>h</span><br><span class="line">push <span class="number">0</span>Ah</span><br><span class="line">call sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  3.  默认实参    直接push立即数</span></span><br><span class="line"><span class="built_in">sum</span>(a)</span><br><span class="line"></span><br><span class="line">push <span class="number">28</span>h    </span><br><span class="line">mov eax , dword ptr[ebp<span class="number">-4</span>]</span><br><span class="line">push eax</span><br><span class="line">call sum</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h2><ul>
<li><code>inline</code>：提高效率，减少函数调用时<strong>参数压栈、开辟栈帧、栈帧回退时的开销（指令）</strong></li>
<li>函数里面的操作很简单比如 <code>x+y</code>时，翻译成汇编指令只有三个操作<code>mov eax , dword ptr[x] ; add eax , dword ptr[y] ; mov dword ptr[..] , eax;</code>。</li>
<li>而我们调用函数时的参数压栈、开辟栈帧、战阵回退时的开销。比函数目的要实现的操作还大，得不偿失。</li>
<li><code>inline</code>对于debug版本无效，只对<code>release</code>版本有效</li>
</ul>
<h3 id="inline函数与普通函数区别？"><a href="#inline函数与普通函数区别？" class="headerlink" title="inline函数与普通函数区别？"></a><strong>inline函数与普通函数区别？</strong></h3><ul>
<li><ol>
<li><strong>开销</strong></li>
</ol>
<ul>
<li>普通函数调用有标准的 参数压栈，栈帧开辟，栈帧回退的开辟</li>
<li>内联函数在编译阶段（生成.o），将函数代码展开，省去编译时开销</li>
</ul>
</li>
<li><ol start="2">
<li><code>inline</code>函数不再生成相应的函数符号</li>
</ol>
</li>
<li><ol start="3">
<li><code>inline</code>不一定展开。递归一定不内联<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line"><span class="comment">//  调用函数：</span></span><br><span class="line"><span class="comment">//    1. 参数压栈（传入的参数）</span></span><br><span class="line"><span class="comment">//    2. call 函数名 a.保存下一指令地址   b.跳转到目标函数</span></span><br><span class="line"><span class="comment">//    3. 进入函数 &#123; ：</span></span><br><span class="line"><span class="comment">//        保留现函数栈底 ，</span></span><br><span class="line"><span class="comment">//        开辟栈帧 ，</span></span><br><span class="line"><span class="comment">//    4. 函数代码段</span></span><br><span class="line"><span class="comment">//    5. 离开函数 &#125; ：</span></span><br><span class="line"><span class="comment">//        栈帧回退 ，</span></span><br><span class="line"><span class="comment">//        取回函数调用方的函数栈底，</span></span><br><span class="line"><span class="comment">//        跳转到函数调用处的下一条指令（ret，对应sum）。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="C-支持，C不支持函数重载。why？"><a href="#C-支持，C不支持函数重载。why？" class="headerlink" title="C++支持，C不支持函数重载。why？"></a>C++支持，C不支持函数重载。why？</h3><ul>
<li>编译时产生函数符号规则不同</li>
<li>c++产生函数符号时，由函数名和参数列表决定</li>
<li>c产生函数符号时，只由函数名决定<h3 id="C与C-代码之间如何互相调用？"><a href="#C与C-代码之间如何互相调用？" class="headerlink" title="C与C++代码之间如何互相调用？"></a>C与C++代码之间如何互相调用？</h3></li>
</ul>
<h3 id="函数重载需要注意什么？"><a href="#函数重载需要注意什么？" class="headerlink" title="函数重载需要注意什么？"></a>函数重载需要注意什么？</h3><ul>
<li>函数名相同，参数列表不同，称为函数重载</li>
<li>一组函数要重载，必须在同一作用域</li>
<li><strong>const和volatile，是如何影响形参类型的。</strong></li>
<li>返回值不同，不构成重载。</li>
</ul>
<p>参数是否为const不构成重载</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> <span class="comment">// int __cdecl(int,int)  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;              <span class="comment">//  int</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">10</span>;       <span class="comment">//  int</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(a).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(b).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(sum).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<h3 id="请你解释一下，什么是多态？"><a href="#请你解释一下，什么是多态？" class="headerlink" title="请你解释一下，什么是多态？"></a>请你解释一下，什么是多态？</h3><ul>
<li>静态（编译时期）的多态：函数重载（编译时期、即生成指令时就确定了要调用哪个）</li>
<li>动态（运行时期）的多肽</li>
</ul>
<h3 id="如何答什么是函数重载"><a href="#如何答什么是函数重载" class="headerlink" title="如何答什么是函数重载"></a>如何答什么是函数重载</h3><ul>
<li><ol>
<li>定义：同一作用域，函数名相同，参数列表不同</li>
</ol>
</li>
<li><ol start="2">
<li>C++为什么支持，C为什么不支持？</li>
</ol>
</li>
<li><ol start="3">
<li>函数重载也是静态时多态的一部分。</li>
</ol>
</li>
</ul>
<h2 id="c-c如何调用c-c"><a href="#c-c如何调用c-c" class="headerlink" title="c++/c如何调用c/c++"></a>c++/c如何调用c/c++</h2><ul>
<li>c++文件中有函数声明。按照c++规则编译生成函数符号（函数名 + 参数列表） ，是 “UND”的。需要到外部文件中去找。但是c文件中相应函数所生成的符号表是按照c规则生成的（函数名）。故找不到。</li>
<li>当c++中这个函数被调用时，（在link时报错）就会发生 <strong>无法解析的外部符号“int __cdecl sum(int,int)”，该符号在main中被引用</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LNK2019	无法解析的外部符号 <span class="string">&quot;int __cdecl sum(int,int)&quot;</span> (?sum@@YAHHH@Z)，</span><br><span class="line">函数 main 中引用了该符号	ConsoleApplication1	</span><br></pre></td></tr></table></figure></li>
<li>解决方法：把C函数的声明放在 <code>extern &quot;C&quot; &#123;&#125;</code>里面<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">main.cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  按照C++的规则生成函数符号 &quot;int __cdecl sum(int,int)&quot; (?sum@@YAHHH@Z)    &quot;UND&quot;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>      <span class="comment">//  告诉编译器，以C的规则生成符号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;SDSDAD&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum.c</span><br><span class="line"><span class="comment">//  按照C的规则生成函数符号 sum .text段</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>C无法直接调用C++怎么办？ 把C++源码放在 <code>extern &quot;C&quot;&#123;&#125;</code>里面</li>
</ul>
<h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><ul>
<li>即可以放在C++里，也可以放在C里</li>
<li>C++定义了__cpluscplus。C++有extern C没有。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cpluscplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cpluscplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C和C-const的区别"><a href="#C和C-const的区别" class="headerlink" title="C和C++const的区别"></a>C和C++const的区别</h2><ul>
<li><strong>const编译方式不同</strong>，<ul>
<li>C中，const修饰的变量就是<strong>当作一个变量来编译生成指令</strong>的（只是在语法层面禁止对变量进行更改赋值，但是仍然可以通过指针对那块内存进行更改）。</li>
<li><strong>C++中，所有出现const常量名字的地方，都被常量的初始化替换了</strong>。！！！！（在编译时就做了）</li>
</ul>
</li>
</ul>
<h3 id="C语言的const"><a href="#C语言的const" class="headerlink" title="C语言的const"></a>C语言的const</h3><ul>
<li>const修饰的量，可以不用初始化；一定不能被赋值。</li>
<li>const修饰的量不叫常量，叫做<strong>常变量</strong>。与变量唯一区别：<strong>不能作为左值。</strong><ul>
<li>因此C语言的const变量不能当作常量去定义数组 <code>int array[const长变量]=&#123;&#125;; error</code></li>
</ul>
</li>
<li>C语言的const，是语法级别的const，通过指针仍可以修改那块常变量的内存。</li>
<li>所以如下，通过p修改之后，对a取值以及对p取值。都是取那块内存存储的值、20<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,*p,a,*(&amp;a));</span><br><span class="line">    <span class="comment">//     20  20  20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-的const"><a href="#C-的const" class="headerlink" title="C++的const"></a>C++的const</h3><ul>
<li><p>const修饰的量，必须初始化</p>
</li>
<li><p>（用立即数初始化）叫做<strong>常量</strong></p>
<ul>
<li><code>const int a = 10</code></li>
<li>可以用来作为大小初始化数组。（因为会被替换成10）</li>
</ul>
</li>
<li><p>C++const修饰的变量，在编译阶段，就已经用常量值替换了。</p>
</li>
<li><p>用变量初始化const变量时，得到的const修饰的变量不是常量，退化成C中的常变量。因为初始值不是立即数，无法在编译时就得到值。<br><img src="/2022/03/29/c++_%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/2022-03-30-19-13-11.png"></p>
</li>
<li><p><strong>C和C++的区别来了！：编译方式不同</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> array[a];   <span class="comment">//  C++中的const得到的是常量，可以用定义数组。（在编译时期就替换为10）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)&amp;a;  <span class="comment">//  注意需要强转</span></span><br><span class="line">    *p = <span class="number">20</span>;        <span class="comment">//  实际上a的内存已经被改变！！！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  a出现的地方已经被编译器替换成10</span></span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*(&amp;a)&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//  20         10       10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/29/c++_%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/2022-03-30-19-59-43.png"></p>
</li>
<li><p>（居然真的可以这样 const变量地址被强转之后可以被普通指针接收。那个普通指针也可以去改变那块内存存储的值。）</p>
</li>
</ul>
<h2 id="const和一级指针结合"><a href="#const和一级指针结合" class="headerlink" title="const和一级指针结合"></a>const和一级指针结合</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>const修饰的量常出现的错误</li>
<li><ol>
<li>常量不能再作为左值 《====  直接修改常量的值</li>
</ol>
</li>
<li><ol start="2">
<li>不能把常量的地址泄露给一个普通的指针或普通的引用变量 《= 可以间接修改常量的值</li>
</ol>
</li>
<li>我都会，就不记笔记了。<br>const如果右边没有指针*的话（那就是顶层const了），const是不参与类型的<br><img src="/2022/03/29/c++_%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/2022-03-30-22-04-48.png"></li>
</ul>
<h2 id="const和二级指针结合"><a href="#const和二级指针结合" class="headerlink" title="const和二级指针结合"></a>const和二级指针结合</h2><ul>
<li><p><code>const int **q</code></p>
<ul>
<li>const修饰的是 <code>**q</code>，也即int。</li>
<li><code>q(int**)</code>和<code>*q(int*)</code>都可以更改和赋值</li>
</ul>
</li>
<li><p><code>int *const* q</code></p>
<ul>
<li>const修饰的是 <code>*q</code></li>
<li><code>q</code> 和<code>**q</code>可以更改和赋值</li>
</ul>
</li>
<li><p><code>int **const q</code></p>
<ul>
<li>const修饰的是<code>q</code></li>
<li>*q 和 **q可以更改和赋值</li>
</ul>
</li>
<li><p>int ** &lt;= const int ** 。      no  不可去掉底层const（const修饰的是 **p）</p>
</li>
<li><p><strong><code>const int* * q&lt;= int* *p</code>   。   no！！！   原因见下</strong></p>
</li>
<li><p>简介来说就是：如果可以的话，会通过<code>const int* *q = &amp;p</code>中的<code>*q</code>，来操作p指针的指向，使得其合法指向常量地址，使得常量地址暴露给非常量指针。</p>
</li>
<li><p>换句话说，常量的地址可能经由q被泄露给p。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这个动作会让p指针无形间升级为一个const *指针！！！</span><br><span class="line">- 如果成立，那么就是 const int *q就是p指针，二者是同一块内存;</span><br><span class="line">- 可以看作是 const int* *q = &amp;p; *q是一个指向const int*指针的指针。指向的那个指针就是p指针，</span><br><span class="line">- 那么*（*q）=...，就是在修改指向的这个指针的内容，也就是在修改p指针的指向）</span><br><span class="line"></span><br><span class="line">那么当有</span><br><span class="line">const int b = 120;</span><br><span class="line">* (*q) = &amp;b; 时。</span><br><span class="line">也即，让*q指向的指针指向b</span><br><span class="line">这是合法的。因为*q认为自己指向的是一个const *指针</span><br><span class="line">可是同时，*q指向的指针，是p指针！</span><br><span class="line">p指针是一个非const*指针！</span><br><span class="line">那么，我们就会有通过p指针，来修改这个const指针的风险！！！</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* &lt;= <span class="keyword">const</span> <span class="keyword">int</span> *         no  不可去掉底层<span class="keyword">const</span>（底层<span class="keyword">const</span>：<span class="keyword">const</span>修饰的是指针指向的内容）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * &lt;= <span class="keyword">int</span>*         ok  可以增加底层<span class="keyword">const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ** &lt;= <span class="keyword">const</span> <span class="keyword">int</span> **      no  不可去掉底层<span class="keyword">const</span>（<span class="keyword">const</span>修饰的是 **p）</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* * &lt;= <span class="keyword">int</span>* *       no！！！   原因见下</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ** &lt;= <span class="keyword">int</span> *<span class="keyword">const</span> *      no  不可去掉底层<span class="keyword">const</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> * &lt;= <span class="keyword">int</span> **      ok   </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> **q = &amp;p;     <span class="comment">//  const int** &lt;= int** 不可以！！！</span></span><br><span class="line"><span class="comment">//  不可以原因！！！</span></span><br><span class="line">这个动作会让p指针无形间升级为一个<span class="keyword">const</span> *指针！！！</span><br><span class="line">- 如果成立，那么就是 *q操作的就是p指针。*q的值，是p指针的内容，也就是p指针的指向，也就是<span class="keyword">int</span>的地址。</span><br><span class="line">- 可以看作是 <span class="keyword">const</span> <span class="keyword">int</span>* (*q) = &amp;p; *q是一个指向<span class="keyword">const</span> <span class="keyword">int</span>*指针的指针。指向的那个指针就是p指针，那么*q=...，就是在修改指向的这个指针的内容，也就是在修改p指针的指向）</span><br><span class="line">- 也即 *q &lt;=&gt; p</span><br><span class="line">那么当有</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">120</span>;</span><br><span class="line">*q = &amp;b; 时。</span><br><span class="line">也即，让*q指向的指针指向b</span><br><span class="line">这是合法的。因为*q认为自己指向的是一个<span class="keyword">const</span> *指针</span><br><span class="line">可是同时，*q指向的指针，是p指针！</span><br><span class="line">p指针是一个非<span class="keyword">const</span>*指针！</span><br><span class="line">那么，我们就会有通过p指针，来修改这个<span class="keyword">const</span>指针的风险！！！</span><br><span class="line">也即，将一个常量的地址，泄露给一个非常量的指针！！</span><br></pre></td></tr></table></figure>

<ul>
<li>那么为什么 <code>int *p = &amp;a ; const int *q = p;</code> 就可以呢<ul>
<li>因为这时没有任何东西指向<code>p</code>指针（的内存），<code>q</code>指向的是<code>a</code>。并没有对<code>p</code>指针本身进行改变。</li>
</ul>
</li>
</ul>
<ul>
<li><p>修改方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//  01</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> **q = &amp;p; <span class="comment">//  wrong!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  02</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> **q = &amp;p;     <span class="comment">//  常量地址泄露给p也没事儿，因为p是个指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  03</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> *q = &amp;p;  </span><br><span class="line"><span class="comment">//  常量地址不会被泄露出去。</span></span><br><span class="line"><span class="comment">//  因为没有人有方法给*q赋值。</span></span><br><span class="line"><span class="comment">//  *q是个指针，指向的指针类型是 `const int * const`</span></span><br><span class="line"><span class="comment">//  也即 *q认为自己无法操作自己指向的指针的指向</span></span><br><span class="line"><span class="comment">//  也就无法操作p指针指向常量地址</span></span><br></pre></td></tr></table></figure></li>
<li><p>例子<br>const右侧没有*则不参与类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;a;     </span><br><span class="line"><span class="comment">//  ok!  int *(const因为右侧没有*所以不参与）&lt;= int*</span></span><br><span class="line"><span class="keyword">int</span> **q = &amp;p;   <span class="comment">//  因为&amp;了，所以要加一个*</span></span><br><span class="line"><span class="comment">//  no!!!   int * * &lt;= int * const *</span></span><br><span class="line"><span class="comment">//  变成 * &lt;= const *</span></span><br><span class="line"><span class="comment">//  因此不行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;      <span class="comment">// const int * &lt;= int*</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> * q = &amp;p;</span><br><span class="line"><span class="comment">//  int * const * &lt;= const int **</span></span><br><span class="line"><span class="comment">//  消去左侧的一个const</span></span><br><span class="line"><span class="comment">//  int * &lt;= const int *</span></span><br><span class="line"><span class="comment">//  所以wrong！！！</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h2><h3 id="引用和指针区别"><a href="#引用和指针区别" class="headerlink" title="引用和指针区别"></a>引用和指针区别</h3><ul>
<li><p>引用是更安全的指针</p>
</li>
<li><p>引用必须初始化，指针不需要</p>
</li>
<li><p>引用只有一级引用，没有多级引用；指针可以有一级、多级指针</p>
</li>
<li><p><strong>定义一个引用和指针在汇编指令上没有任何区别；通过引用变量修改所引用内存的值，和通过指针解引用修改指向变量的值，其底层指令也是一摸一样</strong>。</p>
</li>
<li><p>如何引用数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array[<span class="number">5</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (&amp;r)[<span class="number">5</span>] = array;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><h4 id="lea和mov"><a href="#lea和mov" class="headerlink" title="lea和mov"></a>lea和mov</h4><ul>
<li><strong><code>lea</code>是“<code>load effective address</code>”的缩写</strong>，简单的说，<code>lea</code>指令可以用来将一个内存地址直接赋给目的操作数，例如：<code>lea eax,[ebx+8]</code>就是将<code>ebx+8</code>这个值直接赋给<code>eax</code>，而不是把<code>ebx+8</code>处的内存地址里的数据赋给<code>eax</code>。</li>
<li>而<code>mov</code>指令则恰恰相反，例如：<code>mov eax,[ebx+8]</code>则是把内存地址为<code>ebx+8</code>处的数据赋给<code>eax</code>。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>变量a的地址放入寄存器，然后寄存器的内容存入内存（栈中）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">        lea     rax, [rbp<span class="number">-32</span>]       </span><br><span class="line">        <span class="comment">//   rbp-32这个地址是a的地址 把这个地址放到rax寄存器中</span></span><br><span class="line">        mov     QWORD PTR [rbp<span class="number">-8</span>], rax</span><br><span class="line">        <span class="comment">//   再把寄存器的内容放入内存中</span></span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line">        lea     rax, [rbp<span class="number">-32</span>]</span><br><span class="line">        mov     QWORD PTR [rbp<span class="number">-16</span>], rax  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h2><ul>
<li><p>左值引用所引用的东西有名字，有内存，可以作为左值</p>
</li>
<li><p>右值引用引用的东西没名字，没内存。</p>
</li>
<li><p>左值引用不能引用右值（右值：临时量、数值）。</p>
</li>
<li><p>右值引用不能引用左值。</p>
</li>
<li><p>右值：在寄存器里的，随时会被覆盖。（右值饮用后就是把这个音右值拷贝到栈中，使其可以被引用）</p>
</li>
<li><p>左值：在栈空间里的</p>
</li>
<li><p><strong>用途（目的）</strong></p>
<ul>
<li>为了从语法层面，就可以分辨出一个变量是否即将被销毁。一个变量能被右值引用，也就意味着这个变量即将无效；我们就可以针对这种对象进行指定的操作；如果一个变量被左值引用，就意味着他不会无效，我们对其进行指定操作。</li>
<li><strong>编译器通过判断一个变量/值是否将要被销毁（局部对象出作用于之后被销毁）【（是否是右值）（也即是否是临时量或者数值）】，来判断他是否是右值，进而来看她是否匹配到右值引用参数列表（是否可以被右值引用。），从而调用指定函数</strong></li>
<li><del>左值引用右值引用不会对所引用的东西本身造成影响</del>。引入右值引用只是为了让右值匹配特定的函数参数列表（与左值区分开），来调用针对右值设计的函数来提高效率。</li>
</ul>
</li>
</ul>
<h3 id="左值引用、右值引用在汇编的区别"><a href="#左值引用、右值引用在汇编的区别" class="headerlink" title="左值引用、右值引用在汇编的区别"></a>左值引用、右值引用在汇编的区别</h3><ul>
<li><p><strong>左值引用：把变量的地址拷贝一份放到栈的内存中</strong></p>
<ul>
<li>把变量对应的内存的地址装入寄存器，再从寄存器放入内存的另一处内存空间x中（栈的另一位置）。我们左值引用变量本身的地址应当就是这块内存空间x的地址</li>
</ul>
</li>
<li><p><strong>右值引用：为立即数分配一块内存空间，并把内存空间的地址拷贝一份放到栈的另一块内存空间中</strong></p>
<ul>
<li>由于立即数不是左值，没有名字，没有内存。因此我们先把为这个立即数分配一个存储空间。也即把这个立即数放入一块（栈的）存储空间中。然后再做左值引用的操作：把这个内存地址拷贝一份放到栈中的另一处内存空间x中。</li>
<li>我们右值引用变量本身的地址应当就是这块内存空间x的地址<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line">        lea     rax, [rbp<span class="number">-24</span>]       <span class="comment">// </span></span><br><span class="line">        mov     QWORD PTR [rbp<span class="number">-8</span>], rax</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; rr = <span class="number">10</span>;</span><br><span class="line">        mov     DWORD PTR [rbp<span class="number">-20</span>], <span class="number">0xA</span></span><br><span class="line">        lea     rax, [rbp<span class="number">-20</span>]</span><br><span class="line">        mov     QWORD PTR [rbp<span class="number">-16</span>], rax </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>也因此右值引用变量本身是个左值</strong>，因为他有名字，有内存空间。</p>
</li>
</ul>
<h3 id="常量左值引用、右值引用"><a href="#常量左值引用、右值引用" class="headerlink" title="常量左值引用、右值引用"></a>常量左值引用、右值引用</h3><ul>
<li><strong>常量左值引用</strong>和<strong>右值引用</strong>在<strong>汇编</strong>上没有区别！</li>
<li><strong>区别在于语法层面：不能够改变常左cr引用的变量的值，能够改变右引rr引用的值。</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cr = <span class="number">10</span>;</span><br><span class="line">rr = <span class="number">8</span>; <span class="comment">// ok</span></span><br><span class="line">cr = <span class="number">8</span>; <span class="comment">//  wrong!</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cr = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int t = 10;  cr &lt;= t</span></span><br><span class="line">        mov     DWORD PTR [rbp<span class="number">-36</span>], <span class="number">0xA</span></span><br><span class="line">        lea     rax, [rbp<span class="number">-36</span>]</span><br><span class="line">        mov     QWORD PTR [rbp<span class="number">-32</span>], rax</span><br></pre></td></tr></table></figure>

<ul>
<li>胡咧咧：感觉右值引用实际上是告诉编译器把右值保存在一个内存中，让我们可以引用，并且在引用时通过语法层面确保用户知道，所引用的值是一个即将被销毁的东西。</li>
</ul>
<h3 id="const-引用-指针-题"><a href="#const-引用-指针-题" class="headerlink" title="const 引用 指针 题"></a>const 引用 指针 题</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A.</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> * &amp;q = p;   </span><br><span class="line"><span class="comment">//  p是个引用。引用的对象是个int*指针。通过q可以改变p的指向。观察得ok</span></span><br><span class="line"><span class="comment">//  也可以看成是 int * *q = &amp;p;</span></span><br><span class="line"><span class="comment">//  所以就是 int** &lt;= int** ok</span></span><br><span class="line"></span><br><span class="line">B.wrong!</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;a;  <span class="comment">//  int * &lt;= int*</span></span><br><span class="line"><span class="keyword">int</span> *&amp;q = p;</span><br><span class="line"><span class="comment">//  通过引用变量q可以改变p得指向。而p应当是const不变指向。因此wrong！</span></span><br><span class="line"><span class="comment">//  也可以看作 int **q = &amp;p; </span></span><br><span class="line"><span class="comment">//  即 int ** q&lt;= int *const * p    ; 即 * &lt;= const * 因此wtong！</span></span><br><span class="line"><span class="comment">//  (const修饰*p，p指向int*；*p是int*；q指向int* ；*q是int*，所以当可以通过*q修改p指向，因此不对！)</span></span><br><span class="line"></span><br><span class="line">C.wrong!</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;  <span class="comment">//  const int* &lt;=int*</span></span><br><span class="line"><span class="keyword">int</span> *&amp;q = p;    </span><br><span class="line"><span class="comment">//  int** q = &amp;p;</span></span><br><span class="line"><span class="comment">//  即int ** &lt;= const int **  wrong!</span></span><br><span class="line"></span><br><span class="line">D. wrong!</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * &amp;q = p;</span><br><span class="line"><span class="comment">//  通过q会修改p得指向，使其合法指向常量地址，因此wrong！</span></span><br><span class="line"><span class="comment">//  const int ** q = &amp;p;</span></span><br><span class="line"><span class="comment">//  const int ** &lt;= int ** </span></span><br><span class="line"><span class="comment">// wrong!</span></span><br></pre></td></tr></table></figure>


<h2 id="new、malloc区别。free、delete区别"><a href="#new、malloc区别。free、delete区别" class="headerlink" title="new、malloc区别。free、delete区别"></a>new、malloc区别。free、delete区别</h2><ul>
<li><p>malloc delete 称为C的库函数</p>
</li>
<li><p>new delete 称作运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>();</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">==================================</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(...);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>：</span><br><span class="line">p-&gt;~析构函数();</span><br><span class="line"><span class="built_in">free</span>(p);  释放内存</span><br></pre></td></tr></table></figure></li>
<li><p>new不仅开辟内存，还可内存初始化。</p>
</li>
<li><p>malloc开辟内存失败，通过返回值合nullptr比较</p>
</li>
<li><p>new开辟内存失败，是通过bad_alloc类型的异常来比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) cout &lt;&lt; <span class="string">&quot;wrong&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span>* pp = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc&amp; e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  int *pp = new int[20];  在堆上开辟后不会初始化</span></span><br><span class="line">    <span class="keyword">int</span> *pp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>]();    <span class="comment">// 在堆上开辟后会初始化</span></span><br><span class="line">    <span class="keyword">delete</span> []pp;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>有几种new</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  int *pp = new int[20];  在堆上开辟后不会初始化</span></span><br><span class="line"><span class="keyword">int</span> *pp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>]();    <span class="comment">// 在堆上开辟后会初始化</span></span><br><span class="line"><span class="keyword">delete</span> []pp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//  定位new</span></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="built_in"><span class="keyword">new</span></span> (&amp;data) <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;data&lt;&lt;endl; <span class="comment">//  5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><a href="https://cloud.tencent.com/developer/article/1637791">C++与Java不同</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>容器复习</title>
    <url>/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88792786?spm=1001.2014.3001.5502">https://blog.csdn.net/QIANGWEIYUAN/article/details/88792786?spm=1001.2014.3001.5502</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ STL standard template libaray 标准模板库</span></span><br><span class="line"><span class="comment">一、标准容器 C++11 array  forward_list</span></span><br><span class="line"><span class="comment">1.顺序容器 </span></span><br><span class="line"><span class="comment">vector</span></span><br><span class="line"><span class="comment">deque</span></span><br><span class="line"><span class="comment">list</span></span><br><span class="line"><span class="comment">2.容器适配器</span></span><br><span class="line"><span class="comment">stack</span></span><br><span class="line"><span class="comment">queue</span></span><br><span class="line"><span class="comment">priority_queue</span></span><br><span class="line"><span class="comment">3.关联容器 </span></span><br><span class="line"><span class="comment">无序关联容器 =&gt; 链式哈希表  增删查O(1) </span></span><br><span class="line"><span class="comment">set:集合 key   map:映射表 [key,value]</span></span><br><span class="line"><span class="comment">unordered_set 单重集合</span></span><br><span class="line"><span class="comment">unordered_multiset 多重集合</span></span><br><span class="line"><span class="comment">unordered_map 单重映射表</span></span><br><span class="line"><span class="comment">unordered_multimap 多重映射表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有序关联容器 =&gt; 红黑树 增删查O(log2n) 2是底数(树的层数，树的高度)</span></span><br><span class="line"><span class="comment">set</span></span><br><span class="line"><span class="comment">multiset</span></span><br><span class="line"><span class="comment">map</span></span><br><span class="line"><span class="comment">multimap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、近容器</span></span><br><span class="line"><span class="comment">数组，string，bitset(位容器)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、迭代器</span></span><br><span class="line"><span class="comment">iterator和const_iterator</span></span><br><span class="line"><span class="comment">reverse_iterator和const_reverse_iterator</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、函数对象（类似C的函数指针）</span></span><br><span class="line"><span class="comment">greater,less</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、泛型算法</span></span><br><span class="line"><span class="comment">sort,find,find_if,binary_search,for_each</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>size：元素个数</li>
<li>empty：是否无元素</li>
<li>reserve：预留空间，但不放元素。</li>
<li>resize：重新设置空间，并且每个位置都放上元素（int()）。所以之后再push_back，还是会扩容。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector：向量容器 </span></span><br><span class="line"><span class="comment">底层数据结构：动态开辟的数组，每次以原来空间大小的2倍进行扩容的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">vector&lt;int&gt; vec;</span></span><br><span class="line"><span class="comment">增加:</span></span><br><span class="line"><span class="comment">vec.push_back(20); 末尾添加元素 O(1)   导致容器扩容</span></span><br><span class="line"><span class="comment">vec.insert(it, 20); it迭代器指向的位置添加一个元素20  O(n)   导致容器扩容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">删除:</span></span><br><span class="line"><span class="comment">vec.pop_back(); 末尾删除元素 O(1) </span></span><br><span class="line"><span class="comment">vec.erase(it); 删除it迭代器指向的元素 O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">查询:</span></span><br><span class="line"><span class="comment">operator[] 下标的随机访问vec[5]  O(1)</span></span><br><span class="line"><span class="comment">iterator迭代器进行遍历</span></span><br><span class="line"><span class="comment">find，for_each</span></span><br><span class="line"><span class="comment">foreach =&gt; 通过iterator来实现的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：对容器进行连续插入或者删除操作(insert/erase)，一定要更新迭代器，否则第一次insert或者erase完成，</span></span><br><span class="line"><span class="comment">迭代器就失效了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">常用方法介绍:</span></span><br><span class="line"><span class="comment">size()</span></span><br><span class="line"><span class="comment">empty()</span></span><br><span class="line"><span class="comment">reserve(20)：vector预留空间的   只给容器底层开辟指定大小的内存空间，并不会添加新的元素</span></span><br><span class="line"><span class="comment">resize(20)：容器扩容用的  不仅给容器底层开辟指定大小的内存空间，还会添加新的元素</span></span><br><span class="line"><span class="comment">swap ： 两个容器进行元素交换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">// vector&lt;string&gt; vec; 0 1 2 4 8 16 32 64</span></span><br><span class="line">	<span class="comment">//vec.reserve(20); // 叫做给vector容器预留空间</span></span><br><span class="line">	vec.<span class="built_in">resize</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// int()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// vector的operator[]运算符重载函数</span></span><br><span class="line">	<span class="keyword">int</span> size = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把vec容器中所有的偶数全部删除</span></span><br><span class="line">	<span class="keyword">auto</span> it2 = vec.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it2 != vec.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it2 % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			it2 = vec.<span class="built_in">erase</span>(it2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++it2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过迭代器遍历vector容器</span></span><br><span class="line">	<span class="keyword">auto</span> it1 = vec.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给vector容器中所有的奇数前面都添加一个小于奇数1的偶数   44 45    56 57</span></span><br><span class="line">	<span class="keyword">for</span> (it1 = vec.<span class="built_in">begin</span>(); it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it1 % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			it1 = vec.<span class="built_in">insert</span>(it1, *it1<span class="number">-1</span>);</span><br><span class="line">			++it1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (it1 = vec.<span class="built_in">begin</span>(); it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="deque、list"><a href="#deque、list" class="headerlink" title="deque、list"></a>deque、list</h2><ul>
<li>deque<br><img src="/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/2022-04-08-22-24-44.png"></li>
<li>list<br><img src="/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/2022-04-08-22-25-24.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deque：双端队列容器</span></span><br><span class="line"><span class="comment">底层数据结构：动态开辟的二维数组，一维数组从2开始，以2倍的方式进行扩容，每次扩容后，原来第二维的数组，从</span></span><br><span class="line"><span class="comment">新的第一维数组的下标oldsize/2开始存放，上下都预留相同的空行，方便支持deque的首尾元素添加</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque&lt;int&gt; deq;</span></span><br><span class="line"><span class="comment">增加：</span></span><br><span class="line"><span class="comment">deq.push_back(20); 从末尾添加元素 O(1)  </span></span><br><span class="line"><span class="comment">deq.push_front(20); 从首部添加元素 O(1)   // vec.insert(vec.begin(), 20) O(n)</span></span><br><span class="line"><span class="comment">deq.insert(it, 20); it指向的位置添加元素 O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">删除：</span></span><br><span class="line"><span class="comment">deq.pop_back(); 从末尾删除元素 O(1)  </span></span><br><span class="line"><span class="comment">deq.pop_front(); 从首部删除元素 O(1)  </span></span><br><span class="line"><span class="comment">deq.erase(it);  从it指向的位置删除元素 O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">查询搜索：</span></span><br><span class="line"><span class="comment">iterator(连续的insert和erase一定要考虑迭代器失效的问题)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">list：链表容器</span></span><br><span class="line"><span class="comment">底层数据结构：双向的循环链表   pre data next</span></span><br><span class="line"><span class="comment">list&lt;int&gt; mylist;</span></span><br><span class="line"><span class="comment">增加：</span></span><br><span class="line"><span class="comment">mylist.push_back(20); 从末尾添加元素 O(1)</span></span><br><span class="line"><span class="comment">mylist.push_front(20); 从首部添加元素 O(1)   // vec.insert(vec.begin(), 20) O(n)</span></span><br><span class="line"><span class="comment">mylist.insert(it, 20); it指向的位置添加元素 O(1) // 链表中进行insert的时候，先要进行一个query查询操作</span></span><br><span class="line"><span class="comment">    对于链表来说，查询操作效率就比较慢了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">删除：</span></span><br><span class="line"><span class="comment">mylist.pop_back(); 从末尾删除元素 O(1)</span></span><br><span class="line"><span class="comment">mylist.pop_front(); 从首部删除元素 O(1)</span></span><br><span class="line"><span class="comment">mylist.erase(it);  从it指向的位置删除元素 O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">查询搜索：</span></span><br><span class="line"><span class="comment">iterator(连续的insert和erase一定要考虑迭代器失效的问题)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque和list，比vector容器多出来的增加删除函数接口：</span></span><br><span class="line"><span class="comment">push_front和pop_front</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>vector底层：连续的数组</li>
<li>deque底层：两个维度 每一个第二维度的数组是连续的。是单独new出来的。</li>
</ul>
<h2 id="vector、deque、list对比"><a href="#vector、deque、list对比" class="headerlink" title="vector、deque、list对比"></a>vector、deque、list对比</h2><ul>
<li>deque &amp; vector 的erase/insert操作。(都是O(n))<br><img src="/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/2022-04-08-22-24-31.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector特点：动态数组，内存是连续的，2倍的方式进行扩容， vector&lt;int&gt; vec; 0-1-2-4-8... reserve(20)/resize</span></span><br><span class="line"><span class="comment">deque特点：动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容的时候（第一维的数组进行2倍扩容）</span></span><br><span class="line"><span class="comment">		面经问题：deque底层内存是否是连续的？   并不是  每一个第二维是连续的，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">容器的纵向考察：容器掌握的深度</span></span><br><span class="line"><span class="comment">容器的横向考察：各个相似容器之间的对比</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">vector和deque之间的区别？</span></span><br><span class="line"><span class="comment">1.底层数据结构：</span></span><br><span class="line"><span class="comment">2.前中后插入删除元素的时间复杂度： 末尾 O(1) ； 前 deque O(1) vector O(n) ；中间都是O(n)</span></span><br><span class="line"><span class="comment">3.对于内存的使用效率： vector 需要的内存空间必须是连续的    deque 可以分块进行数据存储，不需要内存空间必须是一片连续的</span></span><br><span class="line"><span class="comment">4.在中间进行insert或者erase，vector和deque它们的效率谁能好一点(vector)？谁能差一点(deque)？  但是都是O(n)</span></span><br><span class="line"><span class="comment">	因为deque的每个第二维的内存单独连续。需要移动元素时还要去找一维的地址。</span></span><br><span class="line"><span class="comment">	vector的所有内存都是连续的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for(int i=0; i&lt;10000; ++i)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; arr[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">vector和list之间的区别？   数组:增加删除O(n) 查询O(n) 随机访问O(1)   链表:(考虑搜索的时间)增加删除O(1)  查询O(n)</span></span><br><span class="line"><span class="comment">1.底层数据结构：数组   双向循环链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><ul>
<li>没有实现自己的迭代器，也就因此不能通过迭代器遍历容器。（如stack）<h3 id="stack、queue、pritority-queue"><a href="#stack、queue、pritority-queue" class="headerlink" title="stack、queue、pritority_queue"></a>stack、queue、pritority_queue</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span> <span class="comment">// stack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span> <span class="comment">// queue和priority_queue</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">标准容器 - 容器适配器 =&gt; 设计模式，就叫做适配器模式</span></span><br><span class="line"><span class="comment">怎么理解这个适配器？</span></span><br><span class="line"><span class="comment">1.适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的</span></span><br><span class="line"><span class="comment">2.没有实现自己的迭代器，也就没有办法通过迭代器遍历。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template&lt;typename T, typename Container=deque&lt;T&gt;&gt;</span></span><br><span class="line"><span class="comment">class Stack</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">	void push(const T &amp;val) &#123; con.push_back(val); &#125;</span></span><br><span class="line"><span class="comment">	void pop() &#123; con.pop_back(); &#125;</span></span><br><span class="line"><span class="comment">	T top()const &#123; return con.back(); &#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">	Container con;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">stack: push入栈  pop出栈  top查看栈顶元素  empty判断栈空  size返回元素个数 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">queue: push入队  pop出队  front查看队头元素 back查看队尾元素  empty判断队空   size返回元素个数</span></span><br><span class="line"><span class="comment">queue =&gt; deque  为什么不依赖vector呢？？？</span></span><br><span class="line"><span class="comment">stack =&gt; deque  为什么不依赖vector呢？？？</span></span><br><span class="line"><span class="comment">1.vector的初始内存使用效率太低了！没有deque好  queue&lt;int&gt; stack&lt;int&gt;  vector 0-1-2-4-8 deque 4096/sizeof(int) = 1024</span></span><br><span class="line"><span class="comment">2.对于queue来说，需要支持尾部插入，头部删除，O(1)  如果queue依赖vector，其出队效率很低</span></span><br><span class="line"><span class="comment">3.vector需要大片的连续内存，而deque只需要分段的内存，当存储大量数据时，显然deque对于内存的利用率更好一些</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">priority_queue: push入队  pop出队  top查看队顶元素  empty判断队空  size返回元素个数  默认：大根堆</span></span><br><span class="line"><span class="comment">priority_queue =&gt; vector 为什么依赖vector？？？</span></span><br><span class="line"><span class="comment">底层默认把数据组成一个大根堆结构  在一个内存连续的数组上构建一个大根堆或者小根堆的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; pque;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		pque.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; pque.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (!pque.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pque.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pque.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		que.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; que.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; que.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s1.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; s1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		s1.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h2><p>不允许重复：一个元素（或者key-value中的key）只存一次，第二次就不存了。<br>允许重复：一个元素可以存多次。（可以看集合的大小就能看出来）</p>
<ul>
<li><p>有序关联容器</p>
<ul>
<li>set：不允许key重复。元素有序。红黑树。#include<set></set></li>
<li>multiset：允许key重复。元素有序。红黑树。#include<set><ul>
<li>元素有序：加入的元素要实现operator&lt;</li>
</ul>
</set></li>
</ul>
</li>
<li><p>无序关联容器</p>
<ul>
<li>unordered_set：不允许key重复。元素无序。链式哈希表。 #include<unordered_set></unordered_set></li>
<li>unordered_multiset：不允许key重复。元素有。链式哈希表#include<unordered_set></unordered_set></li>
</ul>
</li>
<li><p>unordered：无序</p>
</li>
<li><p>multi：重复</p>
</li>
<li><p>使用无序关联容器：#include<unordered_set> #include<unordered_map></unordered_map></unordered_set></p>
</li>
<li><p>使用有序关联容器：#include<set> #include<map></map></set></p>
</li>
<li><p>set换成map即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关联容器：</span></span><br><span class="line"><span class="comment">1.各个容器底层的数据结构 O(1)  O(log2n)</span></span><br><span class="line"><span class="comment">2.常用增删查方法</span></span><br><span class="line"><span class="comment">增加：insert(val)</span></span><br><span class="line"><span class="comment">遍历：iterator自己搜索，调用find成员方法</span></span><br><span class="line"><span class="comment">删除：erase(key)  erase(it)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 处理海量数据查重复；去重复的时候</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> ARR_LEN = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> arr[ARR_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARR_LEN; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = <span class="built_in">rand</span>() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上面的10万个整数中，把数字进行去重打印  set  map</span></span><br><span class="line">	unordered_set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : arr) <span class="comment">// O(n)</span></span><br><span class="line">	&#123;</span><br><span class="line">		set.<span class="built_in">insert</span>(v); <span class="comment">// O(1)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : set)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">// 上面的10万个整数中，统计哪些数字重复了，并且统计数字重复的次数</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k : arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		auto it = map1.find(k);</span></span><br><span class="line"><span class="comment">		if (it == map1.end())</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			map1.insert(&#123;k, 1&#125;);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			it-&gt;second++;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		map1[k]++; <span class="comment">// map1[k]  [k, 1]</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	for (const pair&lt;int, int&gt; &amp;p : map1)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		if (p.second &gt; 1)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; &quot;key:&quot; &lt;&lt; p.first &lt;&lt; &quot; count:&quot; &lt;&lt; p.second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != map1.<span class="built_in">end</span>(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it-&gt;second &gt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt;</span><br><span class="line">				<span class="string">&quot; count:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	[key, value]</span></span><br><span class="line"><span class="comment">	struct pair</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	 first; =&gt; key</span></span><br><span class="line"><span class="comment">	 second; =&gt; value</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	map的operator[]</span></span><br><span class="line"><span class="comment">	1.查询</span></span><br><span class="line"><span class="comment">	2.如果key不存在，它会插入一对数据[key, string()]</span></span><br><span class="line"><span class="comment">	V&amp; operator[](const K &amp;key)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		insert(&#123;key, V()&#125;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	unordered_map&lt;int, string&gt; map1;</span></span><br><span class="line"><span class="comment">	map1.insert(make_pair(1000, &quot;张三&quot;));</span></span><br><span class="line"><span class="comment">	map1.insert(&#123;1010, &quot;李四&quot;&#125;); // map表增加元素</span></span><br><span class="line"><span class="comment">	map1.insert(&#123;1020, &quot;王五&quot; &#125;);</span></span><br><span class="line"><span class="comment">	map1.insert(&#123;1030, &quot;王凯&quot; &#125;);</span></span><br><span class="line"><span class="comment">	map1.erase(1020); // &#123;1020, &quot;王五&quot; &#125;删除了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	auto it1 = map1.find(1030);</span></span><br><span class="line"><span class="comment">	if (it1 != map1.end())</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		// it1 -&gt; pair对象</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;key:&quot; &lt;&lt; it1-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it1-&gt;second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	//map1[2000]; // key:2000 value:&quot;&quot;</span></span><br><span class="line"><span class="comment">	//map1[2000] = &quot;刘硕&quot;; // map1.insert(&#123;2000, &quot;刘硕&quot;&#125;);</span></span><br><span class="line"><span class="comment">	//map1[1000] = &quot;张三2&quot;; // </span></span><br><span class="line"><span class="comment">	//cout &lt;&lt; map1.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	// map operator[](key) =&gt; value  查询</span></span><br><span class="line"><span class="comment">	//cout &lt;&lt; map1[1000] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	unordered_set&lt;<span class="keyword">int</span>&gt; set1; <span class="comment">// 不会存储key值重复的元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		set1.<span class="built_in">insert</span>(<span class="built_in">rand</span>()%<span class="number">20</span>+<span class="number">1</span>); <span class="comment">// vector/deque/list  insert(it, val)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; set1.size() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; set1.count(15) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> it1 = set1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it1 != set1.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	set1.<span class="built_in">erase</span>(<span class="number">20</span>); <span class="comment">// 按key值删除元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (it1 = set1.<span class="built_in">begin</span>(); it1 != set1.<span class="built_in">end</span>(); )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it1 == <span class="number">30</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			it1 = set1.<span class="built_in">erase</span>(it1); <span class="comment">// 调用erase，it1迭代器就失效了</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++it1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	it1 = set1.<span class="built_in">find</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="keyword">if</span> (it1 != set1.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		set1.<span class="built_in">erase</span>(it1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : set1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="有序关联容器"><a href="#有序关联容器" class="headerlink" title="有序关联容器"></a>有序关联容器</h2><ul>
<li>有序关联容器<ul>
<li>set、multiset。红黑树#include<set>。</set></li>
<li>map、mutimap。红黑树#include<map>。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span> <span class="comment">// stack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span> <span class="comment">// queue和priority_queue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用无序关联容器包含的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用有序关联容器包含的头文件  红黑树</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span> <span class="comment">// set multiset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span> <span class="comment">// map multimap</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="keyword">int</span> id=<span class="number">0</span>, string name=<span class="string">&quot;&quot;</span>)</span><br><span class="line">		:_id(id), _name(name) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _id;</span><br><span class="line">	string _name;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;stu);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; stu._id &lt;&lt; <span class="string">&quot; name:&quot;</span> &lt;&lt; stu._name &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>, Student&gt; stuMap;</span><br><span class="line">	stuMap.<span class="built_in">insert</span>(&#123; <span class="number">1000</span>, <span class="built_in">Student</span>(<span class="number">1000</span>, <span class="string">&quot;张雯&quot;</span>) &#125;);</span><br><span class="line">	stuMap.<span class="built_in">insert</span>(&#123; <span class="number">1020</span>, <span class="built_in">Student</span>(<span class="number">1020</span>, <span class="string">&quot;李广&quot;</span>) &#125;);</span><br><span class="line">	stuMap.<span class="built_in">insert</span>(&#123; <span class="number">1030</span>, <span class="built_in">Student</span>(<span class="number">1030</span>, <span class="string">&quot;高洋&quot;</span>) &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stuMap.erase(it) stuMap.erase(1020)  stuMap[2000] [2000, V()]</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; stuMap[1020] &lt;&lt; endl;   stuMap.find(key)</span></span><br><span class="line">	<span class="keyword">auto</span> it = stuMap.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != stuMap.<span class="built_in">end</span>(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="keyword">int</span> id, string name)</span><br><span class="line">		:_id(id), _name(name) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Student &amp;stu)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _id &lt; stu._id;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _id;</span><br><span class="line">	string _name;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;stu);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; stu._id &lt;&lt; <span class="string">&quot; name:&quot;</span> &lt;&lt; stu._name &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Student&gt; set1;</span><br><span class="line"></span><br><span class="line">	set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1020</span>, <span class="string">&quot;李广&quot;</span>));</span><br><span class="line">	set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1000</span>, <span class="string">&quot;张雯&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = set1.<span class="built_in">begin</span>();</span><br><span class="line">		it != set1.<span class="built_in">end</span>(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	set&lt;int&gt; set1;</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; 20; ++i)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		set1.insert(rand()%20+1);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	for (int v : set1)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></map></li>
</ul>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">容器的迭代器</span></span><br><span class="line"><span class="comment">const_iterator:常量的正向迭代器  只能读，而不能写了</span></span><br><span class="line"><span class="comment">iterator:普通的正向迭代器</span></span><br><span class="line"><span class="comment">reverse_iterator:普通的反向迭代器</span></span><br><span class="line"><span class="comment">const_reverse_iterator:常量的反向迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// vector&lt;int&gt;::iterator</span></span><br><span class="line">	<span class="comment">// auto it1 = vec.begin(); </span></span><br><span class="line">	<span class="comment">// const_iterator   &lt;=   iterator</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	class const_iterator</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	public:</span></span><br><span class="line"><span class="comment">		const T&amp; operator*()&#123;return *_ptr;&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	class iterator : public const_iterator</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		T&amp; operator*()&#123;return *_ptr;&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::const_iterator it1 = vec.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rbegin()：返回的是最后一个元素的反向迭代器表示</span></span><br><span class="line">	<span class="comment">// rend：返回的是首元素前驱位置的迭代器的表示</span></span><br><span class="line">	<span class="comment">// vector&lt;int&gt;::reverse_iterator</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator rit = vec.<span class="built_in">rbegin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; rit != vec.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *rit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*for (int v : vec)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li>一个类，重载了<code>operator()</code>小括号运算符。如<code>class xx&#123;bool operator()(int a,int b);&#125;</code>。把这个类的对象称为函数对象或者仿函数。</li>
<li>函数对象好处（代替函数指针）：<ul>
<li>通过函数对象调用<code>operator()</code>，可以省略函数的调用开销，比通过函数指针调用函数（不能够<code>inline</code>内联调用）效率高</li>
<li>因为函数对象是用类生成的，所以可以添加相关的成员变量，用来记录函数对象使用时更多的信息</li>
</ul>
</li>
<li><code>sort(vec.begin(),vec.end(),greater&lt;int&gt;())</code><ul>
<li>传入函数对象：<code>greater&lt;int&gt;()</code>。</li>
</ul>
</li>
<li><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;</code><ul>
<li>传入函数对象的类类型<code>:less&lt;int&gt;</code>，将来会在<code>priority_queue</code>的类中造函数对象<code>less&lt;int&gt; comp</code>;<h3 id="仿函数和函数指针对比"><a href="#仿函数和函数指针对比" class="headerlink" title="仿函数和函数指针对比"></a>仿函数和函数指针对比</h3></li>
</ul>
</li>
<li>函数对象示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Compare：函数对象的类类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Compare&gt;  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare cmp)</span>    <span class="comment">//  cmp是个函数对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(a,b);    <span class="comment">//  通过函数对象 调用的是operator()(a,b);</span></span><br><span class="line">    <span class="comment">//  内联inline！</span></span><br><span class="line">    <span class="comment">//  因为cmp是函数对象。也就是()是类内的函数。那么这个函数就是内联的.</span></span><br><span class="line">    <span class="comment">//  因为通过对象调用，那么</span></span><br><span class="line">    <span class="comment">//  编译器看到指定模板参数类型调用compare时，会实例化compare模板函数，而在这时Compare类型已经指定。也就是说对象cmp确定是什么类型的了。</span></span><br><span class="line">    <span class="comment">//  那么我们就可以知道调用哪个函数了。那么编译器就可以将他内联了，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  mygreater类的对象称为 仿函数 / 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mygreater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span></span>&#123;  <span class="comment">//  二元函数对象</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  myless类的对象称为 仿函数 / 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myless</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;myless&lt;<span class="keyword">int</span>&gt;()(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;   <span class="comment">//  myless&lt;int&gt;()：仿函数 / 函数对象</span></span><br><span class="line">	cout&lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,myless&lt;<span class="keyword">int</span>&gt;()) &lt;&lt;endl;  <span class="comment">//  传入函数对象</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;compare&lt;int,myless&lt;int&gt;&gt;(1,2,myless&lt;int&gt;())&lt;&lt;endl; </span></span><br><span class="line">    <span class="comment">//  &lt;myless&lt;int&gt;&gt; 显示传入函数对象的类型 </span></span><br><span class="line">    <span class="comment">//  (myless&lt;int&gt;()) 传入函数对象 </span></span><br><span class="line">	<span class="comment">//  myless&lt;int&gt;：模板名 + 类型参数列表 = 类名。这是myless&lt;int&gt;()这个对象的类类型。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>函数指针示例<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Compare 函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare cmp)</span>	<span class="comment">//  cmp是一个函数指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(a,b);    <span class="comment">//  通过函数指针调用</span></span><br><span class="line">    <span class="comment">//  通过函数指针调用缺点：！！！</span></span><br><span class="line">    <span class="comment">//  无法inline、开销大！因为有函数调用的开销！</span></span><br><span class="line">    <span class="comment">//  为什么无法内联？</span></span><br><span class="line">    <span class="comment">//  内联是在编译时期做的。而这里我们通过函数指针调用，是在运行时调用，在运行时传入地址，通过地址调用。</span></span><br><span class="line">    <span class="comment">//  而在编译时，编译器当然不知道调用的是那个函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  这俩不是仿函数，是函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">greater</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myless</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;myless&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;   	   <span class="comment">//  myless&lt;int&gt;:函数指针。</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,myless&lt;<span class="keyword">int</span>&gt;)&lt;&lt;endl;  <span class="comment">//  myless&lt;int&gt;的类型是一个函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="STL示例"><a href="#STL示例" class="headerlink" title="STL示例"></a>STL示例</h3><ul>
<li>STL模板参数指定函数对象类型<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;,</span></span><br><span class="line"><span class="comment">	   typename _Compare  = less&lt;typename _Sequence::value_type&gt; &gt;</span></span><br><span class="line"><span class="comment">    class priority_queue</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    protected:</span></span><br><span class="line"><span class="comment">      //  See queue::c for notes on these names.</span></span><br><span class="line"><span class="comment">      _Sequence  c;</span></span><br><span class="line"><span class="comment">      _Compare   comp;	用类型_Compare定义了一个函数对象</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int&gt; q;  //  使用默认底层容器类型vector&lt;int&gt; 使用默认仿函数类型_Compare = less&lt;..&gt;</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int,vector&lt;int&gt;&gt; q;  //  使用默认 _Compare模板参数类型</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)    q.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>函数调用</title>
    <url>/2022/03/27/c++_%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>汇编：函数调用过程</p>
<span id="more"></span>

<h2 id="内存地址与内存空间关系"><a href="#内存地址与内存空间关系" class="headerlink" title="内存地址与内存空间关系"></a>内存地址与内存空间关系</h2><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li><strong>按字节寻址</strong>，那么一个地址背后就代表8个bit的内存单元；</li>
<li><strong>按字（16位）寻址</strong>，那么一个地址背后就代表16bit的内存单元。</li>
<li><strong>按字（32位）寻址</strong>，那么一个地址背后就代表32bit的内存单元</li>
<li>所以对于同一存储器，按照不同的寻址方式，会有不同的寻址范围，也就是会有不同的寻址地址，但是总容量不变。</li>
</ul>
<h3 id="按字节寻址"><a href="#按字节寻址" class="headerlink" title="按字节寻址"></a>按字节寻址</h3><ul>
<li>下面举例按字节寻址方式</li>
<li>一个地址背后是8bit（1Byte）的内存单元</li>
<li>内存地址只是一个编号，代表一个内存空间。那么这个空间是多大呢？<ul>
<li>计算机中存储器的容量是以字节为基本单位的。<strong>也就是说一个内存地址背后是一个字节（8bit）的存储空间。</strong></li>
</ul>
</li>
<li>例如经常说32位的操作系统最多支持4GB的内存空间，也就是说CPU只能寻址2的32次方（4GB）。<strong>这里默认的寻址方式是按字节寻址</strong>。注意这里的4GB是以Byte为单位的，不是bit。<ul>
<li><code>4G=4*1024M(Byte)=4*1024*1024Kb(Byte)</code>，也即按字节寻址会有<code>2^12</code>个地址，而每个地址背后会有8个bit的空间，故总空间大小为<code>2^15bit</code></li>
</ul>
</li>
<li>所以说用4位16进制表示的内存地址和用8位16进制表示的内存地址，其实都是代表一个8bit的存储空间而已：<blockquote>
<p><img src="/2022/03/27/c++_%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/2022-03-27-14-02-21.png"><br><img src="/2022/03/27/c++_%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/2022-03-27-14-02-38.png"></p>
</blockquote>
</li>
</ul>
<h2 id="汇编复习-x86"><a href="#汇编复习-x86" class="headerlink" title="汇编复习(x86)"></a>汇编复习(x86)</h2><h3 id="text和-data-rodata-bss-和-stack"><a href="#text和-data-rodata-bss-和-stack" class="headerlink" title=".text和.data .rodata .bss 和 stack"></a>.text和.data .rodata .bss 和 stack</h3><ul>
<li>指令（代码）都在.text段中</li>
<li>.data .rodata中是数据。（全局变量，地址啥的）</li>
</ul>
<h3 id="ss-sp-bp（指向栈stack的）"><a href="#ss-sp-bp（指向栈stack的）" class="headerlink" title="ss sp bp（指向栈stack的）"></a>ss sp bp（指向栈stack的）</h3><p><img src="/2022/03/27/c++_%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/2022-03-27-14-24-01.png"></p>
<ul>
<li>ss：存放栈<code>stack</code>的段地址（配合sp、bp使用）</li>
</ul>
<h4 id="sp-esp"><a href="#sp-esp" class="headerlink" title="sp esp"></a>sp esp</h4><ul>
<li><code>sp：stack pointer</code>：栈指针寄存器（16位CPU）<ul>
<li>其内存放着一个指针，该指针永远指向系统栈最上面（地址最高的）一个栈帧的栈顶</li>
<li><code>esp：extended stack pointer</code>：32位cpu</li>
<li><code>rsp</code>：64位cpu </li>
<li><code>sp,esp,rsp</code>都是指向栈顶的寄存器</li>
</ul>
</li>
<li><strong>esp中的指针指向的内存空间有内容，该指针指向的是栈顶地址最低的归本栈帧（有内容）的内存单元</strong></li>
</ul>
<p><img src="/2022/03/27/c++_%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/2022-03-27-14-33-19.png"></p>
<h4 id="bp-ebp"><a href="#bp-ebp" class="headerlink" title="bp ebp"></a>bp ebp</h4><ul>
<li><p><strong>ebp中的指针（地址）所指向（对应）的内存空间不归本栈帧（里没有内容）。指针指向的是栈底有内容的下一内存单元。</strong></p>
</li>
<li><p><code>bp：base pointer</code>：基数指针寄存器</p>
<ul>
<li>其内存放着一个指针，该指针永远指向系统栈最上面（地址最高的）一个栈帧的底部</li>
<li><code>ebp：extended base pointer</code></li>
<li>rbp</li>
<li><code>bp ebp rbp</code>都是指向栈底的寄存器</li>
</ul>
</li>
<li><p><strong><code>SP、ESP</code>就是一直指向栈顶的指针,而EBP只是存取某时刻的栈顶指针,以方便对栈的操作,如获取函数参数、局部变量</strong></p>
</li>
<li><p>和堆栈指针SP联合使用，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到</p>
<ul>
<li><blockquote>
<p>比如说，堆栈中压入了很多数据或者地址，你肯定想通过SP来访问这些数据或者地址，但SP是要指向栈顶的，是不能随便乱改的，这时候你就需要使用BP，把SP的值传递给BP，通过BP来寻找堆栈里数据或者地址．一般除了保存数据外,可以作为指针寄存器用于存储器寻址,此时它默认搭配的段寄存器是SS-堆栈段寄存器.BP是16位的,再扩充16位就是EBP,用于32位编程环境的.一般高级语言的参数传递等等,转换为汇编后经常由BP/EBP来负责寻址\处理.</p>
</blockquote>
</li>
<li><blockquote>
<p>SP,BP一般与段寄存器SS 联用，以确定堆栈寄存器中某一单元的地址，SP用以指示栈顶的偏移地址，而BP可 作为堆栈区中的一个基地址，用以确定在堆栈中的操作数地址。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>也即，栈中有东西的内存单元对应的地址是<code>[esp,ebp)</code></strong></li>
<li><strong>也即是，一个栈帧的有效地址是[esp,ebp)</strong><ul>
<li>[esp,ebp)的地址对应的内存单元的的内容，都是本函数中的局部变量等，而<strong>ss[ebp往高的，可能是另一个函数的栈帧，也有可能是进入本函数栈帧前保留的信息</strong>（<strong>有关上一个函数</strong>）。在离开本函数时，需要通过<code>pop ebp</code>来弹出恢复。（进入函数时push ebp，离开函数时pop ebp） </li>
</ul>
</li>
</ul>
<h3 id="push和pop（栈自高向低使用）。"><a href="#push和pop（栈自高向低使用）。" class="headerlink" title="push和pop（栈自高向低使用）。"></a><code>push</code>和<code>pop</code>（栈自高向低使用）。</h3><ul>
<li>栈顶：低地址</li>
<li>栈底：高地址</li>
<li><code>push</code>：从栈顶push<ul>
<li>esp向低移动，再向移出来的内存中放入内容。<code>esp-4,再放int型内容</code> </li>
</ul>
</li>
<li><code>pop</code>：从栈底pop<ul>
<li>esp指向的内容弹出，esp向高移动</li>
</ul>
</li>
</ul>
<h3 id="CS-IP-（指向-text段（代码段）的）"><a href="#CS-IP-（指向-text段（代码段）的）" class="headerlink" title="CS IP （指向.text段（代码段）的）"></a>CS IP （指向.text段（代码段）的）</h3><ul>
<li><code>CS</code>为代码段寄存器，<code>IP</code>为指令指针寄存器，它们指示了<code>CPU</code>当前要读取指令的地址</li>
<li>他们指向的指令位于<code>.text</code>段</li>
</ul>
<h2 id="C-函数调用"><a href="#C-函数调用" class="headerlink" title="C++函数调用"></a>C++函数调用</h2><p><img src="/2022/03/27/c++_%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/2022-03-27-18-37-59.png"></p>
<h3 id="调用sum"><a href="#调用sum" class="headerlink" title="调用sum"></a>调用sum</h3><ul>
<li>call sum<ul>
<li>1、将下一条指令的地址(CS:IP)压入栈stack（这个地址何尝不是一种要保存的数据）。 <ul>
<li> 也即 esp-4，再将源数(add esp , 8)的地址复制到esp所指位置</li>
<li> 当然如果是段间转移就要将CS和IP入栈，如果是段内转移就只要将IP入栈</li>
</ul>
</li>
<li> 2、跳转到sum处</li>
</ul>
</li>
</ul>
<h3 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h3><ul>
<li>{  :   <ul>
<li>【1】保留main栈帧的栈底：将main函数栈帧的栈底（ebp）压入栈。</li>
<li>【2】设置新栈底地址：栈底ebp也移动到新栈帧（sum函数的）的起始处。与此时esp指向同一地址</li>
<li>【3】为新栈帧分配空间：移动栈顶指针esp<br>push ebp<br>mov ebp , esp<br>sub esp , 4ch</li>
</ul>
</li>
<li>代码段：<ul>
<li>int t = 0;    <ul>
<li>mov dword ptr[ebp-4] , 0</li>
</ul>
</li>
<li>t = a + b;    <ul>
<li>mov eax , dword ptr[ebp+0Ch]          </li>
<li>add eax , dword ptr[ebp+08h]</li>
<li>  mov dword ptr[ebp-4] , eax</li>
</ul>
</li>
<li>return a + b; <ul>
<li>mov eax , dword ptr[ebp-4]<br>通过eax寄存器将结果带出函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>}:<ul>
<li>【1】   将esp移到栈顶（为了寻回之前保留的main栈帧以及能跳转到call sum的下一条指令）</li>
<li>【2】   取回main栈帧的栈顶（进入sum前保存在栈里） 存入ebp</li>
<li>【3】   跳转到sum函数的下一条指令的地址（进入sum前保存在栈里）</li>
<li>mov esp , ebp</li>
<li>pop ebp <ul>
<li>esp += 4</li>
<li>取出内容 放入ebp</li>
</ul>
</li>
<li>ret<ul>
<li>(IP)=((ss)∗16+(esp)) 下一条指令指向该地址内存内保存的地址 </li>
<li>(esp)=(esp)+2</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>*/</p>
<h3 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h3><ul>
<li>调用函数：<ol>
<li>参数压栈（传入的参数）</li>
<li>call 函数名 a.保存下一指令地址   b.跳转到目标函数</li>
<li>进入函数 { ：<br> 保留现函数栈底 ，<br> 开辟栈帧 ，</li>
<li>函数代码段</li>
<li>离开函数 } ：<br> 栈帧回退 ，<br> 取回函数调用方的函数栈底，<br> 跳转到函数调用处的下一条指令（ret，对应sum）</li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    t = a + b;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  对于sum</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;  :   </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">【1】保留main栈帧的栈底：将main函数栈帧的栈底（ebp）压入栈。</span></span><br><span class="line"><span class="comment">【2】分配新栈底地址：栈底ebp也移动到新栈帧（sum函数的）的起始处。与esp指向同一地址</span></span><br><span class="line"><span class="comment">【3】为新栈帧分配空间：移动栈顶指针esp</span></span><br><span class="line"><span class="comment">    push ebp</span></span><br><span class="line"><span class="comment">    mov ebp , esp</span></span><br><span class="line"><span class="comment">    sub esp , 4ch</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码段：</span></span><br><span class="line"><span class="comment">int t = 0;    mov dword ptr[ebp-4] , 0</span></span><br><span class="line"><span class="comment">t = a + b;    mov eax , dword ptr[ebp+0Ch]</span></span><br><span class="line"><span class="comment">              add eax , dword ptr[ebp+08h]</span></span><br><span class="line"><span class="comment">              mov dword ptr[ebp-4] , eax</span></span><br><span class="line"><span class="comment">return a + b; mov eax , dword ptr[ebp-4]</span></span><br><span class="line"><span class="comment">通过eax寄存器将结果带出函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;:</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">【1】   栈帧回退：将esp移到栈顶（为了寻回之前保留的main栈帧以及能跳转到call sum的下一条指令）</span></span><br><span class="line"><span class="comment">【2】   取回main栈帧的栈顶（进入sum前保存在栈里） 存入ebp</span></span><br><span class="line"><span class="comment">【3】   跳转到sum函数的下一条指令的地址（进入sum前保存在栈里）</span></span><br><span class="line"><span class="comment">    mov esp , ebp</span></span><br><span class="line"><span class="comment">    pop ebp </span></span><br><span class="line"><span class="comment">        esp += 4</span></span><br><span class="line"><span class="comment">        取出内容 放入ebp</span></span><br><span class="line"><span class="comment">    ret</span></span><br><span class="line"><span class="comment">        (IP)=((ss)∗16+(esp)) 下一条指令指向该地址内存内保存的地址 </span></span><br><span class="line"><span class="comment">        (esp)=(esp)+2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;     <span class="comment">//  mov dowrd ptr[ebp-4]</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;     <span class="comment">//  mov dword ptr[ebp-8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用函数：</span></span><br><span class="line"><span class="comment">//    1. 参数压栈（传入的参数）</span></span><br><span class="line"><span class="comment">//    2. call 函数名 a.保存下一指令地址   b.跳转到目标函数</span></span><br><span class="line"><span class="comment">//    3. 进入函数 &#123; ：</span></span><br><span class="line"><span class="comment">//        保留现函数栈底 ，</span></span><br><span class="line"><span class="comment">//        开辟栈帧 ，</span></span><br><span class="line"><span class="comment">//    4. 函数代码段</span></span><br><span class="line"><span class="comment">//    5. 离开函数 &#125; ：</span></span><br><span class="line"><span class="comment">//        栈帧回退 ，</span></span><br><span class="line"><span class="comment">//        取回函数调用方的函数栈底，</span></span><br><span class="line"><span class="comment">//        跳转到函数调用处的下一条指令（ret，对应sum）。</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">sum</span>(a,b); </span><br><span class="line">    <span class="comment">//  参数压栈</span></span><br><span class="line">    <span class="comment">//  处理形参。在函数调用处为形参开辟空间</span></span><br><span class="line">    <span class="comment">//  mov eax , dword[ebp-8]</span></span><br><span class="line">    <span class="comment">//  push eax</span></span><br><span class="line">    <span class="comment">//  mov eax , dword[ebp-4]</span></span><br><span class="line">    <span class="comment">//  push eax</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  **call sum**</span></span><br><span class="line">    <span class="comment">//      call：</span></span><br><span class="line">    <span class="comment">//      1、将下一条指令的地址(CS:IP)压入栈stack（这个地址何尝不是一种要保存的数据）。 </span></span><br><span class="line">    <span class="comment">//          也即 esp-4，再将源数(add esp , 8)的地址复制到esp所指位置</span></span><br><span class="line">    <span class="comment">//          当然如果是段间转移就要将CS和IP入栈，如果是段内转移就只要将IP入栈</span></span><br><span class="line">    <span class="comment">//      2、跳转到sum处</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  0x08124558  add esp , 8</span></span><br><span class="line">    <span class="comment">//  mov dword ptr[ebp-0Ch] , eax    将结果从寄存器放到内存中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- sum函数的</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> function _Z3sumii:</span><br><span class="line">   <span class="number">0x00007ff76a7516e0</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp</span><br><span class="line">   <span class="number">0x00007ff76a7516e1</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x00007ff76a7516e4</span> &lt;+<span class="number">4</span>&gt;:	sub    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   </span><br><span class="line">   <span class="number">0x00007ff76a7516e8</span> &lt;+<span class="number">8</span>&gt;:	mov    %ecx,<span class="number">0x10</span>(%rbp)</span><br><span class="line">   <span class="number">0x00007ff76a7516eb</span> &lt;+<span class="number">11</span>&gt;:	mov    %edx,<span class="number">0x18</span>(%rbp)</span><br><span class="line">   <span class="number">0x00007ff76a7516ee</span> &lt;+<span class="number">14</span>&gt;:	movl   $<span class="number">0x0</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   <span class="number">0x00007ff76a7516f5</span> &lt;+<span class="number">21</span>&gt;:	mov    <span class="number">0x10</span>(%rbp),%edx</span><br><span class="line">   <span class="number">0x00007ff76a7516f8</span> &lt;+<span class="number">24</span>&gt;:	mov    <span class="number">0x18</span>(%rbp),%eax</span><br><span class="line">   <span class="number">0x00007ff76a7516fb</span> &lt;+<span class="number">27</span>&gt;:	add    %edx,%eax</span><br><span class="line">   <span class="number">0x00007ff76a7516fd</span> &lt;+<span class="number">29</span>&gt;:	mov    %eax,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   <span class="number">0x00007ff76a751700</span> &lt;+<span class="number">32</span>&gt;:	mov    <span class="number">0x10</span>(%rbp),%edx</span><br><span class="line">   <span class="number">0x00007ff76a751703</span> &lt;+<span class="number">35</span>&gt;:	mov    <span class="number">0x18</span>(%rbp),%eax</span><br><span class="line">   <span class="number">0x00007ff76a751706</span> &lt;+<span class="number">38</span>&gt;:	add    %edx,%eax</span><br><span class="line"></span><br><span class="line">=&gt; <span class="number">0x00007ff76a751708</span> &lt;+<span class="number">40</span>&gt;:	add    $<span class="number">0x10</span>,%rsp</span><br><span class="line">   <span class="number">0x00007ff76a75170c</span> &lt;+<span class="number">44</span>&gt;:	pop    %rbp</span><br><span class="line">   <span class="number">0x00007ff76a75170d</span> &lt;+<span class="number">45</span>&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//  =&gt; 0x00007ff703b916ed &lt;+13&gt;:	movl   $0xa,-0x4(%rbp)</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="number">0x00007ff703b916e0</span> &lt;+<span class="number">0</span>&gt;:	push   %rbp</span><br><span class="line">   <span class="number">0x00007ff703b916e1</span> &lt;+<span class="number">1</span>&gt;:	mov    %rsp,%rbp</span><br><span class="line">   <span class="number">0x00007ff703b916e4</span> &lt;+<span class="number">4</span>&gt;:	sub    $<span class="number">0x30</span>,%rsp</span><br><span class="line">   <span class="number">0x00007ff703b916e8</span> &lt;+<span class="number">8</span>&gt;:	call   <span class="number">0x7ff703b91887</span> &lt;__main&gt;</span><br><span class="line">=&gt; <span class="number">0x00007ff703b916ed</span> &lt;+<span class="number">13</span>&gt;:	movl   $<span class="number">0xa</span>,<span class="number">-0x4</span>(%rbp)</span><br><span class="line">   <span class="number">0x00007ff703b916f4</span> &lt;+<span class="number">20</span>&gt;:	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">   <span class="number">0x00007ff703b916f9</span> &lt;+<span class="number">25</span>&gt;:	add    $<span class="number">0x30</span>,%rsp</span><br><span class="line">   <span class="number">0x00007ff703b916fd</span> &lt;+<span class="number">29</span>&gt;:	pop    %rbp</span><br><span class="line">   <span class="number">0x00007ff703b916fe</span> &lt;+<span class="number">30</span>&gt;:	ret    </span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/27/c++_%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/2022-03-30-19-55-09.png"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_对象优化</title>
    <url>/2022/03/12/c++_%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>对象优化：三原则、右值引用、移动构造、move、引用折叠&amp;完美转发forward</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">》》》》C++高级课程内容提纲《《《《</span><br><span class="line">一：对象的应用优化、右值引用的优化</span><br><span class="line">二：智能指针</span><br><span class="line">三：绑定器和函数对象、lambda表达式</span><br><span class="line">四：C++11内容汇总、多线程应用实践</span><br><span class="line">五：设计模式</span><br><span class="line">六：面向对象编程实践</span><br><span class="line">1.深度遍历搜索迷宫路径</span><br><span class="line">2.广度遍历搜索迷宫路径找最短路径</span><br><span class="line">3.大数加减法</span><br><span class="line">4.海量数据查重以及求top k问题</span><br><span class="line">5.数字化男女匹配问题</span><br><span class="line">七：校招C++面经讲解</span><br><span class="line">八：应聘C++研发岗简历该怎么写</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>


<ul>
<li>对象优化</li>
<li><code>Test a = Test(int)</code>：会被优化成int形参的构造函数 <code>Test(int)</code></li>
<li><code>Test a = b</code>：会被优化成拷贝构造 <code>Test(int)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()  &#123; cout&lt;&lt;<span class="string">&quot;Test()&quot;</span>&lt;&lt;endl;&#125;            </span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a):<span class="built_in">m_a</span>(a)  &#123;cout&lt;&lt;<span class="string">&quot;Test(int)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t) :<span class="built_in">m_a</span>(t.m_a) &#123;cout&lt;&lt;<span class="string">&quot;Test(const Test&amp;)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    Test &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;t)</span><br><span class="line">    &#123;</span><br><span class="line">        m_a = t.m_a;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;operator=&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;cout&lt;&lt;<span class="string">&quot;~Test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">10</span>)</span></span>;        <span class="comment">//  拷贝构造函数</span></span><br><span class="line">    Test t3 = t1;       <span class="comment">//  拷贝构造而非赋值运算符</span></span><br><span class="line">    <span class="function">Test <span class="title">t4</span><span class="params">(t2)</span></span>;        <span class="comment">//  赋值运算符</span></span><br><span class="line">    <span class="comment">//  下面这句等同于 Test t5(10);</span></span><br><span class="line">    Test t5 = <span class="built_in">Test</span>(<span class="number">10</span>);     <span class="comment">//  原以为：Test(10) 显示构造、由于临时量、语句结束就要调用析构，语句要执行拷贝构造t5</span></span><br><span class="line">    <span class="comment">//  实际上 只是显示构造 Test(10)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> ！！！！   C++编译器对于对象构造的优化：用临时量生成新对象时，临时对象就不产生了，直接构造新对象就可以了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   t5 = t1;             <span class="comment">//  operator=</span></span><br><span class="line">   t5 = <span class="built_in">Test</span>(<span class="number">2</span>);        <span class="comment">//  构造临时对象 再赋值给t5</span></span><br><span class="line">   <span class="comment">//   这条语句不能优化，因为t5已经存在，怎么可能优化成构造函数</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;-------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   t5 = <span class="number">20</span>;     <span class="comment">//  隐士转换。因为有只待一个整形参数的构造函数</span></span><br><span class="line">   <span class="comment">//  int -&gt; Test(int)   临时对象再赋值</span></span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;-------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Test *pt = &amp;Test(-1);            //  [error]：taking address of temporary [-fpermissive]           </span></span><br><span class="line">   <span class="keyword">const</span> Test &amp;rt = <span class="built_in">Test</span>(<span class="number">-1</span>);       <span class="comment">//  常量引用可以引用右直，非常量引用不可以。</span></span><br><span class="line">   <span class="comment">//具体：const int temp = Test(-1);   const Test &amp; rt = temp; 故不会引用临时地址</span></span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;-------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./lesson01.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">const</span> Test&amp;)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">const</span> Test&amp;)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">------------------</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span></span>=</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">operator</span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">-------------------</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">operator</span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ g++ lesson01.cpp -o lesson01.out -Wall</span><br><span class="line">lesson01.cpp: In function ‘<span class="keyword">int</span> <span class="built_in">main</span>()’:</span><br><span class="line">lesson01.cpp:<span class="number">46</span>:<span class="number">23</span>: error: taking address of temporary [-fpermissive]</span><br><span class="line">    Test *pt = &amp;<span class="built_in">Test</span>(<span class="number">-1</span>);            <span class="comment">//  [warning]：taking address of temporary [-fpermissive]</span></span><br><span class="line">                       ^</span><br><span class="line">lesson01.cpp:<span class="number">46</span>:<span class="number">10</span>: warning: unused variable ‘pt’ [-Wunused-variable]</span><br><span class="line">    Test *pt = &amp;<span class="built_in">Test</span>(<span class="number">-1</span>);            <span class="comment">//  [warning]：taking address of temporary [-fpermissive]</span></span><br><span class="line">          ^~</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ g++ lesson01.cpp -o lesson01.out -Wall</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./lesson01.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">const</span> Test&amp;)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">const</span> Test&amp;)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">------------------</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span></span>=</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">operator</span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">-------------------</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">operator</span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">-------------------</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line">-------------------</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ </span><br></pre></td></tr></table></figure>

<ul>
<li>静态变量的初始化是在第一次运行到他的时候<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 07 C++对象应用优化.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include &quot;pch.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// Test() Test(10) Test(10, 10)</span></span><br><span class="line">	<span class="built_in">Test</span>(<span class="keyword">int</span> a = <span class="number">5</span>, <span class="keyword">int</span> b = <span class="number">5</span>) </span><br><span class="line">		:<span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test(int, int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Test</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Test</span>(<span class="keyword">const</span> Test &amp;src) </span><br><span class="line">		:<span class="built_in">ma</span>(src.ma), <span class="built_in">mb</span>(src.mb)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Test &amp;src)</span><br><span class="line">	&#123;</span><br><span class="line">		ma = src.ma; </span><br><span class="line">		mb = src.mb; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  构造时 t1 t5 t4</span></span><br><span class="line"><span class="comment">//  析构时 t4 t5 t1</span></span><br><span class="line"><span class="comment">//  static变量何时被构造？：第一次运行到这个变量的位置时。</span></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 1.Test(int, int)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;                <span class="comment">// 3.Test(int, int)</span></span><br><span class="line">	Test t3 = t2;                   <span class="comment">// 4.Test(const Test&amp;)</span></span><br><span class="line">	<span class="comment">// static Test t4(30, 30);</span></span><br><span class="line">	<span class="keyword">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>);  <span class="comment">// 5.Test(int, int)</span></span><br><span class="line">	t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>);              <span class="comment">// 6.Test(int, int) operator= ~Test()</span></span><br><span class="line">	<span class="comment">// (50, 50) =  (Test)50; Test(int)</span></span><br><span class="line">	t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>);            <span class="comment">// 7.Test(int,int) operator=  ~Test()</span></span><br><span class="line">	t2 = <span class="number">60</span>;                        <span class="comment">// Test(int) 8.Test(int,int) operator= ~Test()</span></span><br><span class="line">	Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>);    <span class="comment">// 9. Test(int,int) </span></span><br><span class="line">	Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>];         <span class="comment">// 10. Test(int,int) Test(int,int)  调用默认构造函数，依次构造数组里的对象</span></span><br><span class="line">	Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>);       <span class="comment">// ERROR 11. Test(int,int)  ~Test()</span></span><br><span class="line">	<span class="keyword">const</span> Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>);  <span class="comment">// 12. Test(int,int)</span></span><br><span class="line">	<span class="keyword">delete</span> p1;                      <span class="comment">// 13.~Test()</span></span><br><span class="line">	<span class="keyword">delete</span>[]p2;                     <span class="comment">// 14. ~Test() ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 2.Test(int, int)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./lesson01b.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">const</span> Test&amp;)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">operator</span></span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">operator</span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">operator</span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对象的优化三原则"><a href="#对象的优化三原则" class="headerlink" title="对象的优化三原则"></a>对象的优化三原则</h2><p><a href="https://zhuanlan.zhihu.com/p/95544072#:~:text=C%2B%2B%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%9C%A8,%E8%B5%8B%E5%80%BC%E7%BB%99%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%82">实际上</a><br>以下都不考虑编译器自动做出的优化</p>
<h3 id="总"><a href="#总" class="headerlink" title="总"></a>总</h3><ul>
<li>传参数传递引用（可以减少一或多个构造和析构函数）</li>
<li>函数返回对象的时候，有限返回临时对象而非定义好的局部对象</li>
<li>接收返回值是对象的函数调用时，尽量在定义时初始化接收、而非定义好了再用函数返回值去赋值</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="初：不传引用、不返回临时对象"><a href="#初：不传引用、不返回临时对象" class="headerlink" title="初：不传引用、不返回临时对象"></a>初：不传引用、不返回临时对象</h4><ul>
<li>耗费：<ul>
<li><strong>形参</strong>会调用<strong>拷贝构造</strong>函数</li>
<li>返回对象时，会在<strong>main栈帧调用拷贝构造</strong>函数，以函数内的对象为蓝本构造出一个临时对象。然后这个main栈帧上的临时对象再<strong>拷贝赋值</strong>给main调用处的，之前已经定义好的t。</li>
<li>还要对函数中的局部对象tmp进行<strong>析构</strong><br><img src="/2022/03/12/c++_%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96/2022-03-12-23-54-27.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">GetObject</span><span class="params">(Test t)</span> <span class="comment">//  拷贝构造 初始化形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="function">Test <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">	<span class="comment">//  return tmp</span></span><br><span class="line">	<span class="comment">//  由于tmp离开GetObject函数之后就被销毁</span></span><br><span class="line">	故会在main函数栈帧上产生一个临时对象，来接受这个函数的返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t1;						<span class="comment">//  1.  Test(int)</span></span><br><span class="line">	Test t2;						<span class="comment">//  2.  Test(int)</span></span><br><span class="line">	t2 = <span class="built_in">GetObject</span>(t1);				</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;						</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ g++ test01.cpp -o test01.out -Wall -fno-elide-constructors</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./test01.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">const</span> Test&amp;)</span></span></span><br><span class="line"><span class="function">~<span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">operator</span></span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="传引用"><a href="#传引用" class="headerlink" title="传引用"></a>传引用</h4><ul>
<li>形参用引用，节省掉对形参的拷贝构造函<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Test <span class="title">GetObject</span><span class="params">(Test &amp;t)</span> <span class="comment">// 引用、省去拷贝构造</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="function">Test <span class="title">tmp</span><span class="params">(val)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">	<span class="comment">//  return tmp</span></span><br><span class="line">	<span class="comment">//  由于tmp离开GetObject函数之后就被销毁</span></span><br><span class="line">	故会在main函数栈帧上产生一个临时对象，来接受这个函数的返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="返回临时对象"><a href="#返回临时对象" class="headerlink" title="返回临时对象"></a>返回临时对象</h4><ul>
<li>返回构造的临时对象，而非定义好的有地址的对象。<br><img src="/2022/03/12/c++_%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96/2022-03-13-15-04-22.png"></li>
<li>省去了对函数内局部对象的构造和析构。直接在main栈帧上调用拷贝构造和析构。也就是少了一对构造和析构。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 	</span></span><br><span class="line"><span class="comment">用临时对象去构造新对象（Test t = Test(int))，并不是 Test(int) + operator= 而是 Test(int)</span></span><br><span class="line"><span class="comment">编译器会作出优化。将临时对象优化掉 </span></span><br><span class="line"><span class="comment">	Test t = Test(30); </span></span><br><span class="line"><span class="comment">	原本的 现实构造Test(int) + 拷贝赋值运算 operator= 变成 </span></span><br><span class="line"><span class="comment">	Test t(30);	显示构造 Test(int)</span></span><br><span class="line"><span class="comment">	节省了一步operator= 和 一步析构函数 ～Test()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">GetObject</span><span class="params">(Test &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Test</span>(val);				<span class="comment">//  3.  Test(int)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t1;						<span class="comment">//  1.  Test(int)</span></span><br><span class="line">	Test t2;						<span class="comment">//  2.  Test(int)</span></span><br><span class="line">	t2 = <span class="built_in">GetObject</span>(t1);				<span class="comment">//  4.  operator=</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;						<span class="comment">//  5.  Getobject返回的临时对象 ～Test()   </span></span><br><span class="line">									<span class="comment">//  6.  t2 ~Test()  7.  t1 ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./lesson02.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">operator</span></span>=</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br></pre></td></tr></table></figure>

<h4 id="初始化调用处（最终）"><a href="#初始化调用处（最终）" class="headerlink" title="初始化调用处（最终）"></a>初始化调用处（最终）</h4><p><img src="/2022/03/12/c++_%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96/2022-03-13-15-36-40.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">GetObject</span><span class="params">(Test &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = t.<span class="built_in">getData</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Test</span>(val);				</span><br><span class="line"><span class="comment">//  临时对象去构造main栈贞上的对象，即 Test t = Test(val)。因此该临时对象被优化掉，就变成了main栈镇上有个 Test t(int)</span></span><br><span class="line"><span class="comment">//  结果main栈真上的这个对象也是个要去构造别的对象的临时对象，即 Test t2 = Test(int) 故该Test(int)可以被优化掉</span></span><br><span class="line"><span class="comment">//  故而直接就是 Test t2(int)</span></span><br><span class="line"><span class="comment">//  节省了析构函数 构造函数（临时对象被优化掉，即意味着这个临时对象根本就没产生，也故一定不需要调用析构函数去释放他，更不用说调用构造函数造出来他。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test t1;						<span class="comment">//  1.  Test(int)</span></span><br><span class="line">	Test t2 = <span class="built_in">GetObject</span>(t1);		<span class="comment">//  2.  Test t(30)</span></span><br><span class="line">									<span class="comment">//  3.  t1 ~Test()</span></span><br><span class="line">									<span class="comment">//  4.  t2 ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./lesson02.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">Test</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">~<span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">~<span class="title">Test</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>



<h2 id="右值、移动构造"><a href="#右值、移动构造" class="headerlink" title="右值、移动构造"></a>右值、移动构造</h2><ul>
<li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88653747?spm=1001.2014.3001.5502">还没看</a></li>
<li>右值引用：提升有临时对象参与的操作中的效率问题</li>
</ul>
<p><img src="/2022/03/12/c++_%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96/2022-03-13-16-32-47.png"><br><img src="/2022/03/12/c++_%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96/2022-03-13-16-42-45.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  三大件：拷贝构造 拷贝赋值 析构函数</span></span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *ptr=<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;CMyString(const char*)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(!ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">            *m_ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;m_ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(ptr) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_ptr,ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  带左值引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="keyword">const</span> CMyString &amp;str) <span class="comment">//  拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;CMyString(const CMyString &amp;)&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_ptr,str.m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  带右直引用参数的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">CMyString</span>(CMyString &amp;&amp; str)     <span class="comment">//  str即将被销毁，故可以匹配到右直引用的参数列表</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;CMyString(const CMyString &amp;&amp;)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_ptr = str.m_ptr;</span><br><span class="line">        str.m_ptr = <span class="literal">nullptr</span>;        <span class="comment">//  别忘了！！！不然一会str析构，则会把str.m_ptr给释放</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带左值引用参数的赋值重载函数</span></span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;CMyString&amp; operator=(const CMyString &amp;str)&quot;</span>&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;str) <span class="keyword">return</span> *<span class="keyword">this</span>;    <span class="comment">//  判是否是自己 拷贝构造则不需要，因为构造麻，调用构造函数的对象本身还没构造完呢，怎么可能和传进来的一样。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_ptr) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_ptr,str.m_ptr);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  带右直引用参数的赋值重载函数</span></span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span>=(CMyString &amp;&amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;CMyString&amp; operator=(CMyString&amp;&amp;) &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_ptr = str.m_ptr;</span><br><span class="line">        str.m_ptr = <span class="literal">nullptr</span>;        <span class="comment">////  别忘了！！！不然一会str析构，则会把str.m_ptr给释放</span></span><br><span class="line">        <span class="comment">//  这也就是C++ Primer所说的，使右直引用的对象处于可以安全析构的状态。</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CMyString</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;~CMyString()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span> []<span class="keyword">this</span>-&gt;m_ptr;       <span class="comment">//  别忘了[]!!!</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">c_str</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> m_ptr;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> CMyString&amp;);</span><br><span class="line">    <span class="keyword">friend</span> CMyString <span class="keyword">operator</span>+(<span class="keyword">const</span> CMyString&amp;, <span class="keyword">const</span> CMyString&amp;);</span><br><span class="line">    <span class="keyword">char</span> *m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  出于某种原因，在这个返回对象的函数里，我们不能返回临时对象，只能返回已经定义好的对象</span></span><br><span class="line"><span class="comment">//  并且出于某种原因，我们也不能在调用函数处用初始化的方式接收函数返回值</span></span><br><span class="line"><span class="function">CMyString <span class="title">GetString</span><span class="params">(CMyString &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="function">CMyString <span class="title">tmpStr</span><span class="params">(p)</span></span>;        <span class="comment">//  显示构造</span></span><br><span class="line">    <span class="keyword">return</span> tmpStr;              </span><br><span class="line"><span class="comment">//  tmpStr对象 -&gt; 为了获取该对象值，需在main栈帧上**右值拷贝构造**来构造临时对象 ---(然后就析构)--&gt; main栈帧上的临时对象再**右值赋值**给str2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(<span class="string">&quot;aaaaaaaaaaaaa&quot;</span>)</span></span>;</span><br><span class="line">    CMyString str2;</span><br><span class="line">    str2 = <span class="built_in">GetString</span>(str1);</span><br><span class="line">    cout&lt;&lt;str2.<span class="built_in">c_str</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  引入右值引用 -&gt; 右值引用参数的拷贝构造、赋值运算符</span></span><br><span class="line"><span class="comment">//  调用函数个数并没减少，但是不用申请内存、拷贝内容、释放内存，效率极大提高。</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./CMyString.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">CMyString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"><span class="title">CMyString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"><span class="title">CMyString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"><span class="title">CMyString</span><span class="params">(<span class="keyword">const</span> CMyString &amp;&amp;)</span></span></span><br><span class="line"><span class="function">~<span class="title">CMyString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">CMyString&amp; <span class="keyword">operator</span></span>=(CMyString&amp;&amp;) </span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">aaaaaaaaaaaaa</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//  没引入右值引用之前</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ g++ CMyString.cpp -o CMyString.out -Wall -fno-elide-constructors</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./CMyString.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">CMyString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"><span class="title">CMyString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"><span class="title">CMyString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"><span class="title">CMyString</span><span class="params">(<span class="keyword">const</span> CMyString &amp;)</span>    <span class="comment">//  tmpStr拷贝构造栈帧上的临时对象</span></span></span><br><span class="line"><span class="function">~<span class="title">CMyString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">CMyString&amp; <span class="keyword">operator</span></span>=(<span class="keyword">const</span> CMyString &amp;str)  <span class="comment">//  main栈帧上的临时对象拷贝给t</span></span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">aaaaaaaaaaaaa</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>引入右值之后</p>
<ul>
<li>没有做过任何空间的开辟和数据的拷贝，效率很高<br><img src="/2022/03/12/c++_%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96/2022-04-11-12-30-46.png"></li>
</ul>
</li>
<li><p>右值还改善了operator+等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  CMyString operator+(const CMyString &amp;,const CMyString&amp;)</span></span><br><span class="line">CMyString <span class="keyword">operator</span>+(<span class="keyword">const</span> CMyString&amp; str1, <span class="keyword">const</span> CMyString&amp; str2)</span><br><span class="line">&#123;</span><br><span class="line">    CMyString tmpStr;</span><br><span class="line">    tmpStr.m_ptr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str1.m_ptr) + <span class="built_in">strlen</span>(str2.m_ptr) + <span class="number">1</span>]; <span class="comment">//  +1 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(tmpStr.m_ptr, str1.m_ptr);</span><br><span class="line">    <span class="built_in">strcat</span>(tmpStr.m_ptr, str2.m_ptr);   <span class="comment">//  strcat会自动在末尾加&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> tmpStr;</span><br><span class="line">    <span class="comment">//  返回的tmpStr是个即将被销毁的局部对象 是一个右值。!!!</span></span><br><span class="line">    <span class="comment">//  编译器将把他匹配给 右值&amp;&amp;引用的参数列表</span></span><br><span class="line">    <span class="comment">//  因此在构造main栈帧的临时对象时会调用右值拷贝构造。即 CMyString(CMyString&amp;&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; str.<span class="built_in">c_str</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CMyString s1 = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    CMyString s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    CMyString s3 = s1 + s2;     <span class="comment">//  CMyString</span></span><br><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>*)</span><br><span class="line"><span class="built_in">CMyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>*)</span><br><span class="line"><span class="built_in">CMyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>*)          <span class="comment">//  tmpStr</span></span><br><span class="line"><span class="built_in">CMyString</span>(<span class="keyword">const</span> CMyString &amp;&amp;)   <span class="comment">// s3构造</span></span><br><span class="line">~<span class="built_in">CMyString</span>()        <span class="comment">//  tmpStr析构</span></span><br><span class="line">hello World</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/12/c++_%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96/2022-04-11-13-23-33.png"></p>
</li>
</ul>
<h3 id="右值引用、左值引用"><a href="#右值引用、左值引用" class="headerlink" title="右值引用、左值引用"></a>右值引用、左值引用</h3><ul>
<li>见c基础复习</li>
</ul>
<h2 id="std-move-和-std-forward"><a href="#std-move-和-std-forward" class="headerlink" title="std::move 和 std::forward"></a>std::move 和 std::forward</h2><h3 id="move-移动语义"><a href="#move-移动语义" class="headerlink" title="move 移动语义"></a>move 移动语义</h3><ul>
<li><strong>move</strong>：编译器强制将一个对象（无论左右）认为是一个右值。<ul>
<li>目的：为了匹配到想让其构造的函数（因为右值变量本身是一个左值，这会使得其去调用左值引用匹配的函数，与我们预期不符）</li>
</ul>
</li>
<li>move本身不移动内存里的内容，只是让编译器识别他是个右值，并交付给相应函数</li>
<li>虽然move本身不移动，但是正常来讲，move使得这个传入的参数匹配到了处理右值的函数，那么，那个函数正常来讲就会把传入的这个对象所管理的内存交付给别人，使得传入的对象从此无效。</li>
<li>也就是说当 <code>func(std::move(a))</code>时，func会匹配到处理右值函数，正常来讲会把a对象内的ptr交付给别处管理，a从此处于无效的，可析构的状态，之后也就用户也就该知道，不可以访问a。否则极有可能异常。</li>
<li>原理<ul>
<li>引用折叠 + remove_reference_t + static_cast</li>
<li>remove_reference_t获取本来的不带引用的基本类型，然后static_cast为对应右值引用类型。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Ty&gt; <span class="built_in">func</span>(Ty&amp;&amp;)：引用折叠</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> <span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="title">move</span><span class="params">(_Ty&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="comment">// forward _Arg as movable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);    <span class="comment">//  语法层面强转为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">allocator</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; val)</span>   <span class="comment">//  负责对象构造(在已有的内存上)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(val);     <span class="comment">//  定位new  在p指向的内存上构造(拷贝构造)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; rval)</span>   <span class="comment">//  参数val匹配右值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//  在p处定位new 调用T的拷贝构造函数。</span></span><br><span class="line">        <span class="comment">//  rval这个右值引用变量本身为左值；但是他所引用的那个变量val是个右值。因此我们要通过mover(val)来实现类型的转换</span></span><br><span class="line">        <span class="comment">//  move实现的是语法层面的转换，告诉编译器rval是个右值，让他匹配右值拷贝构造函数。并没有对rval本身内存做出什么更改的事情</span></span><br><span class="line">        <span class="comment">// 只是改变了语法层面的类型，为了让编译器识别出他（所引用的）是个右值</span></span><br><span class="line">        <span class="comment">//  因为val为右值，因此调用拷贝构造函数时，匹配的就是T(&amp;&amp;)</span></span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(std::<span class="built_in">move</span>(rval)); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">vector</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        <span class="comment">//        *_last++ = val;     //  元素的operator=</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last++, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  push_back(&amp;&amp;) -&gt; construct(&amp;&amp;) -&gt; new T(&amp;&amp;)（也就是调用 类型的右值拷贝构造，如CMyString(&amp;&amp;))</span></span><br><span class="line">    <span class="comment">//  传入的实参为右值时（如CMyString(&quot;aa&quot;);会匹配到这里)</span></span><br><span class="line">    <span class="comment">//  push_back了之后，容器里装的对象就和push_back左值一样。后续对于容器的操作也一样.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; val)</span>     <span class="comment">//  push_back右值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        <span class="comment">//  因为右值变量本身是左值，因此要move一下，让编译器识别他是右值。</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last++, std::<span class="built_in">move</span>(val));  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="forward完美转发-配合-引用折叠使用"><a href="#forward完美转发-配合-引用折叠使用" class="headerlink" title="forward完美转发 配合 引用折叠使用"></a>forward完美转发 配合 引用折叠使用</h3></li>
<li><strong>forward</strong>：通过显示模板实参+引用折叠调用，作用：保持（识别）实参的左值/右值信息。<ul>
<li>一个【成员函数模板调用forward】可以替代 【一对左值为参数的函数和右值为参数的函数】</li>
</ul>
</li>
<li>原理<ul>
<li><a href="https://blog.csdn.net/qq_25327609/article/details/89533836">remove_reference_t</a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">对左值引用和右值引用分别使用不同的模板函数</span><br><span class="line"><span class="comment">// forward an lvalue as either an lvalue or an rvalue</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">    <span class="comment">// static_cast为原本的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forward an rvalue as an rvalue</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="function">_NODISCARD <span class="keyword">constexpr</span> _Ty&amp;&amp; <span class="title">forwar</span><span class="params">(<span class="keyword">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; _Arg)</span> <span class="keyword">noexcept</span> </span>&#123; </span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(!is_lvalue_reference_v&lt;_Ty&gt;, <span class="string">&quot;bad forward call&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);</span><br><span class="line">    <span class="comment">// static_cast为原本的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>forward<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">forward</span><br><span class="line">美[ˈfɔrwərd]英[ˈfɔː(r)wə(r)d]</span><br><span class="line">adv.向前；前进；提前；进展</span><br><span class="line">v.促进；发送；转交；有助于…的发展</span><br><span class="line">adj.向前的；前进的；（尤指船、飞机或其他交通工具）前部的；未来的</span><br><span class="line">n.（运动队的）前锋</span><br><span class="line">网络转发；转寄；远期</span><br></pre></td></tr></table></figure></li>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">allocator</span></span><br><span class="line"><span class="function">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(std::forward&lt;Ty&gt;(val));</span><br><span class="line">    &#125;</span><br><span class="line">vector</span><br><span class="line">    <span class="comment">//  采用引用折叠 + forward完美转发</span></span><br><span class="line">    <span class="comment">//  引用折叠：推导出val到底是右值引用还是左值引用。使得函数可以同时接收左值引用和右值引用。</span></span><br><span class="line">    <span class="comment">//  forward：传参时保留val他（所引用的）到底是一个左值还是右值的信息，即保留引用的类型。</span></span><br><span class="line">    <span class="comment">//  避免左值引用和右值引用变量本身都是左值而失去左右值信息，那样传参就只能传给左值。</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span>        <span class="comment">//  CMyString&amp;&amp; + &amp;&amp; -》 CMyString&amp;&amp; ; CMyString&amp; + &amp;&amp; -&gt; CMyString&amp;</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last++, std::forward&lt;Ty&gt;(val));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="引用折叠："><a href="#引用折叠：" class="headerlink" title="引用折叠："></a>引用折叠：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span> <span class="params">(Ty &amp;&amp; t)</span></span></span><br><span class="line"><span class="function">传入左值</span></span><br><span class="line"><span class="function">T &amp; &amp;&amp; t 为左值</span></span><br><span class="line"><span class="function">传入右值</span></span><br><span class="line"><span class="function">T &amp;&amp; &amp;&amp; t 为右值</span></span><br><span class="line"><span class="function">好处：一个函数可以匹配两种参数吧。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>move和forward的目的是一致的：正确解析出 左/友值引用所引用的变量究竟是左值还是右值，进而调用相应函数，只不过forward比move更简洁一些。</li>
</ul>
<h3 id="vector-实现右值push-back"><a href="#vector-实现右值push-back" class="headerlink" title="vector 实现右值push_back"></a>vector 实现右值push_back</h3><ul>
<li>vector：push_back右值的原理<ul>
<li><code>push_back(&amp;) -&gt; construct(&amp;) -&gt; new T(&amp;)</code></li>
<li><code>push_back(&amp;&amp;) -&gt; construct(&amp;&amp;) -&gt; new T(&amp;&amp;)</code>（也就是调用 类型的右值拷贝构造，如CMyString(&amp;&amp;))<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 容器的空间配置器 allocator</span></span><br><span class="line"><span class="comment"> * 内存的开辟释放,对象的构造析构,都是通过空间配置器完成.而不是直接通过new delete</span></span><br><span class="line"><span class="comment"> * template&lt;class _Ty</span></span><br><span class="line"><span class="comment"> *      class _Alloc = allocator&lt;_Ty&gt;&gt;</span></span><br><span class="line"><span class="comment"> *      class vector</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//  定义容器的空间配置器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> size)</span>   <span class="comment">//  负责内存开辟</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span>  <span class="comment">//  负责内存释放</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> (T*)p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, Ty&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(std::forward&lt;Ty&gt;(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void construct(T* p, const T&amp; val)   //  负责对象构造(在已有的内存上)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        new (p) T(val);     //  定位new  在p指向的内存上构造(拷贝构造)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void construct(T* p, T&amp;&amp; rval)   //  参数val匹配右值</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        //  在p处定位new 调用T的拷贝构造函数。</span></span><br><span class="line"><span class="comment">        //  rval这个右值引用变量本身为左值；但是他所引用的那个变量val是个右值。因此我们要通过mover(val)来实现类型的转换</span></span><br><span class="line"><span class="comment">        //  move实现的是语法层面的转换，告诉编译器rval是个右值，让他匹配右值拷贝构造函数。并没有对rval本身内存做出什么更改的事情</span></span><br><span class="line"><span class="comment">        // 只是改变了语法层面的类型，为了让编译器识别出他（所引用的）是个右值</span></span><br><span class="line"><span class="comment">        //  因为val为右值，因此调用拷贝构造函数时，匹配的就是T(&amp;&amp;)</span></span><br><span class="line"><span class="comment">        new (p) T(std::move(rval)); </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span>      <span class="comment">//  负责对象析构</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();            <span class="comment">//  ~T()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  容器底层内存开辟,内存释放,对象构造,对象析构,都通过allocator空间配置器来实现</span></span><br><span class="line">                        <span class="comment">//  类型Alloc 的类型默认是 空间配置器Allocator&lt;T&gt;  模板名称 + 类型参数 = 类名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 默认形参     构造函数:Allocator&lt;T&gt;()</span></span><br><span class="line">    vector&lt;T, Alloc&gt;(<span class="keyword">int</span> sz = <span class="number">10</span>, <span class="keyword">const</span> Alloc&amp; alloc = Allocator&lt;T&gt;())</span><br><span class="line">        :_allocator(alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  需要把内存开辟和对象构造分开处理    不然在创建vector的时候，不但开辟内存，还构造了所有元素.正常逻辑应当是我们加入元素.</span></span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">//  开辟内存</span></span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">vector</span>() &#123;</span><br><span class="line">        <span class="comment">//        delete [] _first;</span></span><br><span class="line">                <span class="comment">//  析构有效对象</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);  <span class="comment">//  析构p对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  ,并释放所有空间</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; rhs)  <span class="comment">//  拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;     <span class="comment">//  容器大小</span></span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;   <span class="comment">//  有效元素长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first[i], rhs.first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;T, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; rhs)  <span class="comment">//  拷贝赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)      <span class="comment">//  与拷贝构造区别：避免自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        delete [] _first;   //   析构所有对象 销毁原内存</span></span><br><span class="line">                <span class="comment">//  析构有效对象 释放所有内存</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;</span><br><span class="line">        <span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, rhs._first[i]);  <span class="comment">//  构造有效对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  采用引用折叠 + forward完美转发</span></span><br><span class="line">    <span class="comment">//  引用折叠：推导出val到底是右值引用还是左值引用。使得函数可以同时接收左值引用和右值引用。</span></span><br><span class="line">    <span class="comment">//  forward：传参时保留val他（所引用的）到底是一个左值还是右值的信息，即保留引用的类型。</span></span><br><span class="line">    <span class="comment">//  避免左值引用和右值引用变量本身都是左值而失去左右值信息，那样传参就只能传给左值。</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span>        <span class="comment">//  CMyString&amp;&amp; + &amp;&amp; -》 CMyString&amp;&amp; ; CMyString&amp; + &amp;&amp; -&gt; CMyString&amp;</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last++, std::forward&lt;Ty&gt;(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  push_back需要写两个 但是核心只有参数列表不同，右值还需要通过move来表示。不同也只是为了向下调用时调用到与左/友值匹配的函数。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void push_back(const T&amp; val)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (full())</span></span><br><span class="line"><span class="comment">            expand();</span></span><br><span class="line"><span class="comment">        //        *_last++ = val;     //  元素的operator=</span></span><br><span class="line"><span class="comment">        _allocator.construct(_last++, val);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //  push_back(&amp;&amp;) -&gt; construct(&amp;&amp;) -&gt; new T(&amp;&amp;)（也就是调用 类型的右值拷贝构造，如CMyString(&amp;&amp;))</span></span><br><span class="line"><span class="comment">    //  传入的实参为右值时（如CMyString(&quot;aa&quot;);会匹配到这里)</span></span><br><span class="line"><span class="comment">    //  push_back了之后，容器里装的对象就和push_back左值一样。后续对于容器的操作也一样.</span></span><br><span class="line"><span class="comment">    void push_back(T&amp;&amp; val)     //  push_back右值</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (full())</span></span><br><span class="line"><span class="comment">            expand();</span></span><br><span class="line"><span class="comment">        //  因为右值变量本身是左值，因此要move一下，让编译器识别他是右值。</span></span><br><span class="line"><span class="comment">        _allocator.construct(_last++, std::move(val));  </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//  需要析构对象，并且要把析构对象和释放内存的操作分离开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last);  <span class="comment">//  检查删除元素后，有哪些迭代器失效    _last-1：最后一个元素。有对应迭代器 _last：后继位置，有对应迭代器</span></span><br><span class="line"><span class="comment">//        --_last;        //  只移动指针,并没有析构元素,也没有释放元素管理的内存。</span></span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(--_last);    <span class="comment">//  不仅移动指针 还需要析构元素s</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;vector is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _first == _last; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _last == _end; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _last - _first; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;OutOfRange&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;OutOfRange&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  实现迭代器</span></span><br><span class="line">    <span class="comment">//  迭代器一般实现成容器的嵌套类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span>  //  迭代器就是包装了遍历方法(++)的一个指针</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line">        <span class="comment">//  产生迭代器对象 自动将自己加入迭代器链表</span></span><br><span class="line">        <span class="built_in">iterator</span>(vector&lt;T, Alloc&gt;* pvec, T* p = <span class="literal">nullptr</span>)</span><br><span class="line">            :_pVec(pvec), _ptr(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  cout &lt;&lt; cnt++ &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//  链表头插法                       节点内容    节点指向</span></span><br><span class="line">            Iterator_Base* ib = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = ib;        <span class="comment">//  指针ib是局部变量，会被销毁无所谓。因为ib指向的内存是new出来的啊哈哈哈。不会被销毁的。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; iter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  _pVec == nullptr 代表迭代器失效</span></span><br><span class="line">            <span class="comment">//  首先判断是否是同一容器的迭代器（比较迭代器指向容器的地址是否相同）</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != iter._pVec)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator incompatable!&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _ptr != iter._ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>++()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  _pVec == nullptr 迭代器失效</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator inValid&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  检查迭代器失效</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator inValid&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">        ~<span class="built_in">iterator</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;hh&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//  指向元素</span></span><br><span class="line">        T* _ptr;</span><br><span class="line">        <span class="comment">//  指明是哪个容器的迭代器 T和Alloc都是已知的（外层vector就确定了） 因为同一迭代器的比较才有效</span></span><br><span class="line">        vector&lt;T, Alloc&gt;* _pVec;     <span class="comment">//  迭代器是否有效标志</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  容器需要提供begin end方法  </span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);    <span class="comment">//  [it._ptr , last]的迭代器 如果存在，都要失效</span></span><br><span class="line">        T* p = _last;   <span class="comment">//  p是指针 不是迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            --p;</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);    <span class="comment">//  插入</span></span><br><span class="line">        ++_last;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  1.置迭代器为无效 + 2.移动元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator iter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">verify</span>(iter._ptr - <span class="number">1</span>, _last);  <span class="comment">//  1.</span></span><br><span class="line">        T* p = iter._ptr;           <span class="comment">//  2.</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, iter._ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first; <span class="comment">//  指向数组起始位置</span></span><br><span class="line">    T* _last;  <span class="comment">//  指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;   <span class="comment">//  指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 空间配置器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  为应对迭代器失效 增加代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  用一个链表来维护每个迭代器之间的顺序（可以当成是一个用来维护（装载）迭代器的容器</span></span><br><span class="line">    <span class="comment">//  迭代器节点 _cur指向迭代器 _next指向下一个iterator_base节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* c = <span class="literal">nullptr</span>, Iterator_Base* ne = <span class="literal">nullptr</span>)</span><br><span class="line">            :_cur(c), _next(ne) &#123;&#125;</span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Iterator_Base _head;    <span class="comment">//  一个容器只有一个迭代器头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  检查</span></span><br><span class="line">    <span class="comment">//  将(first,last]之间的元素，如果存在对应的迭代器，那么都要置为失效。并将维护他们的节点从链表中移除。</span></span><br><span class="line">    <span class="comment">//  遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* first, T* last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator_Base* pre = &amp;<span class="keyword">this</span>-&gt;_head;   <span class="comment">//  头节点</span></span><br><span class="line">        Iterator_Base* it = <span class="keyword">this</span>-&gt;_head._next;   <span class="comment">//  第一个有效节点</span></span><br><span class="line">        <span class="keyword">while</span> (it != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;   <span class="comment">//  it 节点 _cur 迭代器 _ptr 指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;_cur-&gt;_ptr &gt; first &amp;&amp; it-&gt;_cur-&gt;_ptr &lt;= last)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  标记迭代器失效 ：iterator持有的_pVec = nullptr</span></span><br><span class="line">                it-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                pre-&gt;_next = it-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> it;          <span class="comment">//  delete掉用于维护迭代器的节点</span></span><br><span class="line">                it = pre-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = it;</span><br><span class="line">                it = it-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  容器的二倍扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _end - _first;</span><br><span class="line">        <span class="keyword">int</span> len = _last - _first;</span><br><span class="line">        <span class="comment">//        T *p_tmp = new T[sz*2];</span></span><br><span class="line">                <span class="comment">//  开辟内存 构造对象</span></span><br><span class="line">        T* p_tmp = _allocator.<span class="built_in">allocate</span>(sz * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//            p_tmp[i] = _first[i];</span></span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p_tmp + i, _first[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  析构对象 释放内存</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        delete [] _first;   //  释放原先内存 析构所有对象</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = p_tmp;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + <span class="number">2</span> * sz;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CMyString <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    vector&lt;CMyString&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(s1);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">CMyString</span>(<span class="string">&quot;aaa&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">CMyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>*)</span><br><span class="line"><span class="built_in">CMyString</span>(<span class="keyword">const</span> CMyString &amp;)</span><br><span class="line"><span class="built_in">CMyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>*)</span><br><span class="line"><span class="built_in">CMyString</span>(<span class="keyword">const</span> CMyString &amp;&amp;)</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br><span class="line">~<span class="built_in">CMyString</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2022/03/15/c++_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>智能指针 ：auto_ptr、scoped_ptr、unique_ptr；shared_ptr、weak_ptr</p>
<span id="more"></span>

<ul>
<li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88562935?spm=1001.2014.3001.5502">优秀博客</a></li>
</ul>
<h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>不要把智能指针这个对象放到堆上！！智能指针是利用栈上的对象出作用域自动析构的特征，来做到资源的自动释放的！！</li>
</ul>
<h2 id="极其简陋版本指针"><a href="#极其简陋版本指针" class="headerlink" title="极其简陋版本指针"></a>极其简陋版本指针</h2><ul>
<li>最简陋<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//data段 heap段 stack段</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">堆的内存是用户手动开辟，并且手动释放的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">智能指针：保证做到对象的自动释放！</span></span><br><span class="line"><span class="comment">利用stack上的对象出作用域自动析构的特征，来做到资源的自动释放</span></span><br><span class="line"><span class="comment">面试题：CSmartPtr&lt;int&gt; *p = new CSmartPtr&lt;int&gt;(new int);</span></span><br><span class="line"><span class="comment">不可以！</span></span><br><span class="line"><span class="comment">因为这个p还是一个裸指针，我们还是需要delete p </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr):<span class="built_in">m_ptr</span>(ptr)&#123;&#125;    </span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    *p = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;hhh&quot;</span>);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">CSmartPtr&lt;Test&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> Test())</span></span>;</span><br><span class="line">    <span class="comment">//  (CSmartPtr 对象.operator-&gt;())-&gt;管理的对象所有的方法</span></span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="不带引用计数的智能指针"><a href="#不带引用计数的智能指针" class="headerlink" title="不带引用计数的智能指针"></a>不带引用计数的智能指针</h2><ul>
<li><p>这几个指针是保证只有一个指针指向指定内存</p>
<ul>
<li>auto_ptr最坑，指针改变指向变成null了都不知道。</li>
<li>scoped_ptr还行，不允许所有拷贝和赋值</li>
<li>unique_ptr最好，可以在用户知晓的情况下，让另一个指针来接管内存<h3 id="C-库：auto-ptr"><a href="#C-库：auto-ptr" class="headerlink" title="C++库：auto_ptr"></a>C++库：<code>auto_ptr</code></h3></li>
<li>拷贝构造时会销毁被拷贝的对象</li>
<li>目的：只能有一个指针指向那个内存</li>
<li>也即永远让只最后一个指针指向该内存<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//  a.release ：置a=nullptr 并返回a指向的内存地址</span></span><br><span class="line">        <span class="built_in">auto_ptr</span>(auto_ptr&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        element_type*</span><br><span class="line">        <span class="built_in">release</span>() <span class="built_in"><span class="keyword">throw</span></span>()</span><br><span class="line">        &#123;</span><br><span class="line">            element_type* __tmp = _M_ptr;</span><br><span class="line">            _M_ptr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> __tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">            cout&lt;&lt;*p1&lt;&lt;endl;</span><br><span class="line">            <span class="function">auto_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;   <span class="comment">//  p1已经被销毁</span></span><br><span class="line">            cout&lt;&lt;*p1&lt;&lt;endl;        <span class="comment">//  段错误 核心已转储</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        如果</span><br><span class="line">        vector&lt;auto_ptr&lt;<span class="keyword">int</span>&gt;&gt; v1;</span><br><span class="line">        vector&lt;auto_ptr&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">v2</span>(v1);</span><br><span class="line">        v1拷贝构造v2，那么v1里的全部auto_ptr都=<span class="literal">nullptr</span></span><br><span class="line">    ```  </span><br><span class="line">  - 所以 `auto_ptr is depracted`</span><br><span class="line"></span><br><span class="line">### C++<span class="number">11</span>：`scoped_ptr`</span><br><span class="line">- 只能这一个scoped_ptr对象。不能拷贝或赋值。</span><br><span class="line">  - 禁止编译器默认提供左值拷贝和左值赋值</span><br><span class="line">  - 编译器本来也不会默认提供右值拷贝和右值赋值，scoped_ptr类的设计者也没提供右值拷贝和赋值。（右值拷贝和右值赋值需要类的设计者自己来做）</span><br><span class="line">- `<span class="built_in">scoped_ptr</span>(<span class="keyword">const</span> scoped_ptr&lt;T&gt;&amp;) = <span class="keyword">delete</span>;`</span><br><span class="line">- `scoped_ptr&lt;T&gt; &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> scoped_ptr&lt;T&gt;&amp;) = <span class="keyword">delete</span>;`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 推荐C++<span class="number">11</span>：`unique_ptr`</span><br><span class="line">- unique_ptr比auto_ptr好处：用户在做出拷贝和赋值操作时，会很清楚被拷贝和赋值的是一个右值，不能再操作那个被拷贝的unique_ptr对象。而scoped_ptr的设定就是不可以进行拷贝或赋值。</span><br><span class="line">- <span class="keyword">delete</span> </span><br><span class="line">  - `<span class="built_in">unique_ptr</span>(<span class="keyword">const</span> unique_ptr&lt;T&gt;&amp;) = <span class="keyword">delete</span>`</span><br><span class="line">  - `unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> unique_pre&lt;T&gt;&amp;) = <span class="keyword">delete</span>`</span><br><span class="line">- 但是有针对右值引用的</span><br><span class="line">  - `<span class="built_in">unique_ptr</span>(<span class="keyword">const</span> unique_ptr&lt;T&gt;&amp;&amp;)`</span><br><span class="line">  - `unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> unique_pre&lt;T&gt;&amp;&amp;)`</span><br><span class="line">```c++</span><br><span class="line">      <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">      : _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>())) &#123; &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">release</span>() <span class="keyword">noexcept</span></span><br><span class="line">      &#123;</span><br><span class="line">        pointer __p = <span class="built_in">get</span>();</span><br><span class="line">        _M_t._M_ptr() = <span class="built_in">pointer</span>();</span><br><span class="line">        <span class="keyword">return</span> __p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>例子1 通过<code>std::move</code>调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">cout&lt;&lt; *p1 &lt;&lt;endl;</span><br><span class="line"><span class="comment">// unique_ptr&lt;int&gt; p2(p1); //  左值引用拷贝构造 delete</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;  <span class="comment">//  unique_ptr(unique&lt;T&gt;&amp;&amp; );</span></span><br><span class="line"><span class="comment">//  std::move 通过强转，使得编译器从语法上认为这是一个右值</span></span><br><span class="line"><span class="comment">//  这就意味着 p1已经被当成一个右值 后续会匹配到一个类构造者设计的一个参数列表针对右值的函数</span></span><br><span class="line"><span class="comment">//  在这个函数里，p2会指向p1指向的内存。p1的内部ptr会指向nullptr，准备被析构。（因为出作用域或生命周期结束而析构）</span></span><br><span class="line"><span class="comment">//  这个过程是由 unique_ptr 内部的函数做的。unique_ptr内部会有一个针对右值的操作，完成上述事情。</span></span><br><span class="line">cout&lt;&lt;*p2&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;*p1&lt;&lt;endl;        <span class="comment">//  段错误 因为p1已经被变成nullptr</span></span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./ptr01.out </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">段错误</span><br></pre></td></tr></table></figure></li>
<li><p>例子2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为unique_ptr有了针对右值引用的拷贝和赋值函数，所以我们可以这样做</span></span><br><span class="line"><span class="comment">返回一个智能指针用于赋值或者拷贝构造。</span></span><br><span class="line"><span class="comment">因为这个函数里的t是个临时量，是右值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">unique_ptr&lt;T&gt; <span class="title">getSmartPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">    <span class="comment">//  (出了函数就要被销毁，因此是一个右值 </span></span><br><span class="line">    <span class="comment">//  t------右值拷贝构造------&gt; main栈帧 ------右值拷贝赋值----&gt; p)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="keyword">int</span>&gt; p = getSmartPtr&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    *p = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;endl; <span class="comment">//  1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="带引用计数的智能指针"><a href="#带引用计数的智能指针" class="headerlink" title="带引用计数的智能指针"></a>带引用计数的智能指针</h2><ul>
<li>使得可以多个指针管理同一内存，并保证自动释放内存</li>
<li>shared_ptr<ul>
<li>强智能指针，可以改变资源的引用计数</li>
</ul>
</li>
<li>weak_ptr<ul>
<li>弱智能指针，不可以改变资源的引用计数<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3></li>
</ul>
</li>
<li>重复对一个裸指针造shared_ptr，不会使得这几个shared_ptr引用计数同步，裸指针指向那个内存也不会算入计数。所以应该一个资源刚被造出来时就用shared_ptr智能指针管理。而不是用裸指针。不然这个指向内存被释放了这个裸指针都不知道。</li>
<li>对于shared_ptr的引用计数，能造成引用计数++的，应该只有别人被它被拷贝构造和别人被它被拷贝赋值时，它的引用计数才会++。</li>
<li>对于shared_ptr的引用计数，能造成引用计数–的，应该只有赋值时和析构（离开作用域或者别人主动delete这个智能指针对象。）时。</li>
<li>简易shared_ptr：（区别在是否线程安全）  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">带引用计数的智能指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  比shared_ptr缺点 引用计数没用atmoic_int</span></span><br><span class="line"><span class="comment">//  给资源计数的类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefCnt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RefCnt</span>(T *ptr = <span class="literal">nullptr</span>):<span class="built_in">m_ptr</span>(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_ptr)  ++m_cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_ref</span><span class="params">()</span>   <span class="comment">// 增加资源引用计数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++m_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">del_ref</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_cnt&gt;<span class="number">0</span>)</span><br><span class="line">            --m_cnt;</span><br><span class="line">        <span class="keyword">return</span> m_cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_cnt = <span class="number">0</span>;  <span class="comment">//  资源计数    真正应当是：atmoic_int CAS原子</span></span><br><span class="line">    T *m_ptr;       <span class="comment">//  资源是否为null  感觉不该有这完应</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  带计数的智能指针</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSmartPtr</span>(T *ptr=<span class="literal">nullptr</span>):<span class="built_in">m_ptr</span>(ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        m_prf = <span class="keyword">new</span> RefCnt&lt;T&gt;(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  拷贝构造</span></span><br><span class="line">    <span class="built_in">CSmartPtr</span>(<span class="keyword">const</span> CSmartPtr&lt;T&gt; &amp;src)</span><br><span class="line">        :<span class="built_in">m_ptr</span>(src.m_ptr),<span class="built_in">m_prf</span>(src.m_prf)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_ptr)</span><br><span class="line">            m_prf-&gt;<span class="built_in">add_ref</span>();       <span class="comment">//  增加引用计数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  赋值</span></span><br><span class="line">    CSmartPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CSmartPtr&lt;T&gt;&amp; src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;src) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==m_prf-&gt;<span class="built_in">del_ref</span>()) <span class="comment">//  引用计数=0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;   <span class="comment">//  delete会先调用T的析构函数 再释放内存</span></span><br><span class="line">            <span class="keyword">delete</span> m_prf;   <span class="comment">//  delete会先调用RefCnt的析构函数~RefCnt 再释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_prf = src.m_prf;</span><br><span class="line">        m_ptr = src.m_ptr;</span><br><span class="line">        m_prf-&gt;<span class="built_in">add_ref</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CSmartPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==m_prf-&gt;<span class="built_in">del_ref</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">delete</span> m_prf;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *m_ptr;               <span class="comment">//  指向资源</span></span><br><span class="line">    RefCnt&lt;T&gt; *m_prf;       <span class="comment">//  指向资源计数类对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果两个智能指针重复引用同一裸指针再那么办？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line">    <span class="function">CSmartPtr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p2&lt;&lt;endl;</span><br><span class="line">    *p1 = <span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;*p1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p2&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./ptr02.out </span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">10</span> <span class="number">10</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="交叉引用-循环引用"><a href="#交叉引用-循环引用" class="headerlink" title="交叉引用/循环引用"></a>交叉引用/循环引用</h3><ul>
<li><code>shared_ptr</code>：会改变资源的引用计数</li>
<li><code>weak_ptr</code>：不会改变资源的引用计数。用作观察者<ul>
<li>weak_ptr只是一个<strong>观察者</strong>,用来观察资源.无法使用所管理资源的内容.</li>
<li>作用:在需要使用对象资源时,lock提升类型,提升为智能指针.然后再使用资源方法.<ul>
<li>这样,既使用了资源,又不会造成循环引用问题.(这个提升出来的shared_ptr对象)出了函数就会自动析构。</li>
</ul>
</li>
</ul>
</li>
<li><strong>弱智能指针weak_ptr区别于shared_ptr之处在于</strong>：<ul>
<li>weak_ptr不会改变资源的引用计数，只是一个观察者的角色，通过观察shared_ptr来判定资源是否存在</li>
<li>weak_ptr持有的引用计数，不是资源的引用计数，而是同一个资源的观察者的计数</li>
<li>weak_ptr没有提供常用的指针操作，无法直接访问资源，需要先通过lock方法提升为shared_ptr强智能指针，才能访问资源</li>
</ul>
</li>
</ul>
<ul>
<li><code>shared_ptr</code>强智能指针循环引用/交叉引用：<ul>
<li>造成问题：new出来的资源无法释放、引用计数不会减到0。所以会有资源泄漏问题。</li>
<li>解决方法：定义对象的时候，用强智能指针shared_ptr；引用对象的时候，用弱智能指针weak_ptr。</li>
</ul>
</li>
</ul>
<ul>
<li>循环引用 问题代码<br><img src="/2022/03/15/c++_%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/2022-03-16-20-42-03.png"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">// 前置声明类B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;B&gt; _ptrb; <span class="comment">// 指向B对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	shared_ptr&lt;A&gt; _ptra; <span class="comment">// 指向A对象的智能指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">shared_ptr&lt;A&gt; <span class="title">ptra</span><span class="params">(<span class="keyword">new</span> A())</span></span>;<span class="comment">// ptra指向A对象，A的引用计数为1</span></span><br><span class="line">	<span class="function">shared_ptr&lt;B&gt; <span class="title">ptrb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;<span class="comment">// ptrb指向B对象，B的引用计数为1</span></span><br><span class="line">	ptra-&gt;_ptrb = ptrb;<span class="comment">// A对象的成员变量_ptrb也指向B对象，B的引用计数为2</span></span><br><span class="line">	ptrb-&gt;_ptra = ptra;<span class="comment">// B对象的成员变量_ptra也指向A对象，A的引用计数为2</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; ptra.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印A的引用计数结果:2</span></span><br><span class="line">	cout &lt;&lt; ptrb.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 打印B的引用计数结果:2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	出main函数作用域，ptra和ptrb两个局部对象析构，分别给A对象和</span></span><br><span class="line"><span class="comment">	B对象的引用计数从2减到1，达不到释放A和B的条件（释放的条件是</span></span><br><span class="line"><span class="comment">	A和B的引用计数为0），因此造成两个new出来的A和B对象无法释放，</span></span><br><span class="line"><span class="comment">	导致内存泄露，这个问题就是“强智能指针的交叉引用(循环引用)问题”</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">B</span>()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>“交叉引用”的问题所在，就是对象无法析构，资源无法释放。怎么解决这个问题呢？请注意强弱智能指针的一个重要应用规则：<strong>定义对象时，用强智能指针shared_ptr，在其它地方引用对象时，使用弱智能指针weak_ptr</strong></p>
</li>
<li><p>解决代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="comment">//  pa-&gt;调用被管理的资源 pa.调用智能指针类本身函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shared_ptr：会改变资源的引用计数</span></span><br><span class="line"><span class="comment">weak_ptr：</span></span><br><span class="line"><span class="comment">强智能指针交叉引用：</span></span><br><span class="line"><span class="comment">造成问题：new出来的资源无法释放、引用计数不会减到0。</span></span><br><span class="line"><span class="comment">资源泄漏问题</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在其他地方引用对象 用弱智能指针</span></span><br><span class="line">    weak_ptr&lt;B&gt; m_p;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;非常好的方法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;~B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在其他地方引用对象 用弱智能指针</span></span><br><span class="line">    weak_ptr&lt;A&gt; m_p;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//  出Test之后这个shared_ptr就被析构。避免了循环引用</span></span><br><span class="line">        shared_ptr&lt;A&gt; m_shared_pa = m_p.<span class="built_in">lock</span>(); <span class="comment">//  lock：锁柱对象，意思是这个资源现在不能随便被释放了。我用着呢。</span></span><br><span class="line">        <span class="keyword">if</span>(m_shared_pa!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;m_shared_pa.<span class="built_in">use_count</span>()&lt;&lt;endl;    <span class="comment">// 2 = 1+1。</span></span><br><span class="line">            m_shared_pa-&gt;<span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  定义对象(new A())时 用强智能指针 shared_ptr 管理对象</span></span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;          </span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  在其他地方引用对象时，用 weak_ptr 管理对象</span></span><br><span class="line">    pa-&gt;m_p = pb;</span><br><span class="line">    pb-&gt;m_p = pa;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;pa.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pb.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    pb-&gt;<span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./ptr03.<span class="function">out </span></span><br><span class="line"><span class="function"><span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">1</span></span><br><span class="line"><span class="function">1</span></span><br><span class="line"><span class="function">2</span></span><br><span class="line"><span class="function">非常好的方法</span></span><br><span class="line"><span class="function">~<span class="title">B</span><span class="params">()</span></span></span><br><span class="line"><span class="function">~<span class="title">A</span><span class="params">()</span></span></span><br><span class="line"><span class="function">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="weak-ptr-解决线程安全问题"><a href="#weak-ptr-解决线程安全问题" class="headerlink" title="weak_ptr 解决线程安全问题"></a>weak_ptr 解决线程安全问题</h3><ul>
<li>weak_ptr观察资源是否还存活。使用lock将weak_ptr对象提升为shared_ptr<ul>
<li><code>shared_ptr&lt;A&gt; sp = pw.lock();</code><ul>
<li>pw封装的指针指向的内存没被释放，则lock提升成功，转为shared_ptr对象</li>
<li>pw封装的指针指向的内存已经被释放，则sp=nullptr</li>
</ul>
</li>
</ul>
</li>
<li>避免多线程状况下，使用裸指针导致访问已经被释放的资源。  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">正解：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">weak_ptr解决多线程安全问题</span></span><br><span class="line"><span class="comment">观察资源是否还存在，如果存在，就使用该资源。不存在则不是用。</span></span><br><span class="line"><span class="comment">避免资源已经被释放了却还再使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;非常好的方法&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler01</span><span class="params">(weak_ptr&lt;A&gt; pw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    如果想访问对象的方法，先通过pw的lock方法进行提升操作，把weak_ptr提升</span></span><br><span class="line"><span class="comment">    为shared_ptr强智能指针，提升过程中，是通过检测它所观察的强智能指针保存</span></span><br><span class="line"><span class="comment">    的Test对象的引用计数，来判定Test对象是否存活，ps如果为nullptr，说明Test对象</span></span><br><span class="line"><span class="comment">    已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    shared_ptr&lt;A&gt; sp = pw.<span class="built_in">lock</span>();   <span class="comment">//  pw封装的指针指向的内存已经被释放</span></span><br><span class="line">    cout&lt;&lt;sp.<span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> != sp)</span><br><span class="line">    &#123;   </span><br><span class="line">        sp-&gt;<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;对象已经被析构&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;A&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">        <span class="function">std::thread <span class="title">t</span><span class="params">(handler01,weak_ptr&lt;A&gt;(p))</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line"><span class="number">0</span></span><br><span class="line">对象已经被析</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反例：</span><br><span class="line"></span><br><span class="line"><span class="comment">// void handler01(A *p)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     sleep(2);   </span></span><br><span class="line"><span class="comment">//     p-&gt;func();  //  这时p已经被析构</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     A *p = new A();</span></span><br><span class="line"><span class="comment">//     std::thread t1(handler01,p);</span></span><br><span class="line"><span class="comment">//     t1.detach();    //  线程分离</span></span><br><span class="line"><span class="comment">//     delete p;</span></span><br><span class="line"><span class="comment">//     sleep(10);   </span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;   </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">shc@shc-virtual-machine:~/code/c++_review$ ./ptr04.out </span></span><br><span class="line"><span class="comment">A()</span></span><br><span class="line"><span class="comment">~A()</span></span><br><span class="line"><span class="comment">非常好的方法    已经析构了却还在使用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h2><ul>
<li>指导智能指针正确释放资源</li>
<li>_deleter：删除器</li>
<li>默认的删除器：直接delete智能指针里封装的裸指针。<ul>
<li>但我们在很多情况下有自定义删除器的必要性。</li>
<li>如智能指针管理的资源是文件或者数组，则不可以这样。数组：delete[]  文件：close</li>
</ul>
</li>
<li>unique_ptr &amp; 删除器 源码  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line">    class unique_ptr</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//  unique_ptr删除</span></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>()</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; __ptr = _M_t._M_ptr();</span><br><span class="line">        <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">get_deleter</span>()(__ptr);</span><br><span class="line">        __ptr = <span class="built_in">pointer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  默认删除函数器对象 就是delete</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//....构造函数</span></span><br><span class="line">    <span class="comment">/// Calls `delete __ptr`</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp* __ptr)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(!is_void&lt;_Tp&gt;::value,</span><br><span class="line">                <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">        <span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(_Tp)&gt;<span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">        <span class="keyword">delete</span> __ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
<li>实例  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unique_ptr</span></span><br><span class="line"><span class="comment">shared_ptr</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">~unique_ptr()&#123;是一个函数对象调用;   deleter(ptr);&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">默认的删除器  --- 直接delete。但如果智能指针管理的资源是文件或者数组，则不可以这样。数组：delete[]  文件：close</span></span><br><span class="line"><span class="comment">函数对象 </span></span><br><span class="line"><span class="comment">template&lt;typename T&gt;</span></span><br><span class="line"><span class="comment">class Deleter</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    void operator()(T *ptr)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        delete ptr;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDeleter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *ptr)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;call MyDeleter().operator()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span> []ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFileDeleter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *ptr)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;call MyFileDeleter().operator()&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">fclose</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="keyword">int</span>,MyDeleter&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">p</span>(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>],MyDeleter&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>],MyDeleter&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">    unique_ptr&lt;FILE,MyFileDeleter&lt;FILE&gt;&gt; <span class="built_in">p3</span>(<span class="built_in">fopen</span>(<span class="string">&quot;./a.txt&quot;</span>,<span class="string">&quot;w&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./ptr05_deletor.<span class="function">out </span></span><br><span class="line"><span class="function">call <span class="title">MyFileDeleter</span><span class="params">()</span>.<span class="title">operator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">call <span class="title">MyDeleter</span><span class="params">()</span>.<span class="title">operator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">call <span class="title">MyDeleter</span><span class="params">()</span>.<span class="title">operator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Lambda表达式写法</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>,function&lt;<span class="title">void</span><span class="params">(<span class="keyword">int</span>*)</span>&gt;&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>],</span></span></span><br><span class="line"><span class="params"><span class="function">    [](<span class="keyword">int</span> *ptr)-&gt;<span class="keyword">void</span>&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout&lt;&lt;<span class="string">&quot;call lambda release int[100]&quot;</span>&lt;&lt;endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        cout&lt;&lt;<span class="keyword">typeid</span>(ptr).name()&lt;&lt;endl;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">delete</span> []ptr;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;FILE,function&lt;<span class="built_in"><span class="keyword">void</span></span>(FILE*)&gt;&gt; <span class="built_in">up2</span>(<span class="built_in">fopen</span>(<span class="string">&quot;b,txt&quot;</span>,<span class="string">&quot;w&quot;</span>),</span><br><span class="line">    [](FILE *ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;call lambda release FILE&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(ptr).<span class="built_in">name</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">fclose</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/c++_review$ ./ptr05_deletor.out </span><br><span class="line">call lambda release FILE</span><br><span class="line">P8_IO_FILE</span><br><span class="line">call lambda release <span class="keyword">int</span>[<span class="number">100</span>]</span><br><span class="line">Pi</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li><p>自动析构时，先析构后构造的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通(非模板)类的成员模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DebugDelete</span>(ostream &amp;s = cerr) :<span class="built_in">os</span>(s)&#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*p)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;deleting unique_ptr  &quot;</span> &lt;&lt;<span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo_general_class_tempalte_member</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> *p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">    DebugDelete d;</span><br><span class="line">    <span class="built_in">d</span>(p);<span class="comment">//d调用DebugDelet::operator()(double*),释放p</span></span><br><span class="line">    <span class="keyword">int</span>* ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="comment">//在一个临时DebugDelete 对象上调用operator()(int*)</span></span><br><span class="line">    <span class="built_in">DebugDelete</span>()(ip);</span><br><span class="line">    <span class="comment">//实例化DebugDelete::opeartor()&lt;int&gt;(int*)const</span></span><br><span class="line">    unique_ptr&lt;<span class="keyword">int</span>, DebugDelete&gt;<span class="built_in">p2</span>(<span class="keyword">new</span> <span class="keyword">int</span>, <span class="built_in">DebugDelete</span>());</span><br><span class="line">    <span class="comment">//实例化DebugDelete::opeartor()&lt;string&gt;(string*)const</span></span><br><span class="line">    unique_ptr&lt;string, DebugDelete&gt;<span class="built_in">sp</span>(<span class="keyword">new</span> string, <span class="built_in">DebugDelete</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">deleting unique_ptr  <span class="keyword">double</span></span><br><span class="line">deleting unique_ptr  <span class="keyword">int</span></span><br><span class="line">deleting unique_ptr  <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:basic_string&lt;<span class="keyword">char</span>,<span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:char_traits&lt;<span class="keyword">char</span>&gt;,<span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:allocator&lt;<span class="keyword">char</span>&gt; &gt;</span><br><span class="line">deleting unique_ptr  <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">可以看到,主动析构的正常进行.</span><br><span class="line">函数结束后自动析构的,先创建了<span class="keyword">int</span>后创建了string,但是先析构了string</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「WHCer」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/qq_29596177/article/details/62218909</span></span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://blog.csdn.net/gatieme/article/details/50947821">C++typeid详解</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++_make_shared</title>
    <url>/2022/05/08/c++_make_shared/</url>
    <content><![CDATA[<ul>
<li>shared_ptr成员<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> :</span> <span class="keyword">public</span> _Ptr_base&lt;_Ty&gt; &#123; <span class="comment">// class for reference counted resource management</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Ptr_base</span> &#123;</span> <span class="comment">// base class for shared_ptr and weak_ptr</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type* _Ptr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    _Ref_count_base* _Rep&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  计数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">declspec</span>(<span class="title">novtable</span>) _<span class="title">Ref_count_base</span> &#123;</span> <span class="comment">// common code for reference counting</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Atomic_counter_t _Uses  = <span class="number">1</span>;</span><br><span class="line">    _Atomic_counter_t _Weaks = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="make-shared-替代-shared-ptr-来创建智能指针对象"><a href="#make-shared-替代-shared-ptr-来创建智能指针对象" class="headerlink" title="make_shared 替代 shared_ptr 来创建智能指针对象"></a>make_shared 替代 shared_ptr 来创建智能指针对象</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul>
<li><p><code>shared_ptr&lt;int&gt; sp(new int(10))</code></p>
<ul>
<li>如果在new计数类时失败。那么会造成内存泄漏，ptr指向的资源不会被释放。</li>
<li>也即，shared_ptr对象构造失败，不会释放已经new出的资源。</li>
<li><img src="/2022/05/08/c++_make_shared/2022-05-08-22-31-12.png"></li>
</ul>
</li>
<li><p><code>make_shared&lt;int&gt; sp = make_shared&lt;int&gt;(10);</code></p>
<ul>
<li>将托管资源和引用计数类的内存整合到一起，由shared_ptr开辟。</li>
<li><img src="/2022/05/08/c++_make_shared/2022-05-08-23-31-18.png"></li>
<li>源码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>, <span class="title">class</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="function">_NODISCARD</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Ty&gt; <span class="title">make_shared</span><span class="params">(_Types&amp;&amp;... _Args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// make a shared_ptr to non-array object</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> _Rx = <span class="keyword">new</span> _Ref_count_obj2&lt;_Ty&gt;(_STD forward&lt;_Types&gt;(_Args)...);</span><br><span class="line">    shared_ptr&lt;_Ty&gt; _Ret;</span><br><span class="line">    _Ret._Set_ptr_rep_and_enable_shared(_STD <span class="built_in">addressof</span>(_Rx-&gt;_Storage._Value), _Rx);</span><br><span class="line">    <span class="keyword">return</span> _Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  int(10) 这块内存由用户自己开辟。这就会使得计数ref类内存和资源类int(10)内存是分开的。两次new。可能会第一次用户new资源成功了，shared_ptr类new计数类ref时失败、</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">//  int(10) 这块内存由make_shared负责开辟。会将计数ref类内存和资源类int(10)内存整合到一起开辟，不会出现有一部分new失败的情况。要么都成功，要么都失败。</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; ssp = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">cout&lt;&lt;*sp&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*ssp&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">10</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">sp2</span><span class="params">(make_shared&lt;Test&gt;(<span class="number">10</span>))</span></span>; <span class="comment">//  new Test(int);</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sp3</span><span class="params">(make_shared&lt;Test&gt;(<span class="number">1</span>,<span class="number">2</span>))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&gt; <span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line">~Test</span><br><span class="line">~Test</span><br><span class="line">~Test</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>make_shared new一次，内存分配效率高。（shared_ptr 用户new一次资源，类里new一次计数类）</li>
<li>防止内存泄漏</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>make_shared无法自定义删除器！！</li>
<li>托管资源的延迟释放！！<ul>
<li>因为make_shared下，计数ref类和资源ptr类必须一起释放。而shared_ptr下，计数ref类和资源类ptr可以分开释放。<ul>
<li>因为make_shared下，计数ref类和资源ptr类是一起new的。</li>
<li>因为shared_ptr下，计数ref类和资源ptr类是两次分开new的。</li>
</ul>
</li>
<li>计数类什么时候释放<ul>
<li>当uses减少至0时，weaks也为0。那么计数类内存和资源内存都释放。如果users=0但是weaks不等于0，则不释放计数类内存，只释放资源内存。因为此时还有weak_ptr在观察这块资源。</li>
</ul>
</li>
<li><img src="/2022/05/08/c++_make_shared/2022-05-08-23-58-41.png"></li>
<li><img src="/2022/05/08/c++_make_shared/2022-05-08-23-53-31.png"></li>
<li>也即，<strong>shared_ptr</strong>方式中，<strong>没有shared_ptr指向内存了</strong>（uses=0），无论weaks是否等于0（是否有weak_ptr观察），就会<strong>释放</strong>掉资源。（资源内存可以先于计数类内存释放）</li>
<li>可是，<strong>make_shared</strong>方式中，没有shared_ptr指向内存了（uses=0），只有weaks=0时–<strong>无weak_ptr观察</strong>，也即只有计数类ref可以释放时，才能将资源内存和计数类内存一起<strong>释放</strong>。</li>
</ul>
</li>
</ul>
<ul>
<li>使用时注意下make_shared里面的参数是要传给对象的构造函数，不是要申请的内存长度。shared_ptr里面的形参是要申请的内存长度。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>继承与多态复习</title>
    <url>/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>1.继承的本质和原理<br>2.派生类的构造过程<br>3.重载、覆盖、隐藏<br>4.静态绑定和动态绑定<br>5.多态 vfptr和vftable<br>6.抽象类的设计原理<br>7.多重继承以及问题<br>8.虚基类 vbptr和vbtable<br>9.RTTI<br>10.C++四种类型强转<br>11.继承多态常见笔试面试题分享</p>
<span id="more"></span>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.继承的本质和原理</span></span><br><span class="line"><span class="comment">继承的本质：a.代码的复用  b.</span></span><br><span class="line"><span class="comment">类和类之间的关系：</span></span><br><span class="line"><span class="comment">组合：a part of... ...一部分的关系</span></span><br><span class="line"><span class="comment">继承：a kind of... ...一种的关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承方式     基类的访问限定     派生类的访问限定      (main)外部的访问限定</span></span><br><span class="line"><span class="comment">public </span></span><br><span class="line"><span class="comment">			  public			public                 Y</span></span><br><span class="line"><span class="comment">			  protected			protected			   N</span></span><br><span class="line"><span class="comment">			  private			不可见的				   N         </span></span><br><span class="line"><span class="comment">protected(基类的成员的访问限定，在派生类里面是不可能超过继承方式的)</span></span><br><span class="line"><span class="comment">			  public			protected			   N</span></span><br><span class="line"><span class="comment">			  protected			protected			   N</span></span><br><span class="line"><span class="comment">			  private			不可见的				   N</span></span><br><span class="line"><span class="comment">private</span></span><br><span class="line"><span class="comment">			  public			private				   N</span></span><br><span class="line"><span class="comment">			  protected			private				   N</span></span><br><span class="line"><span class="comment">			  private			不可见的				   N</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">1.外部只能访问对象public的成员，protected和private的成员无法直接访问</span></span><br><span class="line"><span class="comment">2.在继承结构中，派生类从基类可以继承过来private的成员，但是派生类却无法直接访问</span></span><br><span class="line"><span class="comment">3.protected和private的区别？在基类中定义的成员，想被派生类访问，但是不想被外部访问，</span></span><br><span class="line"><span class="comment">那么在基类中，把相关成员定义成protected保护的；如果派生类和外部都不打算访问，那么</span></span><br><span class="line"><span class="comment">在基类中，就把相关成员定义成private私有的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">默认的继承方式是什么？</span></span><br><span class="line"><span class="comment">要看派生类是用class定义的，还是struct定义的？</span></span><br><span class="line"><span class="comment">class定义派生类，默认继承方式就是private私有的</span></span><br><span class="line"><span class="comment">struct定义派生类，默认继承方式就是public私有的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mc; <span class="comment">// 自己或者友元能访问私有的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承 A 基类/父类   B 派生类/子类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; ma &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> md;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> me;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mf;</span><br><span class="line">	<span class="comment">// int ma;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 在C里面，请问ma的访问限定是什么？ 不可见的，但是能继承来</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; b.mb &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>重载关系<ul>
<li>一组函数要重载，必须处在同一个作用域当中；而且函数名字相同，参数列表不同</li>
</ul>
</li>
<li>隐藏(作用域的隐藏)的关系<ul>
<li>在继承结构当中，派生类的同名成员，把基类的同名成员给隐藏调用了（无论参数列表、返回值是否相同，只要名字相同，都会隐藏）</li>
</ul>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><ul>
<li><p><strong>覆盖</strong>：基类和派生类的方法，返回值、函数名以及参数列表都相同，而且基类的方法是虚函数，那么派生类的方法就自动处理成虚函数，它们之间成为覆盖关系。</p>
</li>
<li><p><strong>一个类添加了虚函数，对这个类有什么影响？</strong></p>
<ul>
<li>总结一：一个类里面定义了虚函数，那么编译阶段，编译器给这个类类型产生一个唯一的vftable虚函数表，虚函数表中主要存储的内容就是RTTI指针和虚函数的地址。当程序运行时，每一张虚函数表都会加载到内存的.<strong>rodata区</strong>。</li>
<li>总结二：一个类里面定义了函数数，那么这个类定义的对象，其运行时，内存中开始部分，多存储一个vfptr虚函数指针，指向相应类型的虚函数表vftable。一个类型定义的n个对象，它们的额vfptr指向的都是同一张虚函数表</li>
<li>总结三：一个类里面虚函数的个数，不影响对象内存大小（vfptr），影响的是虚函数表的大小</li>
<li>总结四：如果派生类中的方法，和基类继承来的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是virtual虚函数，那么派生类的这个方法，自动处理成虚函数。重写《=》覆盖</li>
</ul>
</li>
<li><p><code>vfptr：virtual function pointer</code></p>
</li>
<li><p><code>vftable：virtual function table</code> </p>
</li>
<li><p><code>RTTI：Run-Time Type Information</code></p>
</li>
<li><p>虚函数表：</p>
<ul>
<li><code>virtual function table.</code></li>
<li>运行时加载到<code>.rodata段</code></li>
</ul>
</li>
<li><p><strong>静态绑定</strong>： <code>call  Base::show(0163BD)</code>    call具体函数地址</p>
</li>
<li><p><strong>动态绑定</strong>：<code>call 寄存器</code>。寄存器存放什么地址运行时才知道。因此叫动态绑定</p>
</li>
<li><p><code>call</code>到<code>.text</code>段</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov eax, dword ptr[pb]	 把pb指向的虚函数地址交给eax寄存器</span><br><span class="line">mov ecx, dword ptr[eax]</span><br><span class="line">call ecx（虚函数的地址） 跳转到ecx指向的虚函数地址</span><br><span class="line">动态（运行时期）的绑定（函数的调用）</span><br></pre></td></tr></table></figure></li>
<li><p>虚函数个数不会影响类的大小。无论多少虚函数(&gt;=1)，类只多一个虚函数表指针<code>virtual function table</code></p>
</li>
<li><p><code>Base size Base = int(4) + vfptr(4) = 8</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class _s__RTTIBaseClassDescriptor       <span class="title">size</span><span class="params">(<span class="number">28</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | pTypeDescriptor</span></span><br><span class="line"><span class="function"> <span class="number">4</span>      | numContainedBases</span></span><br><span class="line"><span class="function"> <span class="number">8</span>      | _PMD where</span></span><br><span class="line"><span class="function"><span class="number">20</span>      | attributes</span></span><br><span class="line"><span class="function"><span class="number">24</span>      | pClassDescriptor</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class _s__RTTIBaseClassArray    size(<span class="number">1</span>):</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | arrayOfBaseClassDescriptors</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Base      size(<span class="number">8</span>):</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | &#123;</span>vfptr&#125;</span><br><span class="line"> <span class="number">4</span>      | ma</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">Base::$vftable@:</span><br><span class="line">        | &amp;Base_meta</span><br><span class="line">        |  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>      | &amp;Base::show</span><br><span class="line"> <span class="number">1</span>      | &amp;Base::show</span><br></pre></td></tr></table></figure></li>
<li><p><code>Derive = int(4) + int(4) + vfptr(4)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">class Derive    <span class="title">size</span><span class="params">(<span class="number">12</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | +--- (base class Base)</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | | &#123;</span>vfptr&#125;</span><br><span class="line"> <span class="number">4</span>      | | ma</span><br><span class="line">        | +---</span><br><span class="line"> <span class="number">8</span>      | mb</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">Derive::$vftable@:</span><br><span class="line">        | &amp;Derive_meta</span><br><span class="line">        |  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>      | &amp;Derive::show</span><br><span class="line"> <span class="number">1</span>      | &amp;Base::show</span><br></pre></td></tr></table></figure></li>
<li><p>动态绑定指令</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) :<span class="built_in">ma</span>(data) &#123;&#125;</span><br><span class="line">	<span class="comment">// 虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::show(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="comment">// 虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::show()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derive</span>(<span class="keyword">int</span> data = <span class="number">20</span>) :<span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) &#123;&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::show()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derive <span class="title">d</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">	Base* pb = &amp;d;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	pb-&gt;Base Base::show 如果发现show是普通函数，就进行静态绑定：call Base::show</span></span><br><span class="line"><span class="comment">	pb-&gt;Base Base::show 如果发现show是虚函数，就进行动态绑定了</span></span><br><span class="line"><span class="comment">	mov eax, dword ptr[pb]	 把pb指向的虚函数地址交给eax寄存器</span></span><br><span class="line"><span class="comment">	mov ecx, dword ptr[eax]</span></span><br><span class="line"><span class="comment">	call ecx（虚函数的地址） 跳转到ecx指向的虚函数地址</span></span><br><span class="line"><span class="comment">	动态（运行时期）的绑定（函数的调用）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	pb-&gt;<span class="built_in">show</span>(); <span class="comment">//静态（编译时期）的绑定（函数的调用）call  Base::show (01612DAh)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Base::show(int) 是一个虚函数，此时就得动态绑定了</span></span><br><span class="line"><span class="comment">	mov eax, dword ptr[pb]</span></span><br><span class="line"><span class="comment">	mov ecx, dword ptr[eax+8]</span></span><br><span class="line"><span class="comment">	call ecx（虚函数的地址） 动态（运行时期）的绑定（函数的调用）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	pb-&gt;<span class="built_in">show</span>(<span class="number">10</span>); <span class="comment">//静态绑定 call  Base::show (01612B2h)</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Base) &lt;&lt; endl; <span class="comment">// 4+4 = 8</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Derive) &lt;&lt; endl; <span class="comment">// 8+4 = 12</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	pb的类型：Base -&gt; 有没有虚函数</span></span><br><span class="line"><span class="comment">	如果Base没有虚函数，*pb识别的就是编译时期的类型  *pb &lt;=&gt; Base类型</span></span><br><span class="line"><span class="comment">	如果Base有虚函数，*pb识别的就是运行时期的类型 RTTI类型</span></span><br><span class="line"><span class="comment">	pb-&gt;d(vfptr)-&gt;Derive vftable  class Derive</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(pb).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// class Base*</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(*pb).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// class Base  class Derive </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="问题一：哪些函数不能实现成虚函数？"><a href="#问题一：哪些函数不能实现成虚函数？" class="headerlink" title="问题一：哪些函数不能实现成虚函数？"></a>问题一：哪些函数不能实现成虚函数？</h3><ul>
<li><p><strong>虚函数依赖</strong>：</p>
<ul>
<li>1.虚函数能产生地址，存储在vftable当中</li>
<li>2.对象必须存在。<ul>
<li>因为寻找虚函数地址时要通过对象中的：<code>vfptr -&gt; vftable -&gt; 虚函数地址</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构造函数</strong></p>
<ul>
<li>1.virtual+构造函数 NO！ </li>
<li>2.构造函数中（调用的任何函数，都是静态绑定的）调用虚函数，也不会发生静态绑定</li>
<li>因为对象还没构造完，而虚函数需要有赖于虚函数表指针。</li>
<li>派生类对象构造过程  1.先调用的是基类的构造函数 2.才调用派生类的构造函数。如果基类调用虚函数的话，那么可能是想匹配子类重写的函数。但是子类还没构造，也就没有vptr。</li>
</ul>
</li>
<li><p><strong>static静态成员方法</strong> NO！ virtual + static</p>
<ul>
<li>因为虚函数要依赖于对象。而static成员不属于对象</li>
</ul>
</li>
</ul>
<h3 id="问题二：基类的析构函数必须实现成虚函数"><a href="#问题二：基类的析构函数必须实现成虚函数" class="headerlink" title="问题二：基类的析构函数必须实现成虚函数"></a>问题二：基类的析构函数必须实现成虚函数</h3><ul>
<li>虚析构函数、析构函数调用的时候，对象必须是存在的。</li>
<li>基类的指针（引用）指向堆上new出来的派生类对象的时候， delete pb(基类的指针)，它调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。</li>
</ul>
<h3 id="虚函数不一定是动态绑定"><a href="#虚函数不一定是动态绑定" class="headerlink" title="虚函数不一定是动态绑定"></a>虚函数不一定是动态绑定</h3><ul>
<li>是不是虚函数的调用一定就是动态绑定？ 肯定不是的！</li>
<li>在类的构造函数当中，调用虚函数，也是静态绑定（构造函数中调用其它函数（虚），不会发生动态绑定的）</li>
<li>如果不是通过指针或者引用变量来调用虚函数，那就是静态绑定</li>
</ul>
<h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><ul>
<li>抽象类：有虚函数类</li>
<li>基类：被继承的类</li>
<li>基类一般定义成抽象类</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="如何解释多态？"><a href="#如何解释多态？" class="headerlink" title="如何解释多态？"></a>如何解释多态？</h3><ul>
<li>静态（编译时期）的多态： 函数重载、模板（函数模板和类模板）<ul>
<li>函数重载<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>&#123;&#125; </span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>); call compare_int_int 在编译阶段就确定好调用的函数版本</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10.5</span>, <span class="number">20.5</span>); call compare_douoble_double 在编译阶段就确定好调用的函数版本</span><br></pre></td></tr></table></figure></li>
<li>模板<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>&#123;&#125;</span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">20</span>);  =&gt; <span class="keyword">int</span> 实例化一个 compare&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10.5</span>, <span class="number">20.5</span>); =&gt; <span class="keyword">double</span> 实例化一个 compare&lt;<span class="keyword">double</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>动态（运行时期）的多态：Base Derive</li>
<li>在继承结构中，基类指针（引用）指向派生类对象，通过该指针（引用）调用同名覆盖方法（虚函数），基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名覆盖方法，称为多态</li>
<li><code>pbase-&gt;bark();</code>多态底层是通过动态绑定来实现的。<ul>
<li>pbase-》访问谁的vfptr=》继续访问谁的vftable=》当然调用的是对应的派生类对象的方法了</li>
</ul>
</li>
</ul>
<h3 id="继承的好处是什么？"><a href="#继承的好处是什么？" class="headerlink" title="继承的好处是什么？"></a>继承的好处是什么？</h3><ul>
<li>可以做代码的复用</li>
<li>在基类中给所有派生类提供统一的虚函数接口，让派生类进行重写，然后就可以使用多态了</li>
</ul>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="交换类对象的虚函数指针"><a href="#交换类对象的虚函数指针" class="headerlink" title="交换类对象的虚函数指针"></a>交换类对象的虚函数指针</h3><ul>
<li>交换虚函数指针指向，因此通过虚指针vfptr找到的虚函数表vftable所对应的虚函数地址交换了，调用的函数也就不同。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>(string name) :_name(name) &#123;&#125;</span><br><span class="line">	<span class="comment">// 纯虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是动物实体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name) :<span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; bark: miao miao!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Dog</span>(string name) :<span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; bark: wang wang!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal* p1 = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;加菲猫&quot;</span>); <span class="comment">// vfptr -&gt; Dog vftable</span></span><br><span class="line">	Animal* p2 = <span class="keyword">new</span> <span class="built_in">Dog</span>(<span class="string">&quot;二哈&quot;</span>); <span class="comment">// vfptr -&gt; Cat vftable</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>* p11 = (<span class="keyword">int</span>*)p1;</span><br><span class="line">	<span class="keyword">int</span>* p22 = (<span class="keyword">int</span>*)p2;</span><br><span class="line">	<span class="keyword">int</span> tmp = p11[<span class="number">0</span>]; <span class="comment">// p11[0]访问的就是Cat的前4个字节</span></span><br><span class="line">	p11[<span class="number">0</span>] = p22[<span class="number">0</span>]; <span class="comment">// p22[0]访问的就是Dog的前4个字节</span></span><br><span class="line">	p22[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">bark</span>(); <span class="comment">// p1 -&gt; Cat vfptr -&gt; Dog vftable bark</span></span><br><span class="line">	p2-&gt;<span class="built_in">bark</span>(); <span class="comment">// p2 -&gt; Dog vfptr -&gt; Cat vftable bark</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p1;</span><br><span class="line">	<span class="keyword">delete</span> p2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">加菲猫 bark: wang wang!</span><br><span class="line">二哈 bark: miao miao!</span><br></pre></td></tr></table></figure>
<h3 id="基类函数默认实参"><a href="#基类函数默认实参" class="headerlink" title="基类函数默认实参"></a>基类函数默认实参</h3></li>
<li>派生类虚函数的默认实参最好和基函数相同。因为虚函数的默认实参调用不到。<ul>
<li>函数需要的参数压栈，这是在编译期做的，从汇编可以看到，当参数压栈之后，才会去找要动态绑定那个函数。因此，参数只看静态类型，是哪个静态类型就用哪个静态类型的函数的默认实参，也就是会把相应静态类型的默认实参压栈。</li>
</ul>
</li>
<li>参数压栈 + call虚函数过程<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">push <span class="number">0</span>Ah =&gt; 函数调用，参数压栈是在编译时期就确定好的</span><br><span class="line">mov eax, dword ptr[p]		<span class="comment">//  通过虚函数表vfptr找到vftable</span></span><br><span class="line">mov ecx, dword ptr[eax]</span><br><span class="line">call ecx				<span class="comment">//  调用函数表中相应位置的函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Base::show i:&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i = <span class="number">20</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive::show i:&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* p = <span class="keyword">new</span> <span class="built_in">Derive</span>(); <span class="comment">// 虚析构函数</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	push 0Ah =&gt; 函数调用，参数压栈是在编译时期就确定好的</span></span><br><span class="line"><span class="comment">	mov eax, dword ptr[p]</span></span><br><span class="line"><span class="comment">	mov ecx, dword ptr[eax]</span></span><br><span class="line"><span class="comment">	call ecx</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	p-&gt;<span class="built_in">show</span>(); <span class="comment">// 动态绑定 p-&gt; Derive vfptr -&gt; Derive vftable</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call Derive::show i:<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="访问限定符-编译时"><a href="#访问限定符-编译时" class="headerlink" title="访问限定符(编译时)"></a>访问限定符(编译时)</h3><ul>
<li>访问限定符public private 是在编译阶段起作用的，是语法层面的。不是在运行时期起作用。运行时期所有内存都能随意访问。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Base::show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive::show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derive* p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	成员方法能不能调用，就是说方法的访问权限是不是public的，是在编译阶段就需要确定</span></span><br><span class="line"><span class="comment">	好的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	编译阶段 Base::show</span></span><br><span class="line"><span class="comment">	call Base::show   call ecx</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//“Base::show”: 无法访问 private 成员(在“Base”类中声明)</span></span><br><span class="line">	p-&gt;<span class="built_in">show</span>(); <span class="comment">// 最终能调用到Derive::show，是在运行时期才确定的</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="vfptr什么时候赋值"><a href="#vfptr什么时候赋值" class="headerlink" title="vfptr什么时候赋值"></a>vfptr什么时候赋值</h3><ul>
<li><p>注意虚函数表什么时候都赋值给虚函数指针    </p>
<ul>
<li>在本构造函数压完栈，并且调用完了基类构造函数后。</li>
</ul>
</li>
<li><p>因此父类中的clear不会影响子类的vptr，只会把父类的vptr置为null。子类的vptr还没进行赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  压栈</span></span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line">sub esp, <span class="number">4</span>Ch</span><br><span class="line"><span class="comment">//  调用父类构造</span></span><br><span class="line"><span class="function">call &amp;<span class="title">Base::Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//  父类构造结束后，进入本函数体。</span></span></span><br><span class="line"><span class="function"><span class="comment">//  首先给虚函数表指针vfptr赋值</span></span></span><br><span class="line"><span class="function">vfptr &lt;- &amp;Base::vftable</span></span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		push ebp</span></span><br><span class="line"><span class="comment">		mov ebp, esp</span></span><br><span class="line"><span class="comment">		sub esp, 4Ch</span></span><br><span class="line"><span class="comment">		rep stos esp&lt;-&gt;ebp 0xCCCCCCCC(windows VS GCC/G++)</span></span><br><span class="line"><span class="comment">		vfptr &lt;- &amp;Base::vftable</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Base()&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Base::show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derive</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		push ebp</span></span><br><span class="line"><span class="comment">		mov ebp, esp</span></span><br><span class="line"><span class="comment">		sub esp, 4Ch</span></span><br><span class="line"><span class="comment">		call Base</span></span><br><span class="line"><span class="comment">		rep stos esp&lt;-&gt;ebp 0xCCCCCCCC(windows VS GCC/G++)</span></span><br><span class="line"><span class="comment">		vfptr &lt;- &amp;Derive::vftable</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive::show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	mov eax, dword ptr[pb1]</span></span><br><span class="line"><span class="comment">	mov ecx, dword ptr[eax] eax:0x00000000 不是Base::vftable</span></span><br><span class="line"><span class="comment">	call ecx</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//  error</span></span><br><span class="line">	<span class="comment">//Base *pb1 = new Base();</span></span><br><span class="line">	<span class="comment">//pb1-&gt;show(); // 动态绑定</span></span><br><span class="line">	<span class="comment">//delete pb1;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	vfptr里面存储的是vftable的地址</span></span><br><span class="line"><span class="comment">	vfptr &lt;- vftable</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//  ok</span></span><br><span class="line">	Base* pb2 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">	<span class="comment">// 动态绑定 call Derive::show()</span></span><br><span class="line">	pb2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">delete</span> pb2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>汇编</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">Derive</span>()</span><br><span class="line"><span class="comment">//  压栈、开辟栈帧</span></span><br><span class="line"><span class="number">00007F</span>F66C201E85  push        rbp  </span><br><span class="line"><span class="number">00007F</span>F66C201E86  push        rdi  </span><br><span class="line"><span class="number">00007F</span>F66C201E87  sub         rsp,<span class="number">108</span>h  </span><br><span class="line"><span class="number">00007F</span>F66C201E8E  lea         rbp,[rsp+<span class="number">20</span>h]  </span><br><span class="line">...</span><br><span class="line"><span class="comment">//  调用父类函数</span></span><br><span class="line"><span class="number">00007F</span><span class="function">F66C201EA6  call        <span class="title">Base::Base</span> <span class="params">(<span class="number">07F</span>F66C20112Ch)</span>  </span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="comment">//  虚函数表的地址赋给虚函数指针 </span></span></span><br><span class="line"><span class="function">00007FF66C201EB2  lea         rcx,[Derive::`vftable&#x27; <span class="params">(<span class="number">07F</span>F66C20BC60h)</span>]  </span></span><br><span class="line"><span class="function">00007FF66C201EB9  mov         qword ptr [rax],rcx  </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//  退栈</span></span><br><span class="line"><span class="number">00007F</span>F66C201EC3  mov         rax,qword ptr [<span class="keyword">this</span>]  </span><br><span class="line"><span class="number">00007F</span>F66C201ECA  lea         rsp,[rbp+<span class="number">0E8</span>h]  </span><br><span class="line"><span class="number">00007F</span>F66C201ED1  pop         rdi  </span><br><span class="line"><span class="number">00007F</span>F66C201ED2  pop         rbp  </span><br><span class="line"><span class="number">00007F</span>F66C201ED3  ret  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><ul>
<li>抽象类：有抽象函数的类。抽象类不是虚基类！</li>
<li>virtual<ul>
<li>修饰成员方法：是虚函数</li>
<li>修饰继承方式：是虚继承</li>
</ul>
</li>
<li>虚基类：被虚继承的类</li>
<li>普通继承：内存布局中，基类数据放在派生类前面</li>
<li>虚继承：内存布局中，基类数据移到派生来末尾。在派生类前面加一个vbptr</li>
<li>vfptr -&gt; vftable<ul>
<li>vftable 记录虚函数地址</li>
</ul>
</li>
<li>vbptr -&gt; vbtable<ul>
<li>vbtable记录的是虚基类数据在派生类内存中的偏移量</li>
</ul>
</li>
<li>基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;call A::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="comment">//  ~A(); operator delete(A); </span></span><br><span class="line">	<span class="comment">//  重载基类的，因为是基类的指针指向对象。因此是delete 基类指针。</span></span><br><span class="line">	<span class="comment">//  operator delete被编译器自动看为静态的</span></span><br><span class="line">	<span class="comment">//  A类内重载了operator delete。delete A时就会调用A得operator delete</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pc)</span>	</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator delete A &quot;</span> &lt;&lt; pc &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">free</span>(pc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span>  A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;call B::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="comment">// new B(); 则会调用B类中的operator new 而非基类A中的。所以重载B类的operator new</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator new &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="A-int-vfptr-8"><a href="#A-int-vfptr-8" class="headerlink" title="A int + vfptr = 8"></a>A int + vfptr = 8</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="function">class A <span class="title">size</span><span class="params">(<span class="number">8</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | &#123;</span>vfptr&#125;</span><br><span class="line"> <span class="number">4</span>      | ma</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">A::$vftable@:</span><br><span class="line">        | &amp;A_meta</span><br><span class="line">        |  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>      | &amp;A::func</span><br></pre></td></tr></table></figure>

<h3 id="B-int-int-4-4-16"><a href="#B-int-int-4-4-16" class="headerlink" title="B int + int + 4 + 4 = 16"></a>B int + int + 4 + 4 = 16</h3><p><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-20-41-42.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">class B <span class="title">size</span><span class="params">(<span class="number">16</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | &#123;</span>vbptr&#125;	<span class="keyword">virtual</span> base pointer</span><br><span class="line"> <span class="number">4</span>      | mb</span><br><span class="line">        +---</span><br><span class="line">        +--- (<span class="keyword">virtual</span> base A)</span><br><span class="line"> <span class="number">8</span>      | &#123;vfptr&#125;</span><br><span class="line"><span class="number">12</span>      | ma</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line"><span class="comment">//  vbtable</span></span><br><span class="line">B::$vbtable@:</span><br><span class="line"> <span class="number">0</span>      | <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>      | <span class="number">8</span> (<span class="built_in">Bd</span>(B+<span class="number">0</span>)A)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  vftable</span></span><br><span class="line">B::$vftable@:</span><br><span class="line">        | <span class="number">-8</span></span><br><span class="line"> <span class="number">0</span>      | &amp;B::func</span><br><span class="line"></span><br><span class="line">B::func <span class="keyword">this</span> adjustor: <span class="number">8</span></span><br><span class="line">vbi:       <span class="class"><span class="keyword">class</span>  <span class="title">offset</span> <span class="title">o</span>.<span class="title">vbptr</span>  <span class="title">o</span>.<span class="title">vbte</span> <span class="title">fVtorDisp</span></span></span><br><span class="line"><span class="class">               <span class="title">A</span>       8       0       4 0</span></span><br></pre></td></tr></table></figure>


<h3 id="delete虚基类指针"><a href="#delete虚基类指针" class="headerlink" title="delete虚基类指针"></a>delete虚基类指针</h3><ul>
<li>windows VS 报错</li>
<li>linux g++ ok</li>
<li>基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址</li>
</ul>
<ul>
<li>堆上的<br><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-20-35-23.png"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A* p = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	p-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> <span class="number">00000231E897</span>FEB0</span><br><span class="line">main p:<span class="number">00000231E897</span>FEC0</span><br><span class="line">call B::func</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span> A <span class="number">00000231E897</span>FEC0</span><br><span class="line">堆异常中断</span><br></pre></td></tr></table></figure>
<ul>
<li>栈上的<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址</span></span><br><span class="line">	B b;</span><br><span class="line">	A* p = &amp;b;<span class="comment">//new B(); // B::vftable</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	p-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//delete p;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main p:<span class="number">0000009F</span>C932FBD8</span><br><span class="line">call B::func</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">sizeof</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">sizeof</span> B = <span class="number">1</span>;</span><br><span class="line">为什么不为<span class="number">0</span>？为了让实例化出来的类对象得地址唯一</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">sizeof</span> A = <span class="number">4</span>;	<span class="comment">//  vfptr</span></span><br><span class="line"><span class="keyword">sizeof</span> B = <span class="number">4</span>;	<span class="comment">//  vfptr</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">int</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">sizeof</span> B = <span class="number">4</span>(<span class="keyword">int</span>) + <span class="number">4</span>(vbptr) = <span class="number">8</span>;	<span class="comment">//  vbptr</span></span><br><span class="line"><span class="comment">//  没有虚函数当然就没有虚函数表，自然也就没虚函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">int</span> ; <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">sizeof</span> B = <span class="number">4</span>(<span class="keyword">int</span>) + <span class="number">4</span>(vfptr) + <span class="number">4</span>(vbptr) = <span class="number">12</span>;	<span class="comment">//  vbptr vfptr</span></span><br><span class="line"><span class="comment">//  没有虚函数当然就没有虚函数表，自然也就没虚函数指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-22-13-41.png"></p>
<ul>
<li>菱形继承<br><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-22-16-57.png"></li>
<li>解决方法：用<strong>virtual继承</strong>。将虚基类A的内容移动到了派生类的末尾。<ul>
<li>则D类需要负责处理虚基类A的构造<br><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-22-17-41.png"></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++的多重继承 - 菱形继承的问题  派生类有多份间接基类的数据 设计的问题</span></span><br><span class="line"><span class="comment">好处，可以做更多代码的复用   D -&gt; B,C    B *p = new D()   C *p = new D()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> data) :<span class="built_in">ma</span>(data) &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//=======================================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">int</span> data) :<span class="built_in">A</span>(data), <span class="built_in">mb</span>(data) &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>(<span class="keyword">int</span> data) :<span class="built_in">A</span>(data), <span class="built_in">mc</span>(data) &#123; cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">C</span>() &#123; cout &lt;&lt; <span class="string">&quot;~C()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> mc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//“A::A”: 没有合适的默认构造函数可用</span></span><br><span class="line">	<span class="built_in">D</span>(<span class="keyword">int</span> data) :<span class="built_in">A</span>(data), <span class="built_in">B</span>(data), <span class="built_in">C</span>(data), <span class="built_in">md</span>(data) &#123; cout &lt;&lt; <span class="string">&quot;D()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">D</span>() &#123; cout &lt;&lt; <span class="string">&quot;~D()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> md;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">D <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">B</span>()</span><br><span class="line"><span class="built_in">C</span>()</span><br><span class="line"><span class="built_in">D</span>()</span><br><span class="line">~<span class="built_in">D</span>()</span><br><span class="line">~<span class="built_in">C</span>()</span><br><span class="line">~<span class="built_in">B</span>()</span><br><span class="line">~<span class="built_in">A</span>()</span><br></pre></td></tr></table></figure>


<h2 id="四种类型转换"><a href="#四种类型转换" class="headerlink" title="四种类型转换"></a>四种类型转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++语言级别提供的四种类型转换方式</span></span><br><span class="line"><span class="comment">int a = (int)b;</span></span><br><span class="line"><span class="comment">const_cast : 去掉（指针或者引用）常量属性的一个类型转换</span></span><br><span class="line"><span class="comment">static_cast :  提供编译器认为安全的类型转换（没有任何联系的类型之间的转换就被否定了）</span></span><br><span class="line"><span class="comment">reinterpret_cast : 类似于C风格的强制类型转换</span></span><br><span class="line"><span class="comment">dynamic_cast : 主要用在继承结构中，可以支持RTTI类型识别的上下转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;call Derive1::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive2</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;call Derive2::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="comment">// Derive2实现新功能的API接口函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">derive02func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive2::derive02func&quot;</span> &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typeid(*p).name() == &quot;Derive&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFunc</span><span class="params">(Base *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// dynamic_cast会检查p指针是否指向的是一个Derive2类型的对象？</span></span><br><span class="line">	<span class="comment">// p-&gt;vfptr-&gt;vftable RTTI信息 如果是，dynamic_cast转换类型成功，</span></span><br><span class="line">	<span class="comment">// 返回Derive2对象的地址，给pd2；否则返回nullptr</span></span><br><span class="line">	<span class="comment">// static_cast编译时期的类型转换  dynamic_cast运行时期的类型转换 支持RTTI信息识别</span></span><br><span class="line">	Derive2 *pd2 = <span class="keyword">dynamic_cast</span>&lt;Derive2*&gt;(p);</span><br><span class="line">	<span class="keyword">if</span> (pd2 != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pd2-&gt;<span class="built_in">derive02func</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;<span class="built_in">func</span>(); <span class="comment">// 动态绑定  *p的类型 Derive2  derive02func</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derive1 d1;</span><br><span class="line">	Derive2 d2;</span><br><span class="line">	<span class="built_in">showFunc</span>(&amp;d1);</span><br><span class="line">	<span class="built_in">showFunc</span>(&amp;d2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//static_cast 基类类型 《=》 派生类类型  能不能用static_cast?当然可以！会永远转型成功</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// re interpret 重新阐述</span></span><br><span class="line">	<span class="comment">//int *p = nullptr;</span></span><br><span class="line">	<span class="comment">//double* b = reinterpret_cast&lt;double*&gt;(p);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//const int a = 10;</span></span><br><span class="line">	<span class="comment">//int *p1 = (int*)&amp;a;</span></span><br><span class="line">	<span class="comment">//int *p2 = const_cast&lt;int*&gt;(&amp;a);</span></span><br><span class="line">	<span class="comment">// const_cast&lt;这里面必须是指针或者引用类型 int* int&amp;&gt;</span></span><br><span class="line">	<span class="comment">//int b = const_cast&lt;int&gt;(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++_文件操作</title>
    <url>/2022/05/09/c++_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<ul>
<li>感想：c++的流感觉不如linux 系统级的API。好难受。<h1 id="c-流的文件操作（感觉不好用）"><a href="#c-流的文件操作（感觉不好用）" class="headerlink" title="c++ 流的文件操作（感觉不好用）"></a>c++ 流的文件操作（感觉不好用）</h1><h2 id="输出十六进制"><a href="#输出十六进制" class="headerlink" title="输出十六进制"></a>输出十六进制</h2><h3 id="各类大小"><a href="#各类大小" class="headerlink" title="各类大小"></a>各类大小</h3></li>
<li>一个字节8bit 一个字节对应两个十六进制</li>
<li>各类大小<ul>
<li>大小无区别；区别仅在首位是否为符号位。</li>
<li>unsigned char：1 bytes</li>
<li>char：1 bytes</li>
<li>int：4 bytes</li>
<li>unsigned int：4 bytes</li>
</ul>
</li>
<li>cout&lt;&lt;变量x。<ul>
<li>就是根据变量x的类别，按照他的输出格式符来将二进制数据转化成输出的数据</li>
</ul>
</li>
<li>cout&lt;&lt;hex&lt;&lt;x&lt;&lt;endl;<ul>
<li>前提x必须是整形。不能是char。如果x是char，还要再进行几步强转，有些麻烦。</li>
</ul>
</li>
<li>printf(“%02x”,c); <ul>
<li><strong>将变量c的底层补码形式的二进制数据以十六进制输出</strong>，（我喜欢，够直接），无论c的类型是什么，都可以输出（因为在输出时会发生<strong>类型强转</strong>，转为int）。<ul>
<li>举例：平常的printf(“%d\n”,x); （x为int）。根据x的底层的二进制数据，输出表示的相应的十进制数据。（就是把2进制转换成十进制）</li>
<li>举例：平常的printf(“%c\n”,x); （x为char）。根据x的底层的二进制数据，输出表示的相应字符。（根据ASCII表，一个二进制数据对应一个相应的字符）</li>
</ul>
</li>
<li>02：至少输出两位。少于两位用0补位。<h3 id="ffff问题-符号位扩展"><a href="#ffff问题-符号位扩展" class="headerlink" title="ffff问题 符号位扩展"></a><strong>ffff问题 符号位扩展</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">128</span>;  <span class="comment">//  10000000</span></span><br><span class="line">    <span class="keyword">int</span> x = c;              <span class="comment">//  00000000000000000000000010000000</span></span><br><span class="line">    <span class="keyword">char</span> d = <span class="number">128</span>;           <span class="comment">//  10000000</span></span><br><span class="line">    <span class="keyword">int</span> y = d;              <span class="comment">//  11111111111111111111111110000000</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %02x\n&quot;</span>,c,c); <span class="comment">//  至少2个十六进制位 不够用0补    cout&lt;&lt;c 就是 printf(&quot;%c&quot;,c) cout&lt;&lt;c的输出取决于c的类型。是char就按照char %c输出；是int就按照int %d输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %08x\n&quot;</span>,x,x); <span class="comment">//  至少8个十六进制位 不够用0补    cout&lt;&lt;x 就是 printf(&quot;%d&quot;,x)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %02x\n&quot;</span>,d,d); <span class="comment">//  至少2个十六进制位 不够用0补</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %08x\n&quot;</span>,y,y); <span class="comment">//  至少8个十六进制位 不够用0补</span></span><br><span class="line"></span><br><span class="line">$   € <span class="number">80</span>            </span><br><span class="line">    <span class="number">128</span> <span class="number">0000</span> <span class="number">0080</span>       <span class="comment">//  一般来讲前面多余的0会舍去。但是我们要求了%08x</span></span><br><span class="line">    <span class="number">-128</span> ffff ff80</span><br><span class="line">    <span class="number">-128</span> ffff ff80</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>为什么会有很多fffff</strong>？</li>
<li><strong>关键点1</strong>：<ul>
<li>当<strong>有符号类型向更大类型转换</strong>时，如果首位为1，则将前面全部补1；如果首位为0，那么将前面全部补0。也即，通过扩展首位符号位，将符号保存下来。</li>
<li>当<strong>无符号类型向更大类型转换</strong>时，只需简单地在开头补0，称为0扩展</li>
</ul>
</li>
<li><strong>关键点2</strong><ul>
<li>学过计组的都知道，计算机内部用采用补码表示形式。我们在程序中把一个数拆成一个个bit输出时，就是输出这个变量的真值在计算机内部的补码表示形式。如下<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> q = <span class="number">-9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;((q&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">$ <span class="number">11111111111111111111111111110111</span></span><br><span class="line">这就是<span class="number">-9</span>的补码表示形式，也就是说<span class="number">-9</span>在计算机内部的存储的二进制数据就是这些。</span><br><span class="line">为了方便愚蠢的人类阅读，可以将其转为原码：就是取反+<span class="number">1.</span></span><br><span class="line">得到原码：<span class="number">1000000000000000000000001000</span>。也是我们预知的<span class="number">-9</span>。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在printf(“%02x”)时，也即在输出十六进制时，会首先将要输出的变量转化为int</li>
<li><strong>问题解释</strong><ul>
<li>所以在本例中<ul>
<li>c输出的是80，因为printf(“%x”)，会发生从unsigned char转到int，此时发生的是0扩展，补0而非f。int本为8位十六进制，但是因为前面都是0，被省略。</li>
<li>x输出是128 0000 0080。因为由c到x的符号扩展为0扩展。从二进制和十六进制都可以看出，没有多出fffff。</li>
<li>d输出的是-128 ffff fff80。因为printf(“%x”)，会发生从char转到int，此时发生的是0扩展，由于首位符号位为1，所以扩展补1而非0。呈现为十六进制就是很多f。f不能省略。</li>
<li>y输出是-128 ffff fff80。因为由d到y的符号扩展为有符号扩展。从二进制和十六进制都可以看出，二进制前面补了很多1，也就是十六进制多出fffff。</li>
</ul>
</li>
</ul>
</li>
<li>查看cxdy二进制  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line"><span class="number">10000000</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;((c&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line"><span class="number">00000000000000000000000010000000</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;((x&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">d</span><br><span class="line"><span class="number">10000000</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;((d&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">y</span><br><span class="line"><span class="number">11111111111111111111111110000000</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;((y&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="从文件中读取一定字节并以十六进制输出"><a href="#从文件中读取一定字节并以十六进制输出" class="headerlink" title="从文件中读取一定字节并以十六进制输出"></a>从文件中读取<strong>一定字节</strong>并以十六进制输出</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li>read</li>
<li>从一个文件中读取n个字节。并以<strong>十六进制输出底层二进制信息</strong>。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fileRead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">fileRead</span>(<span class="keyword">const</span> string&amp; fileName)</span><br><span class="line">    &#123;</span><br><span class="line">        ifs.<span class="built_in">open</span>(fileName,ios::binary|ios::in);</span><br><span class="line">        <span class="keyword">if</span>(!ifs)&#123;</span><br><span class="line">            ifs.<span class="built_in">close</span>();</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fileRead&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> fileRead&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">fileRead</span>(<span class="keyword">const</span> fileRead&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAsHexFromBegin</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[len];</span><br><span class="line">        ifs.<span class="built_in">seekg</span>(<span class="number">0</span>,ios::beg);</span><br><span class="line">        ifs.<span class="built_in">read</span>((<span class="keyword">char</span>*)ptr,len);</span><br><span class="line">        for_each(ptr,ptr+len,[](<span class="keyword">unsigned</span> <span class="keyword">char</span> x)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,x);</span><br><span class="line">        &#125;);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">readAsHexFromEnd</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[len];</span><br><span class="line">        ifs.<span class="built_in">seekg</span>(-len,ios::end);</span><br><span class="line">        ifs.<span class="built_in">read</span>((<span class="keyword">char</span>*)ptr,len);</span><br><span class="line">        for_each(ptr,ptr+len,[](<span class="keyword">unsigned</span> <span class="keyword">char</span> x)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,x);</span><br><span class="line">        &#125;);</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ifs.<span class="built_in">seekg</span>(<span class="number">0</span>,ios::end);</span><br><span class="line">        <span class="keyword">int</span> len = ifs.<span class="built_in">tellg</span>();</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">fileRead</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        ifs.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ifstream ifs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">fileRead <span class="title">fr</span><span class="params">(<span class="string">&quot;../task01.png&quot;</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;fr.<span class="built_in">getSize</span>()&lt;&lt;<span class="string">&quot; Bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The first 60 bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    fr.<span class="built_in">readAsHexFromBegin</span>(<span class="number">60</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The last 60 bytes&quot;</span>&lt;&lt;endl;</span><br><span class="line">    fr.<span class="built_in">readAsHexFromEnd</span>(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><img src="/2022/05/09/c++_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/2022-05-09-22-43-51.png"><br><img src="/2022/05/09/c++_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/2022-05-09-22-44-01.png"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">556002</span> Bytes</span><br><span class="line">The first <span class="number">60</span> bytes</span><br><span class="line"><span class="number">89</span> <span class="number">50</span> <span class="number">4</span>e <span class="number">47</span> <span class="number">0</span>d <span class="number">0</span>a <span class="number">1</span>a <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>d <span class="number">49</span> <span class="number">48</span> <span class="number">44</span> <span class="number">52</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">38</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> f7 <span class="number">08</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> aa d9 cb <span class="number">5</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">67</span> <span class="number">41</span> <span class="number">4</span>d</span><br><span class="line"><span class="number">41</span> <span class="number">00</span> <span class="number">00</span> b1 <span class="number">8f</span> <span class="number">0b</span> fc <span class="number">61</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">20</span> <span class="number">63</span> <span class="number">48</span> <span class="number">52</span> <span class="number">4</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">7</span>a</span><br><span class="line">The last <span class="number">60</span> bytes</span><br><span class="line"><span class="number">3</span>a <span class="number">71</span> <span class="number">85</span> <span class="number">3</span>c d4 <span class="number">8</span>a c6 a0 f8 eb <span class="number">4</span>d <span class="number">82</span> <span class="number">83</span> db cb <span class="number">38</span> <span class="number">68</span> <span class="number">44</span> <span class="number">9f</span> c3 ba <span class="number">22</span> a5 <span class="number">90</span> d6 <span class="number">1</span>c <span class="number">2b</span> <span class="number">50</span> d5 <span class="number">44</span> <span class="number">27</span> d6 <span class="number">33</span> d4 <span class="number">30</span> a8 <span class="number">9</span>d bd fe <span class="number">02</span></span><br><span class="line"><span class="number">36</span> <span class="number">83</span> a3 c8 <span class="number">10</span> <span class="number">57</span> <span class="number">8</span>c <span class="number">76</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">49</span> <span class="number">45</span> <span class="number">4</span>e <span class="number">44</span> ae <span class="number">42</span> <span class="number">60</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>

<h3 id="极简-get-不用类型转换。直接取得二进制"><a href="#极简-get-不用类型转换。直接取得二进制" class="headerlink" title="极简 get() 不用类型转换。直接取得二进制"></a><strong>极简</strong> get() 不用类型转换。直接取得二进制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;../task01.png&quot;</span>,std::ios::binary|std::ios::in)</span></span>;</span><br><span class="line">    ifs.<span class="built_in">seekg</span>(<span class="number">0</span>,ios::beg);</span><br><span class="line">    <span class="comment">//  f一个字节一个字节的走</span></span><br><span class="line">    <span class="comment">//  f.get(): 返回一个字节的二进制内容，然后指针向后移动一个字节。</span></span><br><span class="line">    function&lt;<span class="built_in"><span class="keyword">void</span></span>(ifstream&amp;)&gt; _print = [](ifstream&amp; f)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>&amp;&amp;!f.<span class="built_in">eof</span>();++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,f.<span class="built_in">get</span>());    <span class="comment">//  无需类型转换。f.get()读出来的就是一个字节里的内容！！！！</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    _print(ifs);</span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">seekg</span>(<span class="number">-64</span>,ios::end);</span><br><span class="line">    _print(ifs);</span><br><span class="line"></span><br><span class="line"><span class="number">89</span> <span class="number">50</span> <span class="number">4</span>e <span class="number">47</span> <span class="number">0</span>d <span class="number">0</span>a <span class="number">1</span>a <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>d <span class="number">49</span> <span class="number">48</span> <span class="number">44</span> <span class="number">52</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">38</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> f7 <span class="number">08</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> aa d9 cb <span class="number">5</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">67</span> <span class="number">41</span> <span class="number">4</span>d</span><br><span class="line"><span class="number">41</span> <span class="number">00</span> <span class="number">00</span> b1 <span class="number">8f</span> <span class="number">0b</span> fc <span class="number">61</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">20</span> <span class="number">63</span> <span class="number">48</span> <span class="number">52</span> <span class="number">4</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">7</span>a <span class="number">26</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span></span><br><span class="line">d1 <span class="number">99</span> d6 <span class="number">13</span> <span class="number">3</span>a <span class="number">71</span> <span class="number">85</span> <span class="number">3</span>c d4 <span class="number">8</span>a c6 a0 f8 eb <span class="number">4</span>d <span class="number">82</span> <span class="number">83</span> db cb <span class="number">38</span> <span class="number">68</span> <span class="number">44</span> <span class="number">9f</span> c3 ba <span class="number">22</span> a5 <span class="number">90</span> d6 <span class="number">1</span>c <span class="number">2b</span> <span class="number">50</span> d5 <span class="number">44</span> <span class="number">27</span> d6 <span class="number">33</span> d4 <span class="number">30</span> a8</span><br><span class="line"><span class="number">9</span>d bd fe <span class="number">02</span> <span class="number">36</span> <span class="number">83</span> a3 c8 <span class="number">10</span> <span class="number">57</span> <span class="number">8</span>c <span class="number">76</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">49</span> <span class="number">45</span> <span class="number">4</span>e <span class="number">44</span> ae <span class="number">42</span> <span class="number">60</span> <span class="number">82</span></span><br></pre></td></tr></table></figure>


<h2 id="输入流ifstream-API说明"><a href="#输入流ifstream-API说明" class="headerlink" title="输入流ifstream API说明"></a>输入流ifstream API说明</h2><ul>
<li><a href="https://www.cplusplus.com/reference/fstream/ifstream/">cppreference</a></li>
<li><a href="https://www.apiref.com/cpp-zh/cpp/io/basic_ifstream.html">汉译</a></li>
<li><a href="http://c.biancheng.net/view/1541.html">ofstream seekp &amp; seekg</a></li>
<li><a href="http://c.biancheng.net/view/1541.html">ofstream tellp &amp; tellg</a></li>
<li>常用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(filename,mode);    <span class="comment">//  打开文件</span></span><br><span class="line">ifs.<span class="built_in">close</span>();                <span class="comment">//  关闭绑定的文件</span></span><br><span class="line">ifs.<span class="built_in">get</span>();  <span class="comment">//  获取一个字节的二进制内容，并且将文件指针向后移动一个字节。</span></span><br><span class="line">ifs.<span class="built_in">seekg</span>(x,std::ios::beg); <span class="comment">//  将文件指针从文件开始向后移动多少个字节</span></span><br><span class="line">ifs.<span class="built_in">seekg</span>(-x,std::ios::end);    <span class="comment">//  将文件指针从文件末尾向前移动多少个字节</span></span><br><span class="line">ifs.<span class="built_in">tellg</span>();      <span class="comment">//  用于获取文件指针的位置（距离开头多少字节）  </span></span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="keyword">char</span>*)ptr,len);   <span class="comment">//  从文件指针开始读取len个字节，到ptr中。接口为char*    </span></span><br><span class="line">ifs.<span class="built_in">eof</span>();      <span class="comment">//  到文件末尾，则</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>Kib kb ; Mib mb<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1KB=10^3=1000，1MB=10^6B=1000000B=1000KB;</span><br><span class="line">1KiB=2^10=1024，1MiB=2^20=1048576=1024KiB</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Linux下"><a href="#Linux下" class="headerlink" title="Linux下"></a>Linux下</h1><h2 id="使用Linux基本API"><a href="#使用Linux基本API" class="headerlink" title="使用Linux基本API"></a>使用Linux基本API</h2><ul>
<li>未封装<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;./task01.png&quot;</span>,O_RDWR);    </span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  指针从文件开始向后偏移0Byte</span></span><br><span class="line">    <span class="comment">//  读前64bytes</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">read</span>(fd,buf,<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  读后64bytes</span></span><br><span class="line">    ret = <span class="built_in">lseek</span>(fd,<span class="number">-64</span>,SEEK_END);</span><br><span class="line">    <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span> buf);</span><br><span class="line">    <span class="built_in">read</span>(fd,buf,<span class="number">64</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./day02.out </span><br><span class="line"><span class="number">89</span> <span class="number">50</span> <span class="number">4</span>e <span class="number">47</span> <span class="number">0</span>d <span class="number">0</span>a <span class="number">1</span>a <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>d <span class="number">49</span> <span class="number">48</span> <span class="number">44</span> <span class="number">52</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">38</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> f7 <span class="number">08</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> aa d9 cb <span class="number">5</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">67</span> <span class="number">41</span> <span class="number">4</span>d <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> b1 <span class="number">8f</span> <span class="number">0b</span> fc <span class="number">61</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">20</span> <span class="number">63</span> <span class="number">48</span> <span class="number">52</span> <span class="number">4</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">7</span>a <span class="number">26</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> </span><br><span class="line">d1 <span class="number">99</span> d6 <span class="number">13</span> <span class="number">3</span>a <span class="number">71</span> <span class="number">85</span> <span class="number">3</span>c d4 <span class="number">8</span>a c6 a0 f8 eb <span class="number">4</span>d <span class="number">82</span> <span class="number">83</span> db cb <span class="number">38</span> <span class="number">68</span> <span class="number">44</span> <span class="number">9f</span> c3 ba <span class="number">22</span> a5 <span class="number">90</span> d6 <span class="number">1</span>c <span class="number">2b</span> <span class="number">50</span> d5 <span class="number">44</span> <span class="number">27</span> d6 <span class="number">33</span> d4 <span class="number">30</span> a8 <span class="number">9</span>d bd fe <span class="number">02</span> <span class="number">36</span> <span class="number">83</span> a3 c8 <span class="number">10</span> <span class="number">57</span> <span class="number">8</span>c <span class="number">76</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">49</span> <span class="number">45</span> <span class="number">4</span>e <span class="number">44</span> ae <span class="number">42</span> <span class="number">60</span> <span class="number">82</span> </span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">print</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fileRead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">fileRead</span>(<span class="keyword">const</span> string &amp;fp):<span class="built_in">file_path</span>(fp)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = <span class="built_in">open</span>(file_path.<span class="built_in">c_str</span>(),O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span>(fd==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        file_len = <span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_END);        </span><br><span class="line">        <span class="keyword">if</span>(file_len==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(fd);</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fileRead&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> fileRead&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">fileRead</span>(<span class="keyword">const</span> fileRead&amp;)=<span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">readAsHexFromBegin</span><span class="params">(<span class="keyword">int</span> bytes_to_get)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">lseek</span>(fd,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[bytes_to_get];       <span class="comment">//  或许可以用内存池优化</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">read</span>(fd,buf,bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="built_in">strerror</span>(ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        for_each(buf,buf+bytes_to_get,_print&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;());</span><br><span class="line">        <span class="keyword">delete</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">readAsHexFromEnd</span><span class="params">(<span class="keyword">int</span> bytes_to_get)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">lseek</span>(fd,-bytes_to_get,SEEK_END);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>[bytes_to_get];</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">read</span>(fd,buf,bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="built_in">strerror</span>(ret));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        for_each(buf,buf+bytes_to_get,_print&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;());</span><br><span class="line">        <span class="keyword">delete</span> buf;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">fileRead</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  关闭文件</span></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> file_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> string file_path;</span><br><span class="line">    <span class="keyword">int</span> file_len;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">fileRead <span class="title">fr</span><span class="params">(<span class="string">&quot;./task01.png&quot;</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;fr.<span class="built_in">getSize</span>()&lt;&lt;endl;</span><br><span class="line">    fr.<span class="built_in">readAsHexFromBegin</span>(<span class="number">64</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    fr.<span class="built_in">readAsHexFromEnd</span>(<span class="number">64</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./day02.out </span><br><span class="line"><span class="number">556002</span></span><br><span class="line"><span class="number">89</span> <span class="number">50</span> <span class="number">4</span>e <span class="number">47</span> <span class="number">0</span>d <span class="number">0</span>a <span class="number">1</span>a <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>d <span class="number">49</span> <span class="number">48</span> <span class="number">44</span> <span class="number">52</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">38</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> f7 <span class="number">08</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> aa d9 cb <span class="number">5</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">67</span> <span class="number">41</span> <span class="number">4</span>d <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> b1 <span class="number">8f</span> <span class="number">0b</span> fc <span class="number">61</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">20</span> <span class="number">63</span> <span class="number">48</span> <span class="number">52</span> <span class="number">4</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">7</span>a <span class="number">26</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> </span><br><span class="line">d1 <span class="number">99</span> d6 <span class="number">13</span> <span class="number">3</span>a <span class="number">71</span> <span class="number">85</span> <span class="number">3</span>c d4 <span class="number">8</span>a c6 a0 f8 eb <span class="number">4</span>d <span class="number">82</span> <span class="number">83</span> db cb <span class="number">38</span> <span class="number">68</span> <span class="number">44</span> <span class="number">9f</span> c3 ba <span class="number">22</span> a5 <span class="number">90</span> d6 <span class="number">1</span>c <span class="number">2b</span> <span class="number">50</span> d5 <span class="number">44</span> <span class="number">27</span> d6 <span class="number">33</span> d4 <span class="number">30</span> a8 <span class="number">9</span>d bd fe <span class="number">02</span> <span class="number">36</span> <span class="number">83</span> a3 c8 <span class="number">10</span> <span class="number">57</span> <span class="number">8</span>c <span class="number">76</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">49</span> <span class="number">45</span> <span class="number">4</span>e <span class="number">44</span> ae <span class="number">42</span> <span class="number">60</span> <span class="number">82</span> </span><br></pre></td></tr></table></figure>


<h2 id="使用mmap文件映射"><a href="#使用mmap文件映射" class="headerlink" title="使用mmap文件映射"></a>使用mmap文件映射</h2><ul>
<li>将文件映射到内存，之后就操作那块内存的指针就可以。不用再读文件。省了两次拷贝。正常要read读文件，也就是先从磁盘读到内核，在从内核读到用户区内存。而现在映射之后直接操作内存即可。<ul>
<li>所以建立映射之后就可以关闭fd了。</li>
</ul>
</li>
<li>注意建立映射的权限要和打开文件的权限保持一致</li>
<li>注意不用的时候就解除映射。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::unique_ptr;</span><br><span class="line"><span class="keyword">using</span> std::for_each;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  先不用c++异常了。直接assert</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">file</span>(<span class="keyword">const</span> string &amp; name,<span class="keyword">int</span> flag)</span><br><span class="line">        :_name(name),_flag(flag),<span class="built_in">is_mmap</span>(<span class="literal">false</span>),_ptr(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  打开文件</span></span><br><span class="line">        _fd = <span class="built_in">open</span>(_name.<span class="built_in">c_str</span>(),_flag);</span><br><span class="line">        <span class="keyword">if</span>(_fd==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// perror(strerror(errno));</span></span><br><span class="line">            <span class="comment">// assert(fd!=-1);</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="built_in">strerror</span>(errno));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  获取文件信息块</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">stat</span>(_name.<span class="built_in">c_str</span>(),&amp;_st);</span><br><span class="line">        <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取大小</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _st.st_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取文件信息块</span></span><br><span class="line">    <span class="function">struct stat <span class="title">getStat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _st;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read_file_from_begin</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_mmap)&#123;</span><br><span class="line">            <span class="built_in">set_mmap</span>();</span><br><span class="line">            is_mmap = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        for_each(_ptr,_ptr+len,[](<span class="keyword">unsigned</span> <span class="keyword">char</span> x)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,x);</span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read_file_from_end</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_mmap)&#123;</span><br><span class="line">            <span class="built_in">set_mmap</span>();</span><br><span class="line">            is_mmap = <span class="literal">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        for_each(_ptr+_st.st_size-len,_ptr+_st.st_size,[](<span class="keyword">unsigned</span> <span class="keyword">char</span> x)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,x);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  建立文件映射到内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_mmap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_flag==O_RDONLY)&#123;</span><br><span class="line">            _ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>,_st.st_size,PROT_READ,MAP_SHARED,_fd,<span class="number">0</span>);    </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_flag==O_RDWR)&#123;</span><br><span class="line">            _ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>,_st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,_fd,<span class="number">0</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  判断映射成功/失败</span></span><br><span class="line">        <span class="built_in">assert</span>(_ptr!=MAP_FAILED);</span><br><span class="line">        <span class="comment">//  映射之后就是对共享内存操作 而非文件了。所以关闭fd</span></span><br><span class="line">        <span class="keyword">if</span>(_fd!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(_fd);</span><br><span class="line">            _fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">file</span>()&#123;</span><br><span class="line">        <span class="comment">//  关闭文件</span></span><br><span class="line">        <span class="keyword">if</span>(_fd==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(_fd);</span><br><span class="line">            _fd = <span class="number">-1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  解除映射</span></span><br><span class="line">        <span class="keyword">if</span>(is_mmap)&#123;</span><br><span class="line">            <span class="built_in">munmap</span>(_ptr,_st.st_size);</span><br><span class="line">            _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _fd;            <span class="comment">//  文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> _flag;          <span class="comment">//  打开权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> _<span class="title">st</span>;</span>    <span class="comment">//  文件信息结构体</span></span><br><span class="line">    <span class="keyword">const</span> string _name; <span class="comment">//  文件名</span></span><br><span class="line">    <span class="keyword">bool</span> is_mmap;       <span class="comment">//  是否建立了映射</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *_ptr;         <span class="comment">//  文件映射到内存指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// int fd = open(&quot;./task01.png&quot;,O_RDONLY);</span></span><br><span class="line">    <span class="function">file <span class="title">f</span><span class="params">(<span class="string">&quot;./task01.png&quot;</span>,O_RDONLY)</span></span>;</span><br><span class="line">    cout&lt;&lt;f.<span class="built_in">getSize</span>()&lt;&lt;endl;   </span><br><span class="line">    f.<span class="built_in">read_file_from_begin</span>(<span class="number">64</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    f.<span class="built_in">read_file_from_end</span>(<span class="number">64</span>);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">556002</span></span><br><span class="line"><span class="number">89</span> <span class="number">50</span> <span class="number">4</span>e <span class="number">47</span> <span class="number">0</span>d <span class="number">0</span>a <span class="number">1</span>a <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">0</span>d <span class="number">49</span> <span class="number">48</span> <span class="number">44</span> <span class="number">52</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">38</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> f7 <span class="number">08</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> aa d9 cb <span class="number">5</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">04</span> <span class="number">67</span> <span class="number">41</span> <span class="number">4</span>d <span class="number">41</span> <span class="number">00</span> <span class="number">00</span> b1 <span class="number">8f</span> <span class="number">0b</span> fc <span class="number">61</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">20</span> <span class="number">63</span> <span class="number">48</span> <span class="number">52</span> <span class="number">4</span>d <span class="number">00</span> <span class="number">00</span> <span class="number">7</span>a <span class="number">26</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> </span><br><span class="line">d1 <span class="number">99</span> d6 <span class="number">13</span> <span class="number">3</span>a <span class="number">71</span> <span class="number">85</span> <span class="number">3</span>c d4 <span class="number">8</span>a c6 a0 f8 eb <span class="number">4</span>d <span class="number">82</span> <span class="number">83</span> db cb <span class="number">38</span> <span class="number">68</span> <span class="number">44</span> <span class="number">9f</span> c3 ba <span class="number">22</span> a5 <span class="number">90</span> d6 <span class="number">1</span>c <span class="number">2b</span> <span class="number">50</span> d5 <span class="number">44</span> <span class="number">27</span> d6 <span class="number">33</span> d4 <span class="number">30</span> a8 <span class="number">9</span>d bd fe <span class="number">02</span> <span class="number">36</span> <span class="number">83</span> a3 c8 <span class="number">10</span> <span class="number">57</span> <span class="number">8</span>c <span class="number">76</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">49</span> <span class="number">45</span> <span class="number">4</span>e <span class="number">44</span> ae <span class="number">42</span> <span class="number">60</span> <span class="number">82</span> </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++_随笔</title>
    <url>/2022/03/01/c++_%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h2 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h2><ul>
<li><p>默认构造函数：</p>
<ul>
<li>不需要传递任何实参的构造函数。</li>
</ul>
</li>
<li><p>合成默认构造函数</p>
<ul>
<li>只有当类内没有声明任何构造函数时，编译器才会自动的生成默认构造函数。</li>
<li>如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。</li>
</ul>
</li>
<li><p>类内初始值：在类内定义变量时，就初始化他。</p>
</li>
<li><p><code>Sales() = default</code>。因为我们既需要其他构造函数，又需要一个默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales</span>() = <span class="keyword">default</span>;  <span class="comment">//  显示说出 我需要一个编译器合成的默认构造函数。</span></span><br><span class="line">    <span class="comment">//  规则：</span></span><br><span class="line">    <span class="comment">//  对于数据成员来说</span></span><br><span class="line">    <span class="comment">//  如果存在类内的初始值，用它来初始化成员。</span></span><br><span class="line">    <span class="comment">//  否则，默认初始化。</span></span><br><span class="line">    <span class="comment">//  所以，如果想要一个默认构造函数的话</span></span><br><span class="line">        <span class="comment">//  1.  对于内置类型(int)和符合类型(指针、数组)来说</span></span><br><span class="line">            <span class="comment">//   在块中定义的内置类型和复合类型被默认初始化，则他们的值是未定义的。该原则同样适用于类内默认初始化的内置类型成员。</span></span><br><span class="line">            <span class="comment">//   所以</span></span><br><span class="line">            <span class="comment">//  要么 int a = 1;（给他初始值，否则内置类型的值是未定义的）。</span></span><br><span class="line">            <span class="comment">//  要么 Sales类自己定义一个默认构造函数。</span></span><br><span class="line">            <span class="comment">//  否则，用户创建类对象时会得到未定义的值。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  2.  如果Sales类有其他类如A类型的数据成员</span></span><br><span class="line">        <span class="comment">//  那么，要么这个A类自己有一个默认构造函数</span></span><br><span class="line">        <span class="comment">//  要么，调用A类的其他构造函数给这个A类初始值。（这个是我猜的）</span></span><br><span class="line">        <span class="comment">//  否则，语法error。无法生成</span></span><br><span class="line">    <span class="built_in">Sales</span>(<span class="keyword">const</span> string &amp;str):<span class="built_in">m_str</span>(str)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//  以下成员都有类内初始值</span></span><br><span class="line">    <span class="keyword">int</span> m_data1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> m_data2 = <span class="number">2</span>;</span><br><span class="line">    string m_str;   <span class="comment">// string类型有默认构造函数</span></span><br><span class="line">    A m_a1;         <span class="comment">//  A类型有默认构造函数</span></span><br><span class="line">    <span class="function">A <span class="title">m_a2</span><span class="params">(...)</span></span>;    <span class="comment">//  调用A的构造函数给他一个初始值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(...)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>如果编译器不支持类内初始值，那么，我们的默认构造函数就应该使用构造函数初始值列表来初始化类的每个成员</p>
<ul>
<li><code>Sales(const string &amp;str):m_str(str)&#123;&#125;</code></li>
</ul>
</li>
<li><p>通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在，我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显示的初始化每个内置类型的成员。</p>
</li>
<li><p>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有的构造函数都应该显示的初始化每个内置类型成员。</p>
</li>
<li><p>没有出现在构造函数初始值列表的成员将通过相应的类内初始值（如果存在）初始化，或者执行默认初始化。（所以看上去的顺序是先执行这些数据成员的定义，再去到构造函数执行。所以构造函数初始值列表才会覆盖相应通过类内初始值赋值或者默认初始化的成员的值）</p>
</li>
<li><p>类内初始值必须使用=的初始化形式<code>(int a = 5)</code>，或者花括号括起来的直接初始化形式。(<code>vector&lt;A&gt; v&#123;A()&#125;;</code>)</p>
</li>
</ul>
<h2 id="friend声明"><a href="#friend声明" class="headerlink" title="friend声明"></a>friend声明</h2><ul>
<li>类和非成员函数的声明不是必须在他们的<code>friend</code>声明之前。<ul>
<li>当某个函数或者类做出一个friend声明时，我们能隐式的假定这个做出友元声名的函数或者类在当前作用域是可见的。只是在做出友元声明的这一动作上认为他是可见的。</li>
<li><strong>然而，这个友元本身并不一定真的声明在当前作用域中。</strong></li>
</ul>
</li>
<li>甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。即使我们仅仅是用声明友元的类的成员调用该友元函数，他也必须是声明过的。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="comment">/*友元函数可以定义在类内部*/</span>&#125;</span><br><span class="line">  <span class="built_in">X</span>() &#123;<span class="built_in">f</span>();&#125;    <span class="comment">// error！  f还没有被声明</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123;<span class="built_in">f</span>();&#125;    <span class="comment">// error!! f没有被声明，f并不在这个g函数可见的作用域内。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;           <span class="comment">//   声明那个定义在X中的函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123;<span class="built_in">f</span>();&#125;    <span class="comment">//  ok! 现在f的声明在作用域内了。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul>
<li><code>friend</code>友元声明仅仅指定了访问权限，而非一个通常意义声明。- 应在友元声明之外再专门对函数进行一次声明。</li>
<li>通常把友元的声明与类本身放置在同一个头文件中。<h3 id="类作为另一个类的友元"><a href="#类作为另一个类的友元" class="headerlink" title="类作为另一个类的友元"></a>类作为另一个类的友元</h3></li>
</ul>
<h3 id="类的成员函数作为另一个类的友元函数"><a href="#类的成员函数作为另一个类的友元函数" class="headerlink" title="类的成员函数作为另一个类的友元函数"></a>类的成员函数作为另一个类的友元函数</h3><h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><ul>
<li>一个可变数据成员永远不会是const，即使是const对象的成员。</li>
<li>即使是一个const成员函数可以改变mutable成员的值</li>
</ul>
<h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><ul>
<li><code>const A&amp; method(...) const &#123;return *this;&#125;</code><ul>
<li><code>const</code>成员函数返回<code>*this</code>时，返回的是<code>const &amp;</code>。（因为此时的this是一个指向常量的指针）</li>
</ul>
</li>
<li>一个对象的<code>const&amp;</code>不能调用非<code>const</code>成员函数</li>
<li><code>const</code>成员函数不能改变类内成员的值</li>
<li><code>type method ()&#123;&#125; const / type method()&#123;&#125;</code><ul>
<li>一个成员函数是否是<code>const</code>可以作为重载的条件。</li>
<li>是否能够重载一般都是通过参数列表判断，成员函数的参数列表第一个参数是<code>this</code>指针。</li>
<li>如果是一个常量对象调用函数，那么他对应的指针就是<code>const this</code>，相应的就会调用<code>const</code>成员函数；</li>
<li>而非常量对象就会匹配到非<code>const</code>成员函数。</li>
</ul>
</li>
</ul>
<h2 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h2><ul>
<li><code>class A</code> 前向声明。</li>
<li>前向声明只能在很有限的情境下使用<ul>
<li>可以定义指向这种类型的指针或引用</li>
<li>可以声明，但是<strong>不能定义</strong>以不完全类型作为<strong>参数</strong>或者<strong>返回类型</strong>的函数</li>
</ul>
</li>
</ul>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><ul>
<li><strong>类的定义分成<code>2</code>步</strong><ul>
<li><strong><code>1、</code>编译成员的声明</strong></li>
<li><strong><code>2、</code>直到类全部可见之后再编译函数体</strong></li>
</ul>
</li>
<li>即，编译器处理完类中的全部声明后，才会处理成员函数的定义。<ul>
<li>这样处理的原因：因为成员函数体在整个类可见之后才会被处理，所以它能使用类中定义的任何名字。相反，如果函数的定义和成员的声明被同时处理，那么我们就只能使用哪些已经出现的名字。</li>
</ul>
</li>
</ul>
<h2 id="隐式的类类型转换"><a href="#隐式的类类型转换" class="headerlink" title="隐式的类类型转换"></a>隐式的类类型转换</h2><ul>
<li>能够通过一个实参调用的构造函数定义了一条从构造函数的<strong>参数</strong>类型向<strong>类</strong>类型隐式转换的规则。<ul>
<li>```c++<br>class Sales_daat<br>{<br>  public:<pre><code>Sales_data() = default;
Sales_data(const string &amp;s):bookNo(s)&#123;&#125;
//  这个构造函数可以使得 string 隐式转换成 Sales_data类型
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- c++11只允许**一步**类类型转换。（如 &quot;...&quot; -&gt; string -&gt;类类型）</span><br><span class="line">- explicit可以阻止构造函数的的隐式类类型转换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## static</span><br><span class="line">- static成员函数不包含this指针。不能和任何对象绑定在一起。</span><br><span class="line">- static静态成员函数不能访问非static静态数据成员、不能声明为const。</span><br><span class="line">- 对象可以访问static成员函数。</span><br><span class="line">- 我们必须在类的外部定义和初始化**静态成员数据**。</span><br><span class="line">- 我们可以在类的内部定义和初始化**静态成员函数**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">   static的第一种含义：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。</span><br><span class="line">   static的第二种含义：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。</span><br><span class="line">   static的第三种含义：修饰函数时，表明该函数只在同一文件中调用。</span><br><span class="line">   static的第四种含义：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。</span><br><span class="line">   static的第五种含义：修饰类成员函数，如上。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c语言中：</span><br><span class="line">用于函数内部修饰变量，即函数内的静态变量。这种变量的生存期长于该函数，使得函数具有一定的“状态”。使用静态变量的函数一般是不可重入的，也不是线程安全的，比如<span class="built_in">strtok</span>(<span class="number">3</span>)。</span><br><span class="line">用在文件级别（函数体之外），修饰变量或函数，表示该变量或函数只在本文件可见，其他文件看不到也访问不到该变量或函数。专业的说法叫“具有internal linkage”（简言之：不暴露给别的translation unit）。</span><br><span class="line">c++语言中（由于C++引入了类，在保持与C语言兼容的同时，<span class="keyword">static</span>关键字又有了两种新用法）：</span><br><span class="line">用于修饰类的数据成员，即所谓“静态成员”。这种数据成员的生存期大于<span class="class"><span class="keyword">class</span>的对象（实例/<span class="title">instance</span>）。静态数据成员是每个<span class="keyword">class</span>有一份，普通数据成员是每个<span class="title">instance</span> 有一份。</span></span><br><span class="line"><span class="class">用于修饰<span class="keyword">class</span>的成员函数，即所谓“静态成员函数”。这种成员函数只能访问静态成员和其他静态程员函数，不能访问非静态成员和非静态成员函数。</span></span><br><span class="line"><span class="class">————————————————</span></span><br><span class="line"><span class="class">版权声明：本文为<span class="title">CSDN</span>博主「<span class="title">men_wen</span>」的原创文章，遵循<span class="title">CC</span> 4.0 <span class="title">BY</span>-<span class="title">SA</span>版权协议，转载请附上原文出处链接及本声明。</span></span><br><span class="line"><span class="class">原文链接：<span class="title">https</span>:</span><span class="comment">//blog.csdn.net/men_wen/article/details/64443040</span></span><br></pre></td></tr></table></figure>


<h2 id="C-中的RAII机制"><a href="#C-中的RAII机制" class="headerlink" title="C++中的RAII机制"></a>C++中的RAII机制</h2><h2 id="string不会自动转化成const-char"><a href="#string不会自动转化成const-char" class="headerlink" title="string不会自动转化成const char *"></a>string不会自动转化成const char *</h2><p>因为const char*不是一个类，他没有可以用来隐式转换的构造函数！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">val = val*<span class="number">10</span> + data[i]-<span class="string">&#x27;0&#x27;</span>; </span><br><span class="line"><span class="comment">//  atoi(to_string(data[u]).c_str())    atoi只能const char *用  const char *又不是一个类。自然无法隐式完成string-&gt;const char *转换</span></span><br><span class="line"><span class="comment">//  但是string是一个类。所以可以完成const char *-&gt;string的隐式转换（string有只有一个参数const char *的构造函数）</span></span><br></pre></td></tr></table></figure>

<h2 id="堆栈-内存"><a href="#堆栈-内存" class="headerlink" title="堆栈 内存"></a>堆栈 内存</h2><p><a href="https://zhuanlan.zhihu.com/p/56929325">知乎csapp</a></p>
<h2 id="三大件"><a href="#三大件" class="headerlink" title="三大件"></a>三大件</h2><ul>
<li>拷贝构造函数<ul>
<li>第一个参数必须是一个引用类型</li>
<li>一般不explicit</li>
</ul>
</li>
<li>拷贝复制运算符</li>
<li>析构函数</li>
</ul>
<hr>
<p>如果我有一个STL中priority_queue的堆，堆中元素都是指针pa ,pb ,pc，指向a ,b c元素。堆的排序规则是比较这些指针指向的元素的大小。那么在堆中装入pa pb pc三个元素之后，当我直接改变a b c三个元素的大小时，如何才能保证堆中元素是顺序的？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> x):<span class="built_in">pri_mem</span>(x)&#123;cout&lt;&lt;<span class="string">&quot;Base pri_mem = &quot;</span>&lt;&lt;pri_mem&lt;&lt;endl;&#125;;</span><br><span class="line">    <span class="keyword">int</span> test_mem;       <span class="comment">//  我们没有给他类内初始值，因此他被默认初始化，所以是块垃圾</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_mem</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;test_mem = &quot;</span>&lt;&lt;test_mem&lt;&lt;<span class="string">&quot; pri_mem = &quot;</span>&lt;&lt;pri_mem&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> pri_mem = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub_Der</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  父类有默认构造函数，字类才能合成默认构造函数</span></span><br><span class="line">    <span class="built_in">Pub_Der</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//  先执行Base类的构造函数，再执行Pub_Der的Base函数</span></span><br><span class="line">    <span class="built_in">Pub_Der</span>(<span class="keyword">int</span> x):<span class="built_in">Base</span>(x)&#123;cout&lt;&lt;<span class="string">&quot;Pub_Der&quot;</span>&lt;&lt;endl;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test_fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//  派生类可以访问Base的public成员而不可访问private成员</span></span><br><span class="line">        cout&lt;&lt;test_mem&lt;&lt;endl;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;pri_mem&lt;&lt;endl; //  error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pub_Der <span class="title">pd</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">//  Pub_Der(x):Base(x)</span></span><br><span class="line">    pd.<span class="built_in">test_fun</span>();      </span><br><span class="line"></span><br><span class="line">    Pub_Der pd2;        <span class="comment">//  Pub_Der()=default : Base()=default  </span></span><br><span class="line">    pd2.<span class="built_in">show_mem</span>();</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ g++ private_mem.cpp -o private_mem.out -Wall</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./private_mem.out </span><br><span class="line">Base pri_mem = <span class="number">10</span></span><br><span class="line">Pub_Der</span><br><span class="line"><span class="number">1548404848</span></span><br><span class="line">test_mem = <span class="number">-1147499936</span> pri_mem = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><ul>
<li>类派生列表<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="comment">//  成员函数后面+override：处于某种原因，C++新标准允许派生类显式地标注它将使用哪个成员函数改写基类的虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="控制访问和继承"><a href="#控制访问和继承" class="headerlink" title="控制访问和继承"></a>控制访问和继承</h2><h3 id="成员关键字：protected成员"><a href="#成员关键字：protected成员" class="headerlink" title="成员关键字：protected成员"></a>成员关键字：<strong>protected成员</strong></h3><ul>
<li><p>protected关键字：控制本类的该成员能否被</p>
</li>
<li><p><strong>和private类似，protected成员对类的用户（在类外定义的该类对象）来说是不可见的。</strong></p>
</li>
<li><p><strong>和public类似，protected成员对派生类的成员和友元是可见的。</strong></p>
</li>
<li><p>派生类的成员或友元 只能通过 派生类对象 来访问 基类protected成员，派生类 对于一个 基类对象 的protected成员没有任何访问特权。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> prot_mem;     <span class="comment">//  proteced 成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span> <span class="params">(Sneaky &amp;)</span></span>;   <span class="comment">//  能访问Sneaky::prot_mem;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;)</span></span>;     <span class="comment">//  不能访问 Base::prot_mem;</span></span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  可以访问Sneaky对象的protected成员和private成员。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.j = s.prot_mem = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  不能访问Base的protected成员。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span>   <span class="comment">//  不可以</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b.prot_nem = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果派生类（及其友元）能访问基类对象的受保护成员，则上面的void clobber(Base &amp;b){访问Base的protected成员}是合法的。clobber不是Base的友元，但是它可以改变Base的对象的内容。如果这样的话，我们只要定义一个类似Sneaky的class就能避开protected机制、改变一个类的protected成员。</p>
</li>
<li><p>因此，<strong>派生类的成员和友元</strong> 只能访问派生类对象中的 <strong>基类部分</strong> 的protected成员，不能直接访问基类对象中的protected成员。</p>
</li>
</ul>
</li>
<li><p>类的成员和友元：属于编写类时需要实现的部分。</p>
</li>
<li><p>类的用户：程序员使用该类时所创建的对象。</p>
</li>
</ul>
<hr>
<h3 id="成员关键字：protected的由来"><a href="#成员关键字：protected的由来" class="headerlink" title="成员关键字：protected的由来"></a><strong>成员关键字：protected的由来</strong></h3><ul>
<li>不考虑继承的话<ul>
<li>类相关的可以分为<strong>两种</strong>：类的使用者和类的是闲着</li>
<li>使用者（普通用户）使用使用类的对象，只能访问public成员。</li>
<li>实现者编写类的成员和友元代码，成员和友元代码既能访问公有也能访问私有</li>
</ul>
</li>
<li><strong>引入继承</strong><ul>
<li>出现派生类</li>
<li><code>Base</code>希望派生类能使用一部分<code>Base</code>的成员，于是<code>Base</code>把这部分声明为protected的。protected成员可以被派生类访问，而不能被普通用户访问。于是派生类可以访问的就是public成员和protected成员，但是仍不能访问private的。</li>
</ul>
</li>
<li><strong>所以</strong>基类中，接口成员声明为公有。剩下的，属于类的实现细节。这些细节再分为两组，一组只能给基类本身和其友元使用，声明为private；一组要给派生类访问，声明为protected。</li>
</ul>
<hr>
<h3 id="public、private、protected继承（派生访问说明符）"><a href="#public、private、protected继承（派生访问说明符）" class="headerlink" title="public、private、protected继承（派生访问说明符）"></a>public、private、protected继承（派生访问说明符）</h3><ul>
<li><code>public</code>派生类都不能访问基类的<code>private</code>成员</li>
<li><code>private</code>继承是让A类外的东西（包括类外定义的A类对象a）认为A中继承自B的成员都是<code>private</code>的。</li>
<li>但是在A类内，Base的成员对A的可见度并不受private影响。A类内，对于Base成员的可见度只和Base类内定义成员时是public / protected /private有关<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">private</span> / <span class="keyword">protected</span> B&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>C++ Primer</strong><ul>
<li>派生访问说明符对于派生类成员）以及友元）能否直接访问其直接基类的成员没有影响。派生类内对于基类成员的访问权限至于基类中的访问说明符有关。</li>
<li>派生访问说说明符的目的是控制派生类用户（在派生类外使用派生类对象）对于基类成员的访问权限。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> pro_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span> pri_mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="comment">//  Yes , 派生类可访问protected成员。</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> pro_mem;&#125;</span><br><span class="line">  <span class="comment">//  Wrong ! 派生类不能访问基类的private成员。</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> priv_mem;&#125;</span><br><span class="line">  <span class="comment">//  Yes !  派生类可以访问基类的protected成员。</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> pro_mem;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pri_Derv</span> :</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="comment">//  Yes ！ 派生说明符private对类内对基类的访问没有影响。</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pro_mem;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pro_mem</span> :</span> <span class="keyword">protected</span> Base&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Pub_Derv d1;</span><br><span class="line">Priv_Derv d2;</span><br><span class="line">Pro_Derv d3;</span><br><span class="line"></span><br><span class="line">d1.<span class="built_in">pub_mem</span>();     </span><br><span class="line"><span class="comment">//  PASS !</span></span><br><span class="line"><span class="comment">// public继承Base的子类，在【类外使用该类对象】（即用户） 访问Base部分的成员时，</span></span><br><span class="line"><span class="comment">//  其权限是 min(public,  Base类定义相应成员时的权限)</span></span><br><span class="line"></span><br><span class="line">d2.<span class="built_in">pub_mem</span>(); </span><br><span class="line"><span class="comment">//  ERROR !</span></span><br><span class="line"><span class="comment">//  private继承Base的子类，在【类外使用该类对象】（即用户）访问Base部分的的成员时，</span></span><br><span class="line"><span class="comment">//  其权限是 ：min(private, Base类定义相应成员时的权限) = private</span></span><br><span class="line"></span><br><span class="line">d3.<span class="built_in">pub_mem</span>();</span><br><span class="line"><span class="comment">//  ERROR!</span></span><br><span class="line"><span class="comment">//  protected继承Base的子类，在【类外使用该类对象】（即用户）访问Base部分的的成员时，</span></span><br><span class="line"><span class="comment">//  其权限是 ：min(protected, Base类定义相应成员时的权限) </span></span><br><span class="line"><span class="comment">//  当然，Pro_Derv内部的成员和友元可以访问那些继承而来的public和protected成员。只是用户不可以访问pub_mem这样的protected成员。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>友元关系不能继承</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>另一个类A公有的继承另一个类B，那么派生类应当反应与基类的”<strong>是一种(<code>IS A</code>)</strong>“关系<br><img src="/2022/03/01/c++_%E9%9A%8F%E7%AC%94/2022-03-10-15-40-16.png"></li>
</ul>
<ul>
<li><p>派生类不能访问基类的<code>private</code>成员</p>
</li>
<li><p>在派生类对象中含有与基类对应的组成部分，这一事实是继承的关键所在</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> B&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">A a; B b;</span><br><span class="line">A *pa = &amp;b; <span class="comment">//  pa指向b的a的部分</span></span><br><span class="line">A &amp;ra = b;  <span class="comment">//  ra绑定到b的a部分</span></span><br></pre></td></tr></table></figure></li>
<li><p>关键概念：遵循基类的接口</p>
<ul>
<li><p>尽管从语法上我们可以在派生类构造函数体给他的公有或者受保护的基类成员赋值，但最不要这么做、应通过<strong>调用基类</strong>的构造函数来初始化那些从基类继承来的成员</p>
<ul>
<li>每个类控制它自己的成员初始化过程</li>
<li>派生类不能直接初始化它从基类继承来的成员，派生类必须使用基类的构造函数来初始化它的基类部分。</li>
<li>除非我们特别指出（显式调用基类的其他构造函数），否则派生类的基类部分会像数据成员一样执行默认初始化</li>
<li>首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。</li>
</ul>
</li>
<li><p>基类的虚构函数必须是虚构的！！</p>
</li>
<li><p>继承与static成员</p>
<ul>
<li>如果基类中的成员是private的，则派生类无权访问。假设可访问，那么既可以基类访问也可以派生类访问。</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<ul>
<li>如果我们想将某个类用作基类，那么该类必须已经定义而非仅仅声明。（很自然，因为派生类要继承基类，自然要知道基类都有什么成员；隐含原因：一个类不能继承他本身）</li>
</ul>
<h3 id="存在继承关系的类型之间的转换规则"><a href="#存在继承关系的类型之间的转换规则" class="headerlink" title="存在继承关系的类型之间的转换规则"></a>存在继承关系的类型之间的转换规则</h3><ul>
<li>从派生类向基类的转换只对指针或引用类型有效</li>
<li>基类向派生类不存在隐式转换</li>
<li>和任何其他函数一样，炮声类向基类的类型转换也可能会由于访问受限而变得不可行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尽管自动类型转换只对指针或引用类型有效。但是继承体系中的大多数类仍然（显示或者隐式的）定义了拷贝控制成员。</span><br><span class="line">因此，我们通常能够将一个派生类对象拷贝、移动、赋值给一个基类对象。不过需要注意的是，这种操作只能处理派生类的基类部分。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="一些语法"><a href="#一些语法" class="headerlink" title="一些语法"></a>一些语法</h3><ul>
<li><p>基类需要将两种成员函数区分开</p>
<ul>
<li>基类希望派生类直接继承的函数</li>
<li>基类希望派生类进行覆盖的函数<ul>
<li>即为虚函数。<code>virtual</code></li>
<li><strong>virtual使得该函数执行动态绑定。</strong></li>
<li>virtual只能出现在类内部的声明而不能用于类外部的函数定义。</li>
<li>如果基类把一个函数声明为虚函数，那么该函数再派生类中隐式地也是虚函数。</li>
</ul>
</li>
</ul>
</li>
<li><p>当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。</p>
</li>
<li><p>成员函数如果没有被声明为虚函数，则解析过程发生在编译时而非运行时。</p>
</li>
<li><p>派生类可以在它覆盖的虚函数前使用virtual关键字，但不是非得这么做，因为有一旦某个函数被声明为虚函数，则所有的派生类里他都是虚函数。</p>
</li>
<li><p>C++11允许派生类显示标明使用某个成员函数覆盖了它继承的虚函数。具体做法是在函数末尾加上<code>override</code></p>
</li>
<li><p>子类中定义的与父类同名同参数列表的函数方法，就是在实现继承自父类的方法！</p>
</li>
<li><p>有纯虚函数的类称为抽象类，不能new抽象类</p>
<ul>
<li>子类如果没有重写父类的纯虚函数，则子类变成抽象类，不可new</li>
</ul>
</li>
</ul>
<h3 id="多态性核心"><a href="#多态性核心" class="headerlink" title="多态性核心"></a>多态性核心</h3><ul>
<li><strong>C++多态性的根本所在是：引用或指针的静态类型与动态类型可能不同</strong><ul>
<li>使用基类的指针或者引用调用基类中定义的函数时，如果该函数是一个虚函数，那么直到运行时才会决定调用哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。</li>
<li>对非virtual函数的调用在编译时绑定；通过对象进行的函数调用也在编译时绑定。</li>
</ul>
</li>
<li>当且仅当对通过指针或引用调用函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才会和静态类型不同。</li>
</ul>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><ul>
<li><code>=0</code>即为纯虚函数</li>
<li>含有纯虚函数的类是抽象基类。我们不能直接创建一个抽象基类的对象。</li>
</ul>
<h3 id="虚函数经典用法"><a href="#虚函数经典用法" class="headerlink" title="虚函数经典用法"></a>虚函数经典用法</h3><ul>
<li>延缓操作。将serialize()函数延迟到子类去执行<br><img src="/2022/03/01/c++_%E9%9A%8F%E7%AC%94/2022-03-10-16-21-41.png"><br><img src="/2022/03/01/c++_%E9%9A%8F%E7%AC%94/2022-03-10-17-16-16.png"></li>
</ul>
<h2 id="复合-Has-A"><a href="#复合-Has-A" class="headerlink" title="复合 Has A"></a>复合 <code>Has A</code></h2><ul>
<li><strong>Adapter</strong><ul>
<li>只改变接口，不改变本身。<br><img src="/2022/03/01/c++_%E9%9A%8F%E7%AC%94/2022-03-10-14-33-46.png"><br><img src="/2022/03/01/c++_%E9%9A%8F%E7%AC%94/2022-03-10-14-42-43.png"></li>
</ul>
</li>
</ul>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p><img src="/2022/03/01/c++_%E9%9A%8F%E7%AC%94/2022-03-10-15-03-53.png"><br>pointer to implemention<br>编译防火墙 左边类不用再编译，只需要右边的类重新编译。</p>
<h2 id="constexpr-和-virtual"><a href="#constexpr-和-virtual" class="headerlink" title="constexpr 和 virtual"></a>constexpr 和 virtual</h2><p><img src="/2022/03/01/c++_%E9%9A%8F%E7%AC%94/2022-03-19-11-16-34.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Der</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    Base *b = new Der();</span></span><br><span class="line"><span class="comment">//    constexpr int x = b-&gt;func(); 编译error 不认为b-&gt;func()是常量表达式</span></span><br></pre></td></tr></table></figure>




<h2 id="什么时候需要new"><a href="#什么时候需要new" class="headerlink" title="什么时候需要new?"></a>什么时候需要new?</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">：有很多场景是需要<span class="keyword">new</span> 的 例如实现多态</span><br><span class="line">昨天 <span class="number">12</span>:<span class="number">33</span></span><br><span class="line">Majestic 回复 光城~兴：多态也可以通过&amp;获取到子类对象的地址，然后赋值给父类，也可以不用到<span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">其实我最想问的就是，我项目中的类对象是否都需要用智能指针进行封装</span><br><span class="line">昨天 <span class="number">12</span>:<span class="number">47</span></span><br><span class="line">光城~兴 回复 Majestic：不一定需要 智能指针其实帮你做了一些特殊事情 例如 析构</span><br><span class="line">昨天 <span class="number">13</span>:<span class="number">01</span></span><br><span class="line">Majestic 回复 光城~兴：有啥指导原则没，什么时候建议我自定义的类的对象需要用智能指针封装，什么时候不需要，可以只用A a这种用法</span><br><span class="line">昨天 <span class="number">13</span>:<span class="number">16</span></span><br><span class="line">光城~兴 回复 Majestic：指导原则在于 优先使用智能指针替换原始指针 因为可以避免内存泄漏忘记手动释放的问题哈</span><br><span class="line">昨天 <span class="number">16</span>:<span class="number">28</span></span><br><span class="line">Majestic 回复 光城~兴：那就回到了最原始的问题，我明明可以不用<span class="keyword">new</span>构造指针，而是直接A a声明对象，不用A* a=<span class="keyword">new</span> A。这样从根本上避免了内存泄露的问题。</span><br><span class="line">昨天 <span class="number">17</span>:<span class="number">18</span></span><br><span class="line">Majestic 回复 光城~兴：我看网上说<span class="keyword">new</span>存在主要解决动态数组，容量n是个变量的问题。这也不合适呀，我可以用vector等容器push back元素，也能避免用<span class="keyword">new</span></span><br><span class="line">昨天 <span class="number">17</span>:<span class="number">20</span></span><br><span class="line">Majestic 回复 光城~兴：对于我个人的项目，我完全可以不用<span class="keyword">new</span>裸指针，或者智能指针，去声明自定义类对象</span><br><span class="line">昨天 <span class="number">17</span>:<span class="number">21</span></span><br><span class="line">回复</span><br><span class="line">Majestic 回复 光城~兴：所以我什么时候用裸指针或者智能指针呢？这有什么原则嘛</span><br><span class="line"></span><br><span class="line">要动态管理的三种情况</span><br><span class="line"><span class="number">1</span> 当需要大量内存的时候。栈典型大小是<span class="number">1</span>M（有些平台更小），因此任何比<span class="number">50</span><span class="number">-100</span>kb大的对象都要用动态内存。否则对象全放在栈里面，会崩掉。</span><br><span class="line"><span class="number">2</span> 希望自己定义的对象有很长的生命周期，在函数返回后内存仍然存在，这个时候应该用动态内存分配。因为栈上的对象在超出作用域后会直接析构</span><br><span class="line"><span class="number">3</span> 当你构建的数组大小是个变量，大小未知，建议用动态内存。</span><br><span class="line">其他情况建议栈上分配内存，栈上更快且不会泄露。</span><br></pre></td></tr></table></figure>


<h2 id="insert和emplace"><a href="#insert和emplace" class="headerlink" title="insert和emplace"></a>insert和emplace</h2><ul>
<li><code>insert</code><ul>
<li><code>insert()</code> 函数的功能是在 vector 容器的指定位置之前插入一个或多个元素</li>
<li><code>iterator insert(pos,elem)</code>    在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器</li>
<li><code>iterator insert(pos,n,elem)</code>    在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器</li>
</ul>
</li>
<li><code>emplace</code><ul>
<li> 是 C++ 11 标准新增加的成员函数，用于在 vector 容器指定位置之前插入一个新的元素</li>
</ul>
</li>
<li> <code>emplace</code>和<code>insert</code>区别<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="keyword">int</span> num) :<span class="built_in">num</span>(num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(<span class="keyword">const</span> testDemo&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">testDemo</span>(testDemo&amp;&amp; other) :<span class="built_in">num</span>(other.num) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;调用移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    testDemo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">testDemo&amp; testDemo::<span class="keyword">operator</span>=(<span class="keyword">const</span> testDemo&amp; other) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num = other.num;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;insert:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo2&#123;&#125;;</span><br><span class="line">    demo2.<span class="built_in">insert</span>(demo2.<span class="built_in">begin</span>(), <span class="built_in">testDemo</span>(<span class="number">1</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    std::vector&lt;testDemo&gt; demo1&#123;&#125;;</span><br><span class="line">    demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert:</span><br><span class="line">调用构造函数</span><br><span class="line">调用移动构造函数</span><br><span class="line">emplace:</span><br><span class="line">调用构造函数</span><br></pre></td></tr></table></figure></li>
<li>可以看到，通过 insert() 函数向 vector 容器中插入 testDemo 类对象，需要调用类的构造函数和移动构造函数（或拷贝构造函数）；而通过 emplace() 函数实现同样的功能，只需要调用构造函数即可。</li>
<li>简单的理解，就是 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐大家优先使用 emplace()。</li>
</ul>
<h2 id="位（bit）、字节（byte）、字（Word）"><a href="#位（bit）、字节（byte）、字（Word）" class="headerlink" title="位（bit）、字节（byte）、字（Word）"></a>位（bit）、字节（byte）、字（Word）</h2><ul>
<li>1 byte = 8 bit<ul>
<li>4个二进制位(bit)就是一个16进制位</li>
<li>1 byte = 8 bit就是2个16进制位</li>
</ul>
</li>
<li>32位机器：1 word = 4 byte = 32bit</li>
<li>64位机器：1 word = 8 byte = 64bit<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">以下针对RV32</span><br><span class="line">lb 传输字节byte，也即8位二进制，也即2个十六进制位</span><br><span class="line">ld 传输双字节 2bytes，也即16位二进制，也即4个十六进制位</span><br><span class="line">lw 传输一个字word</span><br><span class="line">（RISC-V中一个字是32位）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;如果是lb指令，高56位(RV64)/24位(RV32)做符号扩展</span><br><span class="line">&gt;如果是sb指令，高56位(RV64)/24位(RV32)被忽略</span><br><span class="line">(RV64)      mem[x1]中存储的数据为0x1020304050607080</span><br><span class="line">            lb x11, 1(x1) <span class="comment">#x11=0x0000000000000070</span></span><br><span class="line">            lb x12, 0(x1) <span class="comment">#x12=0xFFFFFFFFFFFFFF80</span></span><br><span class="line">            sb x12, 2(x1) <span class="comment">#mem[x1]=0x1020304050807080</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective_C++</title>
    <url>/2021/09/15/effective_c++/</url>
    <content><![CDATA[<p>Effective条款</p>
<span id="more"></span>

<h1 id="Effective-C-笔记"><a href="#Effective-C-笔记" class="headerlink" title="Effective C++笔记"></a><strong>Effective C++笔记</strong></h1><h2 id="记录一些自己遇到的，并在Effective-C-中得到纠正的编程习惯。"><a href="#记录一些自己遇到的，并在Effective-C-中得到纠正的编程习惯。" class="headerlink" title="记录一些自己遇到的，并在Effective-C++中得到纠正的编程习惯。"></a>记录一些自己遇到的，并在Effective-C++中得到纠正的编程习惯。</h2><h2 id="条款3-尽可能使用const"><a href="#条款3-尽可能使用const" class="headerlink" title="条款3 尽可能使用const"></a><strong>条款3 尽可能使用const</strong></h2><h3 id="bitwise-constness-logical-constness"><a href="#bitwise-constness-logical-constness" class="headerlink" title="bitwise constness / logical constness"></a>bitwise constness / logical constness</h3><ul>
<li>如果函数的返回类型是一个内置类型，那么改动函数返回值从来就不合法。</li>
<li>对于条款03，所说的通过了<code>bitwise-constness</code>检测的，改变了指针所指物的成员函数，在<code>VS2019</code>中会被检测出 编译<code>error</code>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">qualifiers dropped in binding reference of type <span class="string">&quot;int &amp;&quot;</span> to initializer of type <span class="string">&quot;const int&quot;</span>		</span><br></pre></td></tr></table></figure></li>
<li><code>logical constness</code>：<code>mutable</code>修饰成员变量 可以实现在const成员函数中改变这种成员变量。</li>
</ul>
<h3 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a><strong>在const和non-const成员函数中避免重复</strong></h3><ul>
<li>这就是我之前碰到过的问题啊。我的nt代码跟书上的一样hhhhhh。</li>
<li>缺点：代码重复，编译时间，代码膨胀……<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> </span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TextBlock</span>(<span class="keyword">const</span> string&amp; s) :<span class="built_in">text</span>(s) &#123;&#125;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> pos) <span class="keyword">const</span> <span class="comment">//  留给const对象调用</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;const&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> text[pos];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> pos)	<span class="comment">//  给non-const对象调用</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;non-const&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> text[pos];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string text;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">TextBlock <span class="title">a1</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">const</span> TextBlock  <span class="title">a2</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">		cout &lt;&lt; a1[<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; a2[<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// non-const</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>正确操作 ： non-const调用const</strong></li>
<li><pre><code>const成员函数和non-const成员函数所执行的动作一致，所以可以由一个去调用另一个。    -   为什么不是const调用non-const？ 因为const对象只能调用常函数，常函数中也只能调用常函数（因为const对象保证了不改变对象状态），如果const函数中调用了non-const函数，则会违反保证，报错。
</code></pre>
</li>
<li>  所以non-const成员函数调用const成员函数</li>
<li><pre><code>`static_cast&lt;const TextBlock&amp;&gt;(*this)` ： 将当前non-const对象转化成const引用    -   对象转化成`const`是为了调用`const`版本的`[]` 不然会不断重复调用自身`non-const[] `    -   `static_cast &lt;要转化成的类型&gt; (待转化的对象)`
</code></pre>
</li>
<li><code>const_cast&lt;char&amp;&gt;(字符的const引用) </code>：将当前的<code>const</code>字符引用转化为non-const引用<ul>
<li>  <code>const_cast &lt;要转化成的类型&gt; (待转化对象) </code></li>
<li>  注：<code>C++</code>风格中，移除<code>const</code>的操作只能由<code>const_cast</code>操作完成</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> jj05</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">TextBlock</span>(<span class="keyword">const</span> string&amp; s) :<span class="built_in">text</span>(s) &#123;&#125;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) <span class="keyword">const</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;const&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> text[pos];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//  const成员函数和non-const成员函数所执行的动作一致，所以可以由一个去调用另一个。</span></span><br><span class="line">		<span class="comment">// 为什么不是const调用non-const？ 因为const对象只能调用常函数，常函数中也只能调用常函数（因为const对象保证了不改变对象状态），如果const函数中调用了non-const函数，则会违反保证，报错。</span></span><br><span class="line">		<span class="comment">// 	non-const成员函数调用const成员函数</span></span><br><span class="line">		<span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;non-const&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">				<span class="keyword">static_cast</span> &lt;<span class="keyword">const</span> TextBlock&amp;&gt; (*<span class="keyword">this</span>) [pos]</span><br><span class="line">			);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock*&gt;(<span class="keyword">this</span>)-&gt;<span class="keyword">operator</span>[](pos));</span><br><span class="line">			<span class="comment">//  static_cast&lt;const TextBlock&amp;&gt;(*this) ： 将当前non-const对象转化成const引用</span></span><br><span class="line">			<span class="comment">//  对象转化成const是为了调用const版本的[] 不然会不断重复调用自身non-const[] </span></span><br><span class="line">			<span class="comment">//  static_cast &lt;要转化成的类型&gt; (待转化的对象）</span></span><br><span class="line">			<span class="comment">//  const_cast&lt;char&amp;&gt;(字符的const引用) ：将当前的const字符引用转化为non-const引用</span></span><br><span class="line">			<span class="comment">//  const_cast &lt;要转化成的类型&gt; (待转化对象) </span></span><br><span class="line">			<span class="comment">//  注：C++风格中，移除const的操作只能由const_cast操作完成</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		string text;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">		<span class="function">TextBlock <span class="title">tbb</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span></span>;</span><br><span class="line">		cout &lt;&lt; tb[<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; tbb[<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// non-const</span></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// non-const</span></span><br><span class="line"><span class="comment">// const</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>const_cast ：将对象的常量性转除（cast away the constness）。是唯一有此能力的C++-style转型操作符</li>
<li>static_cast ：强迫隐式转换，将non-const转化为const，int转化为double，void*转化为typed指针，pointer-to-base转化为pointer-to-derived。但无法将const转化为non-const</li>
</ul>
<h2 id="条款5-了解C-默默编写并调用那些函数"><a href="#条款5-了解C-默默编写并调用那些函数" class="headerlink" title="条款5 了解C++默默编写并调用那些函数"></a><strong>条款5 了解C++默默编写并调用那些函数</strong></h2><ul>
<li><code>default</code>构造</li>
<li><code>copy</code>构造</li>
<li>析构函数<ul>
<li>编译器产生的析构函数是<code>non-virtual</code>的，除非这个<code>class</code>的<code>base class</code>自身声明有<code>virtual</code>析构函数</li>
</ul>
</li>
<li><code>copy assignment</code>(合成拷贝运算符)<ul>
<li>当一个<code>class</code>符合如下情况时，<code>c++</code>拒绝自动生成<code>copy assignment</code><ul>
<li><code>class</code>中有<code>reference</code>。（<code>reference</code>不能改变指向）</li>
<li><code>class</code>中有<code>const</code>成员。（<code>const</code>成员只能初始化不能赋值）</li>
<li><code>class</code>的<code>base class</code>将<code>copy assignment</code>声明为<code>private</code>(因为编译器为<code>derived class</code>生成的<code>copy assignment</code>操作符想象中可以处理<code>base clas</code>s成分，但他们无法调用<code>derived class</code>无权调用的函数)</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Empty</span>()&#123;&#125;	<span class="comment">//  default构造</span></span><br><span class="line">	<span class="built_in">Empty</span>(<span class="keyword">const</span> Empty&amp; rhs) &#123;&#125;  <span class="comment">//  copy构造</span></span><br><span class="line">	~<span class="built_in">Empty</span>()&#123;...&#125;	<span class="comment">//  析构</span></span><br><span class="line">	Empty&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs)&#123;&#125; <span class="comment">//  赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条款6-若不想使用编译器自动生成的函数，就该明确拒绝。"><a href="#条款6-若不想使用编译器自动生成的函数，就该明确拒绝。" class="headerlink" title="条款6 若不想使用编译器自动生成的函数，就该明确拒绝。"></a><strong>条款6 若不想使用编译器自动生成的函数，就该明确拒绝。</strong></h2><ul>
<li>如果某些操作没有意义，如对于<code>iostream</code>等类来说，拷贝赋值和构造没有意义。就要阻止。</li>
<li>旧标准中，通过将相应函数声明成<code>private</code>（防止其他类使用），并不定义（防止<code>member</code>函数和<code>friend</code>函数）。</li>
<li>新标准中，声明称<code>delete</code>即可。</li>
<li>最好采用新标准</li>
<li><code>iostream</code>源码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CLASS TEMPLATE basic_ios</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Elem</span>, <span class="keyword">class</span> _<span class="title">Traits</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">basic_ios</span> :</span> <span class="keyword">public</span> ios_base &#123; <span class="comment">// base class for basic_istream/basic_ostream</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> _Myos       = basic_ostream&lt;_Elem, _Traits&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Mysb       = basic_streambuf&lt;_Elem, _Traits&gt;;</span><br><span class="line">    <span class="keyword">using</span> _Ctype      = ctype&lt;_Elem&gt;;</span><br><span class="line">    <span class="keyword">using</span> char_type   = _Elem;</span><br><span class="line">    <span class="keyword">using</span> traits_type = _Traits;</span><br><span class="line">    <span class="keyword">using</span> int_type    = <span class="keyword">typename</span> _Traits::int_type;</span><br><span class="line">    <span class="keyword">using</span> pos_type    = <span class="keyword">typename</span> _Traits::pos_type;</span><br><span class="line">    <span class="keyword">using</span> off_type    = <span class="keyword">typename</span> _Traits::off_type;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    _Mysb* _Mystrbuf; <span class="comment">// pointer to stream buffer</span></span><br><span class="line">    _Myos* _Tiestr; <span class="comment">// pointer to tied output stream</span></span><br><span class="line">    _Elem _Fillch; <span class="comment">// the fill character</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">__CLR_OR_THIS_CALL <span class="title">basic_ios</span><span class="params">(<span class="keyword">const</span> basic_ios&amp;)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    basic_ios&amp; __CLR_OR_THIS_CALL <span class="keyword">operator</span>=(<span class="keyword">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条款30-透彻了解inlining的里里外外"><a href="#条款30-透彻了解inlining的里里外外" class="headerlink" title="条款30 透彻了解inlining的里里外外"></a><strong>条款30 透彻了解<code>inlining</code>的里里外外</strong></h2><ul>
<li><strong>构造函数</strong>和<strong>析构函数</strong>不适于设定为<code>inline</code>,即便看起来不含任何代码。因为编译器在编译期间为了完成保证的事情（尤其是在对象被创建和销毁时），会产生代码并安插到程序代码中,有时候就存在于构造和析构函数内。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//class Base&#123;..&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>inline</code>函数无法随着程序的升级而升级。(一字不差<code>hhh</code>)<blockquote>
<ul>
<li>如果f是程序库内的一个<code>inline</code>函数，客户将f函数本体编进程序中，一旦程序库设计者决定改变<code>f</code>，所用到f的客户端程序必须重新编译。这往往是大家都不愿意见到的。然而如果f是<code>non-inline</code>函数，一旦他有任何修改，客户端只需重新链接就好，远比重新编译的负担少很多。如果程序采用动态链接升级版函数，甚至可以不知不觉被应用程序吸纳。</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2022/04/02/c++_%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>函数模板、空间配置器、迭代器、emplace_back</p>
<span id="more"></span>

<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a><strong>函数模板</strong></h2><ul>
<li><p><strong>函数模板</strong>：函数体本身不会被编译。在函数调用出会实例化出相应的模板函数。</p>
</li>
<li><p><strong>模板函数</strong>：在函数调用点，编译器用用户指定的类型，从原函数模版实例化出一份函数代码</p>
</li>
<li><p>函数模板、模板的特例化、普通函数的重载</p>
<ul>
<li>模板特例化优于函数模板</li>
<li>模板特例化和普通函数：优先调用普通函数，但如果显示<code>&lt;类型&gt;</code>了，就调用模板特例化。</li>
<li>严格来讲不构成重载，重载是函数名相同，这几个东西函数名不同啊</li>
</ul>
</li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ 函数模板</span></span><br><span class="line"><span class="comment">模板的意义：对类型也可以进行参数化了</span></span><br><span class="line"><span class="comment">int sum(int a, int b)&#123;return a+b;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数模板 &lt;= 是不进行编译的，因为类型还不知道</span></span><br><span class="line"><span class="comment">模板的实例化 &lt;= 函数调用点进行实例化</span></span><br><span class="line"><span class="comment">模板函数  &lt;=  才是要被编译器所编译的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">模板类型参数 typename/class</span></span><br><span class="line"><span class="comment">模板非类型参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">模板的实参推演 =&gt; 可以根据用户传入的实参的类型，来推导出模板类型参数的具体类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">模板的特例化(专用化) 特殊（不是编译器提供的，而是用户提供的）的实例化</span></span><br><span class="line"><span class="comment">函数模板、模板的特例化、非模板函数的重载关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">模板代码是不能在一个文件中定义，在另外一个文件中使用的</span></span><br><span class="line"><span class="comment">模板代码调用之前，一定要看到模板定义的地方，这样的话，模板</span></span><br><span class="line"><span class="comment">才能够进行正常的实例化，产生能够被编译器编译的代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以，模板代码都是放在头文件当中的，然后在源文件当中直接</span></span><br><span class="line"><span class="comment">进行#include包含</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数模板的函数体不会被编译。因为压根不知道T的类型，无法知道该如何调用&lt;</span></span><br><span class="line"><span class="comment">//  在函数调用点处，才会根据用户指定的T类型编译出模板函数</span></span><br><span class="line"><span class="comment">//  函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//  定义一个模板参数列表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a,T b)</span>   <span class="comment">//  compare是一个函数模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;compare &quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  针对函数模板，提供const char*版本的特例化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> compare&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="keyword">const</span> <span class="keyword">char</span> *a,<span class="keyword">const</span> <span class="keyword">char</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;template&lt;&gt; bool compare&lt;const char*&gt;(const char *a , const char *b)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a,b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a,<span class="keyword">const</span> <span class="keyword">char</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;normal compare&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a,b) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  函数调用点</span></span><br><span class="line">    <span class="built_in">compare</span>(<span class="number">10</span>,<span class="number">20</span>); <span class="comment">//  函数模板的实参推演</span></span><br><span class="line">    compare&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    compare&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>,<span class="number">10.9</span>);  <span class="comment">//  double-&gt;int</span></span><br><span class="line"><span class="comment">//    compare(10.2,30);     double int T没有办法推演</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 函数模板实参的推演 T const char*</span></span><br><span class="line">	<span class="comment">// 对于某些类型来说，依赖编译器默认实例化的模板代码，代码处理逻辑是有错误的</span></span><br><span class="line">	<span class="comment">// 编译器优先把compare处理成函数名字，没有的化，才去找compare模板</span></span><br><span class="line">    <span class="built_in">compare</span>(<span class="string">&quot;acsde&quot;</span>,<span class="string">&quot;badad&quot;</span>);</span><br><span class="line">    compare&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  模板函数：在函数调用点，编译器用用户指定的类型，从原函数模版实例化出一份函数代码</span></span><br><span class="line"><span class="comment">//  函数名 + 模板参数列表 才是 函数名。也即compare&lt;int&gt; 才是函数名</span></span><br><span class="line"><span class="comment">//  在.o文件中可以看见符号</span></span><br><span class="line"><span class="comment">//  bool compare&lt;int&gt;(int a,int b)</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//        return a&lt;b;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">compare <span class="number">10</span> <span class="number">20</span></span><br><span class="line">compare <span class="number">2</span> <span class="number">3</span></span><br><span class="line">compare <span class="number">10</span> <span class="number">10</span></span><br><span class="line">normal compare</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> compare&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="keyword">const</span> <span class="keyword">char</span> *a , <span class="keyword">const</span> <span class="keyword">char</span> *b)</span><br></pre></td></tr></table></figure></li>
<li><p>模板的<strong>非类型参数</strong>：必须是整数类型（整数或地址/引用都可以），必须是常量，只能使用，不能修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  非类型模板参数 SIZE</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> SIZE&gt;	</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; SIZE - <span class="number">1</span> - i; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">12</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">89</span>,<span class="number">32</span>,<span class="number">21</span>,<span class="number">35</span> &#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]);</span><br><span class="line">	sort&lt;<span class="keyword">int</span>, <span class="number">7</span>&gt;(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> val : arr)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="问题-模板定义处和调用处"><a href="#问题-模板定义处和调用处" class="headerlink" title="问题 模板定义处和调用处"></a>问题 模板定义处和调用处</h3><ul>
<li>模板代码不能在一个文件中定义，另一个文件中使用的。模板代码调用之前，一定要看到模板定义的时候（也可以说是，模板定义的地方（文件），一定要可以看到模板代码调用处。），这样的话，模板才能够进行正常的实例化。</li>
<li><strong>常用方案</strong>：所以模板代码一般放在头文件中，然后在源文件中直接include包含</li>
<li>不常用方案：<ul>
<li>在函数模板定义文件中：<code>template bool compare&lt;类型&gt;(类型 a，类型 b)</code></li>
</ul>
</li>
</ul>
<h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><ul>
<li>函数模板本身的函数体不会被编译。</li>
<li>模板函数：在函数调用点，编译器用用户指定的类型，从原函数模版实例化出一份函数代码。</li>
<li>因为c++是分离式编译。会单独编译文件，然后再link。如果函数模板单独放入一个文件a，但调用处却在其他文件b（文件b有该函数模板的声明）。那么这个文件a在编译时是看不到函数调用处的。自然也就不会实例化出函数代码，<strong>在.o文件中自然也就不会有函数符号</strong>。而.o文件<strong>链接时</strong>，b文件中<strong>UND未定义的引用</strong>需要在外部.o文件去寻找相应定义处。然而，那个a文件对应的.o文件中并没有相应函数符号，也因此，找不到。所以，会在<strong>链接linked</strong>时报错。！</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><p>compare.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  函数模板本身不会被编译，在函数调用点处才会根据用户指定的模板参数来实例化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template compare &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;   </span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  特例化的函数模板会被编译。也因此会被其他文件找到</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> compare&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;template&lt;&gt; compare&lt;int&gt;()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  告诉编译器，进行指定类型的模板实例化。</span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">bool</span> compare&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*);</span><br></pre></td></tr></table></figure></li>
<li><p>main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  模板代码不能在一个文件中定义，另一个文件中使用的。模板代码调用之前，一定要看到模板定义的时候，这样的话，模板才能够进行正常的实例化</span></span><br><span class="line"><span class="comment">//  所以模板代码一般放在头文件中，然后在源文件中直接include包含</span></span><br><span class="line"><span class="comment">//  未定义的引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>;  <span class="comment">//  未定义的引用（声明） 编译后是*UND* 需要到外部去找定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    compare&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//  compare&lt;double&gt;(1.3, 1.5);</span></span><br><span class="line">    <span class="comment">//  LNK2019	无法解析的外部符号 &quot;bool __cdecl compare&lt;double&gt;(double,double)&quot; (? ? $compare@N@@YA_NNN@Z)，函数 main 中引用了该符号</span></span><br><span class="line">    compare&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a><strong>类模板</strong></h2><ul>
<li><p><strong>模板名 + 类型参数列表 = 类名</strong></p>
</li>
<li><p>构造函数 析构函数 本来要求和类名相同，但是C++特殊规定不需要写参数列表</p>
</li>
<li><p>所以 构造函数析构函数不用加<T>，其他出现模板的地方都应该加上类型参数列表</T></p>
</li>
<li><p>类模板 -》实例化 -》 模板类</p>
</li>
<li><p>类模板的选择性实例化。并且不是一下子实例化出类中所有函数的代码。</p>
<ul>
<li>函数代码中调用了哪个函数，才生成相应T的函数。</li>
</ul>
</li>
<li><p>memcpy浅拷贝</p>
<ul>
<li>memcpy是内存的二进制格式拷贝，将一段内存空间中内容原封不动的拷贝到另外一段内存空间中。</li>
<li>如果拷贝的是内置类型的元素，memcpy即高效又不会出错，但如果拷贝的是自定义类型元素，并且自定义类型元素中涉及到资源管理时，就会出错，因为memcpy的拷贝实际是浅拷贝。</li>
</ul>
</li>
</ul>
<h3 id="顺序栈代码"><a href="#顺序栈代码" class="headerlink" title="顺序栈代码"></a>顺序栈代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数模板 </span></span><br><span class="line"><span class="comment">模板的非类型参数 必须是整数类型（整数或者地址/引用都可以）都是常量，只能使用，而不能修改</span></span><br><span class="line"><span class="comment">类模板 =&gt; 实例化 =&gt; 模板类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T=<span class="keyword">int</span>&gt;</span><br><span class="line">class SeqStack <span class="comment">// 模板名称+类型参数列表 = 类名称</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造和析构函数名不用加&lt;T&gt;，其它出现模板的地方都加上类型参数列表</span></span><br><span class="line">	<span class="built_in">SeqStack</span>(<span class="keyword">int</span> size = <span class="number">10</span>)</span><br><span class="line">		: _pstack(<span class="keyword">new</span> T[size])</span><br><span class="line">		, _top(<span class="number">0</span>)</span><br><span class="line">		, _size(size)</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~<span class="built_in">SeqStack</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">delete</span>[]_pstack;</span><br><span class="line">		_pstack = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">SeqStack</span>(<span class="keyword">const</span> SeqStack&lt;T&gt; &amp;stack)</span><br><span class="line">		:_top(stack._top)</span><br><span class="line">		,_size(stack._size)</span><br><span class="line">	&#123;</span><br><span class="line">		_pstack = <span class="keyword">new</span> T[_size];</span><br><span class="line">		<span class="comment">// 不要用memcopy进行拷贝</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			_pstack[i] = stack._pstack[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SeqStack&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SeqStack&lt;T&gt; &amp;stack)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == &amp;stack)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span>[]_pstack;</span><br><span class="line"></span><br><span class="line">		_top = stack._top;</span><br><span class="line">		_size = stack._size;</span><br><span class="line">		_pstack = <span class="keyword">new</span> T[_size];</span><br><span class="line">		<span class="comment">// 不要用memcopy进行拷贝</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			_pstack[i] = stack._pstack[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;val)</span></span>; <span class="comment">// 入栈操作</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> <span class="comment">// 出栈操作</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		--_top;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T <span class="title">top</span><span class="params">()</span><span class="keyword">const</span> <span class="comment">// 返回栈顶元素</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">&quot;stack is empty!&quot;</span>; <span class="comment">// 抛异常也代表函数逻辑结束</span></span><br><span class="line">		<span class="keyword">return</span> _pstack[_top - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _top == _size; &#125; <span class="comment">// 栈满</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _top == <span class="number">0</span>; &#125; <span class="comment">// 栈空</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T *_pstack;</span><br><span class="line">	<span class="keyword">int</span> _top;</span><br><span class="line">	<span class="keyword">int</span> _size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 顺序栈底层数组按2倍的方式扩容</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		T *ptmp = <span class="keyword">new</span> T[_size * <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _top; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			ptmp[i] = _pstack[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span> []_pstack;</span><br><span class="line">		_pstack = ptmp;</span><br><span class="line">		_size *= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> SeqStack&lt;T&gt;::<span class="built_in">push</span>(<span class="keyword">const</span> T &amp;val) <span class="comment">// 入栈操作</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">		<span class="built_in">expand</span>();</span><br><span class="line">	_pstack[_top++] = val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 类模板的选择性实例化</span></span><br><span class="line">	<span class="comment">// 模板类 class SeqStack&lt;int&gt;&#123;&#125;;</span></span><br><span class="line">	SeqStack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	s1.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">	s1.<span class="built_in">push</span>(<span class="number">78</span>);</span><br><span class="line">	s1.<span class="built_in">push</span>(<span class="number">32</span>);</span><br><span class="line">	s1.<span class="built_in">push</span>(<span class="number">15</span>);</span><br><span class="line">	s1.<span class="built_in">pop</span>();</span><br><span class="line">	cout &lt;&lt; s1.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	SeqStack&lt;&gt; s2;  <span class="comment">//  默认参数列表是int 所以&lt;&gt;即可</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="空间配置器allocator"><a href="#空间配置器allocator" class="headerlink" title="空间配置器allocator"></a><strong>空间配置器allocator</strong></h2><ul>
<li><p>空间配置器：</p>
<ul>
<li>负责内存的开辟、释放；对象的构造、析构</li>
<li>将内存的开辟和对象的构造分离开</li>
<li>将内存的释放和对象的析构分离开</li>
</ul>
</li>
<li><p>没用空间配置器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;T&gt;(<span class="keyword">int</span> sz = <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  需要把内存开辟和对象构造分开处理    不然在创建vector的时候，不但开辟内存，还构造了所有元素.正常逻辑应当是我们加入元素.</span></span><br><span class="line">        _first = <span class="keyword">new</span> T[sz];</span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  析构有效对象，并释放所有空间</span></span><br><span class="line">        <span class="keyword">delete</span> [] _first;</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">const</span> vector&lt;T&gt;&amp; rhs)  <span class="comment">//  拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;     <span class="comment">//  容器大小</span></span><br><span class="line">        _first = <span class="keyword">new</span> T[sz];</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;   <span class="comment">//  有效元素长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _first[i] = rhs._first[i];</span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> vector&lt;T&gt;&amp; rhs)  <span class="comment">//  拷贝赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;rhs)      <span class="comment">//  与拷贝构造区别：避免自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> [] _first;   <span class="comment">//   销毁原内存</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;</span><br><span class="line">        _first = <span class="keyword">new</span> T[sz];</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _first[i] = rhs._first[i];</span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        *_last++ = val;     <span class="comment">//  元素的operator=</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要析构对象，并且要把析构对象和释放内存的操作分离开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        --_last;        <span class="comment">//  并没有析构对象。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;vector is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> *(_last<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _first==_last;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _last==_end;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _last - _first;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * _first; <span class="comment">//  指向数组起始位置</span></span><br><span class="line">    T * _last;  <span class="comment">//  指向数组中有效元素的后继位置</span></span><br><span class="line">    T * _end;   <span class="comment">//  指向数组空间的后继位置</span></span><br><span class="line">    <span class="comment">//  容器的二倍扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _end - _first;</span><br><span class="line">        <span class="keyword">int</span> len = _last - _first;</span><br><span class="line">        T *p_tmp = <span class="keyword">new</span> T[sz*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            p_tmp[i] = _first[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> [] _first;   <span class="comment">//  释放原先内存</span></span><br><span class="line">        _first = p_tmp;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + <span class="number">2</span>*sz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()&#123;cout&lt;&lt;<span class="string">&quot;Test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;cout&lt;&lt;<span class="string">&quot;~Test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Test(const Test&amp; t)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Test&amp; operator=&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1,t2,t3;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vector&lt;Test&gt; v;         <span class="comment">//  还没加入对象就构造了对象</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(t1);    <span class="comment">//  operator=</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    v.<span class="built_in">pop_back</span>();           <span class="comment">//  没调用析构</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">----------------</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">Test&amp; <span class="keyword">operator</span>=</span><br><span class="line">Test&amp; <span class="keyword">operator</span>=</span><br><span class="line">Test&amp; <span class="keyword">operator</span>=</span><br><span class="line">----------------</span><br><span class="line">----------------</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>使用空间配置器 allocator</p>
<ul>
<li>负责内存的开辟和释放，负责在指定内存上构造对象，以及析构指定内存上的对象</li>
</ul>
</li>
<li><p>好处：</p>
<ul>
<li>分离了内存开辟和对象的构造，分离了内存的释放和对象的析构；</li>
<li>不必开辟多少内存就构造多少不必要的对象<code>(T* p = new T[size])</code></li>
<li>应当是：<code>T *p = _allocator.allocate(sz); 开辟了sz大小的内存，并没有构造任何对象</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 容器的空间配置器 allocator</span></span><br><span class="line"><span class="comment"> * 内存的开辟释放,对象的构造析构,都是通过空间配置器完成.而不是直接通过new delete</span></span><br><span class="line"><span class="comment"> * template&lt;class _Ty</span></span><br><span class="line"><span class="comment"> *      class _Alloc = allocator&lt;_Ty&gt;&gt;</span></span><br><span class="line"><span class="comment"> *      class vector</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义容器的空间配置器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">int</span> size)</span>   <span class="comment">//  负责内存开辟</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T)*size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span>  <span class="comment">//  负责内存释放</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p,<span class="keyword">const</span> T&amp; val)</span>   <span class="comment">//  负责对象构造(在已有的内存上)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(val);     <span class="comment">//  定位new  在p指向的内存上构造(拷贝构造)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span>      <span class="comment">//  负责对象析构</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();            <span class="comment">//  ~T()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  容器底层内存开辟,内存释放,对象构造,对象析构,都通过allocator空间配置器来实现</span></span><br><span class="line">                        <span class="comment">//  类型Alloc 的类型默认是 空间配置器Allocator&lt;T&gt;  模板名称 + 类型参数 = 类名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T , <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 默认形参     构造函数:Allocator&lt;T&gt;()</span></span><br><span class="line">    vector&lt;T,Alloc&gt;(<span class="keyword">int</span> sz = <span class="number">10</span>,<span class="keyword">const</span> Alloc&amp; alloc = Allocator&lt;T&gt;())</span><br><span class="line">            :_allocator(alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  需要把内存开辟和对象构造分开处理    不然在创建vector的时候，不但开辟内存，还构造了所有元素.正常逻辑应当是我们加入元素.</span></span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">//  开辟内存</span></span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">vector</span>() &#123;</span><br><span class="line"><span class="comment">//        delete [] _first;</span></span><br><span class="line">        <span class="comment">//  析构有效对象</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);  <span class="comment">//  析构p对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  ,并释放所有空间</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">const</span> vector&lt;T,Alloc&gt;&amp; rhs)  <span class="comment">//  拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;     <span class="comment">//  容器大小</span></span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;   <span class="comment">//  有效元素长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first[i],rhs.first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> vector&lt;T,Alloc&gt;&amp; rhs)  <span class="comment">//  拷贝赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)      <span class="comment">//  与拷贝构造区别：避免自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        delete [] _first;   //   析构所有对象 销毁原内存</span></span><br><span class="line">        <span class="comment">//  析构有效对象 释放所有内存</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;</span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first+i,rhs._first[i]) ;  <span class="comment">//  构造有效对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line"><span class="comment">//        *_last++ = val;     //  元素的operator=</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last++,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要析构对象，并且要把析构对象和释放内存的操作分离开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line"><span class="comment">//        --_last;        //  只移动指针,并没有析构元素,也没有释放元素管理的内存。</span></span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(--_last);    <span class="comment">//  不仅移动指针 还需要析构元素s</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;vector is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> *(_last<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _first==_last;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _last==_end;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _last - _first;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * _first; <span class="comment">//  指向数组起始位置</span></span><br><span class="line">    T * _last;  <span class="comment">//  指向数组中有效元素的后继位置</span></span><br><span class="line">    T * _end;   <span class="comment">//  指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 空间配置器对象</span></span><br><span class="line">    <span class="comment">//  容器的二倍扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _end - _first;</span><br><span class="line">        <span class="keyword">int</span> len = _last - _first;</span><br><span class="line"><span class="comment">//        T *p_tmp = new T[sz*2];</span></span><br><span class="line">        <span class="comment">//  开辟内存 构造对象</span></span><br><span class="line">        T *p_tmp = _allocator.<span class="built_in">allocate</span>(sz*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            p_tmp[i] = _first[i];</span></span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p_tmp+i,_first[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  析构对象 释放内存</span></span><br><span class="line">        <span class="keyword">for</span>(T *p = _first;p!=_last;++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        delete [] _first;   //  释放原先内存 析构所有对象</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = p_tmp;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + <span class="number">2</span>*sz;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>()&#123;cout&lt;&lt;<span class="string">&quot;Test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;cout&lt;&lt;<span class="string">&quot;~Test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Test(const Test&amp; t)&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Test&amp; operator=&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1,t2,t3;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    vector&lt;Test&gt; v;         <span class="comment">//  只开辟了空间 没有构造对象</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(t1);    <span class="comment">//  Test(const Test&amp; )</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">    v.<span class="built_in">push_back</span>(t3);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">    v.<span class="built_in">pop_back</span>();           <span class="comment">//  调用析构 不是释放内存</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;----------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">----------------</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)     <span class="comment">//  _allocator.construct(_last++,val);</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)     </span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; t)</span><br><span class="line">----------------</span><br><span class="line">~<span class="built_in">Test</span>()                 <span class="comment">//  _allocator.destroy(_last);</span></span><br><span class="line">----------------</span><br><span class="line">~<span class="built_in">Test</span>()                 <span class="comment">//  _allocator.destroy(_last);</span></span><br><span class="line">~<span class="built_in">Test</span>()                 <span class="comment">//  _allocator.destroy(_last);</span></span><br><span class="line">~<span class="built_in">Test</span>()                 <span class="comment">//  ~Test();</span></span><br><span class="line">~<span class="built_in">Test</span>()                 <span class="comment">//  ~Test();</span></span><br><span class="line">~<span class="built_in">Test</span>()                 <span class="comment">//  ~Test();</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h2><ul>
<li>提供一种统一的方式，来透明的遍历容器</li>
<li>一般实现成容器的嵌套类型</li>
<li><code>for each</code>也是通过迭代器实现的。</li>
<li>begin 返回容器底层首元素的迭代器位置</li>
<li>end 返回的是容器末尾元素的后继位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  定义容器的空间配置器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span>&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T , <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 默认形参     构造函数:Allocator&lt;T&gt;()</span></span><br><span class="line">    vector&lt;T,Alloc&gt;(<span class="keyword">int</span> sz = <span class="number">10</span>,<span class="keyword">const</span> Alloc&amp; alloc = Allocator&lt;T&gt;())</span><br><span class="line">            :_allocator(alloc)&#123;        </span><br><span class="line">            _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">//  开辟内存</span></span><br><span class="line">            _last = _first;</span><br><span class="line">            _end = _first + sz;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  实现迭代器</span></span><br><span class="line">    <span class="comment">//  迭代器一般实现成容器的嵌套类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span>  //  迭代器就是包装了遍历方法(++)的一个指针</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">iterator</span>(T *p = <span class="literal">nullptr</span>)</span><br><span class="line">            :_ptr(p)&#123;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; iter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _ptr!=iter._ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++()</span><br><span class="line">        &#123;</span><br><span class="line">            _ptr++;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()&#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">        <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;<span class="keyword">return</span> *_ptr;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T *_ptr;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  需要给容器提供begin end方法</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(_first);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(_last);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * _first; <span class="comment">//  指向数组起始位置</span></span><br><span class="line">    T * _last;  <span class="comment">//  指向数组中有效元素的后继位置</span></span><br><span class="line">    T * _end;   <span class="comment">//  指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 空间配置器对象</span></span><br><span class="line">    <span class="comment">//  容器的二倍扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i) vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();iter!=vec.<span class="built_in">end</span>();++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*iter&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:vec)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h2><h3 id="迭代器为什么失效"><a href="#迭代器为什么失效" class="headerlink" title="迭代器为什么失效"></a>迭代器为什么失效</h3><ul>
<li><p>当前容器调用erase方法后，当前位置到容器末尾元素的所有迭代器都失效了</p>
</li>
<li><p>当前容器调用insert方法后，如果没扩容，当前位置到容器末尾元素的所有迭代器都失效了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   迭代器依然有效            迭代器全部失效</span><br><span class="line">首元素 -----&gt;    插入点/删除点  -----&gt;    末尾元素</span><br></pre></td></tr></table></figure></li>
<li><p>如果insert之后扩容了，那么就全部失效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原来容器的所有迭代器都失效</span><br><span class="line">首元素 -&gt; 插入点/删除点 -&gt; 末尾元素</span><br></pre></td></tr></table></figure></li>
<li><p>实现：将要失效的迭代器的pVec指向置为null，当需要再次调用这个迭代器时，会先判断pVec是否为null，为null，则抛出异常</p>
<h3 id="失效后如何解决"><a href="#失效后如何解决" class="headerlink" title="失效后如何解决"></a>失效后如何解决</h3></li>
<li><p>对失效迭代器进行更新操作</p>
</li>
<li><p>erase删除当前迭代器指向元素，返回下一位置元素的迭代器。</p>
</li>
<li><p>insert:当前位置增加新元素，原元素依次向后移动。</p>
</li>
<li><p>如何处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;++i) v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:v) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(; it!=v.<span class="built_in">end</span>();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  迭代器失效</span></span><br><span class="line">            it = v.<span class="built_in">erase</span>(it);   <span class="comment">//  erase删除当前迭代器指向元素，返回下一位置元素的迭代器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ++it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:v) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    it = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span>(;it!=v.<span class="built_in">end</span>();++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*it%<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            it = v.<span class="built_in">insert</span>(it,*it<span class="number">-1</span>);     <span class="comment">// insert:当前位置增加新元素，原元素依次向后移动</span></span><br><span class="line">            ++it;</span><br><span class="line">            <span class="comment">//            break;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x:v) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">14</span> <span class="number">0</span> <span class="number">9</span> <span class="number">4</span> <span class="number">18</span> <span class="number">18</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">1</span> <span class="number">7</span> <span class="number">1</span> <span class="number">11</span> <span class="number">15</span> <span class="number">2</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">9</span> <span class="number">5</span> <span class="number">5</span> <span class="number">1</span> <span class="number">7</span> <span class="number">1</span> <span class="number">11</span> <span class="number">15</span> <span class="number">7</span></span><br><span class="line">Hello, World!</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">4</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">1</span> <span class="number">6</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">10</span> <span class="number">11</span> <span class="number">14</span> <span class="number">15</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></li>
<li><p>不同容器的迭代器是不能比较运算的。</p>
</li>
<li><p>push_back</p>
<ul>
<li>当扩容的时候会使得所有迭代器失效</li>
<li>当正常的时候，会使得end()迭代器失效</li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>代码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 容器的空间配置器 allocator</span></span><br><span class="line"><span class="comment"> * 内存的开辟释放,对象的构造析构,都是通过空间配置器完成.而不是直接通过new delete</span></span><br><span class="line"><span class="comment"> * template&lt;class _Ty</span></span><br><span class="line"><span class="comment"> *      class _Alloc = allocator&lt;_Ty&gt;&gt;</span></span><br><span class="line"><span class="comment"> *      class vector</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义容器的空间配置器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T *<span class="title">allocate</span><span class="params">(<span class="keyword">int</span> size)</span>   <span class="comment">//  负责内存开辟</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T)*size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T *<span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p)</span>  <span class="comment">//  负责内存释放</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p,<span class="keyword">const</span> T&amp; val)</span>   <span class="comment">//  负责对象构造(在已有的内存上)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(val);     <span class="comment">//  定位new  在p指向的内存上构造(拷贝构造)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span>      <span class="comment">//  负责对象析构</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();            <span class="comment">//  ~T()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  容器底层内存开辟,内存释放,对象构造,对象析构,都通过allocator空间配置器来实现</span></span><br><span class="line">                        <span class="comment">//  类型Alloc 的类型默认是 空间配置器Allocator&lt;T&gt;  模板名称 + 类型参数 = 类名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T , <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 默认形参     构造函数:Allocator&lt;T&gt;()</span></span><br><span class="line">    vector&lt;T,Alloc&gt;(<span class="keyword">int</span> sz = <span class="number">10</span>,<span class="keyword">const</span> Alloc&amp; alloc = Allocator&lt;T&gt;())</span><br><span class="line">            :_allocator(alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  需要把内存开辟和对象构造分开处理    不然在创建vector的时候，不但开辟内存，还构造了所有元素.正常逻辑应当是我们加入元素.</span></span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">//  开辟内存</span></span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">vector</span>() &#123;</span><br><span class="line"><span class="comment">//        delete [] _first;</span></span><br><span class="line">        <span class="comment">//  析构有效对象</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);  <span class="comment">//  析构p对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  ,并释放所有空间</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">const</span> vector&lt;T,Alloc&gt;&amp; rhs)  <span class="comment">//  拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;     <span class="comment">//  容器大小</span></span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;   <span class="comment">//  有效元素长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first[i],rhs.first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;T,Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> vector&lt;T,Alloc&gt;&amp; rhs)  <span class="comment">//  拷贝赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)      <span class="comment">//  与拷贝构造区别：避免自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        delete [] _first;   //   析构所有对象 销毁原内存</span></span><br><span class="line">        <span class="comment">//  析构有效对象 释放所有内存</span></span><br><span class="line">        <span class="keyword">for</span> (T *p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;</span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first+i,rhs._first[i]) ;  <span class="comment">//  构造有效对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line"><span class="comment">//        *_last++ = val;     //  元素的operator=</span></span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last++,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要析构对象，并且要把析构对象和释放内存的操作分离开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">verify</span>(_last<span class="number">-1</span>,_last);  <span class="comment">//  检查删除元素后，有哪些迭代器失效    _last-1：最后一个元素。有对应迭代器 _last：后继位置，有对应迭代器</span></span><br><span class="line"><span class="comment">//        --_last;        //  只移动指针,并没有析构元素,也没有释放元素管理的内存。</span></span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(--_last);    <span class="comment">//  不仅移动指针 还需要析构元素s</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;vector is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> *(_last<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _first==_last;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _last==_end;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> _last - _first;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;OutOfRange&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;OutOfRange&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  实现迭代器</span></span><br><span class="line">    <span class="comment">//  迭代器一般实现成容器的嵌套类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span>  //  迭代器就是包装了遍历方法(++)的一个指针</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">vector</span>&lt;</span>T,Alloc&gt; ;</span><br><span class="line">        <span class="comment">//  产生迭代器对象 自动将自己加入迭代器链表</span></span><br><span class="line">        <span class="built_in">iterator</span>(vector&lt;T,Alloc&gt; *pvec , T *p = <span class="literal">nullptr</span>)</span><br><span class="line">            :_pVec(pvec),_ptr(p)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;cnt++&lt;&lt;endl;</span><br><span class="line">            <span class="comment">//  链表头插法                       节点内容    节点指向</span></span><br><span class="line">            Iterator_Base *ib = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>,_pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = ib;        <span class="comment">//  指针ib是局部变量，会被销毁无所谓。因为ib指向的内存是new出来的啊哈哈哈。不会被销毁的。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; iter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  _pVec == nullptr 代表迭代器失效</span></span><br><span class="line">            <span class="comment">//  首先判断是否是同一容器的迭代器（比较迭代器指向容器的地址是否相同）</span></span><br><span class="line">            <span class="keyword">if</span>(_pVec == <span class="literal">nullptr</span> || _pVec != iter._pVec)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator incompatable!&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _ptr!=iter._ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>++()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  _pVec == nullptr 迭代器失效</span></span><br><span class="line">            <span class="keyword">if</span>(_pVec==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator inValid&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  检查迭代器失效</span></span><br><span class="line">            <span class="keyword">if</span>(_pVec==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator inValid&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>&#123;<span class="keyword">return</span> *_ptr;&#125;</span><br><span class="line">        ~<span class="built_in">iterator</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;hh&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//  指向元素</span></span><br><span class="line">        T *_ptr;</span><br><span class="line">        <span class="comment">//  指明是哪个容器的迭代器 T和Alloc都是已知的（外层vector就确定了） 因为同一迭代器的比较才有效</span></span><br><span class="line">        vector&lt;T,Alloc&gt; *_pVec;     <span class="comment">//  迭代器是否有效标志</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  容器需要提供begin end方法  </span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span> , _first);&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span> , _last);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it,<span class="keyword">const</span> T &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr<span class="number">-1</span>,_last);    <span class="comment">//  [it._ptr , last]的迭代器 如果存在，都要失效</span></span><br><span class="line">        T *p = _last;   <span class="comment">//  p是指针 不是迭代器</span></span><br><span class="line">        <span class="keyword">while</span>(p &gt; it._ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p,*(p<span class="number">-1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p<span class="number">-1</span>);</span><br><span class="line">            --p;</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p,val);    <span class="comment">//  插入</span></span><br><span class="line">        ++_last;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  1.置迭代器为无效 + 2.移动元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator iter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">verify</span>(iter._ptr<span class="number">-1</span>,_last);  <span class="comment">//  1.</span></span><br><span class="line">        T *p = iter._ptr;           <span class="comment">//  2.</span></span><br><span class="line">        <span class="keyword">while</span>(p &lt; _last<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p,*(p+<span class="number">1</span>));</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>,iter._ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T * _first; <span class="comment">//  指向数组起始位置</span></span><br><span class="line">    T * _last;  <span class="comment">//  指向数组中有效元素的后继位置</span></span><br><span class="line">    T * _end;   <span class="comment">//  指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 空间配置器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  为应对迭代器失效 增加代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  用一个链表来维护每个迭代器之间的顺序（可以当成是一个用来维护（装载）迭代器的容器</span></span><br><span class="line">    <span class="comment">//  迭代器节点 _cur指向迭代器 _next指向下一个iterator_base节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator *c= <span class="literal">nullptr</span>,Iterator_Base *ne = <span class="literal">nullptr</span>)</span><br><span class="line">            :_cur(c),_next(ne)&#123;&#125;</span><br><span class="line">        iterator *_cur;</span><br><span class="line">        Iterator_Base *_next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Iterator_Base _head;    <span class="comment">//  一个容器只有一个迭代器头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  检查</span></span><br><span class="line">    <span class="comment">//  将(first,last]之间的元素，如果存在对应的迭代器，那么都要置为失效。并将维护他们的节点从链表中移除。</span></span><br><span class="line">    <span class="comment">//  遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* first , T* last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator_Base *pre = &amp;<span class="keyword">this</span>-&gt;_head;   <span class="comment">//  头节点</span></span><br><span class="line">        Iterator_Base *it = <span class="keyword">this</span>-&gt;_head._next;   <span class="comment">//  第一个有效节点</span></span><br><span class="line">        <span class="keyword">while</span>(it!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;   <span class="comment">//  it 节点 _cur 迭代器 _ptr 指向的元素</span></span><br><span class="line">            <span class="keyword">if</span>(it-&gt;_cur-&gt;_ptr &gt; first &amp;&amp; it-&gt;_cur-&gt;_ptr &lt;= last)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  标记迭代器失效 ：iterator持有的_pVec = nullptr</span></span><br><span class="line">                it-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                pre-&gt;_next = it-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> it;          <span class="comment">//  delete掉用于维护迭代器的节点</span></span><br><span class="line">                it = pre-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = it;</span><br><span class="line">                it = it-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  容器的二倍扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _end - _first;</span><br><span class="line">        <span class="keyword">int</span> len = _last - _first;</span><br><span class="line"><span class="comment">//        T *p_tmp = new T[sz*2];</span></span><br><span class="line">        <span class="comment">//  开辟内存 构造对象</span></span><br><span class="line">        T *p_tmp = _allocator.<span class="built_in">allocate</span>(sz*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            p_tmp[i] = _first[i];</span></span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p_tmp+i,_first[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  析构对象 释放内存</span></span><br><span class="line">        <span class="keyword">for</span>(T *p = _first;p!=_last;++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        delete [] _first;   //  释放原先内存 析构所有对象</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = p_tmp;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + <span class="number">2</span>*sz;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i) vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">20</span>);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator iter1 = vec.<span class="built_in">end</span>();    <span class="comment">//  end() 产生迭代器 迭代器加入链表</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator iter2 = vec.<span class="built_in">end</span>();</span><br><span class="line">    cout&lt;&lt; (iter1!=iter2) &lt;&lt;endl;</span><br><span class="line"><span class="comment">//  每次调用end() 都会新产生一个迭代器（虽然他们要指向的位置是一致的，但是还是会产生） 也就是说 迭代器链表中会有很多指向位置相同的迭代器节点(*_cur)</span></span><br><span class="line"><span class="comment">//    for(vector&lt;int&gt;::iterator iter = vec.begin();iter!=vec.end();++iter)</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        ++i;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;&quot;-----------------------------&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*it % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 迭代器失效的问题，第一次调用erase以后，迭代器it就失效了</span></span><br><span class="line">            it = vec.<span class="built_in">erase</span>(it); <span class="comment">// insert(it, val)   erase(it)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: vec) &#123;</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line">v.<span class="built_in">insert</span>(it,*it<span class="number">-1</span>);     <span class="comment">// insert:当前位置增加新元素，原元素依次向后移动</span></span><br><span class="line">++it;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2022/04/02/c++_%E6%A8%A1%E6%9D%BF/2022-04-03-23-37-04.png"></li>
<li>vector类里内置一个iterator类 和 一个链表节点类<ul>
<li>iterator用于提供遍历vector功能</li>
<li>链表用于维持iterator的失效和有效</li>
</ul>
</li>
<li>当begin end insert erase时才会生成迭代器对象</li>
<li>不是有一个元素就有一个迭代器对象，而是需要单独要求有iterator对象，才会生成相应iterator对象。<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4></li>
</ul>
<p><img src="/2022/04/02/c++_%E6%A8%A1%E6%9D%BF/2022-04-03-23-27-50.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">老师晚上好呀。我想问个问题。这个是您在讲迭代器失效问题时实现的vector中的迭代器。我有个地方不能理解：在Iterator_Base中需要用到iterator对象的地址，可是这个iterator对象是个在函数里的临时量啊。比如当begin（）函数结束后，这个iterator对象不是会被析构吗。。。@施磊老师 </span><br><span class="line">@明天就大三    你分析挺全面得，但是你没看到begin函数得返回类型是一个值吗？   它不是返回应用或者指针，所以它肯定会在调用方函数栈上生成一个对象，把需要return得东西存起来</span><br><span class="line">@明天就大三</span><br><span class="line">当然，你再C++高级课程里面应该也看了给大家讲得对象优化和右值引用就知道，</span><br><span class="line">如果你这样用：</span><br><span class="line">iterator it = vec.begin()   此时，编译器就优化了，return后面那个临时对象就不产生，直接构造it就完了</span><br><span class="line"></span><br><span class="line">如果你这样用：（我觉得这下面说的不对 会影响生命周期）不过没关系，压根没有赋值函数</span><br><span class="line">iterator it;</span><br><span class="line">it = begin();   此时，return后面那个就直接在调用方得栈帧上构造一个临时对象，临时对象给it赋值，完了临时对象析构。return后面那个临时对象不会产生，被C++编译器优化掉了，所以不用担心它得生命周期问题</span><br></pre></td></tr></table></figure>



<h2 id="emplace-back实现"><a href="#emplace-back实现" class="headerlink" title="emplace_back实现"></a><strong>emplace_back</strong>实现</h2><ul>
<li>将原本用来构造临时量的参数传入emplace_back，然后直接在vector容器的内存上调用构造函数；而非在外面构造完临时对象再传入容器，再通过construct在vector上调用拷贝构造。</li>
<li>节省了一个临时对象的构造和析构。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;Test&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    v.<span class="built_in">push_back</span>(t);</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;======================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">Test</span>(<span class="number">5</span>));   <span class="comment">//  临时对象Test(int) -&gt; 右值拷贝构造Test(Test&amp;&amp;) -&gt; 临时对象析构~Test()</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="built_in">Test</span>(<span class="number">5</span>));    <span class="comment">//  临时对象Test(int) -&gt; 右值拷贝构造Test(Test&amp;&amp;) -&gt; 临时对象析构~Test()</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;======================&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//    v.push_back(10,20);   error</span></span><br><span class="line"><span class="comment">//  原地构造 无需临时对象</span></span><br><span class="line"><span class="comment">//  emplace 原地构造：将原本用来构造临时量的对象传入vector容器，在vector容器内存上利用这些参数构造对象；而在外面非构造完临时对象再传入容器，再在容器上调用拷贝构造。节省了一个对象的构造和析构</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">5</span>);      <span class="comment">//  直接在vector管理的内存上构造 Test(int) 无需临时对象。省去了构造和析构</span></span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="number">10</span>,<span class="number">5</span>);   <span class="comment">//  直接在vector管理的内存上构造 Test(int int) 无需临时对象。省去了构造和析构</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;======================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;)</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp;)</span><br><span class="line">======================</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(Test&amp;&amp;)</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(Test&amp;&amp;)</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">======================</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>)</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)</span><br><span class="line">======================</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by dell on 2022-04-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> x) &#123;cout&lt;&lt;<span class="string">&quot;Test(int)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;cout&lt;&lt;<span class="string">&quot;Test(int,int)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; )&#123;cout&lt;&lt;<span class="string">&quot;Test(const Test&amp;)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test &amp;&amp;)&#123;cout&lt;&lt;<span class="string">&quot;Test(Test&amp;&amp;)&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;cout&lt;&lt;<span class="string">&quot;~Test()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 容器的空间配置器 allocator</span></span><br><span class="line"><span class="comment"> * 内存的开辟释放,对象的构造析构,都是通过空间配置器完成.而不是直接通过new delete</span></span><br><span class="line"><span class="comment"> * template&lt;class _Ty</span></span><br><span class="line"><span class="comment"> *      class _Alloc = allocator&lt;_Ty&gt;&gt;</span></span><br><span class="line"><span class="comment"> *      class vector</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义容器的空间配置器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> size)</span>   <span class="comment">//  负责内存开辟</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span>  <span class="comment">//  负责内存释放</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> (T*)p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ty&gt;    <span class="comment">//  不定个数参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T *p,Ty&amp;&amp;... val)</span>    <span class="comment">//  引用折叠</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> (p) <span class="built_in">T</span>(std::forward&lt;Ty&gt;(val)...);    <span class="comment">//  ...不定参数+完美转发 传入相应构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    template&lt;typename Ty&gt;</span></span><br><span class="line"><span class="comment">    void construct(T* p, Ty&amp;&amp; val)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        new (p) T(std::forward&lt;Ty&gt;(val));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void construct(T* p, const T&amp; val)   //  负责对象构造(在已有的内存上)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        new (p) T(val);     //  定位new  在p指向的内存上构造(拷贝构造)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void construct(T* p, T&amp;&amp; rval)   //  参数val匹配右值</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        //  在p处定位new 调用T的拷贝构造函数。</span></span><br><span class="line"><span class="comment">        //  rval这个右值引用变量本身为左值；但是他所引用的那个变量val是个右值。因此我们要通过mover(val)来实现类型的转换</span></span><br><span class="line"><span class="comment">        //  move实现的是语法层面的转换，告诉编译器rval是个右值，让他匹配右值拷贝构造函数。并没有对rval本身内存做出什么更改的事情</span></span><br><span class="line"><span class="comment">        // 只是改变了语法层面的类型，为了让编译器识别出他（所引用的）是个右值</span></span><br><span class="line"><span class="comment">        //  因为val为右值，因此调用拷贝构造函数时，匹配的就是T(&amp;&amp;)</span></span><br><span class="line"><span class="comment">        new (p) T(std::move(rval));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* p)</span>      <span class="comment">//  负责对象析构</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p-&gt;~<span class="built_in">T</span>();            <span class="comment">//  ~T()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  容器底层内存开辟,内存释放,对象构造,对象析构,都通过allocator空间配置器来实现</span></span><br><span class="line"><span class="comment">//  类型Alloc 的类型默认是 空间配置器Allocator&lt;T&gt;  模板名称 + 类型参数 = 类名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Alloc = Allocator&lt;T&gt;&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:                        <span class="comment">// 默认形参     构造函数:Allocator&lt;T&gt;()</span></span><br><span class="line">    vector&lt;T, Alloc&gt;(<span class="keyword">int</span> sz = <span class="number">10</span>, <span class="keyword">const</span> Alloc&amp; alloc = Allocator&lt;T&gt;())</span><br><span class="line">            :_allocator(alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  需要把内存开辟和对象构造分开处理    不然在创建vector的时候，不但开辟内存，还构造了所有元素.正常逻辑应当是我们加入元素.</span></span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">//  开辟内存</span></span><br><span class="line">        _last = _first;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">vector</span>() &#123;</span><br><span class="line">        <span class="comment">//        delete [] _first;</span></span><br><span class="line">        <span class="comment">//  析构有效对象</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);  <span class="comment">//  析构p对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  ,并释放所有空间</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line">        _first = _last = _end = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>(<span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; rhs)  <span class="comment">//  拷贝构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;     <span class="comment">//  容器大小</span></span><br><span class="line"><span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;   <span class="comment">//  有效元素长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first[i], rhs.first[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;T, Alloc&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; rhs)  <span class="comment">//  拷贝赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)      <span class="comment">//  与拷贝构造区别：避免自赋值</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//        delete [] _first;   //   析构所有对象 销毁原内存</span></span><br><span class="line">        <span class="comment">//  析构有效对象 释放所有内存</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sz = rhs._end - rhs._first;</span><br><span class="line">        <span class="comment">//        _first = new T[sz];</span></span><br><span class="line">        _first = _allocator.<span class="built_in">allocate</span>(sz);   <span class="comment">// 分配内存</span></span><br><span class="line">        <span class="keyword">int</span> len = rhs._last - rhs._first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(_first + i, rhs._first[i]);  <span class="comment">//  构造有效对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + sz;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  emplace_back实现 引用折叠 + forward万能转发 + 不定模板参数</span></span><br><span class="line">    <span class="comment">//  emplace实现原地构造，避免临时量的产生：其实就是把原本要构造临时量对象的参数直接传进来，直接在vector容器的内存上定位new，</span></span><br><span class="line">    <span class="comment">//  即调用相应构造函数，而不是先构造临时量对象、传入临时量对象，再在vector容器的内存上调用拷贝构造。从而避免一个临时对象的拷贝和析构</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ty&gt;    <span class="comment">//  不定模板参数 ...代表有很多模板参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Ty&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_allocator.<span class="built_in">construct</span>(_last++,std::forward&lt;Ty&gt;(args)...);  <span class="comment">//  ...代表不定个数的参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  采用引用折叠 + forward完美转发</span></span><br><span class="line">    <span class="comment">//  引用折叠：推导出val到底是右值引用还是左值引用。使得函数可以同时接收左值引用和右值引用。</span></span><br><span class="line">    <span class="comment">//  forward：传参时保留val他（所引用的）到底是一个左值还是右值的信息，即保留引用的类型。</span></span><br><span class="line">    <span class="comment">//  避免左值引用和右值引用变量本身都是左值而失去左右值信息，那样传参就只能传给左值。</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Ty&amp;&amp; val)</span>        <span class="comment">//  CMyString&amp;&amp; + &amp;&amp; -》 CMyString&amp;&amp; ; CMyString&amp; + &amp;&amp; -&gt; CMyString&amp;</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">full</span>())</span><br><span class="line">            <span class="built_in">expand</span>();</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(_last++, std::forward&lt;Ty&gt;(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  push_back需要写两个 但是核心只有参数列表不同，右值还需要通过move来表示。不同也只是为了向下调用时调用到与左/友值匹配的函数。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void push_back(const T&amp; val)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (full())</span></span><br><span class="line"><span class="comment">            expand();</span></span><br><span class="line"><span class="comment">        //        *_last++ = val;     //  元素的operator=</span></span><br><span class="line"><span class="comment">        _allocator.construct(_last++, val);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //  push_back(&amp;&amp;) -&gt; construct(&amp;&amp;) -&gt; new T(&amp;&amp;)（也就是调用 类型的右值拷贝构造，如CMyString(&amp;&amp;))</span></span><br><span class="line"><span class="comment">    //  传入的实参为右值时（如CMyString(&quot;aa&quot;);会匹配到这里)</span></span><br><span class="line"><span class="comment">    //  push_back了之后，容器里装的对象就和push_back左值一样。后续对于容器的操作也一样.</span></span><br><span class="line"><span class="comment">    void push_back(T&amp;&amp; val)     //  push_back右值</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (full())</span></span><br><span class="line"><span class="comment">            expand();</span></span><br><span class="line"><span class="comment">        //  因为右值变量本身是左值，因此要move一下，让编译器识别他是右值。</span></span><br><span class="line"><span class="comment">        _allocator.construct(_last++, std::move(val));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//  需要析构对象，并且要把析构对象和释放内存的操作分离开</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">verify</span>(_last - <span class="number">1</span>, _last);  <span class="comment">//  检查删除元素后，有哪些迭代器失效    _last-1：最后一个元素。有对应迭代器 _last：后继位置，有对应迭代器</span></span><br><span class="line"><span class="comment">//        --_last;        //  只移动指针,并没有析构元素,也没有释放元素管理的内存。</span></span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(--_last);    <span class="comment">//  不仅移动指针 还需要析构元素s</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;vector is empty&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> *(_last - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _first == _last; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _last == _end; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _last - _first; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;OutOfRange&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;OutOfRange&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> _first[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  实现迭代器</span></span><br><span class="line">    <span class="comment">//  迭代器一般实现成容器的嵌套类型</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span>  //  迭代器就是包装了遍历方法(++)的一个指针</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">vector</span>&lt;</span>T, Alloc&gt;;</span><br><span class="line">        <span class="comment">//  产生迭代器对象 自动将自己加入迭代器链表</span></span><br><span class="line">        <span class="built_in">iterator</span>(vector&lt;T, Alloc&gt;* pvec, T* p = <span class="literal">nullptr</span>)</span><br><span class="line">                :_pVec(pvec), _ptr(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  cout &lt;&lt; cnt++ &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//  链表头插法                       节点内容    节点指向</span></span><br><span class="line">            Iterator_Base* ib = <span class="keyword">new</span> <span class="built_in">Iterator_Base</span>(<span class="keyword">this</span>, _pVec-&gt;_head._next);</span><br><span class="line">            _pVec-&gt;_head._next = ib;        <span class="comment">//  指针ib是局部变量，会被销毁无所谓。因为ib指向的内存是new出来的啊哈哈哈。不会被销毁的。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; iter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  _pVec == nullptr 代表迭代器失效</span></span><br><span class="line">            <span class="comment">//  首先判断是否是同一容器的迭代器（比较迭代器指向容器的地址是否相同）</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span> || _pVec != iter._pVec)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator incompatable!&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> _ptr != iter._ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>++()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  _pVec == nullptr 迭代器失效</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator inValid&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            _ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  检查迭代器失效</span></span><br><span class="line">            <span class="keyword">if</span> (_pVec == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="string">&quot;iterator inValid&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">        ~<span class="built_in">iterator</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;hh&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//  指向元素</span></span><br><span class="line">        T* _ptr;</span><br><span class="line">        <span class="comment">//  指明是哪个容器的迭代器 T和Alloc都是已知的（外层vector就确定了） 因为同一迭代器的比较才有效</span></span><br><span class="line">        vector&lt;T, Alloc&gt;* _pVec;     <span class="comment">//  迭代器是否有效标志</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  容器需要提供begin end方法</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _first); &#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, _last); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">verify</span>(it._ptr - <span class="number">1</span>, _last);    <span class="comment">//  [it._ptr , last]的迭代器 如果存在，都要失效</span></span><br><span class="line">        T* p = _last;   <span class="comment">//  p是指针 不是迭代器</span></span><br><span class="line">        <span class="keyword">while</span> (p &gt; it._ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p - <span class="number">1</span>));</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p - <span class="number">1</span>);</span><br><span class="line">            --p;</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">construct</span>(p, val);    <span class="comment">//  插入</span></span><br><span class="line">        ++_last;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  1.置迭代器为无效 + 2.移动元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">erase</span><span class="params">(iterator iter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">verify</span>(iter._ptr - <span class="number">1</span>, _last);  <span class="comment">//  1.</span></span><br><span class="line">        T* p = iter._ptr;           <span class="comment">//  2.</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; _last - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p, *(p + <span class="number">1</span>));</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        _last--;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="keyword">this</span>, iter._ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _first; <span class="comment">//  指向数组起始位置</span></span><br><span class="line">    T* _last;  <span class="comment">//  指向数组中有效元素的后继位置</span></span><br><span class="line">    T* _end;   <span class="comment">//  指向数组空间的后继位置</span></span><br><span class="line">    Alloc _allocator;   <span class="comment">// 空间配置器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  为应对迭代器失效 增加代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  用一个链表来维护每个迭代器之间的顺序（可以当成是一个用来维护（装载）迭代器的容器</span></span><br><span class="line">    <span class="comment">//  迭代器节点 _cur指向迭代器 _next指向下一个iterator_base节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Iterator_Base</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">Iterator_Base</span>(iterator* c = <span class="literal">nullptr</span>, Iterator_Base* ne = <span class="literal">nullptr</span>)</span><br><span class="line">                :_cur(c), _next(ne) &#123;&#125;</span><br><span class="line">        iterator* _cur;</span><br><span class="line">        Iterator_Base* _next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Iterator_Base _head;    <span class="comment">//  一个容器只有一个迭代器头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  检查</span></span><br><span class="line">    <span class="comment">//  将(first,last]之间的元素，如果存在对应的迭代器，那么都要置为失效。并将维护他们的节点从链表中移除。</span></span><br><span class="line">    <span class="comment">//  遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verify</span><span class="params">(T* first, T* last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator_Base* pre = &amp;<span class="keyword">this</span>-&gt;_head;   <span class="comment">//  头节点</span></span><br><span class="line">        Iterator_Base* it = <span class="keyword">this</span>-&gt;_head._next;   <span class="comment">//  第一个有效节点</span></span><br><span class="line">        <span class="keyword">while</span> (it != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;   <span class="comment">//  it 节点 _cur 迭代器 _ptr 指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (it-&gt;_cur-&gt;_ptr &gt; first &amp;&amp; it-&gt;_cur-&gt;_ptr &lt;= last)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  标记迭代器失效 ：iterator持有的_pVec = nullptr</span></span><br><span class="line">                it-&gt;_cur-&gt;_pVec = <span class="literal">nullptr</span>;</span><br><span class="line">                pre-&gt;_next = it-&gt;_next;</span><br><span class="line">                <span class="keyword">delete</span> it;          <span class="comment">//  delete掉用于维护迭代器的节点</span></span><br><span class="line">                it = pre-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = it;</span><br><span class="line">                it = it-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  容器的二倍扩容操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = _end - _first;</span><br><span class="line">        <span class="keyword">int</span> len = _last - _first;</span><br><span class="line">        <span class="comment">//        T *p_tmp = new T[sz*2];</span></span><br><span class="line">        <span class="comment">//  开辟内存 构造对象</span></span><br><span class="line">        T* p_tmp = _allocator.<span class="built_in">allocate</span>(sz * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//            p_tmp[i] = _first[i];</span></span><br><span class="line">            _allocator.<span class="built_in">construct</span>(p_tmp + i, _first[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  析构对象 释放内存</span></span><br><span class="line">        <span class="keyword">for</span> (T* p = _first; p != _last; ++p)</span><br><span class="line">        &#123;</span><br><span class="line">            _allocator.<span class="built_in">destroy</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        delete [] _first;   //  释放原先内存 析构所有对象</span></span><br><span class="line">        _allocator.<span class="built_in">deallocate</span>(_first);</span><br><span class="line"></span><br><span class="line">        _first = p_tmp;</span><br><span class="line">        _last = _first + len;</span><br><span class="line">        _end = _first + <span class="number">2</span> * sz;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="关于容器里放指针"><a href="#关于容器里放指针" class="headerlink" title="关于容器里放指针"></a>关于容器里放指针</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ul>
<li>delete指针会发生什么。<ul>
<li>调用指针指向的对象的析构函数</li>
<li>释放指针指向的内存</li>
<li>并没有释放指针本身所占空间。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Complex *pc = new Complex();</span></span><br><span class="line"><span class="keyword">delete</span> pc;</span><br><span class="line">-&gt;</span><br><span class="line">Complex::~<span class="built_in">Complex</span>(pc);  调用指针指向的对象的析构函数</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;    释放指针指向的内存</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>指针（内置类型）的析构函数是什么？<ul>
<li>为空。</li>
</ul>
</li>
</ul>
<h3 id="析构函数补充（内置类型何时释放）"><a href="#析构函数补充（内置类型何时释放）" class="headerlink" title="析构函数补充（内置类型何时释放）"></a>析构函数补充（内置类型何时释放）</h3><ul>
<li>在一个构造函数中，成员的初始化是在函数体执行<strong>之前</strong>完成的。且按照他们在类中<strong>出现的顺序</strong>（定义的顺序）进行初始化（构造函数初始化值列表的前后位置官位不会影响实际的初始化顺序）。</li>
<li>在一个构造函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序销毁。</li>
<li>在一个析构函数中，不存在类似构造函数钟初始化列表的东西来控制成员如何销毁。析构部分是<strong>隐式</strong>的。<strong>成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数</strong>。<strong>内置类型没有析构函数，因此销毁内置类型成员什么也不需要</strong>。</li>
<li>因此，当一个A类中，有B类对象b，那么在<code>~A()</code>中，不需要去调用<code>b.~B()</code>，因此A类中的成员销毁是隐式的，完全依赖于成员本身的类型。b的销毁会在A的析构函数执行结束之后，隐式进行，也即自动调用b的析构函数，并释放内存（这步大概吧）。同理A类中的其他成员如int a，则调用a的析构函数（空），然后释放内存。</li>
<li>因此，如果一个A类中，存在 <code>int * p = new B()</code>，如果我们不再析构函数中，进行<code>delete p</code>，指望着隐式销毁p所指向的B的话，是不会成功的。析构函数结束后，会自动调用 指针p的析构函数（为空），然后释放指针p的内存。这样，p所指向的内存就泄露了。因此，必须函数体内<code>delete p</code>。 </li>
</ul>
<h3 id="vector里面放指针"><a href="#vector里面放指针" class="headerlink" title="vector里面放指针"></a>vector里面放指针</h3><ul>
<li>vector的析构函数不会delete容器内的元素，只会调用容器内元素本身的析构函数，具体可以看上面的vector代码。也就是说，不会delete存在容器里的指针，即，需要用户手动控制释放这些指针指向的内存。<ul>
<li>vector的析构函数里只会调用存储元素的析构函数。而指针本身的析构函数是空。不会调用指针指向对象的析构函数。</li>
</ul>
</li>
<li>所以如果要在容器内存指针，<ul>
<li>要么存智能指针，如shared_ptr。</li>
<li>要么自己手动在vector生命周期将结束时，delete这些指针。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    cout&lt;&lt;<span class="string">&quot;======================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Test</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;====================&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;shared_ptr&lt;Test&gt;&gt; v;</span><br><span class="line">        v.<span class="built_in">push_back</span>(shared_ptr&lt;Test&gt;(<span class="keyword">new</span> <span class="built_in">Test</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">======================</span><br><span class="line">Test</span><br><span class="line">Test</span><br><span class="line">====================</span><br><span class="line">Test</span><br><span class="line">~Test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP_3_程序的机器级表示</title>
    <url>/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>architecture（计算机的体系结构，架构）<ul>
<li>also ISA：instruction set architecture 指令集架构</li>
<li>当我们谈论指令和指令集，这是编译器的目标，为你提供一系列指令，告诉机器确切第做了什么</li>
<li>事实证明，关于指令如何实现，硬件的实现者已经想好了。有的速度快，需要很多硬件；有的速度慢，但需要很少的硬件。</li>
<li>所以，人们创建了instruction set architecture 指令集架构这一抽象概念<ul>
<li>编译器的目标是他</li>
<li>如何最好的实现他是硬件研究者需要负责的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>text c program —Complier—-&gt; text 汇编asm program —–Assembler—–&gt; binary 文本表示的指令转化成了实际的字节object program ——linker—–&gt; binary executable program</p>
<h2 id="x86常识"><a href="#x86常识" class="headerlink" title="x86常识"></a>x86常识</h2><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><ul>
<li><p>汇编中</p>
<ul>
<li>%开头 代表寄存器的实际名称</li>
<li>句点.开头，表示他们事实上不是指令而是一些别的东西</li>
<li>他们与一些被需要的东西有关， <ul>
<li>一些信息提供给调试器，使它能够定位程序的各个部分</li>
<li>一些信息提供给链接器，告诉他这是一个全局定义的函数</li>
<li>还有很多其他信息，在一开始的时候不需要考虑他们太多，因此先删掉 </li>
</ul>
</li>
</ul>
</li>
<li><p>gcc -Og -S sum.c</p>
<ul>
<li>O : Optimize 优化</li>
<li>S : stop 只做第一阶段的事情</li>
</ul>
</li>
<li><p>objdump 会输出代码反汇编的结果。</p>
<ul>
<li>objdump -d</li>
<li>反汇编程序无法访问源代码，甚至无法访问汇编代码，他只是通过实际代码文件中的字节辨别出来的。</li>
</ul>
</li>
<li><p>gdb</p>
<ul>
<li>disassemble 函数名：查看函数二进制代码</li>
</ul>
</li>
</ul>
<h3 id="寄存器-Register"><a href="#寄存器-Register" class="headerlink" title="寄存器(Register)"></a>寄存器(Register)</h3><ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-05-26-12-11-00.png"></li>
<li>%rsp比较特殊，我们不能随意改变，因为这里面存的是栈指针，指向当前栈顶（stack top）</li>
<li>左边一列是原先就有的，右边一列是新增的</li>
<li>%rax和%eax的关系<ul>
<li>%rax是64位寄存器</li>
<li>%eax是32位寄存器</li>
<li>操作%eax就是操作%rax的低32位</li>
</ul>
</li>
<li>另一特殊寄存器%rip：instruction pointer。包含当前执行指令的地址。不是我们可以正常访问的寄存器（但也有一些技巧可以获得），它只是告诉我们程序执行到了哪里。<h3 id="操作数-Operand"><a href="#操作数-Operand" class="headerlink" title="操作数(Operand)"></a>操作数(Operand)</h3></li>
<li>立即数（immediate）<ul>
<li>Example：$0400,$-533</li>
<li>Like C constant ,but prefixed with $</li>
<li>encoded with 1,2 or 4 bytes</li>
</ul>
</li>
<li>寄存器（register）：上图十六个整形寄存器之一<ul>
<li>example：%rax，%r13</li>
<li>but % rsp reserved for special use</li>
<li>Others have special uses for particular instructions</li>
</ul>
</li>
<li>内存（memory）:8 consecutive bytes of memory at address given by register<ul>
<li>example：(%rax)</li>
<li>various other “address mode”</li>
</ul>
</li>
</ul>
<h3 id="经典指令"><a href="#经典指令" class="headerlink" title="经典指令"></a>经典指令</h3><ul>
<li><p>mov指令</p>
<ul>
<li>mov的src和dst顺序<ul>
<li><a href="https://stackoverflow.com/questions/2397528/">https://stackoverflow.com/questions/2397528/</a></li>
<li>mov dest, src称为 Intel syntax 。 (例如mov eax, 123)</li>
<li>mov src, dest称为 AT&amp;T syntax 。 (例如mov $123, %eax)</li>
<li>包括GNU汇编器在内的UNIX汇编器使用AT＆T语法，所有其他x86汇编器都使用Intel语法</li>
</ul>
</li>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-05-24-19-50-55.png"></li>
</ul>
</li>
<li><p>机器不允许直接将数据从一个内存位置复制到另一个内存位置。需要使用两个指令。</p>
<ul>
<li>先将内存的值移到寄存器中</li>
<li>再将寄存器中的值移到内存中</li>
</ul>
</li>
<li><p>understanding swap</p>
<ul>
<li><img src="/2022/05/24/csapp_3_%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/2022-05-30-09-07-35.png"></li>
</ul>
</li>
<li><p>小问题：movq、leaq、addq、subq…中的q是什么？quad word（Intel术语）：4字=8Bytes=64位</p>
</li>
<li><p>addq,subq,imulq,salq，sarq,shrq,xorq,andq,orq等，都是src在前，dest在后。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">addq src dst  dst = dst + src</span><br><span class="line">subq src dst  dst = dst - src</span><br><span class="line">imulq src dst dst = dst * src</span><br><span class="line">salq src dst  dst = dst &lt;&lt; src</span><br><span class="line">sarq src dst  dst = dst &gt;&gt; src  <span class="comment">// 算数右移</span></span><br><span class="line">shrq src dst  dst = dst &gt;&gt; src  <span class="comment">// 逻辑右移</span></span><br><span class="line">xorq src dst  dst = dst ^ src</span><br><span class="line">andq src dst  dst = dst &amp; src</span><br><span class="line">orq  src dst  dst = dst | src  </span><br></pre></td></tr></table></figure></li>
<li><p>内存地址编码方式</p>
<ul>
<li>Simple Memory addressing modes。<ul>
<li>normal：(R)  —- mem[reg[R]]<ul>
<li>寄存器R中存的就是内存地址</li>
<li>movq (%rcx),%rax ：%rax = *(%rcx)</li>
</ul>
</li>
<li>displacement：mem[reg[R]+D]<ul>
<li>R中存储内存基地址，向高偏移D个Bytes，得到目标地址</li>
<li>movq 8(%rbp),%rdx ：%rdx = *(%rbp+8)</li>
</ul>
</li>
</ul>
</li>
<li>Complete Memory Addressing Modes<ul>
<li>most genernal form ：D(R) —- mem[reg[Rb] + S*reg[Rb] + D]<ul>
<li> 数组引用常见形式</li>
<li>D：偏移量。1 / 2 / 4 Bytes</li>
<li>Rb：该寄存器存储目标内存基地址   </li>
<li>Ri：下标寄存器</li>
<li>Scale：比例。1 / 2 / 4 / 8 Bytes。数组元素的数据类型大小。</li>
</ul>
</li>
<li>special cases<ul>
<li>(Rb,Ri) —- mem[reg[Rb]+reg[Ri]]。mem[寄存器] 就是寄存器存储的地址对应的存储单元的存储的值</li>
<li>D(Rb,Ri) —- mem[reg[Rb]+Reg[Ri]+D]</li>
<li>(Rb,Ri,S) —- mem[reg[Rb]+S*reg[Ri]]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>lea指令：load effective address。将src表达的地址值赋值给Dst<ul>
<li>leaq Src Dst（AT&amp;T syntax）<ul>
<li>src is address mode expression</li>
<li>set dest to address denoted by expression</li>
</ul>
</li>
<li>作用：<ul>
<li>计算地址 p = &amp;x[i]</li>
<li>计算数值 x + k*y</li>
</ul>
</li>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func</span><span class="params">(<span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x*<span class="number">12</span>;    </span><br><span class="line">  <span class="comment">// convert to asm by complier</span></span><br><span class="line">  <span class="built_in">leaq</span> (%rdi,%rdi,<span class="number">2</span>),%rax  ：%rax = reg[%rdi]+reg[%rdi]*<span class="number">2</span> = <span class="number">3</span> * %rdi</span><br><span class="line">  salq $<span class="number">2</span> , %rax             ：%rax &lt;&lt; <span class="number">2</span> = %rax * <span class="number">4</span> = <span class="number">12</span> &amp; %rdi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">arith</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">long</span> t1 = x+y;    t1 ：</span><br><span class="line">  <span class="keyword">long</span> t2 = z+t1;   t2 ：</span><br><span class="line">  <span class="keyword">long</span> t3 = x+<span class="number">4</span>;    </span><br><span class="line">  <span class="keyword">long</span> t4 = y*<span class="number">48</span>;</span><br><span class="line">  <span class="keyword">long</span> t5 = t3+t4;</span><br><span class="line">  <span class="keyword">long</span> rval = t2*t5;</span><br><span class="line">  <span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arith：</span><br><span class="line">  <span class="built_in">leaq</span> (%rdi,%rsi),%rax     ---&gt; %rax = %rdi+%rsi   <span class="comment">//  t1</span></span><br><span class="line">  addq %rdx,%rax            ---&gt; %rax += %rdx       <span class="comment">//  t2</span></span><br><span class="line">  <span class="built_in">leaq</span> (%rsi,%rsi,<span class="number">2</span>),%rdx   ---&gt; %rdx = <span class="number">2</span>*rsi + %rsi = <span class="number">3</span>*%rsi   </span><br><span class="line">  salq $<span class="number">4</span> , %rdx            ---&gt; %rdx &lt;&lt;= <span class="number">4</span>         <span class="comment">//  t4</span></span><br><span class="line">  leaq <span class="number">4</span>(%rdi,%rdx),%rcx    ---&gt; %rcx = %rdx + %rdi + <span class="number">4</span> <span class="comment">//  t5   t3 = %rdi + 4</span></span><br><span class="line">  imulq %rdx,%rax           ---&gt; %rax = %rax * %rcx <span class="comment">// rval</span></span><br><span class="line">  ret       </span><br><span class="line"></span><br><span class="line">%rdi x</span><br><span class="line">%rsi y</span><br><span class="line">%rax t1 t2 val</span><br><span class="line">%rdx t4</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h1><h2 id="information-about-currently-executing-program"><a href="#information-about-currently-executing-program" class="headerlink" title="information about currently executing program"></a>information about currently executing program</h2><ul>
<li>temproary data（临时量）：<ul>
<li>%rax…</li>
</ul>
</li>
<li>location of runtime stack：<ul>
<li>%rsp(栈指针)：指向当前栈顶</li>
</ul>
</li>
<li>location of current code control point<ul>
<li>%rip（当前程序运行到哪里）：包含当前执行指令的地址。不是我们可以正常访问的寄存器，它只是告诉我们程序执行到了哪里。</li>
</ul>
</li>
<li>status of recent tests<ul>
<li>condition codes：CF，ZF，SF，OF</li>
<li><a href="https://blog.csdn.net/zenny_chen/article/details/121829354">https://blog.csdn.net/zenny_chen/article/details/121829354</a></li>
</ul>
</li>
</ul>
<h3 id="Condition-Codes"><a href="#Condition-Codes" class="headerlink" title="Condition Codes"></a>Condition Codes</h3><h4 id="Implicitly-Setting"><a href="#Implicitly-Setting" class="headerlink" title="Implicitly Setting"></a>Implicitly Setting</h4><ul>
<li>Single bit register<ul>
<li>CF：Carry Flag（for unisgned）（carry：进位）</li>
<li>ZF：Zero Flag</li>
<li>SF：Sign Flag（for signed）</li>
<li>OF：Overflow Flag（for signed）</li>
</ul>
</li>
<li>他们在算数过程中是如何被设置的？如 addq Src,Dest &lt;-&gt; t=a+b。他们的设置可以被认为是算数运算的副作用。<ul>
<li>CF：unsigned 溢出(au bu 并且 t溢出)</li>
<li>ZF：t=0</li>
<li>SF：t&lt;0（signed）</li>
<li>OF：signed（补码）溢出：<code>a&gt;0&amp;&amp;b&gt;0&amp;&amp;t&lt;0 || a&lt;0&amp;&amp;b&lt;0&amp;&amp;t&gt;0</code></li>
</ul>
</li>
<li>lea指令不会设置这些标志位</li>
</ul>
<h4 id="Explicitly-Setting-Compare"><a href="#Explicitly-Setting-Compare" class="headerlink" title="Explicitly Setting: Compare"></a>Explicitly Setting: Compare</h4>]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>CSAPP</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>git常识</title>
    <url>/2022/05/01/git%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<p>git常识</p>
<span id="more"></span>


<ul>
<li>分布式git 集中式SVN<ul>
<li>集中式SVN：版本控制只发生在远程仓库上。本地没有。所以要如果没有连接远程仓库，就不能获取之前版本的代码。也就是必须在一个局域网里开发。</li>
<li>git：版本控制在本地仓库和远程仓库均有。断网也能获取之前版本的代码。</li>
<li>github：远程代码版本托管系统<blockquote>
<p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-01-22-09-33.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="仓库拉取"><a href="#仓库拉取" class="headerlink" title="仓库拉取"></a>仓库拉取</h2><ul>
<li>git clone ssh远程仓库地址：<ul>
<li>拉取仓库代码到本地，在本地生成一个仓库</li>
<li>本地自动创建两个东西<ul>
<li>远程仓库的名称 origin</li>
<li>本地仓库默认生成主干分支 <code>main</code> 。与远程仓库的对应关系生成好了就<code>main -&gt; origin/main</code></li>
</ul>
</li>
</ul>
</li>
<li>工作区、暂存区、本地仓库代码分支、远程仓库代码分支<blockquote>
<p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-02-09-53-43.png"></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>git clone命令的作用是，可以把指定的远程仓库代码拉取到本地<br>git add 把git工作区的代码改动添加到暂存区<br>git commit -m “xxx” 把暂存区的代码提交到本地分支<br>写代码是在工作区，add是把代码从工作区交到暂存区<br>git push (origin main) 把本地分支的代码推送（提交）到远程分支上去<br>git pull 把远程代码拉取到本地<br>git status 查看当前操作的状态信息<br>git log 查看代码修改日志。（看谁改过代码）<br>工作区：当前存放项目代码的目录<br>暂存区：git add把工作区修改的内容添加到暂存区当中<br>本地仓库：git commit把本地暂存区的修改提交到本地代码仓库分支中（不同分支代表不同的代<br>码版本）<br>远程仓库：通过git push把本地仓库的某一个分支上的代码推送到远程仓库的某个分支上<br>HEAD指针：本地仓库每一个分支上的代码修改都会生成一个commit id信息，HEAD指针指向最<br>近一次的commit提交，通过这个commit id可以进行版本回退。HEAD指向最新的修改<br>git reflog：查看进行过的commit、reset操作<br>git diff HEAD –main.cpp 查看工作区main.cpp和本地仓库的main.cpp有什么区别</p>
</blockquote>
<blockquote>
<p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-02-10-44-21.png"></p>
</blockquote>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-02-11-30-41.png"></p>
<ul>
<li>各种回退<ul>
<li>工作区回退<ul>
<li><code>git checkout --filename</code></li>
<li>用本地仓库分支代码将工作区代码覆盖掉</li>
</ul>
</li>
<li>暂存区回退 <ul>
<li><code>git reset HEAD filename</code></li>
<li>取消对暂存区的修改</li>
</ul>
</li>
<li>本地仓库版本回退<ul>
<li><code>git reset --hard commitid</code></li>
<li>本地仓库回退到commitid版本</li>
</ul>
</li>
<li>远程仓库版本回退<ul>
<li>先本地回退，再<code>git push -f</code>。</li>
<li>回退到没发生错误的版本，强制提交。（如果别人还没提交代码的话）</li>
<li>本地的commit落后于远程的commit时，不能提交到远程仓库。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dell@DESKTOP-TVUERHD MINGW64 /e/Git/HelloWorld/HelloWorld (main)</span><br><span class="line">$ git push</span><br><span class="line">To github.com:Cstardust/HelloWorld.git</span><br><span class="line"> ! [rejected]        main -&gt; main (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;github.com:Cstardust/HelloWorld.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure></li>
<li>如果自己提交错误代码，那么回退本地仓库，再用本地仓库覆盖远程仓库。前提：两次提交之间没有其他人commit。<ul>
<li>当确定自己提交错误之后没有别人提交，那么可以<code>git push -f</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>git checkout –  在git add之前，把工作区的代码用版本库中的代码覆盖掉，注意命令中的–不能<br>去掉，否则成切换分支的命令了<br>git reset HEAD 把git add之后，暂存区的内容全部撤销<br>git reset –hard  commitid 把提交到本地仓库中的代码改动进行回退<br>git reflog 查看HEAD指针的改动日志<br>git push -f 强制推送本地仓库代码到远程仓库<br>git diff HEAD –  查看工作区file文件和仓库中该文件最新版本的代码有什么区别</p>
</blockquote>
<ul>
<li>常识：指令信息含义<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dell@DESKTOP-TVUERHD MINGW64 /e/Git/HelloWorld/HelloWorld (main)</span><br><span class="line">$ git reflog</span><br><span class="line"><span class="comment">#  HEAD指针指向的版本是 当前的本地main分支 远程的main分支 远程的head指针也指向相同版本 </span></span><br><span class="line">717c054 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;0&#125;: reset: moving to 717c</span><br><span class="line">cb65a86 HEAD@&#123;1&#125;: reset: moving to cb65</span><br><span class="line">717c054 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;2&#125;: commit: windows一个错误的commit</span><br><span class="line">cb65a86 HEAD@&#123;3&#125;: reset: moving to HEAD</span><br><span class="line">cb65a86 HEAD@&#123;4&#125;: pull: Fast-forward</span><br><span class="line">0bcc164 HEAD@&#123;5&#125;: commit: 创建const.cpp文件，写了c++const代码</span><br><span class="line">34a386c HEAD@&#123;6&#125;: <span class="built_in">clone</span>: from github.com:Cstardust/HelloWorld.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id><a href="#" class="headerlink" title=".."></a>..</h2><h2 id="git工作实践"><a href="#git工作实践" class="headerlink" title="git工作实践"></a>git工作实践</h2><p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-03-21-33-55.png"></p>
]]></content>
      <categories>
        <category>技能 &amp; 工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP_2_信息的表示和处理</title>
    <url>/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/</url>
    <content><![CDATA[<p>无符号数、有符号数（补码）<br>浮点型、IEEE</p>
<span id="more"></span>

<h1 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h1><h2 id="补码和无符号数"><a href="#补码和无符号数" class="headerlink" title="补码和无符号数"></a>补码和无符号数</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li>补码和无符号数关系<ul>
<li>无符号数和有符号数并列。</li>
<li>有符号数 的一种表示形式是 补码</li>
</ul>
</li>
<li>转化(位数为[w-1,0])<ul>
<li>补码 -&gt; 无符号<ul>
<li><code>T2U(x) = x + 2^w   (x&lt;0)</code></li>
<li><code>T2U(x) = x         (x&gt;=0)</code></li>
</ul>
</li>
<li>无符号 -&gt; 补码<ul>
<li><code>U2T(u) = u (u&lt;=TMax)</code></li>
<li><code>U2T(u) = u-2^w (u&gt;TMax)</code></li>
</ul>
</li>
</ul>
</li>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-18-09-28-30.png"></li>
<li>补码表示范围<ul>
<li>前提：总共有n位。位数分别是[n-1,0]。也即从0开始，最高位是n-1</li>
<li><code>[-2^(n-1),2^(n-1)-1];</code>（下例中就是<code>[-2^7 , 2^7-1];</code>）</li>
</ul>
</li>
<li>无符号数表示范围<ul>
<li>前提：总共有n位。位数分别是[n-1,0]。也即从0开始，最高位是n-1</li>
<li><code>[0,2^n-1]</code>（下例中就是<code>[0 , 2^8-1];</code>）</li>
</ul>
</li>
<li><strong>首位的符号位可以看作是一个带正/负号的数值位。</strong><ul>
<li>当首位符号位为0时，该补码形式所表示的真值就是[6,0]位的和 + 首位0；首位符号位为1时，该补码形式所表示的真值就是就是 首位-2^7 + [6,0]位的数值位之和。</li>
<li>补码与原码转化。原码 = ~补码+1。不用记，无所谓。求真值用上面的方法就好。</li>
</ul>
</li>
<li>例子：总共8位。[7,0]<ul>
<li>有符号数 补码形式。<code>[-2^7 , 2^7-1];</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>     <span class="comment">//  2^7 - 1 = 127</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>     </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>     <span class="comment">//  0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>     <span class="comment">//  -2^7 + 2^6 + 2^5 + ... + 2^0 = -1;</span></span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>     <span class="comment">//  -2^7 + 1 = -127（该二进制数据对应的真值）</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>     <span class="comment">//  -2^7 = -128（该二进制数据对应的真值）</span></span><br></pre></td></tr></table></figure></li>
<li>无符号数。[0,255]<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>     <span class="comment">//  2^8-1=255</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>     <span class="comment">//  254</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>     <span class="comment">//  2^0 = 1;</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>     <span class="comment">//  0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>从min到max是个循环</strong></li>
<li>例子<ul>
<li>无符号  0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7 …<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span>   <span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li>补码  0 1 2 3 -4 -3 -2 -1 0 1 2 3…<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span>   <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">-2</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   <span class="number">-3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span>   <span class="number">-4</span></span><br></pre></td></tr></table></figure></li>
<li>有符号数（补码）的溢出：是由正变负，由负变正</li>
<li>无符号数的溢出：由正变0，由0变正。（无符号数的溢出就是取模）</li>
</ul>
</li>
</ul>
<ul>
<li>左移 导致溢出。举例有符号补码<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;  <span class="comment">//  有符号数 补码形式表示</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">33</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;(x&lt;&lt;i)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">31</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;(((x&lt;&lt;i)&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./test.out</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">00000000000000000000000000000001</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">00000000000000000000000000000010</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">00000000000000000000000000000100</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">00000000000000000000000000001000</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">00000000000000000000000000010000</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">00000000000000000000000000100000</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">00000000000000000000000001000000</span></span><br><span class="line"><span class="number">128</span></span><br><span class="line"><span class="number">00000000000000000000000010000000</span></span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">00000000000000000000000100000000</span></span><br><span class="line"><span class="number">512</span></span><br><span class="line"><span class="number">00000000000000000000001000000000</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">00000000000000000000010000000000</span></span><br><span class="line"><span class="number">2048</span></span><br><span class="line"><span class="number">00000000000000000000100000000000</span></span><br><span class="line"><span class="number">4096</span></span><br><span class="line"><span class="number">00000000000000000001000000000000</span></span><br><span class="line"><span class="number">8192</span></span><br><span class="line"><span class="number">00000000000000000010000000000000</span></span><br><span class="line"><span class="number">16384</span></span><br><span class="line"><span class="number">00000000000000000100000000000000</span></span><br><span class="line"><span class="number">32768</span></span><br><span class="line"><span class="number">00000000000000001000000000000000</span></span><br><span class="line"><span class="number">65536</span></span><br><span class="line"><span class="number">00000000000000010000000000000000</span></span><br><span class="line"><span class="number">131072</span></span><br><span class="line"><span class="number">00000000000000100000000000000000</span></span><br><span class="line"><span class="number">262144</span></span><br><span class="line"><span class="number">00000000000001000000000000000000</span></span><br><span class="line"><span class="number">524288</span></span><br><span class="line"><span class="number">00000000000010000000000000000000</span></span><br><span class="line"><span class="number">1048576</span></span><br><span class="line"><span class="number">00000000000100000000000000000000</span></span><br><span class="line"><span class="number">2097152</span></span><br><span class="line"><span class="number">00000000001000000000000000000000</span></span><br><span class="line"><span class="number">4194304</span></span><br><span class="line"><span class="number">00000000010000000000000000000000</span></span><br><span class="line"><span class="number">8388608</span></span><br><span class="line"><span class="number">00000000100000000000000000000000</span></span><br><span class="line"><span class="number">16777216</span></span><br><span class="line"><span class="number">00000001000000000000000000000000</span></span><br><span class="line"><span class="number">335544321</span></span><br><span class="line"><span class="number">00000010000000000000000000000000</span></span><br><span class="line"><span class="number">67108864</span></span><br><span class="line"><span class="number">00000100000000000000000000000000</span></span><br><span class="line"><span class="number">134217728</span></span><br><span class="line"><span class="number">00001000000000000000000000000000</span></span><br><span class="line"><span class="number">268435456</span></span><br><span class="line"><span class="number">00010000000000000000000000000000</span></span><br><span class="line"><span class="number">536870912</span></span><br><span class="line"><span class="number">00100000000000000000000000000000</span></span><br><span class="line"><span class="number">1073741824</span></span><br><span class="line"><span class="number">01000000000000000000000000000000</span></span><br><span class="line"><span class="number">-2147483648</span></span><br><span class="line"><span class="number">10000000000000000000000000000000</span></span><br><span class="line"></span><br><span class="line">如果x是<span class="keyword">unsigned</span> <span class="keyword">int</span>的话 那么就是</span><br><span class="line"><span class="number">2147483648</span></span><br><span class="line"><span class="number">10000000000000000000000000000000</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h3><ul>
<li>有符号数与无符号数发生比较/运算时，<strong>有符号数会先被转化为无符号数</strong><ul>
<li>signed(two’s complement) -&gt; unsigned</li>
</ul>
</li>
<li>例子 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELTA sizeof(char)</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  死循环</span></span><br><span class="line">i-<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) 得到一个<span class="keyword">unsigned</span></span><br><span class="line"><span class="comment">// 因为sizeof 返回 size_t ，是unsigned</span></span><br><span class="line"><span class="keyword">for</span>(i=CNT;i-DELTA&gt;=<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>例子。错把无符号数当作有符号数。递减得到INT_MAX<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  死循环。不会终止。</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">unsigned</span> i = <span class="number">4</span> ; i&gt;=<span class="number">0</span> ; --i )</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00000000000000000000000000000100</span>  <span class="number">4</span></span><br><span class="line">...</span><br><span class="line"><span class="number">00000000000000000000000000000001</span>  <span class="number">1</span></span><br><span class="line"><span class="number">00000000000000000000000000000000</span>  <span class="number">0</span></span><br><span class="line"><span class="number">11111111111111111111111111111111</span>  <span class="keyword">signed</span> : <span class="number">-1</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">32</span><span class="number">-1</span></span><br><span class="line"><span class="number">11111111111111111111111111111110</span>  <span class="keyword">signed</span> : <span class="number">-2</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">32</span><span class="number">-2</span></span><br><span class="line">...</span><br><span class="line"><span class="number">10000000000000000000000000000000</span>  <span class="keyword">signed</span> : <span class="number">-2</span>^<span class="number">31</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">32</span></span><br><span class="line"><span class="number">01111111111111111111111111111111</span>  <span class="keyword">signed</span> : <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">31</span><span class="number">-1</span></span><br><span class="line"><span class="number">01111111111111111111111111111110</span>  <span class="keyword">signed</span> : <span class="number">2</span>^<span class="number">31</span><span class="number">-2</span> / <span class="keyword">unsigned</span> : <span class="number">2</span>^<span class="number">31</span><span class="number">-2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>printf并没用使用变量的任何类型信息，只是根据%d %u %x这样的指示符来按照指示将变量底下的字节以相应形式输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  32位</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>;                   <span class="number">11111.</span>.<span class="number">.1111</span></span><br><span class="line"><span class="keyword">unsigned</span> u = <span class="number">2147483648</span>;      <span class="number">10000.</span>.<span class="number">.0000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%u=%d\n&quot;</span>,x,x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;u=%u=%d\n&quot;</span>,u,u);</span><br><span class="line"></span><br><span class="line">x = <span class="number">4294967295</span> = <span class="number">-1</span>;</span><br><span class="line">u = <span class="number">2147836848</span> = <span class="number">-2147836848</span></span><br></pre></td></tr></table></figure></li>
<li><p>有符号数转无符号数对于标准的算数运算并无多大差异，但对于&lt;&gt;比较运算开输送，就会导致非直观的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表达式                              类型             结果</span></span><br><span class="line"><span class="number">-2147483647</span><span class="number">-1</span> == <span class="number">2147836848U</span>         <span class="keyword">unsigned</span>            <span class="number">1</span></span><br><span class="line"><span class="number">-2147483647</span><span class="number">-1U</span> &lt; <span class="number">2147836847</span>          <span class="keyword">unsigned</span>            <span class="number">0</span>      </span><br><span class="line"><span class="comment">// 1000...0000 U &lt; 0111...1111  </span></span><br><span class="line"><span class="number">-2147483647</span><span class="number">-1U</span> &lt; <span class="number">-2147483647</span>         <span class="keyword">unsigned</span>            <span class="number">1</span></span><br><span class="line"><span class="comment">// 1000...0000 U &lt; 1000...0001       </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h3><ul>
<li><p><strong>符号的扩展发生了什么</strong>（符号扩展在由小类型到大类型时发生）</p>
</li>
<li><p>有符号数：补码的符号扩展。</p>
<ul>
<li><strong>复制符号位</strong>：向高位拿了一个新位用作符号位，<strong>新符号位的权重是原符号位的2倍，把这个原先的符号位用作正的数值位</strong>。</li>
<li>这样并不改变这些数值位的总和；也即并不改变数（真值）的大小</li>
<li>将各个权值位相加，可得补码对应的真值。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   : <span class="number">-8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">-2</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   : <span class="number">-16</span> + <span class="number">8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">-2</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>无符号数：0扩展</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line">    <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   : <span class="number">8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">14</span></span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   : <span class="number">8</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">14</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h3><ul>
<li>截断会导致数变化很大。例如补码被截断就有可能一正一负，无符号数被截断就是取模。</li>
<li>无符号数。直接模<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1011</span>  <span class="comment">//  8+2+1=11</span></span><br><span class="line"><span class="number">011</span>   <span class="comment">//  3 = 11%8</span></span><br></pre></td></tr></table></figure></li>
<li>有符号数。补码形式。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">11011</span>   <span class="comment">//  -16+8+2+1=-5</span></span><br><span class="line">-&gt;</span><br><span class="line"><span class="number">1011</span>   <span class="comment">//  -8+2+1=5</span></span><br><span class="line">没变。是因为从<span class="number">1011</span>到<span class="number">11011</span>可以看作是符号位拓展。</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="number">10011</span>   <span class="comment">//  -16+2+1=-13</span></span><br><span class="line">-&gt;</span><br><span class="line"><span class="number">0011</span>   <span class="comment">//  2+1=3</span></span><br><span class="line"><span class="number">3</span> != <span class="number">-13</span>%<span class="number">16</span></span><br></pre></td></tr></table></figure></li>
<li>无论溢出的那个下一个高位有什么，我们都假装看不到并舍弃。只拿低位的[n-1,0]位当作我获得的结果，编译器对这个过程也不会有任何warning</li>
</ul>
<ul>
<li>乘法指令（3个周期）比移位指令（1个周期）花的时间周期多</li>
<li>现代计算机除法仍然很慢 30个周期</li>
</ul>
<h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><ul>
<li><p>补码右移：算数移位。copy符号位</p>
</li>
<li><p>补码左移：直接移，低位补0</p>
</li>
<li><p>无符号数右移：逻辑右移。高位补0</p>
</li>
<li><p>无符号数左移：逻辑左移。低位补0</p>
</li>
<li><p>总共w位，如果右移k位，且k&gt;=w位，那么结果是:</p>
<ul>
<li>大多数机器中都是这样做：实际位移量是 k mod w。</li>
<li>C标准中规避了说明这种情况下如何做，因此这种行为对C程序来说没有保证。</li>
</ul>
</li>
<li><p>习题</p>
<ul>
<li>六进制中从8到F的最高有效位为1，记住这一点就会发现十六进制表示二进制更方便<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">unsigned</span> word)</span></span>&#123;</span><br><span class="line">              <span class="comment">//  逻辑左移 低位补0</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)( (word&lt;&lt;<span class="number">24</span>) &gt;&gt; <span class="number">24</span> );</span><br><span class="line">                        <span class="comment">//  逻辑右移 高位补0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">unsigned</span> word)</span></span>&#123;</span><br><span class="line">              <span class="comment">//  算数左移 低位补0</span></span><br><span class="line">  <span class="keyword">return</span> ( (<span class="keyword">int</span>)word&lt;&lt;<span class="number">24</span> ) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                        <span class="comment">//  算数右移 高位补x[w-1]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">w                   <span class="title">fun1</span><span class="params">(w)</span>                 <span class="title">fun2</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">0x00000076        0x00000076              0x00000076    </span></span><br><span class="line"><span class="function">0x87654321        0x00000021              0x00000021</span></span><br><span class="line"><span class="function">0x000000c9        0x000000c9              0xffffffc9</span></span><br><span class="line"><span class="function">0xEDCBA987        0x00000087              0xffffff87</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 左移24/4=6个十六进制位：只留下最低两位十六进制位</span></span></span><br><span class="line"><span class="function"><span class="comment">// 右移24/4=6个十六进制位：逻辑移位补0，算数移位补x[w-1]</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="对一个数取负"><a href="#对一个数取负" class="headerlink" title="对一个数取负"></a>对一个数取负</h3><ul>
<li><p><strong>对补码的所有位（包括符号位）取反 ，再 + 1</strong></p>
</li>
<li><p><strong>[-x]补 = ~[x]补 + 1</strong></p>
</li>
<li><p>例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x     <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>    <span class="number">-8</span>+<span class="number">2</span>=<span class="number">-6</span></span><br><span class="line">~x    <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>   </span><br><span class="line">~x+<span class="number">1</span>  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>    <span class="number">2</span>+<span class="number">4</span>=<span class="number">6</span>     </span><br></pre></td></tr></table></figure></li>
<li><p>很巧啊，类似，从补码转到原码/从原码转到补码。都是取反+1，不过原码&lt;-&gt;补码不涉及符号位。</p>
</li>
<li><p><strong>原码补码转化公式：[x]补 =  ~[x]原+1</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x     <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">-2</span>  这是原码  </span><br><span class="line">~x    <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">~x+<span class="number">1</span>  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>   <span class="number">-8</span>+<span class="number">4</span>+<span class="number">2</span>=<span class="number">-2</span>   这是x原码对应的补码</span><br></pre></td></tr></table></figure></li>
<li><p>所以啊，为什么说 在程序中求 -x 就是在求 ~x+1?</p>
<ul>
<li>因为补码及其相反数的转化公式为：**[-x]补 = ~[x]补 + 1**</li>
<li>可不是因为原码补码的转化公式是：[x]补 =  ~[x]原+1。大一做算法题的时候还误以为是这个原因。</li>
</ul>
</li>
</ul>
<h3 id="特别的-TMin的相反数是什么？"><a href="#特别的-TMin的相反数是什么？" class="headerlink" title="特别的 TMin的相反数是什么？"></a>特别的 TMin的相反数是什么？</h3><ul>
<li>T Min的相反数还是 T Min</li>
<li>应用公式：[-x]补 = ~[x]补 + 1</li>
<li>假设n=4<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>   : T MAX</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   : T MIN</span><br><span class="line"></span><br><span class="line">~ T MIN</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">+<span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>   = -TMIN</span><br></pre></td></tr></table></figure></li>
<li>所以<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  1.</span></span><br><span class="line">x &gt; y 不一定有 -x &lt; -y</span><br><span class="line">当y=T MIN时 y和-y都是最小的</span><br><span class="line"></span><br><span class="line"><span class="comment">//  2.</span></span><br><span class="line">x &gt;=<span class="number">0</span>  =&gt;   -x&lt;=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  3.</span></span><br><span class="line">x&lt;=<span class="number">0</span>  !=&gt;   -x&gt;=<span class="number">0</span></span><br><span class="line">当x=T min时，x=-x=Tmin</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如何编写unsigned"><a href="#如何编写unsigned" class="headerlink" title="如何编写unsigned"></a>如何编写unsigned</h3><ul>
<li>该用unsigned吗？<ul>
<li>Java等语言抹去了unsigned，只保留了补码。<ul>
<li>但Java中&gt;&gt;是算数右移，&gt;&gt;&gt;是逻辑右移</li>
</ul>
</li>
</ul>
</li>
<li>C标准并没有明确规定有符号溢出会发生什么。我们知识假设是按照补码。但严格意义上我们不能假设C标准以外的东西</li>
<li>提出<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> i=...;  <span class="comment">//size_t : unsigned value of word size</span></span><br><span class="line"><span class="keyword">for</span>(i=cnt<span class="number">-2</span>;i&lt;cnt;--i)</span><br><span class="line">&#123;</span><br><span class="line">  a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最终：自己谨慎点吧</li>
</ul>
<h3 id="所以unsigned这么不好用，什么时候用？"><a href="#所以unsigned这么不好用，什么时候用？" class="headerlink" title="所以unsigned这么不好用，什么时候用？"></a>所以unsigned这么不好用，什么时候用？</h3><ul>
<li>加密算法（需要取模）</li>
<li>仅仅把字看作位的集合，而没有任何数学意义。</li>
</ul>
<h3 id="无符号数加法"><a href="#无符号数加法" class="headerlink" title="无符号数加法"></a>无符号数加法</h3><ul>
<li><p>阿贝尔群</p>
</li>
<li><p>无符号加法公式</p>
<ul>
<li>x + w位的无符号数y (写作uwy) <ul>
<li> = x + y  (x+y &lt; 2^w)</li>
<li> = x + y - 2^w  (2^w &lt;= x+y &lt; 2^w+1)</li>
</ul>
</li>
</ul>
</li>
<li><p>整数加法和无符号数加法关系。当x+y &gt; 2^w - 1时，和溢出<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-20-09-42-42.png"></p>
</li>
</ul>
<h3 id="有符号数（补码）加法"><a href="#有符号数（补码）加法" class="headerlink" title="有符号数（补码）加法"></a>有符号数（补码）加法</h3><ul>
<li>阿贝尔群</li>
<li>补码加法公式<ul>
<li>x + w位的补码y（写作twy）<ul>
<li>x + y - 2^w     （2^(w-1) &lt;= x + y）</li>
<li>x + y             （ -2^(w-1) &lt;= x + y &lt; 2^(w-1)）</li>
<li>x + y + 2^w     （ x + y &lt; -2^(w-1)）</li>
</ul>
</li>
</ul>
</li>
<li>整数加法和无符号数加法之间的关系。x + y &lt; 2^(w-1) 时,负溢出 ； x + y &gt; 2^(w-1)-1时,正溢出<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-20-19-46-45.png"></li>
</ul>
<h3 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h3><ul>
<li>两个w位的无符号数相乘，结果应当用2w位保存，但是c语言中无符号乘法被定义成产生w位的值，也就是说会截断低位的w位。</li>
<li>将一个无符号数截断为w位 ，等价于计算该值模2^w</li>
<li>-&gt;得到公式： x * uwy = (x*y) mod (2^w)</li>
</ul>
<h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><ul>
<li>两个w位的有符号数相乘，结果应当用2w位保存，但是c语言中有符号乘法被定义成产生w位的值，也就是说会截断低位的w位。</li>
<li>将一个无符号数截断为w位，相当于 先计算该值模2^w , 再把无符号数转换为补码。</li>
<li>-&gt;得到公式：x * twy = U2T ( (x*y) mod (2^w) )</li>
</ul>
<ul>
<li>补码乘法和无符号乘法的位级表示是一样的（位级等价性）</li>
</ul>
<h2 id="字长"><a href="#字长" class="headerlink" title="字长"></a><strong>字长</strong></h2><h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><ul>
<li><p>64位机器，寻址是2^64。 这是逻辑上的。实际上最大是2^47。可也正常人没钱买这么大内存。</p>
</li>
<li><p>运行程序时，程序认为他有这么大内存，实际上没有。操作系统只允许他访问能够访问的区域。</p>
</li>
<li><p>机器级程序将内存视为一个非常大的字节数组，称为<strong>虚拟内存</strong>。</p>
</li>
<li><p>内存的每一个字节都由唯一的数字来标识，称为它的地址。</p>
</li>
<li><p>所有可能地址的集合就称为<strong>虚拟地址空间</strong>。</p>
<ul>
<li>顾名思义，虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。</li>
</ul>
</li>
<li><p>程序对象：程序数据、指令、控制信息。</p>
<ul>
<li>编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的程序对象，即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。</li>
<li>每个程序对象可以简单的视为一个字节快，而程序本身就是一个字节序列</li>
</ul>
</li>
<li><p>字节顺序：</p>
<ul>
<li>几乎在所有的机器上，多字节对象被存储为连续的字节序列；<strong>对象地址</strong>为所使用字节的<strong>最小地址</strong>。<blockquote>
<p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-11-20-42-03.png"></p>
</blockquote>
</li>
<li>大端机器较少，x86机器都是小端，arm处理器既可处理大端也可处理小端，但一般都是小端。</li>
<li>基本上只有互联网是唯一一个有大端序的地方。当向网络发送数据包时，会以大端序接收<blockquote>
<p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-11-21-01-15.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>按字节，将信息以16进制打印</strong>（这不是我昨天刚写过类似的吗哈哈哈）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start,<span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\t0x%.2x\n&quot;</span>,start+i,start[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">show_bytes</span>((byte_pointer)&amp;a,<span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./a.out </span><br><span class="line"><span class="number">0x7ffc93b80294</span>  <span class="number">0x09</span></span><br><span class="line"><span class="number">0x7ffc93b80295</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7ffc93b80296</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7ffc93b80297</span>  <span class="number">0x00</span></span><br></pre></td></tr></table></figure></li>
<li><p>单位转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">KB MB GB TB</span><br><span class="line">K、M、G、T是数字大小的进制，单位(<span class="number">1</span>)</span><br><span class="line">B是物理意义上的单位，指Bytes</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>^<span class="number">10</span> = <span class="number">1024</span> ==<span class="number">10</span>^<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>KB = <span class="number">1024B</span> = <span class="number">2</span>^<span class="number">10</span> Bytes;</span><br><span class="line"><span class="number">1</span>MB = <span class="number">1024</span>KB = <span class="number">1024</span>*<span class="number">1024</span>KB = <span class="number">2</span>^<span class="number">20</span> Bytes</span><br><span class="line"><span class="number">1</span>GB = <span class="number">1024</span>MB = <span class="number">2</span>^<span class="number">30</span> Bytes = <span class="number">10</span>^<span class="number">9</span> Bytes</span><br><span class="line"><span class="number">1</span>TB = <span class="number">1024</span>GB</span><br><span class="line"><span class="number">1</span>PB = <span class="number">1024</span>TB = <span class="number">1125899906842624</span> Bytes</span><br><span class="line"><span class="number">1</span>EB = <span class="number">1024</span>PB = <span class="number">1152921504606846976</span> Bytes</span><br><span class="line"><span class="number">1</span>MM = <span class="number">2</span>^<span class="number">20</span> * <span class="number">2</span>^<span class="number">20</span> = <span class="number">2</span>^<span class="number">40</span> Bytes = <span class="number">10</span>^<span class="number">12</span> Bytes</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>^<span class="number">47</span> 估算：</span><br><span class="line"><span class="number">2</span>^<span class="number">40</span> * <span class="number">2</span>^<span class="number">7</span> = <span class="number">128</span> * <span class="number">10</span>^<span class="number">12</span> Bytes = <span class="number">128</span> MM Bytes = <span class="number">128</span>*<span class="number">10</span>^<span class="number">3</span> G Bytes</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="什么是字长"><a href="#什么是字长" class="headerlink" title="什么是字长"></a><strong>什么是字长</strong></h3><ul>
<li><p>每台计算机都有一个字长，<strong>指明指针数据的标称大小</strong>。因为虚拟地址是以这样的一个字来编码的，所有字长决定的最重要的系统参数就是<strong>虚拟地址空间的最大大小</strong>。也就是说，对于一个字长为w位的机器而言，虚拟地址的范围是[0,2^w-1]。程序最多访问2 ^w 个字节。（一个地址背后是1Bytes、8bits的存储空间）</p>
</li>
<li><p>大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。我们将程序称为“32位程序”或“64位程序”时，区别在于该程序是如何编译的，而不是其运行的机器类型。</p>
<ul>
<li>生成32位程序，该程序可以在32位/64位机器上运行<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc -m32 prog.c</span><br></pre></td></tr></table></figure></li>
<li>生成64位程序，只能在64位机器上运行<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc -m64 prog.c</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>困扰我好久了！这些话解决了大半。</p>
</li>
<li><p>Whatever the largest number is that or the range that sort of signifies how big a pointer is in this language , Or hardware wise the largest sort of chunkof hardware for which.<br>无论最大数是多少，或者指针表的范围是多少，或者硬件的一个chunk块是多大<br>There’s a standard support for storing it for arithmetic operations and so forth<br>有一个标准确定如何存储值和进行算数运算等<br>So when we say it’s a 64-bit machine<br>所以当我们说他是64位机器时<br>What we mean is that it regular and routinely manipulate 64-bit and operations<br>意思是他惯常处理64位值和算数运算<br>And also it has a pointer or the values of addresses are 64-bit<br>并且他的指针和地址的值是64位<br>Even if for right now only 47 of those bits are usable , it’s still considered a 64-bit machine<br>即便只有47位是有效的，我们也认为他是64位机器</p>
</li>
<li><p>我们的机器有个奇怪的特性，当我们用gcc作为编译器时，我们可以指定是32位还是64位编译，并且32位和64位会生成两种不同类型的代码。但就目前而言，重点是硬件本身并不一定决定字长的大小，it’s a combination of the hardware and the complier that determines，是由硬件和编译器一起决定的。</p>
<ul>
<li>And that code can be run on the point is a 64-bit machine，and can insert of a backward compatibiltiy a style also excutes 32-bit code</li>
</ul>
</li>
<li><p>And we also saw one of the other feature is<br>并且我们可以看到另一个特性<br>Even though it’s a 64-bit word size machine ,  the data type int without any other qualifiers<br>即使它是个64位机器：对于数据类型int来说，如果没有任何其他的修饰符<br>it is jusy 32-bit<br>它就是32位的<br>so the sort of this mixture of how big things are<br>所以这种数据类型大小的定义是混合的</p>
</li>
<li><p>So when people just say word or word size ，<br>所以当人们说字或者字长时<br>let’s must say give a precise definition that’s not a very meaningful term<br>我们必须说。从精确的定义来说，这不是个有意义的术语/措辞<br>And we’ll sort of throw  it around when we mean sort of generic chunk of bits<br>我们说他的时候一般是泛指一个比特块，<br>without trying to assume that it has a particular number of bits to it<br>而不去假设他具有特定数量的bit</p>
</li>
</ul>
<ul>
<li>64bit的标准int仍然是32位，64位与32位相比，主要特征是<strong>64bit的指针是64位的</strong>，或者说是8字节的。<ul>
<li><blockquote>
<p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-11-20-45-53.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ul>
<li><blockquote>
<p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-11-21-44-55.png"></p>
</blockquote>
</li>
<li><p>p75 <strong>经典</strong></p>
<ul>
<li>记住 <strong>无符号数 和 补码的位级表示相同！！哪怕经过加减乘除计算之后，也仍是这样。</strong>（位级别相同的两组补码和无符号数，各自经历相同的加减乘除计算之后，<strong>得到的结果的位级表示仍然相同</strong>）</li>
<li>记住 -Tmin = Tmin</li>
<li>记住第a位的数 在 左(右)移b位后，会移动到a+(-)b位上。（数的位数范围[w-1,0]）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已知</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="built_in">foo</span>();</span><br><span class="line"><span class="keyword">int</span> y = <span class="built_in">bar</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> ux = x;</span><br><span class="line"><span class="keyword">unsigned</span> uy = y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(x&gt;<span class="number">0</span>) || (x<span class="number">-1</span>&lt;<span class="number">0</span>)      </span><br><span class="line"><span class="comment">//  FALSE</span></span><br><span class="line">x = Tmin = <span class="number">-2147483648</span> </span><br><span class="line">则 x&lt;<span class="number">0</span> , x<span class="number">-1</span>&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">(x&amp;<span class="number">7</span>)!=<span class="number">7</span> || (x&lt;&lt;<span class="number">29</span> &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">//  TRUE</span></span><br><span class="line"><span class="comment">//  x&amp;7 != 7 ok</span></span><br><span class="line"><span class="comment">//  x&amp;7 == 7 则 x = aaaa...0111</span></span><br><span class="line"><span class="comment">//  则 x&lt;&lt;29 = 111000...0001</span></span><br><span class="line"></span><br><span class="line">(x*x) &gt;= <span class="number">0</span></span><br><span class="line"><span class="comment">//  FALSE</span></span><br><span class="line">x = <span class="number">0xffff</span></span><br><span class="line"><span class="number">0xffff</span> * <span class="number">0xffff</span>  = <span class="number">-131071</span></span><br><span class="line"></span><br><span class="line">x&lt;<span class="number">0</span> || -x&lt;=<span class="number">0</span></span><br><span class="line"><span class="comment">//  TRUE</span></span><br><span class="line">x = Tmin = <span class="number">-2147483648</span></span><br><span class="line">-x = Tmin &lt;=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x&gt;<span class="number">0</span> || -x&gt;=<span class="number">0</span></span><br><span class="line"><span class="comment">// FALSE</span></span><br><span class="line">x = Tmin = <span class="number">-2147483648</span></span><br><span class="line">-x = Tmin &lt;=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">x+y == uy + ux</span><br><span class="line"><span class="comment">//  TRUE</span></span><br><span class="line">补码和无符号数的位级行为相同</span><br><span class="line">也就是说 x + y 与 ux + uy 的位级表示相同</span><br><span class="line">且 在 == 比较时 会将补码转化成无符号数</span><br><span class="line">故 x + y == ux + uy</span><br><span class="line"></span><br><span class="line">x*(~y) + uy*ux == -x</span><br><span class="line"><span class="comment">// TRUE</span></span><br><span class="line">~y = -y<span class="number">-1</span>;</span><br><span class="line">x*(-y<span class="number">-1</span>) + uy*ux = -xy -x + uy * ux = -x</span><br><span class="line">补码和无符号数的位级行为相同</span><br><span class="line">也就是说 uy*ux 与 -xy的位级表示相同 。（也许完整的乘积的位级表示可能不同，但是按照C语言标准，截断之后的乘积的位级表示是相同的）（C标准规定截断位w位）</span><br><span class="line">因此 -xy可以和uy*ux相抵消</span><br><span class="line">故 剩下-x</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><ul>
<li>csapp p59</li>
<li>习题<ul>
<li>当length = 0时，会访问非法内存。<ul>
<li>length = 0，length - 1 = -1 -&gt; UMAX。</li>
<li>i先转化成unsigned，然后从0增至UMAX</li>
</ul>
</li>
<li>改正：<ul>
<li>length 类型改为 int。（即便length想要&gt;INT_MAX也没关系，想想就知道了）</li>
<li>i &lt;= length - 1 ——&gt; i &lt; length<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sum_eles</span><span class="params">(<span class="keyword">float</span> a[],<span class="keyword">unsigned</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;=length<span class="number">-1</span> ; ++i)</span><br><span class="line">    result += a[i];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><h2 id="IEEE浮点数表示（比唐书说得清楚些）"><a href="#IEEE浮点数表示（比唐书说得清楚些）" class="headerlink" title="IEEE浮点数表示（比唐书说得清楚些）"></a>IEEE浮点数表示（比唐书说得清楚些）</h2><h3 id="基本规则说明"><a href="#基本规则说明" class="headerlink" title="基本规则说明"></a>基本规则说明</h3><ul>
<li>IEEE浮点标准用 V = (-1)^s * M * 2^E来表示一个数。<ul>
<li>符号（sign）：1负0正</li>
<li>尾数（significand）：M为一二进制小数。范围是 1<del>2-无穷小 （2^(-n)） 或者 0</del>1 - 无穷小 （2^(-n)）</li>
<li>阶码（exponent）：E的作用是对浮点数加权</li>
</ul>
</li>
<li>将浮点数的位表示为三个字段，分别对这三个值进行编码：<ul>
<li>一个单独的符号位s 直接编码符号s</li>
<li>k位的阶码字段 <code>exp=ek-1...e1e0</code> 编码阶码E</li>
<li>n位的小数字段<code>frac=fn-1...f1f0</code>编码尾数M，但是编码出来的值也依赖于阶码字段的值是否等于0</li>
</ul>
</li>
<li>图示<ul>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-12-34-53.png"></li>
<li>阶码的值决定了一个浮点数是否是规格化的<img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-12-35-18.png"></li>
</ul>
</li>
</ul>
<h3 id="是否规格化（三种情况）"><a href="#是否规格化（三种情况）" class="headerlink" title="是否规格化（三种情况）"></a>是否规格化（三种情况）</h3><ul>
<li>规格化的值：exp的位模式 既不全为0，也不全为1。<ul>
<li>E = e-Bias。其中e是无符号数。偏置值Bias=2^(k-1) - 1。<ul>
<li>因此，指数的取值范围：单精度 [-126,127] ；双精度 [-1022,+1023]</li>
</ul>
</li>
<li>M = 1+f。称为隐含的以1开头的表示。<ul>
<li>其中f属于[0,1)，f的二进制表示为<code>0.fn-1...f1f0</code>（即小数点在最高位有效位的左边）。因此M可以看为二进制：<code>1.fn-1...f1f0</code>。（可以通过调整E，使得M属于[1,2)。通过M=1+f，使得f不必显示写出那个1。这样，就获得了一个额外的精度位）</li>
</ul>
</li>
</ul>
</li>
<li>非规格化的值：exp的位模式全部为0<ul>
<li>E = 1-Bias</li>
<li>M = f。即小数字段的值，不包含隐含的开头的1。也即f的值的小数点左侧实际上为0。</li>
<li>非规格化数用途<ul>
<li>提供了一种表示数值0的方法<ul>
<li>+0.0：位模式全部为0。s = 0，exp = 0，frac = 0.</li>
<li>-0.0：s=1，exp=0，frac=0.</li>
</ul>
</li>
<li>还可用于表示那些非常接近0.0的数</li>
</ul>
</li>
</ul>
</li>
<li>特殊值：exp的位模式全部为1.<ul>
<li>s=0，frac=0，表示正无穷</li>
<li>s=1，frac=0，表示负无穷</li>
<li>frac!=0时，其结果表示为 NaN （Not a number）。可用作表示未初始化的数值，或计算结果不能是实数或者无穷。</li>
</ul>
</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><p>假设6位浮点格式（3位阶码2位尾数）。可表示的数不是均匀分布的，越靠近远点越稠密<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-13-09-51.png"></p>
</li>
<li><p>8位浮点格式的非负值示例<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-12-25-43.png"></p>
</li>
<li><p>最靠近0：非规格化数。</p>
<ul>
<li>E = 1-7 = -6 。权 = 2^E = 1/64</li>
<li><code>f = 0，1/8，...，7/8</code></li>
<li>所以V [0,1/64 * 7/8]。（非连续）</li>
<li>最小为0</li>
</ul>
</li>
<li><p>规格化数</p>
<ul>
<li>最小规格化数：<ul>
<li>E = 1-7 = -6</li>
<li><code>frac = 0,1/8...7/8 -&gt; M = 1+f = 1...15/8</code></li>
<li>所以V [8/512 , 15/512]</li>
<li>最小为8/512。</li>
</ul>
</li>
<li>逐渐增大</li>
<li>最大规格化数<ul>
<li>E = 7 </li>
<li><code>frac = 0,1/8...7/8 -&gt; M = 1+f = 1...15/8</code></li>
<li>所以，最大规格化值 V = 15/8*2^7 = 240</li>
</ul>
</li>
</ul>
</li>
<li><p>无穷大</p>
<ul>
<li>超过最大规格化数，溢出到正无穷</li>
</ul>
</li>
<li><p>k位阶码，n位小数的一般规律</p>
<ul>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-15-09-28.png"></li>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-15-39-17.png"></li>
</ul>
</li>
</ul>
<ul>
<li>整数转化成IEEE规格化表示<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">12345</span></span><br><span class="line">二进制：<span class="number">11000000111001</span></span><br><span class="line"><span class="number">12345</span> = (<span class="number">1.1000000111001</span>)<span class="number">2</span> * <span class="number">2</span>^<span class="number">13</span></span><br><span class="line">为了用IEEE单精度形式编码，</span><br><span class="line">构造小数字段：应该丢弃开头的<span class="number">1</span>（作为隐含的<span class="number">1</span>），并在末尾+<span class="number">10</span>个<span class="number">0</span>，来构造小数字段：<span class="number">10000001110010000000000</span></span><br><span class="line">构造阶码字段：<span class="number">13</span> + bias（<span class="number">2</span>^(<span class="number">8</span><span class="number">-1</span>)<span class="number">-1</span> = <span class="number">127</span>） = <span class="number">140</span>。二进制表示为 <span class="number">10001100</span></span><br><span class="line">再加上符号位<span class="number">0</span></span><br><span class="line">得到二进制的浮点数表示</span><br><span class="line">s   exp       frac</span><br><span class="line"><span class="number">0</span> <span class="number">10001100</span> <span class="number">10000001110010000000000</span></span><br></pre></td></tr></table></figure></li>
<li>比较<ul>
<li>12345整形（0x00003039）：</li>
<li>12345.0单精度浮点数：（0x4640E400）：</li>
<li><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-22-15-49-44.png"></li>
</ul>
</li>
</ul>
<h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h2><ul>
<li>向上舍入</li>
<li>向下舍入</li>
<li>向0舍入</li>
<li><strong>向偶数舍入</strong><ul>
<li>向偶数舍入原则有2个</li>
<li>当要舍入到的位的 之后的位 不等于中间值（半值）时，向最靠近的数舍入。也即&lt;半值就向下舍入，大于半值就向上舍入</li>
<li>当要舍入到的位的 之后的位 等于中间值（半值）时，向偶数舍入<ul>
<li>如果要舍入到的位，现在是偶数，那么向下舍入，直接舍去后面的位，原先要舍入到的位的数就是舍入的结果。</li>
<li>如果要舍入到的位，现在是奇数，那么向上舍入。</li>
</ul>
</li>
<li>例子：舍入到小数点后一位<ul>
<li>10.010(2) -&gt; 10.0 <ul>
<li>因为 小数点右边一位的0之后的10 = 0.25 = 0.5/2 ，也即等于半值，所以向偶数舍入，又因小数点后一位为偶数0，所以结果为10.0</li>
</ul>
</li>
<li>10.011(2) -&gt; 10.1<ul>
<li>因为 0之后的11 = 0.375 &gt; 0.5/2 ，也即&gt;半值，所以向上舍入，故10.1</li>
</ul>
</li>
<li>10.110(2) -&gt; 11.0<ul>
<li>因为 小数点右边一位的1之后的10 = 0.25 = 0.5/2 ，也即等于半值，所以向偶数舍入，又因小数点后一位为偶数1，所以(+1向上舍入)结果为11.0</li>
</ul>
</li>
<li>11.001(2) -&gt; 11.0<ul>
<li>因为 0之后的01 = 0.125 &lt; 0.5/2 ，也即&lt;半值，所以向下舍入，故10.0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul>
<li><p>不是阿贝尔群</p>
<ul>
<li>具备交换律 但 不具备 结合律</li>
</ul>
</li>
<li><p>赶作业去了</p>
</li>
<li><p><a href="https://zh.m.wikipedia.org/zh-hans/%E9%98%BF%E8%B4%9D%E5%B0%94%E7%BE%A4">阿贝尔群</a>（近世代数里讲过）<br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-23-09-14-31.png"></p>
</li>
</ul>
<h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-23-09-11-15.png"></p>
<h1 id="摘要（csapp）"><a href="#摘要（csapp）" class="headerlink" title="摘要（csapp）"></a>摘要（csapp）</h1><p><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-23-09-17-51.png"><br><img src="/2022/05/10/csapp_2_%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86_BitsBytesInteger/2022-05-23-09-17-58.png"></p>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>CSAPP</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
<span id="more"></span>

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx内存池</title>
    <url>/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="nginx内存池"><a href="#nginx内存池" class="headerlink" title="nginx内存池"></a>nginx内存池</h1><ul>
<li>内存池中分为大内存block和小内存block</li>
<li>大内存block的头信息在小内存块中。大内存块头信息通过链表连接起来。</li>
</ul>
<p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-29-10-55-50.png"></p>
<h2 id="内存池结构"><a href="#内存池结构" class="headerlink" title="内存池结构"></a>内存池结构</h2><blockquote>
<p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-10-40-03.png"></p>
</blockquote>
<h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><ul>
<li>内存池<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;                <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;              <span class="comment">//  p-&gt;max：一个Block块内最多能分配多大的小内存。其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095              </span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* current;                    <span class="comment">//  指向当前内存块</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;                <span class="comment">//  大内存Block头信息的链表入口</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* cleanup;            <span class="comment">//  外部资源的头信息链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="小内存Block-头信息"><a href="#小内存Block-头信息" class="headerlink" title="小内存Block 头信息"></a>小内存Block 头信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  小内存池头信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char               *last;             <span class="comment">//  可用内存起始</span></span><br><span class="line">    u_char               *end;              <span class="comment">//  内存末尾</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *next;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;           <span class="comment">//  分配内存是否成功</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>            <span class="title">ngx_pool_t</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="大内存Block-头信息"><a href="#大内存Block-头信息" class="headerlink" title="大内存Block 头信息"></a>大内存Block 头信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  大内存池头信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *next;</span><br><span class="line">    <span class="keyword">void</span>                 *alloc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="外部资源-头信息"><a href="#外部资源-头信息" class="headerlink" title="外部资源  头信息"></a>外部资源  头信息</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;</span><br><span class="line">    <span class="keyword">void</span>                 *data;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>     <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>   <span class="title">ngx_pool_cleanup_t</span></span></span><br></pre></td></tr></table></figure>


<h3 id="一些宏"><a href="#一些宏" class="headerlink" title="一些宏"></a>一些宏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_DEFAULT_POOL_SIZE    (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MIN_POOL_SIZE                                                     \</span></span><br><span class="line"><span class="meta">    ngx_align((sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t)),            \</span></span><br><span class="line"><span class="meta">              NGX_POOL_ALIGNMENT)</span></span><br></pre></td></tr></table></figure>


<h2 id="创建内存池-ngx-create-pool"><a href="#创建内存池-ngx-create-pool" class="headerlink" title="创建内存池 ngx_create_pool"></a>创建内存池 ngx_create_pool</h2><h3 id="ngx-create-pool"><a href="#ngx-create-pool" class="headerlink" title="ngx_create_pool"></a>ngx_create_pool</h3><ul>
<li>创造的是一个内存Block，从操作系统malloc而来。是打头的那个。有完整的ngx_pool_t，记录了整个内存池的信息。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  size：内存池大小（实际可以使用的比size小）</span></span><br><span class="line"><span class="comment">//  log：日志</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  开辟内存池。依据平台调用相应函数</span></span><br><span class="line">    <span class="comment">//  ngx_pool_t + 自由内存</span></span><br><span class="line">    p = <span class="built_in">ngx_memalign</span>(NGX_POOL_ALIGNMENT, size, log);    </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);      <span class="comment">//  内存池起始</span></span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;                     <span class="comment">//  内存池末尾</span></span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;                                   <span class="comment">//  下一个小内存block</span></span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;                                    <span class="comment">//  当前内存块分配内存失败次数</span></span><br><span class="line"></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);                   <span class="comment">//  内存Block实际能使用的大小。整个内存池大小size - 内存池头信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  p-&gt;max：一个Block块内最多能分配多大的小内存。</span></span><br><span class="line">        <span class="comment">//  其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095</span></span><br><span class="line">    <span class="comment">//  p-&gt;max = min(size,4095)</span></span><br><span class="line">    <span class="comment">//  max不超过一个页面的大小</span></span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;log = log;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ngx-memalign"><a href="#ngx-memalign" class="headerlink" title="ngx_memalign"></a>ngx_memalign</h3></li>
<li>向操作系统malloc内存</li>
<li><code>ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)</code>：<ul>
<li>开辟内存池（size和log参数起作用），并根据平台选择是否内存对齐（alignment参数起作用）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux has memalign() or posix_memalign()</span></span><br><span class="line"><span class="comment"> * Solaris has memalign()</span></span><br><span class="line"><span class="comment"> * FreeBSD 7.0 has posix_memalign(), besides, early version&#x27;s malloc()</span></span><br><span class="line"><span class="comment"> * aligns allocations bigger than page size at the page boundary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  根据平台选择是否内存对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span>;  <span class="comment">//  进行内存对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memalign(alignment, size, log)  ngx_alloc(size, log)    <span class="comment">//  ngx_alloc(size,log) 不进行内存对齐</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//  ngx_alloc：就是malloc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">// void *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log);  //  内存对齐的malloc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    <span class="keyword">int</span>    err;</span><br><span class="line">    err = <span class="built_in">posix_memalign</span>(&amp;p, alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, err,</span><br><span class="line">                      <span class="string">&quot;posix_memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug3</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;posix_memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (NGX_HAVE_MEMALIGN)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    p = <span class="built_in">memalign</span>(alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug3</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="内存Block分配-ngx-palloc"><a href="#内存Block分配-ngx-palloc" class="headerlink" title="内存Block分配 ngx_palloc"></a>内存Block分配 ngx_palloc</h2><ul>
<li>小块内存分配、大块内存分配</li>
<li>ngx_palloc 考虑了内存对齐<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line"><span class="comment">//  分配小块内存（优先从内存池分配，如果没有，再新开辟ngx_memalign）</span></span><br><span class="line"><span class="comment">//  size：上级要请求的</span></span><br><span class="line"><span class="comment">//  pool-&gt;max block块内空闲内存的上限</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(pool, size, <span class="number">1</span>); <span class="comment">//  指针 ，大小 ，1:对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//  分配大块内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ngx-palloc-small-小块内存分配"><a href="#ngx-palloc-small-小块内存分配" class="headerlink" title="ngx_palloc_small 小块内存分配"></a>ngx_palloc_small 小块内存分配</h3><ul>
<li><p>从操作系统开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用memalign。</p>
</li>
<li><p><strong>效率极高</strong>：如何分配内存：通过移动last指针分配内存。将移出的size内存返回给上级</p>
</li>
<li><p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-55-14.png"></p>
</li>
<li><p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-55-41.png"></p>
</li>
<li><p>ngx_palloc_small</p>
<ul>
<li>先尝试用已有的内存池中拿出size大小的内存块，当内存池里没有可分配的满足size大小的内存块时，再ngx_palloc_block开辟新block块。从block里拿出size大小的内存返回给上级。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line">        <span class="keyword">if</span> (align) &#123;    <span class="comment">//  如果要求对齐</span></span><br><span class="line">            m = <span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT);    <span class="comment">//  内存对齐：把指针调整到平台相关的4/8倍数。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  内存池的空闲内存大于要申请的内存</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            <span class="comment">//  m指针偏移size字节，即内存池给应用程序分配内存</span></span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  如果本block块剩余的不够size，那么顺着p-&gt;d.next向下走到第二个内存块block。</span></span><br><span class="line">        p = p-&gt;d.next;      </span><br><span class="line">    &#125; <span class="keyword">while</span> (p);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  从pool-&gt;current开始 遍历完了 所有的block，也没找到够用的空闲内存</span></span><br><span class="line">    <span class="comment">//  那么就只能新开辟block</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span>(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>ngx_palloc_block<ul>
<li>原有内存池内存不够，分配新的内存块加入内存池<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p, *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (pool-&gt;d.end - (u_char *) pool);   <span class="comment">//  Block大小</span></span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">ngx_memalign</span>(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = (<span class="keyword">ngx_pool_t</span> *) m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span>-&gt;d.end = m + psize;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT);</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  由于进入到这个函数必然意味着之前的block都分配内存失败</span></span><br><span class="line">    <span class="comment">//  所以要把前几个block的fail次数都++;</span></span><br><span class="line">    <span class="comment">//  当一个block了=块分配内存失败次数</span></span><br><span class="line">    <span class="comment">//  当一个block块失败次数&gt;4之后，就认为这块Block的剩余内存已经很少，之后请求小内存时就不从这块Block开始请求</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>ngx_free 释放大块内存<br>小块内存不释放</p>
<h3 id="ngx-palloc-large-大内存块分配"><a href="#ngx-palloc-large-大内存块分配" class="headerlink" title="ngx_palloc_large 大内存块分配"></a>ngx_palloc_large 大内存块分配</h3><ul>
<li><p>从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</p>
</li>
<li><p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-54-56.png"></p>
</li>
<li><p>malloc大块内存用于存储数据；从小内存池申请一块内存用作大内存池头信息；维护大内存池链表；将本次malloc的大块内存全部返回给上级使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>              *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  malloc大块内存；不进行字节对齐</span></span><br><span class="line">    p = <span class="built_in">ngx_alloc</span>(size, pool-&gt;log);     </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  以pool-&gt;large为起始 遍历大内存池头信息节点</span></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//  如果遍历到的这块大内存池节点的头信息的alloc==nullptr</span></span><br><span class="line">        <span class="comment">//  意味着并这个ngx_pool_large_t没有管理一块大内存。</span></span><br><span class="line">        <span class="comment">//  所以直接由他管理</span></span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  为了效率</span></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  向小内存池申请一段内存用作大内存池头信息</span></span><br><span class="line">    large = <span class="built_in">ngx_palloc_small</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;    <span class="comment">//  没申请来就放弃本次操作</span></span><br><span class="line">        <span class="built_in">ngx_free</span>(p);    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  将大内存池头插法插入large起始的链表中</span></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ngx_alloc() 分配大块内存，不进行内存对齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ngx_free()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_free          free</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="大小内存Block的重置-ngx-reset-pool"><a href="#大小内存Block的重置-ngx-reset-pool" class="headerlink" title="大小内存Block的重置 ngx_reset_pool"></a>大小内存Block的重置 ngx_reset_pool</h2><ul>
<li><code>nginx</code>大块内存block通过<code>malloc</code>分配  <ul>
<li>大块内存：通过<code>free</code>释放</li>
</ul>
</li>
<li><code>nginx</code>小内存通过在内存池（的一个小内存块）中移动last指针来实现内存分配<ul>
<li>小块内存：无<code>free</code>释放，只是通过移动last指针来重置</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_reset_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>        *p;   <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;   <span class="comment">//  大内存Block的头信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  大块内存 free掉</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  小块内存 不释放。只是移动指针。</span></span><br><span class="line">        <span class="comment">//  因为从实现方式上来看，就释放不了。我们通过移动last指针来分配内存。可能我们要释放2号内存，但是我们只有last和end的两个指针，且last指向5号内存。</span></span><br><span class="line">        <span class="comment">//  从nginx的功能来看，也无需释放。</span></span><br><span class="line">    <span class="comment">// for (p = pool; p; p = p-&gt;d.next) &#123;</span></span><br><span class="line">    <span class="comment">//     p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);</span></span><br><span class="line">    <span class="comment">//     p-&gt;d.failed = 0;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    p = pool;</span><br><span class="line">    p-&gt;d.last = (u_char*)p+<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=p-&gt;d.next;p;p=p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;d.last = (u_char*)p+<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重置首块内存Block中用于管理所有内存Block的</span></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="释放指定大内存块-ngx-pfree"><a href="#释放指定大内存块-ngx-pfree" class="headerlink" title="释放指定大内存块 ngx_pfree"></a>释放指定大内存块 ngx_pfree</h2><ul>
<li>释放指定大内存块<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_int_t</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_pfree</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="为什么reset-pool中nginx内存池的小内存块不free释放？？"><a href="#为什么reset-pool中nginx内存池的小内存块不free释放？？" class="headerlink" title="为什么reset_pool中nginx内存池的小内存块不free释放？？"></a><strong>为什么reset_pool中nginx内存池的小内存块不free释放？？</strong></h2><ul>
<li>因为没有free小块内存的接口。</li>
<li>所以只能移动last指针<h3 id="1-为什么没free接口"><a href="#1-为什么没free接口" class="headerlink" title="1. 为什么没free接口"></a>1. 为什么没free接口</h3></li>
<li>首先nginx内存池的没办法回收针对某一特定小内存块进行free回收。 <ul>
<li>因为从实现方式上来看，就释放不了。我们通过移动last指针来分配内存。可能我们要释放2号内存，但是我们只有last和end的两个指针，且last指向3号下的free内存。那么如果移动last到2那里然后free，那么就会把3也free掉</li>
<li><blockquote>
<p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-18-47-48.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>因此</strong>nginx<strong>没有提供</strong>free回收小块内存的接口函数</li>
<li>所以重置时我们只能通过移动last指针来表示哪些内存是空闲内存</li>
</ul>
<h3 id="2-为什么移动last可以"><a href="#2-为什么移动last可以" class="headerlink" title="2. 为什么移动last可以"></a>2. 为什么移动last可以</h3><ul>
<li>那么在释放内存时为什么移动last就可以。这样能表明装有没用数据的内存是空闲的，不害怕有用的内存被覆盖吗？</li>
<li>当<code>reset_pool</code>时，不会有有用的内存块。因为我们是短连接。</li>
<li><code>nginx</code>本质：<code>http</code>服务器。<strong>短连接、间歇性。</strong><ul>
<li>client向nginx server发送请求后，nginx处理完请求，并发送完response响应后；即一次服务处理完后，就主动和客户端断开tcp连接，该次连接的资源就都可以释放了。（server就像和client端没见过面一样。之前的东西都不必再保留，一干二净。）</li>
<li><strong>所以，当nginx server 处理完一次请求后，就可以调用<code>ngx_reset_pool</code>，free大块内存；将小块内存的last指针回退，等待下次覆盖。</strong></li>
</ul>
</li>
<li>而<strong>长连接</strong>不论client是否发来请求，server和client是不能断开的。也即处理完请求后，连接也不能断开，资源也不允许释放，直到系统资源耗尽。长连接的这种server应该用SGI STL的二级空间配置器中的内存池。？？？？？？<ul>
<li>长连接举例：<code>http1.1 keep-alive = 60s</code>，即http服务器返回响应后，需等待<code>60s</code>。如果这段时间之内客户端又发来请求，那么重置等待时间。如果没发来请求，那么就断开连接。</li>
</ul>
</li>
<li>以上关于nginx用于短连接的场景我可以理解。不过他为什么不能用于长连接？我只写过短连接的webserver，还没写过长连接的。等写了长连接的server应该就能理解了吧。</li>
<li><strong><a href="https://www.jianshu.com/p/3fc3646fad80">长连接短连接</a></strong></li>
<li><a href="https://www.jianshu.com/p/734ef8e5a712">nginx服务器入门</a></li>
</ul>
<h2 id="nginx内存池和sgi-stl二级空间配置器"><a href="#nginx内存池和sgi-stl二级空间配置器" class="headerlink" title="nginx内存池和sgi stl二级空间配置器"></a>nginx内存池和sgi stl二级空间配置器</h2><ul>
<li>nginx对于小块内存的分配效率绝对比sgi stl二级空间配置器高，因为nginx只需要移动指针。</li>
<li>nginx无法释放小块内存。sgi stl 小块和大块都释放。<ul>
<li>故nginx适用于短连接Web服务器（http服务器）。sgi stl适用于长连接服务器。</li>
<li>？why？</li>
</ul>
</li>
</ul>
<h2 id="内存池外部资源释放"><a href="#内存池外部资源释放" class="headerlink" title="内存池外部资源释放"></a>内存池外部资源释放</h2><h3 id="外部资源信息头"><a href="#外部资源信息头" class="headerlink" title="外部资源信息头"></a>外部资源信息头</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;</span><br><span class="line">    <span class="keyword">void</span>                 *data;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>     <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>   <span class="title">ngx_pool_cleanup_t</span></span></span><br></pre></td></tr></table></figure>

<h3 id="内存池外部资源释放-1"><a href="#内存池外部资源释放-1" class="headerlink" title="内存池外部资源释放"></a>内存池外部资源释放</h3><p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-29-10-59-23.png"></p>
<h4 id="对于cleanup-add的使用有两种方式"><a href="#对于cleanup-add的使用有两种方式" class="headerlink" title="对于cleanup_add的使用有两种方式"></a>对于cleanup_add的使用有两种方式</h4><ul>
<li><ol>
<li>一种是给c-&gt;data开辟一块内存，然后把外部资源拷贝进去。之后destroy中c-&gt;handler(void*p)</li>
</ol>
<ul>
<li><code>ngx_pool_cleanup_t * c = ngx_pool_cleanup_add(pool,sizeof(x))</code></li>
<li>感觉适用于一个这块内存里很多指针管理很多外部资源，可以省去挨个设置外部资源信息头以及回调函数。</li>
</ul>
</li>
<li><ol start="2">
<li>一种是不给c-&gt;data开辟内存，直接让c-&gt;data指向要释放的内存。</li>
</ol>
<ul>
<li><code>ngx_pool_cleanup_t * c = ngx_pool_cleanup_add(pool,0)</code></li>
</ul>
</li>
<li>我觉得在一块申请的内存中由很多指针管理外部资源时，【第一种优于第二种】。<ul>
<li>相较于【第二种不拷贝方法】单独为 每个指针管理的外部资源都设置一个外部资源信息头，以及一个释放的回调函数；不如【第一种方法】只设置一个回调函数和一个信息头。将这些外部资源拷贝到一块内存中，然后将这块内存传入即可。这样就可以用一个信息头，一个回调函数，即可释放多个资源。</li>
</ul>
</li>
</ul>
<h4 id="源码论证"><a href="#源码论证" class="headerlink" title="源码论证"></a>源码论证</h4><ul>
<li>第【1】种<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  结构体</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">ngx_fd_t</span>              fd;</span><br><span class="line">        u_char               *name;</span><br><span class="line">        <span class="keyword">ngx_log_t</span>            *log;</span><br><span class="line">    &#125; <span class="keyword">ngx_pool_cleanup_file_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  为c-&gt;data开辟内存</span></span><br><span class="line">    cln = <span class="built_in">ngx_pool_cleanup_add</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_file_t</span>));</span><br><span class="line">    ....</span><br><span class="line">    cln-&gt;handler = clean ? ngx_pool_delete_file : ngx_pool_cleanup_file;</span><br><span class="line">    <span class="comment">//  将管理的资源地址拷贝到c-&gt;data指向的内存</span></span><br><span class="line">    clnf = cln-&gt;data;</span><br><span class="line">    clnf-&gt;fd = file-&gt;fd;</span><br><span class="line">    clnf-&gt;name = file-&gt;name.data;</span><br><span class="line">    clnf-&gt;log = pool-&gt;log;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  预制的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_pool_delete_file</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data;</span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, c-&gt;log, <span class="number">0</span>, <span class="string">&quot;file cleanup: fd:%d %s&quot;</span>,</span><br><span class="line">                   c-&gt;fd, c-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ngx_delete_file</span>(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ngx_close_file</span>(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第【2】种<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  不申请内存</span></span><br><span class="line">cln = <span class="built_in">ngx_pool_cleanup_add</span>(r-&gt;pool, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (cln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  直接将地址给cln-&gt;data</span></span><br><span class="line">cln-&gt;handler = ngx_http_file_cache_cleanup;</span><br><span class="line">cln-&gt;data = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  预制回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_http_file_cache_cleanup</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_http_cache_t</span>  *c = data;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;updated) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug0</span>(NGX_LOG_DEBUG_HTTP, c-&gt;file.log, <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;http file cache cleanup&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;updating &amp;&amp; !c-&gt;background) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_http_file_cache_free</span>(c, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>cleanup_add功能概述：通过预置回调函数，实现c++中对象析构的功能。也即释放内存。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_pool_cleanup_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    <span class="comment">//  从小内存block中 分配一块内存用作ngx_pool_cleanup_t</span></span><br><span class="line">    c = <span class="built_in">ngx_palloc</span>(p, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  看用户是怎么调用的</span></span><br><span class="line">        <span class="comment">//  size&gt;0 从内存池中申请一块内存。用作之后用户将外部资源拷贝到这里</span></span><br><span class="line">        <span class="comment">//  size=0 不申请内存。用户直接将c-&gt;data = 外部资源地址</span></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span>(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, p-&gt;log, <span class="number">0</span>, <span class="string">&quot;add cleanup: %p&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内存池销毁"><a href="#内存池销毁" class="headerlink" title="内存池销毁"></a>内存池销毁</h3><ul>
<li>先遍历链表执行外部资源的释放操作；再遍历链表执行释放大块内存的操作；再遍历链表重置小块内存Block   </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    <span class="comment">//  遍历外部资源信息头链表， 调用预设置的回调函数handler，释放外部资源。</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;run cleanup: %p&quot;</span>, c);</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;free: %p, unused: %uz&quot;</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历大块内存信息头，释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历小块内存信息头，释放小块内村</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">ngx_free</span>(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><ul>
<li>环境：ubuntu 18.04 ； nginx-1.12.2 ；工具：Source Insigh4.0</li>
<li>指令<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line">gcc -o ngx_testpool ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br></pre></td></tr></table></figure></li>
<li><code>void *memcpy(void *des, const void *src, size_t n)</code><ul>
<li>将src指向的内存中的内容逐字节的拷贝到des指向的内存<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span>* q = &amp;b;	<span class="comment">//  q不能=null！因为是要把p指向的内存的内容拷贝到q的内存里。q如果是null则error</span></span><br><span class="line">	<span class="built_in">memcpy</span>(q, p, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">	cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00000021</span>ACF5F904</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">00000021</span>ACF5F8E4</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ngx_testpool.c<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span><span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *log, <span class="keyword">ngx_err_t</span> err,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//  多个指针</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">    <span class="keyword">char</span> *ptr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">yData</span> <span class="title">yData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler\n&quot;</span>);</span><br><span class="line">    stData *q = (stData*) p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(q-&gt;pfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler_02</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *q = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler_02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. ngx_create_pool 造内存池</span></span><br><span class="line">        <span class="comment">//  第一块内存Block。里面有完整的ngx_pool_t</span></span><br><span class="line">        <span class="comment">// ngx_pool_t::max = min(512 - sizeof(ngx_pool_t) , 4095)     </span></span><br><span class="line">        <span class="keyword">ngx_pool_t</span> *pool = <span class="built_in">ngx_create_pool</span>(<span class="number">512</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(pool == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_create_pool fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 小块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请小块内存</span></span><br><span class="line">        stData *p1 = <span class="built_in">ngx_palloc</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(yData)); <span class="comment">// 从小块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 128 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  小块内存保存的指针管理的外部资源</span></span><br><span class="line">        p1-&gt;ptr = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        p1-&gt;pfile = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        p1-&gt;ptr2 = <span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr2, <span class="string">&quot;hhhh&quot;</span>);</span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span> *c1 = <span class="built_in">ngx_pool_cleanup_add</span>(pool,<span class="built_in"><span class="keyword">sizeof</span></span>(yData));     <span class="comment">//  开辟内存，用于handler传参</span></span><br><span class="line">        c1-&gt;handler = self_handler;</span><br><span class="line">        <span class="built_in">memcpy</span>(c1-&gt;data,p1,<span class="built_in"><span class="keyword">sizeof</span></span>(yData));                                      <span class="comment">//  用户只负责拷贝！！将外部资源拷贝一下到c1-&gt;data。将p1指针指向的内容逐字节拷贝到c-&gt;data指向的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 大块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请大块内存</span></span><br><span class="line">        yData *p2 = <span class="built_in">ngx_palloc</span>(pool, <span class="number">512</span>); <span class="comment">// 从大块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 512 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  外部资源</span></span><br><span class="line">        p2-&gt;ptr = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p2-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span> *c2 = <span class="built_in">ngx_pool_cleanup_add</span>(pool,<span class="number">0</span>);                   <span class="comment">//  不开辟内存，直接让c-&gt;data指向要释放的内存</span></span><br><span class="line">        c2-&gt;handler = self_handler_02;</span><br><span class="line">        c2-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放内存池</span></span><br><span class="line">    <span class="built_in">ngx_destroy_pool</span>(pool); <span class="comment">// 1.调用所有的预置的清理函数 2.释放大块内存 3.释放小块内存池所有内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ gcc -o ngx_testpool.out ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ ./ngx_testpool.out </span><br><span class="line">self_handler_02</span><br><span class="line">free ptr mem!</span><br><span class="line">self_handler</span><br><span class="line">free ptr mem!</span><br><span class="line">free ptr mem!</span><br><span class="line">close file!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存对齐好处"><a href="#内存对齐好处" class="headerlink" title="内存对齐好处"></a>内存对齐好处</h2><ul>
<li>较少cpu的IO次数</li>
<li>内存对齐博客待完善</li>
</ul>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><ul>
<li>gcc -g 生成的可执行文件可以调试</li>
<li>gdb …out   </li>
<li>start 开始一行一行运行</li>
<li>n 下一行</li>
<li>s（step）进入函数</li>
<li>finish 跳出函数</li>
<li>quit 退出</li>
<li>l 当前附近代码</li>
</ul>
<h2 id="nginx内存池不足（我认为）"><a href="#nginx内存池不足（我认为）" class="headerlink" title="nginx内存池不足（我认为）"></a>nginx内存池不足（我认为）</h2><ul>
<li>链表管理<ul>
<li>链表的查找遍历时间复杂度是 O(n)。ngx_pfree 效率不高</li>
</ul>
</li>
<li>小内存块链表，current 问题：<ul>
<li>当遇到密集地分配比较大的小内存场景时，导致已分配结点，分配失败，failed 次数增加。current 指向新的结点，由于是单向链表，前面的结点其实还有足够的空闲空间分配给其它小内存的，导致空闲空间利用率不高。</li>
</ul>
</li>
<li>ngx_reset_pool中没有释放外部资源。需要等到destroy时才可以释放。</li>
<li>ngx_reset_pool中，在重置小块内村的last指针时，有一部分没有重置，造成内存碎片。</li>
</ul>
<h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><ul>
<li>移植之后解决了ngx_reset_pool中没有释放外部资源的问题</li>
<li>解决了reset中last指针的问题。</li>
</ul>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ul>
<li><a href="https://blog.csdn.net/q1449660223/article/details/106094683">堆、栈</a></li>
</ul>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>sgi_stl二级空间配置器</title>
    <url>/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。"><a href="#一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。" class="headerlink" title="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。"></a>一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。</h2><h2 id="二级空间配置器就是-一级空间配置器-基于freelist实现的内存池的结合"><a href="#二级空间配置器就是-一级空间配置器-基于freelist实现的内存池的结合" class="headerlink" title="二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合"></a>二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合</h2><h1 id="SGI-STL-二级空间配置器-原理"><a href="#SGI-STL-二级空间配置器-原理" class="headerlink" title="SGI STL 二级空间配置器 原理"></a>SGI STL 二级空间配置器 原理</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><ul>
<li> <code>template&lt;typename T&gt; class my_allocator&#123;&#125;</code></li>
<li>整体<ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-17-24.png"></li>
</ul>
</li>
<li>_S_chunk_alloc<ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-18-11.png"></li>
</ul>
</li>
</ul>
<h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><ul>
<li>SGI STL包含了一级空间配置器和二级空间配置器，<ul>
<li>其中一级空间配置器allocator采用malloc和free来管理内存，和C++标准库中提供的allocator是一样的，</li>
<li>但其二级空间配置器allocator采用了基于freelist（自由链表）原理的内存池机制实现内存管理。</li>
</ul>
</li>
<li>SGI STL二级空间配置器：线程安全</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) allocator<span class="meta-string">&lt; T &gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) alloc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  一级空间配置器</span></span><br><span class="line">allocator&lt; T &gt;：</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> // 一级空间配置器内存管理类 -- 通过<span class="title">malloc</span>和<span class="title">free</span>管理内</span></span><br><span class="line"><span class="class">存</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//  二级空间配置器</span></span><br><span class="line"><span class="class"><span class="title">alloc</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span> <span class="comment">// 二级空间配置器内存管理类 -- 通过自定义内存池实现内存管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> :</span> <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>

<h2 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h2><ul>
<li><p>内存池粒度信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;       <span class="comment">//  内存对齐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">//  最大块大小   &gt;128就不会放到内存池里了，也即不会用二级空间配置器。会用一级空间配置器  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">//  静态链表的成员个数 _MAX_BYTES/_ALIGN</span></span><br></pre></td></tr></table></figure></li>
<li><p>每一个内存chunk块的头信息</p>
<ul>
<li>chunk：数据块，区块。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自由链表数组。数组的每个成员是静态的_Obj*指针。_STL_VOLATILE是为了保证多线程安全（通过防止线程缓存？多线程中一般堆上和数据段都会加volatile）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;__threads, __inst&gt;::_Obj* __STL_VOLATILE</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::</span><br><span class="line">_S_free_list[_NFREELISTS] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Chunk allocation state</code>. 记录内存<code>chunk</code>块的分配情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  static：类内声明、类外定义。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;         <span class="comment">//   空闲free内存的起始start位置 [</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;           <span class="comment">//   空闲free内存的结束end位置 )       (包括回收的吗？)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;         <span class="comment">//   总共malloc过的内存大小（因为malloc是从堆heap上请求的，所以叫heapsize）</span></span><br><span class="line"><span class="comment">//  类外定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>我认为SGI STL二级空间配置器中的<strong>内存池</strong>，分为<strong>三部分</strong></p>
<ul>
<li>一部分给用户使用</li>
<li>一部分是用户还没使用的，已经形成chunk链表内存池</li>
<li>一部分是还没加入chunk链表内存池的原始空闲内存</li>
</ul>
</li>
</ul>
<h2 id="重要辅助函数"><a href="#重要辅助函数" class="headerlink" title="重要辅助函数"></a>重要辅助函数</h2><ul>
<li>将bytes上调至最邻近的_ALIGN = 8的倍数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分析<ul>
<li>计组复习：<ul>
<li>机器数的解释规则都是补码。也就是计算机里的数都是以补码形式存储的。</li>
<li>补码<ul>
<li>正数：补码=原码=真值</li>
<li>负数：补码=~原码+1<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">枚举变量的取值为花括号内的任意一个值（有且只能有其中一个值），而这个值是<span class="keyword">int</span>型的。</span><br><span class="line">在X86系统中，所以<span class="built_in"><span class="keyword">sizeof</span></span>(_ALIGN) = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) = <span class="number">4</span>，也就是枚举变量的值为<span class="number">4</span></span><br><span class="line">_ALIGN</span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00001000</span></span><br><span class="line">_ALIGN - <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000111</span></span><br><span class="line">~(ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN</span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00001000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span></span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000111</span></span><br><span class="line"></span><br><span class="line">~((<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span> + bytes</span><br><span class="line"><span class="number">000.</span>..| <span class="number">00000111</span>    +<span class="number">0</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001000</span>    +<span class="number">1</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001001</span>    +<span class="number">2</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001111</span>    +<span class="number">8</span></span><br><span class="line"><span class="comment">// -&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00010000</span>    +<span class="number">9</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00010111</span>    +<span class="number">16</span></span><br><span class="line"><span class="comment">// -&gt; 16</span></span><br><span class="line"></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00011000</span>    +<span class="number">17</span></span><br><span class="line"><span class="comment">// -&gt; 24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp; </span><br><span class="line">~((<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">111.</span>..| <span class="number">11111000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>返回位于第几个内存块<ul>
<li>bytes &gt;= 1  内存块号 &gt;= 0<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//  bytes &gt;= 1  内存块号 &gt;= 0</span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">      <span class="comment">//  (bytes + 7)/(ALIGN = 8) - 1。（+7(ALIGN-1)：为了保证12345678位于同一组？</span></span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>][<span class="number">9</span>,<span class="number">16</span>][<span class="number">17</span>,<span class="number">24</span>]</span><br><span class="line">  <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>例子<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> _ALIGN = <span class="number">8</span> &#125;;     <span class="comment">//  4</span></span><br><span class="line"><span class="comment">//  将bytes上调至最邻近的8的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回位于第几个内存块</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);   <span class="comment">//  (bytes + 7)/8  -1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;                    <span class="comment">//  4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;              <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;     <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>) &lt;&lt; endl;                 <span class="comment">//  8    </span></span><br><span class="line">    <span class="comment">//  size_t ：unsigned long long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(_ALIGN) &lt;&lt; endl;                 <span class="comment">//  4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(_ALIGN).<span class="built_in">name</span>() &lt;&lt; endl;          <span class="comment">//  enum &lt;unnamed-enum-_ALIGN&gt;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>((<span class="keyword">size_t</span>)_ALIGN) &lt;&lt; endl;         <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>((<span class="keyword">size_t</span>)_ALIGN).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">//  unsigned __int64</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; _ALIGN &lt;&lt; endl;                         <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _ALIGN<span class="number">-1</span> &lt;&lt; endl;                       <span class="comment">//  7</span></span><br><span class="line">    cout &lt;&lt; ~(_ALIGN - <span class="number">1</span>) &lt;&lt; endl;                  <span class="comment">//  -8</span></span><br><span class="line">    cout &lt;&lt; ((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &lt;&lt; endl;           <span class="comment">//  7</span></span><br><span class="line">    cout &lt;&lt; (~(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &lt;&lt; endl;          <span class="comment">//  18446744073709551606</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">0</span>) &lt;&lt; endl;                 <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">1</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">7</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">8</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">9</span>) &lt;&lt; endl;                 <span class="comment">//  16</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">16</span>) &lt;&lt; endl;                <span class="comment">//  16</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">17</span>) &lt;&lt; endl;                <span class="comment">//  24</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//  cout &lt;&lt; _S_freelist_index(0) &lt;&lt; endl;   bytes至少&gt;=1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">1</span>) &lt;&lt; endl;           <span class="comment">//  0   </span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">7</span>) &lt;&lt; endl;           <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">8</span>) &lt;&lt; endl;           <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">15</span>) &lt;&lt; endl;          <span class="comment">//  1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">16</span>) &lt;&lt; endl;          <span class="comment">//  1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">17</span>) &lt;&lt; endl;          <span class="comment">//  2</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">24</span>) &lt;&lt; endl;          <span class="comment">//  2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h2><ul>
<li>概述：根据n大小，采取相应方式获取内存，并返回。<ul>
<li>n&gt;128<ul>
<li>malloc_alloc::allocate(__n)。同一级空间配置器。开辟后返回</li>
</ul>
</li>
<li>n&lt;128<ul>
<li>根据n大小，借助free从freelist相应元素管理的内存池中取出相应大小内存块。当内存池不存在时，开辟内存池。</li>
<li>对于传入的请求内存大小n，n决定了请求那个freelist成员指向的内存池的内存块。<ul>
<li><code>_Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n)</code></li>
</ul>
</li>
<li>如果相应的<code>freelist</code>成员=nullptr的话，<ul>
<li>调用<code>_S_refill</code>：<code>__ret = _S_refill(_S_round_up(__n));</code><ul>
<li>开辟内存块数=nobjs(20)的内存池，内存池中的每个内存块的大小都是传入的<code>__n</code><ul>
<li><code>char* __chunk = _S_chunk_alloc(__n, __nobjs);</code></li>
</ul>
</li>
<li>_S_refill根据传入的n大小，计算出开辟的内存池应该由哪个freelist成员管理。<ul>
<li><code>__my_free_list = _S_free_list + _S_freelist_index(__n);</code></li>
</ul>
</li>
<li>将内存池挂到freelist相应成员下，</li>
<li>并维护每个空闲内存块之间指向关系。（每个空闲内存块连接在一起组成内存池）</li>
<li>返回第一个内存块。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>freelist[]（自由链表）是一个静态的链表</li>
<li>数组的每个元素指向一个内存池。</li>
<li>同一内存池的chunk内存块的大小一致。</li>
<li>不同内存池的chunk内存块大小不一致。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span>     <span class="comment">//  请求的一块大小为n的空间</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果&gt;128bytes，那么调用malloc_alloc::allocate（同一级空间配置器的allocator的allocate一样)</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);          <span class="comment">//  应当在哪个</span></span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;                            <span class="comment">//  上锁</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;      <span class="comment">//  __RESTRICT线程安全</span></span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//  _S_round_up(n)（向上取8的倍数）。根据n的大小，计算出应该开辟多大内存。</span></span><br><span class="line">      <span class="comment">//  _S_refill：在相应freelist成员下开辟内存池，且内存池的每个内存块大小都为__n向上取8的倍数。并返回内存池的第一个内存块。</span></span><br><span class="line">      <span class="comment">//   如何确定将内存池接在哪个freelist成员下？通过_S_freelist_index(n)计算出。</span></span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));            <span class="comment">//  开辟内存池</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-07-18.png"></p>
<h2 id="S-refill"><a href="#S-refill" class="headerlink" title="_S_refill"></a>_S_refill</h2><ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-08-25.png"></li>
<li>__n：内存池里每个内存块的大小。并且可以借助n计算出该内存池应该接在那个freelist成员下。</li>
<li>概述：当freelist的某个元素obj*=nullptr时，会调用_S_refill，(<code>_S_refill</code>向下调用<code>_S_chunk_alloc</code>)开辟内存池，并返回内存池的第一个内存块。并且<code>_S_refill</code>内维护从原始内存中申请来的内存池中每个内存块chunk节点之间的指向关系。<ul>
<li><code>_S_chunk_alloc</code>：分配指定大小的内存池</li>
<li>静态链表：把每个chunk块通过Obj*里的指针连接起来</li>
</ul>
</li>
<li>allocate函数中调用_S_refill。n是传入的参数，代表allocate请求一个多大的内存块。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns an object of size __n, and optionally adds to size __n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that __n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)  <span class="comment">//  n是一个chunk块的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  分配指定大小的内存池    __nobjs：chunk内存块数量 ；这里的 __n：每个chunk内存块大小。</span></span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  __nobjs：申请到的chunk块数量。当只申请到一个时，直接返回该内存块给上一级使用。无需建立各个chunk的连接关系，无需挂载到相应的freelist成员下。（因为只有一个）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);  </span><br><span class="line">    </span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);     <span class="comment">//  根据内存块大小求出内存池应该在由freelist第几个成员管理（指向）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  静态链表：把每个chunk块通过Obj*里的指针连接起来</span></span><br><span class="line">    <span class="comment">//  每个内存块，有一部分的内存时union联合体Obj，里面有一个Obj*指针，负责连接每个空闲内存块。</span></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      __result = (_Obj*)__chunk;</span><br><span class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);    <span class="comment">//  __n：一个内存块的大小（因为第一个内存块要分配出去）</span></span><br><span class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">        __current_obj = __next_obj;                             </span><br><span class="line">        __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);          <span class="comment">//   维护内存块间的连接  char* 因此+__n是偏移n个bytes +n是为了一次跑一个chunk块</span></span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;                               <span class="comment">//   空闲内存块数为0?</span></span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);   <span class="comment">//  返回第一个内存块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="S-chunk-alloc"><a href="#S-chunk-alloc" class="headerlink" title="_S_chunk_alloc"></a>_S_chunk_alloc</h2><ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-20-41-44.png"></li>
<li><code>allocate(size_t n) -&gt; _S_refill(size_t n) -&gt; _S_chunk_alloc(size_t __size__,int &amp;nobjs)</code></li>
<li>将所有备用内存池都应用到，哪怕只剩下<code>8bytes</code>（最小的块就是<code>8bytes</code>，将这些用不到的小内存块挂载到相应的<code>freelist</code>成员下。）。</li>
<li><code>chunk_alloc</code>里可能<code>malloc</code>，也可能不<code>malloc</code>。<ul>
<li><code>malloc</code>：备用内存(当前<code>start-end</code>)不够</li>
<li>不<code>malloc</code>：备用内存(当前<code>start-end</code>)本身就够<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></li>
</ul>
</li>
<li>从 【备用空闲内存池申请】 或者 【操作系统中开辟】 内存池。这个内存池中，每个<code>chunk</code>大小为<code>size</code> bytes，数量为<code>_nobjs</code>。将所申请的这一整个池子的首地址返回给上一级–_S_refill。在_S_refill中，负责将该池子中的每个chunk块建立起链表关系，并挂载到相应free-list成员下。并且_S_refill负责把一个size大小的chunk返回给上一级allocate。（用户调用请求函数）。</li>
<li>而在_S_chunk_alloc中，对于内存池子是从备用内存池请求，还是再从操统中开辟，又分以下情况讨论<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">    <span class="keyword">if</span>(_bytes_left &gt;= total_bytes)&#123; </span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> result;  <span class="comment">//  total大小内存块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(__bytes_left &gt;= __size)&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> result;  <span class="comment">//  尽量return大点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 后半+的这个是为了malloc越来越大</span></span><br><span class="line">      <span class="comment">// 计算要malloc多少内存s</span></span><br><span class="line">      bytes_to_get = <span class="number">2</span>*__total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// malloc内存</span></span><br><span class="line">      _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">            <span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">            <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                          </span><br><span class="line">              <span class="comment">//  头插法</span></span><br><span class="line">              <span class="comment">//  start_free头插接入_S_free_list + _S_freelist_index(__bytes_left)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      _S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">      _S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">      <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;            <span class="comment">//  本次总共需要请求的内存大小</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//  __default_alloc_template&lt;__threads, __inst&gt; 从开始到现在，请求的剩余空闲的的内存大小。不包括回收的。只是开辟的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;                <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">        __result = _S_start_free;                       <span class="comment">//  __result 作为返回内存首地址</span></span><br><span class="line">        _S_start_free += __total_bytes;                 <span class="comment">//  移动_S_start_free</span></span><br><span class="line">        <span class="keyword">return</span>(__result);                               <span class="comment">//  [result , _S_start_free)  作为请求结果返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;                <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get =                         <span class="comment">//  当剩余的空闲内存不够时，需要向操统malloc内存。这是计算出需要malloc内存的大小（至少malloc出来要求内存的(__total_bytes)两倍）</span></span><br><span class="line">	  <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                         <span class="comment">//  </span></span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//  向操统malloc内存</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;                       <span class="comment">//  malloc失败</span></span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">	    _Obj* __p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="comment">//  从别的freelist成员管理的原始备用内存池中借用至少size大小的chunk块</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size;</span><br><span class="line">                 __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES;</span><br><span class="line">                 __i += (<span class="keyword">size_t</span>) _ALIGN) &#123;</span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  都没有时，尝试下allcoate来补救</span></span><br><span class="line">	    _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        _S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><ul>
<li><p>什么时候调用chunk_alloc?当某个freelist成员的内存池为空时。（没分配过内存池或者内存池耗尽）</p>
</li>
<li><p><strong>调用上下文</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">allocate中：<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">_Obj* __RESTRICT __result </span>= *__my_free_list;</span><br><span class="line"><span class="comment">//  当某个freelist成员的内存池为空时。（没分配过内存池或者内存池耗尽） 调用__S_chunk_alloc</span></span><br><span class="line"><span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">  __ret = _S_refill(_S_round_up(__n));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//  消耗内存池</span></span><br><span class="line">  *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">  __ret = __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __ret;</span><br><span class="line"></span><br><span class="line">S_refill中</span><br><span class="line"><span class="number">1.</span> <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line"><span class="number">2.</span> 连接得到的chunk块</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>整体<blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-21-13-13.png"></p>
</blockquote>
</li>
<li>我将图中形成链表的自由（空闲）内存节点们称为内存池。</li>
<li>将没有建立链表连接的称为原始内存（或者叫备用内存池）。</li>
</ul>
<hr>
<ul>
<li>大体：<code>start-free==0</code>时，就是一点 <strong>备用的 空闲的</strong> 内存也没有了<ul>
<li>备用内存：<ul>
<li>优先是只进行了malloc的空闲原始内存，也就是没有被形成freelist某成员内存池的</li>
<li>如果没有，其次是已经参与形成内存链表池的空闲chunk块。</li>
</ul>
</li>
</ul>
</li>
<li>当没有备用内存(<code>bytes_left==0</code>)时，正常从操统中malloc内存<ul>
<li>一小块返回给用户使用，</li>
<li>一部分返回给上一级加工成内存池（把chunk块之间连起来）</li>
<li>一部分在 <code>[_start_free</code> 和 <code>_end_free)</code>之间，用作备用内存（备用内存池/原始内存）。</li>
</ul>
</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-09-38.png"></li>
</ul>
<hr>
<ul>
<li>当有备用内存时<ul>
<li>start和free之间malloc的原始内存，还没参与形成内存池</li>
<li> [start，free) &gt; size (nobjs&gt;1)，则将这块内存挂给相应freelist成员</li>
<li>图中为空闲内存有160bytes，而上层申请16*20bytes内存<br><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-10-52.png"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>条件同上<ul>
<li>start和free之间malloc的原始内存，还没参与形成内存池</li>
<li>nobjs = [start，free) / size = 1，则将这内存块返回。（因为只有一个，所以不必挂载形成内存池） </li>
<li>图中空闲内存为160bytes，而上层申请16*128bytes内存。<ul>
<li>返回1个128bytes内存块</li>
</ul>
</li>
<li>用户又接着申请32bytes</li>
<li>用户接着申请128bytes</li>
</ul>
</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-08-16.png"></li>
<li><blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-08-39-50.png"></p>
</blockquote>
</li>
<li>第三张红圈的例子：解释如下。<ul>
<li>只返回一个<code>128bytes</code>块时，<code>freelist</code>的<code>128bytes</code>成员仍是空，因为返回的这一个直接就用作请求结果了，并没空闲内存块。</li>
<li>当上层(allocate)再次请求128Bytes时，_S_refill调用<code>chunk = _S_chunk_alloc(size_t __size = 128, int&amp; __nobjs = 20)</code>。由于剩下<code>__bytes_left = 32bytes &lt; size = 128bytes</code>。故进入<code>else</code>。</li>
<li>剩余的<code>32bytes</code>被<code>freelist</code>的<code>32bytes</code>成员管理（因为这个<code>32bytes</code>对于128bytes的chunk块来说无用）。再开辟<code>bytes_to_get</code>的内存。移动<code>free_start</code>。接下来的操作同一开始malloc内存。（再循环调用<code>chunk_alloc...</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>malloc失败<ul>
<li>从别的freelist成员已经形成链表的内存池中，拿出一块chunk，给本次请求用<blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-10-58-25.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h2><ul>
<li>功能概述：归还p指向的、大小为n的内存块，还给内存池链表。（n用于计算归还的该块内存应该在哪个freelist成员管理的内存之中）<ul>
<li>将p头插入法插入内存池链表中。</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-32-12.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)  <span class="comment">//  n&gt;128 同一级空间配置器</span></span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);  <span class="comment">//  找到相应freelist成员</span></span><br><span class="line">      _Obj* __q = (_Obj*)__p;       <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="malloc-alloc-template"><a href="#malloc-alloc-template" class="headerlink" title="__malloc_alloc_template"></a>__malloc_alloc_template</h2><ul>
<li><p>辅助__malloc_alloc_template的类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  申请nbytes。如果空间不足，则释放nbytes</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  释放p</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>malloc_alloc:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="malloc-alloc-allocate"><a href="#malloc-alloc-allocate" class="headerlink" title="malloc_alloc::allocate"></a>malloc_alloc::allocate</h3><ul>
<li>功能概述<ul>
<li>分配nbytes成功 返回result</li>
<li>分配失败，那么就调用预制好的_S_oom_malloc，释放nbytes空间，给result<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>调用上下文<ul>
<li>在没有空间（不能malloc）的情况下，又必须进行malloc。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_S_chunk_alloc()&#123;</span><br><span class="line">  malloc = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 没有空间 却又只能allcoate</span></span><br><span class="line">  _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">  _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="malloc-alloc-S-oom-malloc"><a href="#malloc-alloc-S-oom-malloc" class="headerlink" title="malloc_alloc::_S_oom_malloc"></a>malloc_alloc::_S_oom_malloc</h3><ul>
<li>功能概述：循环调用用户预制的回调函数，以期解决内存不够的问题，好拿出nbyte内存。</li>
<li>oom：out of memory 内存耗尽</li>
<li>用户先前设置好回调函数<code>__malloc_alloc_oom_handler</code><ul>
<li>设置：那么这个回调函数必须实现 释放其他内存，使得可以给当前请求分配内存的功能。否则会陷入死循环，直到可以malloc内存。<code>return</code>malloc的内存。</li>
<li>没设置：直接抛异常 throw bad_alloc<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __my_malloc_handler)();   <span class="comment">//  用于接收回调函数</span></span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;   <span class="comment">//  设置回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<span class="comment">//  如果用户之前没设置回调函数，那么直接抛异常</span></span><br><span class="line">        (*__my_malloc_handler)();                           <span class="comment">//  调用回调函数</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);                       <span class="comment">//  </span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="reallocate"><a href="#reallocate" class="headerlink" title="reallocate"></a>reallocate</h2><ul>
<li>功能概述<ul>
<li>为指针p重新分配指向的空间，大小为new_sz。并返回这块新内存的地址。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">reallocate</span>(<span class="keyword">void</span>* __p,size_t__old_sz,<span class="keyword">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  old new都&gt;128byets，那么用的就应当是和一级空间配置器一样的方法malloc</span></span><br><span class="line">    <span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));   <span class="comment">//  重新分配内存。释放p地址内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果即将分配的chunk块大小一致，那么不必，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="keyword">return</span>(__p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重新从内存池中申请new_size大小内存，并拷贝数据到新申请来的内存里</span></span><br><span class="line">    __result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">    __copy_sz = __new_sz &gt; __old_sz? __old_sz : __new_sz;</span><br><span class="line">    <span class="built_in">memcpy</span>(__result, __p, __copy_sz); <span class="comment">//  拷贝数据</span></span><br><span class="line">    <span class="built_in">deallocate</span>(__p, __old_sz);  <span class="comment">//  将p指向的内存还给内存池链表</span></span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="经典内存池优点"><a href="#经典内存池优点" class="headerlink" title="经典内存池优点"></a>经典内存池优点</h2><ul>
<li><p>C/C++下内存管理是让几乎每一个程序员头疼的问题，分配足够的内存、追踪内存的分配、在不需要的时候释放内存——这个任务相当复杂。而直接使用系统调用malloc/free、new/delete进行内存分配和释放，有以下弊端：<br>利用默认的内存管理函数new/delete或malloc/free在堆上分配和释放内存会有一些额外的开销。</p>
</li>
<li><p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。</p>
</li>
<li><p>默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。 </p>
</li>
<li><p>可见，如果应用程序频繁地在堆上分配和释放内存，则会导致性能的损失。并且会使系统中出现大量的内存碎片，降低程序性能，降低内存的利用率。</p>
</li>
<li><p>默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池则可以获得更好的性能。</p>
</li>
<li><p>内存池（memory pool)是代替直接调用malloc/free、new/delete进行内存管理的常用方法，当我们申请内存空间时，首先到我们的内存池中查找合适的内存块，而不是直接向操作系统申请，优势在于：</p>
<ul>
<li>比malloc/free进行内存申请/释放的方式快;</li>
<li>不会产生或很少产生堆碎片;</li>
<li>可避免内存泄漏;</li>
</ul>
</li>
<li><p>普通内存池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象。</span><br><span class="line"></span><br><span class="line">（2）每个对象连同一个指向下一个对象的指针一起构成一个内存节点（Memory Node）。各个空闲的内存节点通过指针来形成一个链表，链表的每一个内存节点都是一块可供分配的内存空间。</span><br><span class="line"></span><br><span class="line">（3）某个内存节点一旦分配出去，就将从链表中去除。</span><br><span class="line"></span><br><span class="line">（4）一旦释放了某个内存节点的空间，又将该节点重新加入自由内存节点链表。</span><br><span class="line"></span><br><span class="line">（5）如果一个内存块的所有内存节点分配完毕，若程序继续申请新的对象空间，则会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。</span><br><span class="line"></span><br><span class="line">经典内存池的实现过程大致如上面所述，其形象化的过程如下图所示： </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SGI-STL-二级空间配置器优点"><a href="#SGI-STL-二级空间配置器优点" class="headerlink" title="SGI STL 二级空间配置器优点"></a>SGI STL 二级空间配置器优点</h2><ul>
<li>对于每一个字节数的chunk块分配，都是返回给用户一个使用的内存块，并给freelist一个内存池，，并留有另一部分作为备用内存池。这个备用可以给当前的字节数freelist成员使用，也可以给其他字节数的freelist成员使用。</li>
<li>对于备用内存池划分chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的内存块再次分配出去，备用内存池使用的一滴不剩。</li>
<li>当指定bytes字节数内存分配失败以后，有一个异常处理的过程，bytes -&gt; 128字节所有的chunk块进行查看，如果哪个freelist成员下的内存链表池中有chunk块，借一个出去。<ul>
<li>如果操作失败，会调用<code>_S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get)</code>来malloc内存；<ul>
<li><code>allocate</code>里面通过调用<code>oom_malloc</code>，来调用预先设置好的回调函数<code>__malloc_alloc_oom_handler</code>。用于处理<code>malloc</code>失败的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缺点-我认为"><a href="#缺点-我认为" class="headerlink" title="缺点 我认为"></a>缺点 我认为</h2><ul>
<li>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：<ul>
<li>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它 会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造 成很多内部碎片；</li>
<li>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过 程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全 是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有： <ul>
<li>1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失 败；</li>
<li>2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请 不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">灼夭. 10:11:37</span><br><span class="line">xdm 请问大家个问题。二级空间配置器真的解决了内存碎片的问题吗。我觉得虽然解决了外部碎片的问题，但好像又会导致产生很多内部碎片呀？还是说虽然会产生内部碎片，但是无所谓？对程序性能、内存利用率也没啥太大影响？</span><br><span class="line"></span><br><span class="line">灼夭. 10:11:51</span><br><span class="line">Alex💡 10:23:52</span><br><span class="line">灼夭.  </span><br><span class="line">xdm 请问大家个问题。二级空间配置器真的解决了内存碎片的问题吗。我觉得虽然解决了外部碎片的问题，但好像又会导致产生很多内部碎片呀？还是说虽然会产生内部碎片，但是无所谓？对程序性能、内存利用率也没啥太大影响？</span><br><span class="line">@灼夭. 我之前看侯捷讲的说法是，二级配置器可以很好的解决频繁调用malloc带来的时间消耗以及额外内存消耗，但是与此同时，内存池分配的小块内存都是8的倍数，也会存在一定的内部碎片，但相对于malloc而言，其性能还是好的。</span><br><span class="line"></span><br><span class="line">灼夭. 10:27:53</span><br><span class="line">Alex💡  </span><br><span class="line">@灼夭. 我之前看侯捷讲的说法是，二级配置器可以很好的解决频繁调用malloc带来的时间消耗以及额外内存消耗，但是与此同时，内存池分配的小块内存都是8的倍数，也会存在一定的内部碎片，但相对于malloc而言，其性能还是好的。</span><br><span class="line">@Alex💡 哦哦哦 多谢xd</span><br><span class="line"></span><br><span class="line">Alex💡 10:28:17</span><br><span class="line">没事儿。</span><br></pre></td></tr></table></figure>


<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p><a href="https://blog.csdn.net/fdk_lcl/article/details/89482835">https://blog.csdn.net/fdk_lcl/article/details/89482835</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">round - 必应词典</span><br><span class="line">美[raʊnd]英[raʊnd]</span><br><span class="line">n.旋转；巡视；一连串；绕圈</span><br><span class="line">adv.环绕；附近；各处；向四面</span><br><span class="line">prep.环绕；在…周围；始终</span><br><span class="line">v.绕过；拐过；使成圆形；把…四舍五入</span><br><span class="line">adj.圆的；球形的；肥胖的；弧形的</span><br><span class="line">网络回合；轮；圆形的</span><br><span class="line"></span><br><span class="line">round up 向上取整</span><br></pre></td></tr></table></figure>








<ul>
<li>计组<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>计算机里的数都是补码形式，因为CPU只会做加法，数的补码形式就可以用加法实现减法运算，进而以加法完成所有的运算。至于数以什么码的形式输入和输出，编程人员是可以控制的。</span><br><span class="line"><span class="number">2.</span>计算机里数码的位数是<span class="number">2</span>的正整数次方，比如<span class="number">4</span>位、<span class="number">8</span>位、<span class="number">16</span>位，因为CPU及周边电路一旦制成，一次处理数据位数、总线位数、各种寄存器位数就都固定下来，都是<span class="number">2</span>的正整数次方位，这样选择的理由很多，可参照有关资料了解。</span><br><span class="line"><span class="number">3.</span>一个<span class="number">8</span>位的补码数，它表示数的范围是<span class="number">-128</span>~+<span class="number">127</span>，原码表示数的范围是<span class="number">-127</span>~+<span class="number">127</span>，反码表示数的范围是<span class="number">-127</span>~+<span class="number">127</span>，就是因为最高位是符号位，实际数位只有<span class="number">7</span> 位。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存碎片是问题吗？"><a href="#内存碎片是问题吗？" class="headerlink" title="内存碎片是问题吗？"></a>内存碎片是问题吗？</h2><ul>
<li>截</li>
</ul>
<hr>
<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Default node allocator.</span></span><br><span class="line"><span class="comment">// With a reasonable compiler, this should be roughly as fast as the</span></span><br><span class="line"><span class="comment">// original STL class-specific allocators, but with less fragmentation.</span></span><br><span class="line"><span class="comment">// Default_alloc_template parameters are experimental and MAY</span></span><br><span class="line"><span class="comment">// DISAPPEAR in the future.  Clients should just use alloc for now.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Important implementation properties:</span></span><br><span class="line"><span class="comment">// 1. If the client request an object of size &gt; _MAX_BYTES, the resulting</span></span><br><span class="line"><span class="comment">//    object will be obtained directly from malloc.</span></span><br><span class="line"><span class="comment">// 2. In all other cases, we allocate an object of size exactly</span></span><br><span class="line"><span class="comment">//    _S_round_up(requested_size).  Thus the client has enough size</span></span><br><span class="line"><span class="comment">//    information that we can return the object to the proper free list</span></span><br><span class="line"><span class="comment">//    without permanently losing part of the object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The first template parameter specifies whether more than one thread</span></span><br><span class="line"><span class="comment">// may use this allocator.  It is safe to allocate an object from</span></span><br><span class="line"><span class="comment">// one instance of a default_alloc and deallocate it with another</span></span><br><span class="line"><span class="comment">// one.  This effectively transfers its ownership to the second one.</span></span><br><span class="line"><span class="comment">// This may have undesirable effects on reference locality.</span></span><br><span class="line"><span class="comment">// The second parameter is unreferenced and serves only to allow the</span></span><br><span class="line"><span class="comment">// creation of multiple default_alloc instances.</span></span><br><span class="line"><span class="comment">// Node that containers built on different allocator instances have</span></span><br><span class="line"><span class="comment">// different types, limiting the utility of this approach.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size __n, and optionally adds to size __n free list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_THREADS</span></span><br><span class="line">    <span class="keyword">static</span> _STL_mutex_lock _S_node_allocator_lock;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It would be nice to use _STL_auto_lock here.  But we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need the NULL check.  And we do need a test whether</span></span><br><span class="line">    <span class="comment">// threads have actually been started.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125;</span><br><span class="line">            ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size __n, and optionally adds to size __n free list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_THREADS</span></span><br><span class="line">    <span class="keyword">static</span> _STL_mutex_lock _S_node_allocator_lock;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It would be nice to use _STL_auto_lock here.  But we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need the NULL check.  And we do need a test whether</span></span><br><span class="line">    <span class="comment">// threads have actually been started.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125;</span><br><span class="line">            ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  申请nbytes。如果空间不足，则释放nbytes</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  释放p</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>SGI_STL</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx内存池移植代码</title>
    <url>/2022/04/30/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<h1 id="OOP移植内存池"><a href="#OOP移植内存池" class="headerlink" title="OOP移植内存池"></a>OOP移植内存池</h1><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="/2022/04/30/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%A7%BB%E6%A4%8D/2022-05-01-09-17-05.png"></p>
<h2 id="ngx-mem-pool-h"><a href="#ngx-mem-pool-h" class="headerlink" title="ngx_mem_pool.h"></a>ngx_mem_pool.h</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> nginx_memory_pool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nginx_memory_pool</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> u_char = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ngx_uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  小内存池（Block）头信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char* last;                           <span class="comment">//  可用内存起始</span></span><br><span class="line">    u_char* end;                            <span class="comment">//  内存末尾</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* next;                       <span class="comment">//  小内存Block链表</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;           <span class="comment">//  分配内存是否成功</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  大内存池（Block）头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* next;     <span class="comment">//   大内存Block的头信息链表</span></span><br><span class="line">    <span class="keyword">void</span>* alloc;                <span class="comment">//   指向申请的大内存Block</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span>* data)</span></span>;     <span class="comment">//  回调函数；负责清理外部资源</span></span><br><span class="line"><span class="comment">//  外部资源的头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_t</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;      <span class="comment">//  处理外部资源的回调函数</span></span><br><span class="line">    <span class="keyword">void</span>* data;                         <span class="comment">//  传给handler的参数</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* next;           <span class="comment">//  外部资源头信息链表。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  管理整个内存池的头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;                <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;              <span class="comment">//  大块内存和小块内存的分界线。p-&gt;max：一个小块Block块内最多能分配多大的内存。其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095              </span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* current;                    <span class="comment">//  指向第一块提供小块内存分配的小块内存Block地址</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;                <span class="comment">//  大内存Block头信息的链表入口</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* cleanup;            <span class="comment">//  外部资源的头信息链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  32位 4   64位 8</span></span><br><span class="line"><span class="comment">//  小块内存考虑字节对齐时的单位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_ALIGNMENT = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);    <span class="comment">/* platform word */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  默认一个页面大小：4KB</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ngx_pagesize = <span class="number">4096</span>;  <span class="comment">//  1024B = 1KB</span></span><br><span class="line"><span class="comment">//  ngx小块内存block里可分配的最大空间。（也即不能超过一个页）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MAX_ALLOC_FROM_POOL = ngx_pagesize - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  默认创建的内存池大小为16K</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_DEFAULT_POOL_SIZE = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//  对齐为16的整数倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_POOL_ALIGNMENT = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将d上调至a的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align(d,a) ( ((d)+(a-1)) &amp; ~(a-1) )</span></span><br><span class="line"><span class="comment">//  把指针p调整到a的临近倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                   \</span></span><br><span class="line"><span class="meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memset(buf, c, n)     (void) memset(buf, c, n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ngx小块内存池最小的size调整成 NGX_POOL_ALIGNMENT 的倍数</span></span><br><span class="line"><span class="comment">//  保证至少能有一个ngx_pool_t头信息的大小 如 sizeof(ngx_pool_t)【15】 + 2*8 = 31    调整至32</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MIN_POOL_SIZE = <span class="built_in">ngx_align</span>((<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>)), NGX_POOL_ALIGNMENT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* OOP 移植nginx内存池</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ngx_mem_pool</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  构造函数，创建内存池。</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span>(<span class="keyword">size_t</span> size = NGX_DEFAULT_POOL_SIZE);</span><br><span class="line">    <span class="comment">//  析构函数，释放内存池</span></span><br><span class="line">    ~<span class="built_in">ngx_mem_pool</span>();</span><br><span class="line">    <span class="comment">//  考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  不考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_pnalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  调用ngx_palloc，并初始化为0.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_pcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  释放大块内存block。ngx不提供释放小块内存的接口。原因见博客</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_pfree</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</span><br><span class="line">    <span class="comment">//  内存重置函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">//  添加回调清理操作函数</span></span><br><span class="line">    <span class="function"><span class="keyword">ngx_pool_cleanup_t</span>* <span class="title">ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  指向nginx内存池的入口指针，一个内存池只有一个pool。即第一个创建的内存block里的ngx_pool_t。pool_的指向不会改变，始终是第一个，因为只有第一个有。会发生改变的是它指向的current，next之类的东西。</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* pool_;                      </span><br><span class="line">    <span class="comment">//  尝试从内存池中拿出size大小内存。内存池不够则从操作系统开辟。align=1意味着需要内存对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span>;</span><br><span class="line">    <span class="comment">//  从操作系统开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用ngx_memalign。在unix平台下ngx_memalign就是ngx_alloc</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  从操作系统开辟大块内存，挂载到某个已有的大块头信息下。（或再从内存池申请一块用作大内存block头信息）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;           </span><br><span class="line">    <span class="comment">//  销毁内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span><span class="params">()</span></span>;           </span><br><span class="line">    <span class="comment">//  创建size大小的内存池  （每个小内存block的大小均为size）</span></span><br><span class="line">    <span class="function"><span class="keyword">ngx_pool_t</span>* <span class="title">ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//    void* ngx_alloc(size_t size);  //  从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="ngx-mem-pool-cpp"><a href="#ngx-mem-pool-cpp" class="headerlink" title="ngx_mem_pool.cpp"></a>ngx_mem_pool.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;ngx_mem_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//  创建size大小的内存池  （每个小内存block的大小均为size）</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span>* <span class="title">ngx_mem_pool::ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pool_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_t</span>*&gt;(<span class="built_in">malloc</span>(size));</span><br><span class="line">    <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;d.last = (u_char*)pool_ + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    pool_-&gt;d.end = (u_char*)pool_ + size;</span><br><span class="line">    pool_-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    pool_-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    pool_-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;current = pool_;</span><br><span class="line">    pool_-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">    pool_-&gt;cleanup = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pool_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  考虑字节对齐，从内存池申请size大小的内存。下层有可能从操统开辟新内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool_-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  尝试从内存池中拿出size大小内存。内存池不够则从操作系统开辟。align=1意味着需要内存对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc_small</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char* m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p;</span><br><span class="line">    p = pool_-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align) &#123;</span><br><span class="line">            m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT));  <span class="comment">//  ??</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>)(p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操作系统malloc开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用ngx_memalign。在unix平台下ngx_memalign就是ngx_alloc。（就是对malloc的浅封装）</span></span><br><span class="line"><span class="keyword">void</span>* ngx_mem_pool :: <span class="built_in">ngx_palloc_block</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char* m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p, * new_m;</span><br><span class="line"></span><br><span class="line">    psize = (<span class="keyword">size_t</span>)(pool_-&gt;d.end - (u_char*)pool_);</span><br><span class="line"></span><br><span class="line">    m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">malloc</span>(psize));   <span class="comment">//  ngx_alloc底层就是malloc</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new_m = (<span class="keyword">ngx_pool_t</span>*)m;</span><br><span class="line"></span><br><span class="line">    new_m-&gt;d.end = m + psize;</span><br><span class="line">    new_m-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    new_m-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT));</span><br><span class="line">    new_m-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool_-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool_-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = new_m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操作系统malloc开辟大块内存，挂载到某个已有的大块头信息下。（或再从内存池申请一块用作大内存block头信息）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc_large</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (large = pool_-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_large_t</span>*&gt;(<span class="built_in">ngx_palloc_small</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool_-&gt;large;</span><br><span class="line">    pool_-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</span></span><br><span class="line"><span class="comment">// void* ngx_mem_pool::ngx_alloc(size_t size)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     void* p = malloc(size);</span></span><br><span class="line"><span class="comment">//     return p;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  释放大块内存block。ngx不提供释放小块内存的接口。原因见博客</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_pfree</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* l;</span><br><span class="line">    <span class="keyword">for</span> (l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_pnalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool_-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用ngx_palloc，并初始化为0.</span></span><br><span class="line"><span class="keyword">void</span>* ngx_mem_pool :: <span class="built_in">ngx_pcalloc</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  从内存池申请内存</span></span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">ngx_palloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;    <span class="comment">//  清0操作</span></span><br><span class="line">        <span class="built_in">ngx_memzero</span>(p, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  内存重置函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_reset_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  自己加的：释放外部资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">ngx_pool_cleanup_t</span>* c = pool_-&gt;cleanup; c; c = c-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler&amp;&amp;c-&gt;data) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">            c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line">            c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">ngx_pool_large_t</span>* l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重置小块内存</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p = pool_;</span><br><span class="line">    p-&gt;d.last = (u_char*)p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = p-&gt;d.next; p; p = p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;d.last = (u_char*)p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for (p = pool_; p; p = p-&gt;d.next) &#123;</span></span><br><span class="line">    <span class="comment">//    p-&gt;d.last = (u_char*)p + sizeof(ngx_pool_t);</span></span><br><span class="line">    <span class="comment">//    p-&gt;d.failed = 0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//  重置pool_成员</span></span><br><span class="line">    pool_-&gt;current = pool_;</span><br><span class="line">    pool_-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  销毁内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_destroy_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p, * n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放外部资源</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool_-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放小块内村</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool_, n = pool_-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  申请外部资源信息头、添加回调清理操作函数</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_cleanup_t</span>* <span class="title">ngx_mem_pool::ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* c;</span><br><span class="line"></span><br><span class="line">    c = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_cleanup_t</span>*&gt;(<span class="built_in">ngx_palloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line">    c-&gt;next = pool_-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ngx_mem_pool::<span class="built_in">ngx_mem_pool</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    pool_ = <span class="built_in">ngx_create_pool</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_mem_pool::~<span class="built_in">ngx_mem_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~ngx_mem_pool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">ngx_destroy_pool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="test-mem-pool-cpp"><a href="#test-mem-pool-cpp" class="headerlink" title="test_mem_pool.cpp"></a>test_mem_pool.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;ngx_mem_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//  多个指针</span></span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    FILE* pfile;</span><br><span class="line">    <span class="keyword">char</span>* ptr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">yData</span> <span class="title">yData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler\n&quot;</span>);</span><br><span class="line">    stData* q = (stData*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(q-&gt;pfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler_02</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* q = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler_02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. ngx_create_pool 造内存池</span></span><br><span class="line">        <span class="comment">//  第一块内存Block。里面有完整的ngx_pool_t</span></span><br><span class="line">        <span class="comment">// ngx_pool_t::max = min(512 - sizeof(ngx_pool_t) , 4095)     </span></span><br><span class="line">        <span class="function">ngx_mem_pool <span class="title">mem_pool</span><span class="params">(<span class="number">512</span>)</span></span>;</span><br><span class="line">    <span class="comment">//  2. 小块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请小块内存</span></span><br><span class="line">        stData* p1 = <span class="keyword">static_cast</span>&lt;stData*&gt;(mem_pool.<span class="built_in">ngx_palloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(yData))); <span class="comment">// 从小块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc %d bytes fail\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(yData));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  小块内存保存的指针管理的外部资源</span></span><br><span class="line">        p1-&gt;ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        p1-&gt;pfile = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        p1-&gt;ptr2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr2, <span class="string">&quot;goodbye world&quot;</span>);</span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span>* c1 = mem_pool.<span class="built_in">ngx_pool_cleanup_add</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(yData));     <span class="comment">//  开辟内存，用于handler传参</span></span><br><span class="line">        c1-&gt;handler = self_handler;</span><br><span class="line">        <span class="built_in">memcpy</span>(c1-&gt;data, p1, <span class="built_in"><span class="keyword">sizeof</span></span>(yData));                                      <span class="comment">//  用户只负责拷贝！！将外部资源拷贝一下到c1-&gt;data。将p1指针指向的内容逐字节拷贝到c-&gt;data指向的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 大块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请大块内存</span></span><br><span class="line">        yData* p2 = <span class="keyword">static_cast</span>&lt;yData*&gt;(mem_pool.<span class="built_in">ngx_palloc</span>(<span class="number">512</span>)); <span class="comment">// 从大块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 512 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  外部资源</span></span><br><span class="line">        p2-&gt;ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p2-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span>* c2 = mem_pool.<span class="built_in">ngx_pool_cleanup_add</span>(<span class="number">0</span>);                   <span class="comment">//  不开辟内存，直接让c-&gt;data指向要释放的内存</span></span><br><span class="line">        c2-&gt;handler = self_handler_02;</span><br><span class="line">        c2-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  重置内存池</span></span><br><span class="line">        <span class="comment">//  mem_pool.ngx_reset_pool();</span></span><br><span class="line">        <span class="comment">//  std::cout &lt;&lt; &quot;reset over&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  释放内存池</span></span><br><span class="line">        <span class="comment">//   ~mem_pool() 调用mem_pool.ngx_destroy_pool(); // 1.调用所有的预置的清理函数 2.释放大块内存 3.释放小块内存池所有内存</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul>
<li>环境 ubuntu / VS均可<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/my_nginx$ ./test_mem_pool.out </span><br><span class="line">~ngx_mem_pool</span><br><span class="line">self_handler_02</span><br><span class="line">free ptr mem!</span><br><span class="line">self_handler</span><br><span class="line">free ptr mem!</span><br><span class="line">free ptr mem!</span><br><span class="line">close file!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><ul>
<li>VS Debug下出现<code>heap corruption detected</code><ul>
<li>测试代码问题：添加外部资源时的大小不对。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>pcap解析</title>
    <url>/2022/05/12/pcap%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="WireShark抓包结构"><a href="#WireShark抓包结构" class="headerlink" title="WireShark抓包结构"></a>WireShark抓包结构</h1><p><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-17-12-43-33.png"></p>
<h1 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h1><ul>
<li>报文封装结构<ul>
<li>网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</li>
<li><blockquote>
<p><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-16-58-46.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>pcap文件结构<ul>
<li><blockquote>
<p><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-16-15-33.png"></p>
</blockquote>
</li>
</ul>
</li>
<li>例子<ul>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-17-12-52.png"></li>
</ul>
</li>
</ul>
<h2 id="Pcap-Header"><a href="#Pcap-Header" class="headerlink" title="Pcap Header"></a>Pcap Header</h2><ul>
<li>pcap文件头，占24Bytes，分为7个字段。</li>
<li>Magic(4Bytes)：0x D4 C3 B2 A1代表小端序 0x A1 B2 C3 D4代表大端序</li>
<li>Major(2Bytes)：当前文件的主要版本号，一般为0x0002</li>
<li>Minor(2Bytes)：当前文件次要版本号，一般为0x0004</li>
<li>ThisZone(4Bytes)：当地的标准时间，如果用的GMT为0则全0，一般全0</li>
<li>SigFigs(4Bytes)：时间戳的精度，一般为全零</li>
<li>SnapLen(4Bytes)：最大的存储长度，该值设置所抓获的数据包的最大长度。</li>
<li>LinkType(4Bytes)：链路类型。解析数据包首先要判断它的LinkType，所以这个值很重要。一般的值为1，即以太网</li>
</ul>
<p><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-13-00-07.png"></p>
<ul>
<li>本pcap文件中<ul>
<li>Magic：小端序</li>
<li>SnapLen：抓获的数据包的最大长度为0x00040000：4*65536 bytes</li>
<li>LinkTypes ：0x 00000001：以太网类型</li>
</ul>
</li>
</ul>
<h2 id="Packet-Header"><a href="#Packet-Header" class="headerlink" title="Packet Header"></a>Packet Header</h2><ul>
<li>数据包头可以有多个，每个数据包头后面都跟着真正的数据包。数据包头则依次为：时间戳（秒）、时间戳（微妙）、抓包长度和实际长度，依次各占4个字节。以下是Packet Header的4个字段含义</li>
<li>Timestamp(4Bytes)：时间戳高位，精确到seconds，这是Unix时间戳。捕获数据包的时间一般是根据这个值</li>
<li>Timestamp(4Bytes)：时间戳低位，能够精确到microseconds</li>
<li>Caplen(4Bytes)：当前数据区的长度，即抓取到的数据帧长度，由此可以得到下一个数据帧的位置。</li>
<li>Len(4Bytes)：离线数据长度，网路中实际数据帧的长度，一般不大于Caplen，多数情况下和Caplen值一样<br><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-16-11-18.png"></li>
<li>本图中<ul>
<li>Timestamp：<ul>
<li>Unix 时间戳是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数</li>
<li>unix时间戳高位：0x6279C37B<ul>
<li>1652147067 / 31536000 = 52.389239821156773211567732115677年</li>
<li>1970+52=2022。零142天</li>
<li>2022-05-10 09:44:27</li>
</ul>
</li>
<li>unix时间戳低位：0x0009EDB4</li>
</ul>
</li>
<li>抓取到的数据帧Packet长度<ul>
<li>Caplen：0x00000042。packet data的长度是 4*16+2=66 Bytes</li>
</ul>
</li>
<li>离线数据长度： <ul>
<li>Len：0x00000042。网络中实际数据帧长度<h2 id="Packet-Data"><a href="#Packet-Data" class="headerlink" title="Packet Data"></a>Packet Data</h2></li>
</ul>
</li>
</ul>
</li>
<li>packet header中的caplen就是说得packet data的长度。pcap文件中各个捕获的数据帧之间没有人为写入的间隔标志。packet data部分的格式就是标准的网络协议格式<br><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-15-18-47-40.png"></li>
</ul>
<h2 id="WireShark对比"><a href="#WireShark对比" class="headerlink" title="WireShark对比"></a>WireShark对比</h2><ul>
<li>WireShark只留下了packet data。</li>
<li>直接打开裸的原始pcap文件<ul>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-17-12-52.png"></li>
</ul>
</li>
<li>WireShark解析后的<ul>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-17-38-41.png"></li>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-17-40-46.png"></li>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-12-17-41-15.png"></li>
</ul>
</li>
</ul>
<h2 id="静态解析pcap"><a href="#静态解析pcap" class="headerlink" title="静态解析pcap"></a>静态解析pcap</h2><ul>
<li>解析packet_header ，获取时间<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::unique_ptr;</span><br><span class="line"><span class="keyword">using</span> std::for_each;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  先不用c++异常了。直接assert</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">file</span>(<span class="keyword">const</span> string &amp; name,<span class="keyword">int</span> flag)</span><br><span class="line">        :_name(name),_flag(flag),<span class="built_in">is_mmap</span>(<span class="literal">false</span>),_ptr(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  打开文件</span></span><br><span class="line">        _fd = <span class="built_in">open</span>(_name.<span class="built_in">c_str</span>(),_flag);</span><br><span class="line">        <span class="keyword">if</span>(_fd==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="built_in">assert</span>(_fd!=<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  获取文件信息块</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">stat</span>(_name.<span class="built_in">c_str</span>(),&amp;_st);</span><br><span class="line">        <span class="built_in">assert</span>(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!is_mmap)&#123;</span><br><span class="line">            <span class="built_in">set_mmap</span>();</span><br><span class="line">            is_mmap = <span class="literal">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取大小</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _st.st_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取文件信息块</span></span><br><span class="line">    <span class="function">struct stat <span class="title">getStat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _st;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read_file_from_begin</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_mmap)&#123;</span><br><span class="line">            <span class="built_in">set_mmap</span>();</span><br><span class="line">            is_mmap = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        for_each(_ptr,_ptr+len,[](<span class="keyword">unsigned</span> <span class="keyword">char</span> x)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,x);</span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">read_file_from_end</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_mmap)&#123;</span><br><span class="line">            <span class="built_in">set_mmap</span>();</span><br><span class="line">            is_mmap = <span class="literal">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        for_each(_ptr+_st.st_size-len,_ptr+_st.st_size,[](<span class="keyword">unsigned</span> <span class="keyword">char</span> x)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>,x);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取相应位置指针</span></span><br><span class="line">    <span class="function">u_char * <span class="title">get_ptr_from_begin</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">u_char * <span class="title">get_ptr_from_end</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ptr + _st.st_size - len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  建立文件映射到内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_mmap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_flag==O_RDONLY)&#123;</span><br><span class="line">            _ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>,_st.st_size,PROT_READ,MAP_SHARED,_fd,<span class="number">0</span>);    </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(_flag==O_RDWR)&#123;</span><br><span class="line">            _ptr = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">mmap</span>(<span class="literal">NULL</span>,_st.st_size,PROT_READ|PROT_WRITE,MAP_SHARED,_fd,<span class="number">0</span>);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  判断映射成功/失败</span></span><br><span class="line">        <span class="built_in">assert</span>(_ptr!=MAP_FAILED);</span><br><span class="line">        <span class="comment">//  映射之后就是对共享内存操作 而非文件了。所以关闭fd</span></span><br><span class="line">        <span class="keyword">if</span>(_fd!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(_fd);</span><br><span class="line">            _fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">file</span>()&#123;</span><br><span class="line">        <span class="comment">//  关闭文件</span></span><br><span class="line">        <span class="keyword">if</span>(_fd!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(_fd);</span><br><span class="line">            _fd = <span class="number">-1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  解除映射</span></span><br><span class="line">        <span class="keyword">if</span>(is_mmap)&#123;</span><br><span class="line">            <span class="built_in">munmap</span>(_ptr,_st.st_size);</span><br><span class="line">            _ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _fd;            <span class="comment">//  文件描述符</span></span><br><span class="line">    <span class="keyword">const</span> string _name; <span class="comment">//  文件名</span></span><br><span class="line">    <span class="keyword">int</span> _flag;          <span class="comment">//  打开权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> _<span class="title">st</span>;</span>    <span class="comment">//  文件信息结构体</span></span><br><span class="line">    <span class="keyword">bool</span> is_mmap;       <span class="comment">//  是否建立了映射</span></span><br><span class="line">    u_char *_ptr;         <span class="comment">//  文件映射到内存指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  pcap文件头、占24个Bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_header</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _magic;             <span class="comment">//  大小端序   //  4个字节</span></span><br><span class="line">    <span class="keyword">uint16_t</span> _major;             <span class="comment">//  版本号</span></span><br><span class="line">    <span class="keyword">uint16_t</span> _minor;             <span class="comment">//  版本号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _this_zone;         <span class="comment">//  当地的标准时间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _sig_fig;           <span class="comment">//  时间戳精度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _snap_len;          <span class="comment">//  抓获数据包的最大长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _link_type;         <span class="comment">//  链路类型</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pcap_header</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">pcap_header</span>(u_char* p)</span><br><span class="line">        :_magic(*(<span class="keyword">uint32_t</span>*)p),_major(*(<span class="keyword">uint16_t</span>*)(p+<span class="number">4</span>)),_minor(*(<span class="keyword">uint16_t</span>*)(p+<span class="number">6</span>)),_this_zone(*(<span class="keyword">uint32_t</span>*)(p+<span class="number">8</span>))</span><br><span class="line">        ,_sig_fig(*(<span class="keyword">uint32_t</span>*)(p+<span class="number">12</span>)),_snap_len(*(<span class="keyword">uint32_t</span>*)(p+<span class="number">16</span>)),_link_type(*((<span class="keyword">uint32_t</span>*)(p+<span class="number">20</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">is_little</span>())&#123;</span><br><span class="line">            <span class="built_in">change_to_little</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_little</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _magic == <span class="number">0xa1b2c3d4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  大端转小端</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change_to_little</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _major = <span class="built_in">ntohs</span>(_major);</span><br><span class="line">        _minor = <span class="built_in">ntohs</span>(_minor);</span><br><span class="line">        _this_zone = <span class="built_in">ntohl</span>(_this_zone);</span><br><span class="line">        _sig_fig = <span class="built_in">ntohl</span>(_sig_fig);</span><br><span class="line">        _snap_len = <span class="built_in">ntohl</span>(_snap_len);</span><br><span class="line">        _link_type = <span class="built_in">ntohl</span>(_link_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  调试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">is_little</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_magic);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04x\n&quot;</span>,_major);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%04x\n&quot;</span>,_minor);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_this_zone);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_sig_fig);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_snap_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_link_type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  packet文件头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_header</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _time_h;            <span class="comment">//  unix时间戳高位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _time_l;</span><br><span class="line">    <span class="keyword">uint32_t</span> _cap_len;           <span class="comment">//  packet_data长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _len;               <span class="comment">//  离线数据长度，网路中实际数据帧的长度。一般等于capture_len</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">packet_header</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">packet_header</span>(u_char *p , <span class="keyword">bool</span> is_little)</span><br><span class="line">        :_time_h(*(<span class="keyword">uint32_t</span>*)(p)),_time_l(*(<span class="keyword">uint32_t</span>*)(p+<span class="number">4</span>)),_cap_len(*(<span class="keyword">uint32_t</span>*)(p+<span class="number">8</span>)),_len(*(<span class="keyword">uint32_t</span>*)(p+<span class="number">12</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is_little)&#123;</span><br><span class="line">            <span class="built_in">change_to_little</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change_to_little</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _time_h = <span class="built_in">ntohl</span>(_time_h);</span><br><span class="line">        _time_l = <span class="built_in">ntohl</span>(_time_l);</span><br><span class="line">        _cap_len = <span class="built_in">ntohl</span>(_cap_len);</span><br><span class="line">        _len = <span class="built_in">ntohl</span>(_len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  调试代码</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;header&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_time_h);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_time_l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_cap_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%08x\n&quot;</span>,_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_data</span>&#123;</span></span><br><span class="line">    u_char * _ptr;               <span class="comment">//  指向packet_data内容</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _len;               <span class="comment">//  packet_data长度</span></span><br><span class="line">    <span class="built_in">packet_data</span>(u_char *p,<span class="keyword">uint32_t</span> len,<span class="keyword">bool</span> is_little)</span><br><span class="line">        :_ptr(p),_len(len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!is_little)&#123;</span><br><span class="line">                <span class="built_in">change_to_little</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">packet_data</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change_to_little</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;change to little&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pcap_file</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> file&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pcap_file</span>(<span class="keyword">const</span> string &amp; name,<span class="keyword">int</span> flag)</span><br><span class="line">        :<span class="built_in">file</span>(name,flag),_parse_len(<span class="number">0</span>)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  解析文件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parse_file</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">parse_pacp_header</span>();</span><br><span class="line">        <span class="keyword">while</span>(_parse_len &lt; <span class="built_in">getSize</span>())&#123;</span><br><span class="line">            <span class="built_in">parse_packet_header</span>();</span><br><span class="line">            <span class="built_in">parse_packet_data</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> vector&lt;packet_header&gt;&amp; <span class="title">get_packets_header</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _vec_header;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  解析pcap_header</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parse_pacp_header</span><span class="params">()</span></span>&#123;</span><br><span class="line">        u_char *p = <span class="built_in">get_ptr_from_begin</span>(_parse_len);</span><br><span class="line">        _pc_header = <span class="built_in">pcap_header</span>(p);                                    <span class="comment">//  记录pcap头</span></span><br><span class="line">        _is_little = _pc_header.<span class="built_in">is_little</span>();                            <span class="comment">//  是否小端</span></span><br><span class="line">        _parse_len += _pcap_header_len;                                 <span class="comment">//  维护长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  解析packet_header</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parse_packet_header</span><span class="params">()</span></span>&#123;</span><br><span class="line">        u_char *p = <span class="built_in">get_ptr_from_begin</span>(_parse_len);</span><br><span class="line">        _vec_header.<span class="built_in">emplace_back</span>(<span class="built_in">packet_header</span>(p,_is_little));           <span class="comment">//  记录packet头</span></span><br><span class="line">        _parse_len += _packet_header_len;                                <span class="comment">//  维护长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  解析packet_data</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parse_packet_data</span><span class="params">()</span></span>&#123;</span><br><span class="line">        u_char *p = <span class="built_in">get_ptr_from_begin</span>(_parse_len);                      </span><br><span class="line">        <span class="keyword">uint32_t</span> data_len = _vec_header[_vec_header.<span class="built_in">size</span>()<span class="number">-1</span>]._cap_len;</span><br><span class="line">        _vec_data.<span class="built_in">emplace_back</span>(<span class="built_in">packet_data</span>(p,data_len,_is_little));     <span class="comment">//  记录packet data</span></span><br><span class="line">        _parse_len += data_len;                                         <span class="comment">//  维护长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  是否小端</span></span><br><span class="line">    <span class="keyword">bool</span> _is_little;</span><br><span class="line">    <span class="comment">//  pcap_header  , packet_header , packet_data </span></span><br><span class="line">    pcap_header _pc_header;</span><br><span class="line">    vector&lt;packet_header&gt; _vec_header;</span><br><span class="line">    vector&lt;packet_data&gt; _vec_data;</span><br><span class="line">    <span class="comment">//  已经解析完的文件长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _parse_len;</span><br><span class="line">    <span class="comment">//  常量                   </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> _pcap_header_len = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> _packet_header_len = <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_packet_time</span><span class="params">(<span class="keyword">const</span> vector&lt;packet_header&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">        <span class="keyword">time_t</span> t = vec[i]._time_h;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;<span class="built_in">ctime</span>(&amp;t)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">pcap_file <span class="title">pf</span><span class="params">(<span class="string">&quot;./day3.pcap&quot;</span>,O_RDONLY)</span></span>;</span><br><span class="line">    pf.<span class="built_in">parse_file</span>();                                                <span class="comment">//  解析文件</span></span><br><span class="line">    <span class="keyword">const</span> vector&lt;packet_header&gt; &amp;vec = pf.<span class="built_in">get_packets_header</span>();     <span class="comment">//  获取packet header</span></span><br><span class="line">    <span class="built_in">show_packet_time</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>       Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">27</span> <span class="number">2022</span></span><br><span class="line"><span class="number">1</span>       Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">27</span> <span class="number">2022</span></span><br><span class="line"><span class="number">2</span>       Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">27</span> <span class="number">2022</span></span><br><span class="line"><span class="number">3</span>       Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">27</span> <span class="number">2022</span></span><br><span class="line"><span class="number">4</span>       Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">27</span> <span class="number">2022</span></span><br><span class="line">...</span><br><span class="line"><span class="number">50</span>      Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">28</span> <span class="number">2022</span></span><br><span class="line"><span class="number">51</span>      Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">28</span> <span class="number">2022</span></span><br><span class="line"><span class="number">52</span>      Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">28</span> <span class="number">2022</span></span><br><span class="line"><span class="number">53</span>      Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">28</span> <span class="number">2022</span></span><br><span class="line"><span class="number">54</span>      Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">28</span> <span class="number">2022</span></span><br><span class="line"><span class="number">55</span>      Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">28</span> <span class="number">2022</span></span><br><span class="line"><span class="number">56</span>      Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">28</span> <span class="number">2022</span></span><br><span class="line"><span class="number">57</span>      Tue May <span class="number">10</span> <span class="number">09</span>:<span class="number">44</span>:<span class="number">28</span> <span class="number">2022</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="大小端重申"><a href="#大小端重申" class="headerlink" title="大小端重申"></a>大小端重申</h1><ul>
<li><p>无论文件本身如何大端小端，程序从文件中识别表示一个变量的字节时 都是按照小端顺序（先识别高地址，再识别低地址）来识别文件中存储的字节序列的。因此，如果文件中的字节序列为大端序列，则程序识别起来就会与预期不符；为小端序列，则相符。</p>
</li>
<li><p>unsigned int val = 0x12345678</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>小端模式</th>
<th>大端模式</th>
</tr>
</thead>
<tbody><tr>
<td>0x4000</td>
<td>0x78</td>
<td>0x12</td>
</tr>
<tr>
<td>0x4001</td>
<td>0x56</td>
<td>0x34</td>
</tr>
<tr>
<td>0x4002</td>
<td>0x34</td>
<td>0x56</td>
</tr>
<tr>
<td>0x4003</td>
<td>0x12</td>
<td>0x78</td>
</tr>
</tbody></table>
</li>
<li><p>读入内存的数据为大端模式（文件或者对方发送的字节的存储方式为大端模式），程序则识别为0x78563412，不合预期。</p>
</li>
<li><p>读入内存的数据为小端模式（文件或者对方发送的字节的存储方式为小端模式），程序则识别为0x12345678，符合预期。</p>
</li>
<li><p>因此，对于大端模式，应当将变量a调转一下字节序列，转化为小端模式。这样程序识别时就可以符合预期。</p>
</li>
<li><p>探究读取方式和大小端序列的影响</p>
</li>
<li><p>两种读取数据方式（无论a是什么类型）：</p>
<ul>
<li>赋值：<ul>
<li>int a = pSrc-&gt;a;   //  ptr指向文件映射到的内存中的一个结构体。结构体中有变量a。 </li>
<li>或者 int a = *pSrca;   //  pa指向文件映射到的内存中 a变量字节的位置</li>
</ul>
</li>
<li>memcpy 直接拷贝字节<ul>
<li>void *memcpy(void *<strong>restrict</strong> __dest, const void *<strong>restrict</strong> __src, size_t __n)</li>
<li>memcpy(&amp;a,pSrc,4); </li>
</ul>
</li>
</ul>
</li>
<li><p>无论什么读取方式，无论变量a是什么类型，如果文件中pSrc处的字节为 d4 c3 b2 a1，那么 局部变量a的值都是 0xa1b2c3d4。</p>
<ul>
<li><strong>a变量在内存中的实际字节仍然是 d4 c3 b2 a1，但是程序识别时是按照小端序列进行识别的。实际识别出来是0xa1b2c3d4。所以在输出或者比较或者读的时候，变量a的值都是0xa1b2c3d4</strong>。</li>
</ul>
</li>
<li><p>部分代码</p>
<ul>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-26-10-05-35.png"></li>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-26-09-58-41.png"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  pcap文件头、占24个Bytes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcap_header</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _magic;             <span class="comment">//  大小端序   //  4个字节</span></span><br><span class="line">    <span class="keyword">char16_t</span> _major;             <span class="comment">//  版本号</span></span><br><span class="line">    <span class="keyword">uint16_t</span> _minor;             <span class="comment">//  版本号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _this_zone;         <span class="comment">//  当地的标准时间</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _sig_fig;           <span class="comment">//  时间戳精度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _snap_len;          <span class="comment">//  抓获数据包的最大长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> _link_type;         <span class="comment">//  链路类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> PCAP_HEADER_LEN = <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">pcap_header</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">pcap_header</span>(u_char* p)</span><br><span class="line">        <span class="comment">// :_magic(*(uint32_t*)p),_major(*(char16_t*)(p+4)),_minor(*(uint16_t*)(p+6)),_this_zone(*(uint32_t*)(p+8))</span></span><br><span class="line">        <span class="comment">// ,_sig_fig(*(uint32_t*)(p+12)),_snap_len(*(uint32_t*)(p+16)),_link_type(*((uint32_t*)(p+20)))</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;_magic,p,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;memcpy赋值方式（字节拷贝）  magic = %08x\n&quot;</span>,_magic);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;magic==0xa1b2c3d4? &quot;</span> &lt;&lt;(_magic==<span class="number">0xa1b2c3d4</span>)&lt;&lt;endl;</span><br><span class="line">        _magic = (*(<span class="keyword">uint32_t</span>*)p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=赋值方式（变量赋值）  magic = %08x\n&quot;</span>,_magic);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;magic==0xa1b2c3d4? &quot;</span> &lt;&lt;(_magic==<span class="number">0xa1b2c3d4</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;_major,p+<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;memcpy赋值方式（字节拷贝）  _major = %04x\n&quot;</span>,_major);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot; major==0x0200? &quot;</span> &lt;&lt;(_major==<span class="number">0x0200</span>)&lt;&lt;endl;</span><br><span class="line">        _major = (*(<span class="keyword">char16_t</span>*)(p+<span class="number">4</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=赋值方式（变量赋值）  _major = %04x\n&quot;</span>,_major);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;major==0x0200? &quot;</span> &lt;&lt;(_major==<span class="number">0x0200</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;_minor,p+<span class="number">6</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;memcpy赋值方式（字节拷贝）  _minor = %04x\n&quot;</span>,_minor);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;minor==0x0400? &quot;</span>&lt;&lt;(_minor==<span class="number">0x0400</span>)&lt;&lt;endl;</span><br><span class="line">        _minor = (*(<span class="keyword">uint16_t</span>*)(p+<span class="number">4</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;=赋值方式（变量赋值）  _minor = %04x\n&quot;</span>,_minor);</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;minor==0x0400? &quot;</span> &lt;&lt;(_minor==<span class="number">0x0400</span>)&lt;&lt;endl;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="Ethernet协议"><a href="#Ethernet协议" class="headerlink" title="Ethernet协议"></a>Ethernet协议</h2><ul>
<li>（yi ther nait）</li>
<li><a href="https://www.cnblogs.com/cxuanBlog/p/14600398.html">数据链路层</a></li>
<li>数据链路层协议有：<ul>
<li>Ethernet以太网协议 </li>
<li>IEEE802.3协议 </li>
<li>PPP协议 </li>
<li>HDLC协议</li>
</ul>
</li>
<li>如今局域网里最常见的以太帧，是Ethernet II。如今大多数的TCP/IP应用（如HTTP、FTP、SMTP、POP3等）都是采用Ethernet II帧承载<h3 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h3></li>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-17-12-38-54.png"></li>
</ul>
<table>
<thead>
<tr>
<th>Inter Frame Gap</th>
<th>前同步码</th>
<th>帧开始定界符</th>
<th>目的mac地址（DMac）</th>
<th>源mac地址 (SMac)</th>
<th>类型(Type)</th>
<th>数据(Payload)</th>
<th>校验（FCS）</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;=12</td>
<td>7</td>
<td>1</td>
<td>6</td>
<td>6</td>
<td>2</td>
<td>46 ~ 1500</td>
<td>4</td>
</tr>
</tbody></table>
<ul>
<li>所以，在使用**Ethernet II协议时，数据链路层中，帧的长度范围为[64bytes , 1518bytes]**（6+6+2+x+4）</li>
</ul>
<h4 id="链路层各字段"><a href="#链路层各字段" class="headerlink" title="链路层各字段"></a>链路层各字段</h4><ul>
<li>DMAC：目的MAC地址，IPV4为6字节，该字段标识帧的接收者</li>
<li>SMAC：源MAC地址，IPV4为6字节，该字段标识帧的发送者</li>
<li>Type：协议类型。标识出了链路直接封装的协议类型<ul>
<li>DMAC，SMAC，TYPE在一些书上被称为以太网帧头</li>
</ul>
</li>
<li>Payload：数据字段<ul>
<li>Payload的最小长度必须为46 bytes以保证帧长（链路层的帧长）至少为64bytes；如果填入该字段的信息少于46 bytes，该字段须填充为64 bytes。</li>
<li>Payload的最大长度为1500 bytes。</li>
<li>以太帧的长度必须为整数字节，因此真的负载长度不足整数字节，需要插入填充字段以保证数据帧的长度为整数字节。</li>
</ul>
</li>
<li>FCS：帧校验序列FCS是为接收者提供判断是否传输错误的一种方法，如果发现错误，丢弃此帧。<ul>
<li>FCS只是通用叫法，具体的FCS还可以细分多种校验方法。在以太帧中，FCS通常采用循环冗余码校验CRC</li>
</ul>
</li>
<li>各type值对应协议（对应数据链路层的上一层：网络层所采用的协议）<ul>
<li>0x0800    Internet Protocol (IP) [RFC894]</li>
<li>0x0801    X.75 Internet</li>
<li>0x0805    X.25 Level 3</li>
<li>0x0806    Address Resolution Protocol (ARP)[RFC7042]</li>
</ul>
</li>
<li>发现 Wireshark 展现给我们的帧中没有校验字段：<ul>
<li>这是因为有时校验和会由网卡计算，这时wireshark抓到的本机发送的数据包的校验和都是错误的，所以默认关闭了WireShark自己的校验。</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/yetugeng/article/details/100514693">wireshark展示的帧去掉了物理层的字段们以及数据链路层的FCS字段</a>：<ul>
<li>在物理层上网卡要先去掉前导同步码和帧开始定界符，然后对帧进行CRC检验，如果帧校验和错，就丢弃此帧。如果校验和正确，就判断帧的目 的硬件地址是否符合自己的接收条件（目的地址是自己的物理硬件地址、广播地址、可接收的多播硬件地址等），如果符合，就将帧交“设备驱动程序”做进一步处 理。这时我们的抓包软件才能抓到数据，因此，抓包软件抓到的是去掉前导同步码、帧开始分界符、FCS之外的数据，</li>
</ul>
</li>
</ul>
<h4 id="物理层各字段"><a href="#物理层各字段" class="headerlink" title="物理层各字段"></a>物理层各字段</h4><ul>
<li>帧间隙：每个以太帧之间都要有帧间隙（Inter Frame Gap），即每发完一个帧后要等待一段时间才能再发另外一个帧，以便让帧接收者对接收的帧做必要的处理（如调整缓存的指针、更新计数、通知对报文进行处理等等）。在以太网标准中规定最小帧间隙是12个字节，其数据为全1。对于个别的接口，可减少到64(GE)或40比特(10GE)，其他的接口都不应该小于12字节。</li>
<li>前同步码：以太网标准中规定前导码为10101010 10101010 10101010 10101010 10101010 10101010 10101010（二进制），共7字节。</li>
<li>帧开始定界符：以太网标准中规定帧开始定界符为10101011（二进制），共1字节。</li>
</ul>
<h4 id="wireShark"><a href="#wireShark" class="headerlink" title="wireShark"></a>wireShark</h4><ul>
<li>wireshark抓到的是去除了物理层，以及数据链路层的FCS。只留下了 DMac,SMac,Type，以及Payload<ul>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-17-13-34-26.png"></li>
</ul>
</li>
<li>pcap文件同上<ul>
<li><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-17-13-39-02.png"></li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://blog.csdn.net/weixin_39447690/article/details/100062453">一字节的变量没必要大小端转换</a></li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="/2022/05/12/pcap%E8%A7%A3%E6%9E%90/2022-05-25-22-27-25.png"><br><a href="https://blog.csdn.net/u010599211/article/details/116696069">https://blog.csdn.net/u010599211/article/details/116696069</a><br><a href="https://www.luhalu.cn/message/network/1052">https://www.luhalu.cn/message/network/1052</a></p>
<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>ARP是个独立的三层协议，并不需要IP协议封装，而是直接生成自己的报文，到达数据链路层后，由数据链路层协议进行封装，一般是以太网协议。封装的过程，就是在ARP报文的前面加上以太网帧头，再加上4字节的冗余校验码结尾，校验码用于检验数据传输是否出现损坏。<br><a href="https://blog.csdn.net/weixin_46027505/article/details/106440848">https://blog.csdn.net/weixin_46027505/article/details/106440848</a><br><a href="https://zhuanlan.zhihu.com/p/399661455">https://zhuanlan.zhihu.com/p/399661455</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>sgi_stl二级空间配置器移植代码</title>
    <url>/2022/04/30/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="sgi-stl-内存池"><a href="#sgi-stl-内存池" class="headerlink" title="sgi_stl 内存池"></a>sgi_stl 内存池</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><ul>
<li><code>template&lt;typename T&gt; class my_allocator&#123;&#125;</code><br><img src="/2022/04/30/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-20-40-33.png"><br><img src="/2022/04/30/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-20-41-44.png"></li>
</ul>
<h2 id="OOP封装"><a href="#OOP封装" class="headerlink" title="OOP封装"></a>OOP封装</h2><ul>
<li>对外接口<ul>
<li>allocate、deallocate、reallocate、construct、destroy<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 移植SGI STL二级空间配置器源码</span></span><br><span class="line"><span class="comment">* 不同于nginx内存池，二级空间配置器中使用到的内存池需要注意多线程问题</span></span><br><span class="line"><span class="comment">* nginx内存池，可以一个线程创建一个内存池</span></span><br><span class="line"><span class="comment">* 而二级空间配置器，是用来给容器使用的，如vector对象。而一个vector对象很有可能在多个线程并发使用</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 移植成功！一个线程安全的二级空间配置器 my_allocator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//  一级空间配置器 将对象构造和内存开辟分开</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first_level_my_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		T* p = <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T)*size);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; _val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (p) <span class="built_in">T</span>(_val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; rval)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (p) <span class="built_in">T</span>(std::<span class="built_in">move</span>(rval));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="comment">//  预制的回调函数 _S_oom_malloc -&gt; __malloc_alloc_oom_handler</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//  尝试分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);	<span class="comment">//  尝试释放nbytes内存，返回给result</span></span><br><span class="line">		<span class="keyword">return</span> __result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">free</span>(__p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新分配new_sz大小内存 </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">		<span class="keyword">return</span> __result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//  用户通过这个接口来预制自己的回调函数。用以释放内存来解决内存不足的问题</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">void</span></span> (*__old)() = __malloc_alloc_oom_handler;</span><br><span class="line">		__malloc_alloc_oom_handler = __f;</span><br><span class="line">		<span class="keyword">return</span>(__old);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  my_allocator中用到的__malloc_alloc_template中的两个函数和一个成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		__my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) &#123; <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); &#125;</span><br><span class="line">		(*__my_malloc_handler)();</span><br><span class="line">		__result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">		<span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		__my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) &#123; <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); &#125;</span><br><span class="line">		(*__my_malloc_handler)();</span><br><span class="line">		__result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">		<span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*__malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">using</span> malloc_alloc = __malloc_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  二级空间配置器 对外接口为allocate、deallocate、reallocate、construct、destroy</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> _Newfirst = T;</span><br><span class="line">	<span class="keyword">using</span> _From_primary = my_allocator;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">(<span class="keyword">const</span> my_allocator&amp;)</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Other</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">(<span class="keyword">const</span> my_allocator&lt;_Other&gt;&amp;)</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  开辟内存</span></span><br><span class="line">	<span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新分配内存。并将原先的内存归还给操作系统。并且不要再使用p的原指向地址</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  构建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* __p, <span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (__p) <span class="built_in">T</span>(val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* __p, T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (__p) <span class="built_in">T</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* __p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		__p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">	<span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _ALIGN = <span class="number">8</span> &#125;;								<span class="comment">//  自由链表从8bytes开始，以8bytes为对齐方式，一直扩充到128Bytes</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _MAX_BYTES = <span class="number">128</span> &#125;;							<span class="comment">//  最大块大小   &gt;128就不会放到内存池里了，也即不会用二级空间配置器。会用一级空间配置器</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _NFREELISTS = <span class="number">16</span> &#125;;  						<span class="comment">//  自由链表成员个数  _MAX_BYTES/_ALIGN</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  将byte上调至8的倍数</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  计算出bytes大小的chunk应该挂载到自由链表free-list的哪个成员下</span></span><br><span class="line">	<span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">		<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  开辟内存池，挂载到freelist成员下，返回请求的内存块。</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">	<span class="comment">//  从还没形成链表的原始内存中取内存分配给自由链表成员，去形成链表。如果原始空闲内存不够了，则再开辟</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  每个chunk块的信息。_M_free_list_link指向下一个chunk块</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">		<span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  基于free-list的内存池，需要考虑线程安全</span></span><br><span class="line">	<span class="keyword">static</span> _Obj* <span class="keyword">volatile</span> _S_free_list[_NFREELISTS];	<span class="comment">//  防止被线程缓存</span></span><br><span class="line">	<span class="keyword">static</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  static：类内声明、类外定义。</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;         <span class="comment">//   空闲free内存的起始start位置 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;           <span class="comment">//   空闲free内存的结束end位置 ) </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;         <span class="comment">//   总共malloc过的内存大小（因为malloc是从堆heap上请求的，所以叫heapsize）</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  static 类内声明，类外定义/初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::mutex my_allocator&lt;T&gt;::mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> my_allocator&lt;T&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> my_allocator&lt;T&gt;::_Obj* <span class="keyword">volatile</span></span><br><span class="line">my_allocator&lt;T&gt; ::_S_free_list[my_allocator&lt;T&gt;::_NFREELISTS] </span><br><span class="line">= &#123; <span class="literal">nullptr</span>,<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* my_allocator&lt;T&gt;::<span class="built_in">allocate</span>(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	__n = __n * <span class="built_in"><span class="keyword">sizeof</span></span>(T);		<span class="comment">//  因为vector容器传来的是元素个数</span></span><br><span class="line">	<span class="comment">//  std::cout &lt;&lt; &quot;user allocate &quot; &lt;&lt; __n &lt;&lt; std::endl;</span></span><br><span class="line">	<span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES) &#123;</span><br><span class="line">		__ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		_Obj* <span class="keyword">volatile</span>* __my_free_list</span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);</span><br><span class="line">		<span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">		<span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">		<span class="comment">// unwinding.</span></span><br><span class="line">		<span class="comment">//  _S_free_list 是所有线程共享的。加锁实现线程安全</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">		_Obj* __result = *__my_free_list;</span><br><span class="line">		<span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">			__ret = _S_refill(_S_round_up(__n));</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			*__my_free_list = __result-&gt;_M_free_list_link;</span><br><span class="line">			__ret = __result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T*&gt;(__ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* my_allocator&lt;T&gt;::_S_refill(<span class="keyword">size_t</span> __n)  <span class="comment">//  n是一个chunk块的大小</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  分配指定大小的内存池    __nobjs：chunk内存块数量 ；这里的 __n：每个chunk内存块大小。</span></span><br><span class="line">	<span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">	_Obj* <span class="keyword">volatile</span>* __my_free_list;</span><br><span class="line">	_Obj* __result;</span><br><span class="line">	_Obj* __current_obj;</span><br><span class="line">	_Obj* __next_obj;</span><br><span class="line">	<span class="keyword">int</span> __i;</span><br><span class="line">	<span class="comment">//  __nobjs：申请到的chunk块数量。当只申请到一个时，直接返回该内存块给上一级使用。无需建立各个chunk的连接关系，无需挂载到相应的freelist成员下。（因为只有一个）</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line"></span><br><span class="line">	__my_free_list = _S_free_list + _S_freelist_index(__n);     <span class="comment">//  根据内存块大小求出内存池应该在由freelist第几个成员管理（指向）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  静态链表：把每个chunk块通过Obj*里的指针连接起来</span></span><br><span class="line">	<span class="comment">//  每个内存块，有一部分的内存时union联合体Obj，里面有一个Obj*指针，负责连接每个空闲内存块。</span></span><br><span class="line">	<span class="comment">/* Build free list in chunk */</span></span><br><span class="line">	__result = (_Obj*)__chunk;</span><br><span class="line">	*__my_free_list = __next_obj = (_Obj*)(__chunk + __n);    <span class="comment">//  __n：一个内存块的大小（因为第一个内存块要分配出去）</span></span><br><span class="line">	<span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">		__current_obj = __next_obj;</span><br><span class="line">		__next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);          <span class="comment">//   维护内存块间的连接  char* 因此+__n是偏移n个bytes +n是为了一次跑一个chunk块</span></span><br><span class="line">		<span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;                               <span class="comment">//   空闲内存块数为0?</span></span><br><span class="line">			__current_obj-&gt;_M_free_list_link = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			__current_obj-&gt;_M_free_list_link = __next_obj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(__result);   <span class="comment">//  返回第一个内存块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size,<span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span>* __result;</span><br><span class="line">	<span class="keyword">size_t</span> __total_bytes = __size * __nobjs;            <span class="comment">//  本次总共需要请求的内存大小</span></span><br><span class="line">	<span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//  __default_alloc_template&lt;__threads, __inst&gt; 从开始到现在，请求的剩余空闲的的内存大小。不包括回收的。只是开辟的。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;                <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">		__result = _S_start_free;                       <span class="comment">//  __result 作为返回内存首地址</span></span><br><span class="line">		_S_start_free += __total_bytes;                 <span class="comment">//  移动_S_start_free</span></span><br><span class="line">		<span class="keyword">return</span>(__result);                               <span class="comment">//  [result , _S_start_free)  作为请求结果返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;                <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">		__nobjs = (<span class="keyword">int</span>)(__bytes_left / __size);</span><br><span class="line">		__total_bytes = __size * __nobjs;</span><br><span class="line">		__result = _S_start_free;</span><br><span class="line">		_S_start_free += __total_bytes;</span><br><span class="line">		<span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;                                            <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">		<span class="keyword">size_t</span> __bytes_to_get =                         <span class="comment">//  当剩余的空闲内存不够时，需要向操统malloc内存。这是计算出需要malloc内存的大小（至少malloc出来要求内存的(__total_bytes)两倍）</span></span><br><span class="line">			<span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">		<span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">		<span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">		<span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                         <span class="comment">//  </span></span><br><span class="line">			_Obj* <span class="keyword">volatile</span>* __my_free_list =</span><br><span class="line">				_S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">			((_Obj*)_S_start_free)-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">			*__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">		&#125;</span><br><span class="line">		_S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//  向操统malloc内存</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == _S_start_free) &#123;                       <span class="comment">//  malloc失败</span></span><br><span class="line">			<span class="keyword">size_t</span> __i;</span><br><span class="line">			_Obj* <span class="keyword">volatile</span>* __my_free_list;</span><br><span class="line">			_Obj* __p;</span><br><span class="line">			<span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">			<span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">			<span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="comment">//  从别的freelist成员管理的原始备用内存池中借用至少size大小的chunk块</span></span><br><span class="line">			<span class="keyword">for</span> (__i = __size;__i &lt;= (<span class="keyword">size_t</span>)_MAX_BYTES;__i += (<span class="keyword">size_t</span>)_ALIGN) </span><br><span class="line">			&#123;</span><br><span class="line">				__my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">				__p = *__my_free_list;</span><br><span class="line">				<span class="keyword">if</span> (<span class="literal">nullptr</span> != __p) &#123;</span><br><span class="line">					*__my_free_list = __p-&gt;_M_free_list_link;</span><br><span class="line">					_S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">					_S_end_free = _S_start_free + __i;</span><br><span class="line">					<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">					<span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">					<span class="comment">// right free list.</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//  都没有时，只能allcoate</span></span><br><span class="line">			_S_end_free = <span class="literal">nullptr</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">			_S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">			<span class="comment">// This should either throw an</span></span><br><span class="line">			<span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">			<span class="comment">// succeeded.</span></span><br><span class="line">		&#125;</span><br><span class="line">		_S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">		_S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">		<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* __p may not be 0 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> my_allocator&lt;T&gt;::<span class="built_in">deallocate</span>(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)		<span class="comment">//  因为vector容器传来的是字节大小</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES)	<span class="comment">//  n&gt;128 同一级空间配置器</span></span><br><span class="line">	&#123;</span><br><span class="line">		malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		_Obj* <span class="keyword">volatile</span>* __my_free_list</span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);  <span class="comment">//  找到相应freelist成员</span></span><br><span class="line">		_Obj* __q = (_Obj*)__p;       <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// acquire lock</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">		__q-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">		*__my_free_list = __q;</span><br><span class="line">		<span class="comment">// lock is released here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* my_allocator&lt;T&gt;::<span class="built_in">reallocate</span>(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line">	<span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  old new都&gt;128byets，那么用的就应当是和一级空间配置器一样的方法malloc</span></span><br><span class="line">	<span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>)_MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>)_MAX_BYTES) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  如果即将分配的chunk块大小一致，那么不必，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="keyword">return</span>(__p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新开辟new_size大小内存，并拷贝数据到新开辟的内存里</span></span><br><span class="line">	__result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">	__copy_sz = __new_sz &gt; __old_sz ? __old_sz : __new_sz;</span><br><span class="line">	<span class="built_in">memcpy</span>(__result, __p, __copy_sz); <span class="comment">//  拷贝数据</span></span><br><span class="line">	<span class="built_in">deallocate</span>(__p, __old_sz);  <span class="comment">//  释放</span></span><br><span class="line">	<span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;myallocator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>,my_allocator&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">		std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/sgi_stl$ g++ *.cpp -o sgi_stl_allocator.out -Wall</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/sgi_stl$ ./sgi_stl_allocator.out </span><br><span class="line"><span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>空间配置器</tag>
        <tag>内存池</tag>
      </tags>
  </entry>
  <entry>
    <title>数独</title>
    <url>/2021/07/04/sudoku/</url>
    <content><![CDATA[<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a><strong>收获</strong></h1><ul>
<li>第一次安装<code>Ubuntu</code>，在<code>linux</code>下进行<code>c/c++</code>编程（虽然只是刚几百行的数独）</li>
<li>学会基本使用<code>cmake</code>，掌握基本<code>g++</code>编译参数，编写简单<code>CMakeLists</code>，基本掌握<code>gdb</code>调试，了解了<code>makeFile</code>。理解并配置<code>vscode</code>下的<code>launch.json</code>和<code>task.json</code>。</li>
<li>学会使用<code>git</code>。第一次在<code>github</code>上传项目。</li>
<li>就为了这点醋才包的饺子啊</li>
<li>增强代码能力，熟悉语法。</li>
<li><code>sudoku</code>很简单，不过我也勉强算迈出第一步了吧<code>hh</code>。</li>
<li>大二都开学一个月了，还这么菜。。。没办法啊。。上学期光搞算法了。。。</li>
</ul>
<h1 id="sudoku笔记"><a href="#sudoku笔记" class="headerlink" title="sudoku笔记"></a><strong>sudoku笔记</strong></h1><h2 id="bug收录在C-bug"><a href="#bug收录在C-bug" class="headerlink" title="bug收录在C++_bug"></a><strong>bug收录在C++_bug</strong></h2><h2 id="全局变量-静态static全局变量-const全局变量-静态变量"><a href="#全局变量-静态static全局变量-const全局变量-静态变量" class="headerlink" title="全局变量 静态static全局变量 const全局变量 静态变量"></a><strong>全局变量 静态static全局变量 const全局变量 静态变量</strong></h2><ul>
<li><a href="https://blog.csdn.net/qq_22238021/article/details/79533711?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1">参考 不错的博客</a></li>
<li>一个挺基础的问题。上学期大一的时候遇见过没整明白。。想想可能是VS编译时做了某些优化吧。。现在直接vscode中用命令行编译条理清晰了不少。</li>
<li>今后应该可以告别这个问题了。<h3 id="（非const非static-全局变量：全局作用域-跨文件-生命周期-程序生命周期"><a href="#（非const非static-全局变量：全局作用域-跨文件-生命周期-程序生命周期" class="headerlink" title="（非const非static)全局变量：全局作用域 (跨文件) 生命周期=程序生命周期"></a><strong>（非const非static)全局变量：全局作用域 (跨文件) 生命周期=程序生命周期</strong></h3><ul>
<li>即在所有文件中均可见。在整个源程序中只可以定义一个这个名字的全局变量。<strong>不同文件间同名的全局变量会发生冲突。</strong></li>
<li><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存</li>
<li>反面示例 <code>error: multiple definition</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/mistake_try/build$ make</span><br><span class="line">Scanning dependencies of target main</span><br><span class="line">[ 25%] Building CXX object CMakeFiles/main.dir/src/a.cpp.o</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/main.dir/src/b.cpp.o</span><br><span class="line">[ 75%] Building CXX object CMakeFiles/main.dir/main.cpp.o</span><br><span class="line">[100%] Linking CXX executable main</span><br><span class="line">CMakeFiles/main.dir/src/b.cpp.o:(.bss+0x0): `str[abi:cxx11]<span class="string">&#x27;被多次定义</span></span><br><span class="line"><span class="string">CMakeFiles/main.dir/src/a.cpp.o:(.bss+0x0)：第一次在此定义</span></span><br><span class="line"><span class="string">collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="string">CMakeFiles/main.dir/build.make:146: recipe for target &#x27;</span>main<span class="string">&#x27; failed</span></span><br><span class="line"><span class="string">make[2]: *** [main] Error 1</span></span><br><span class="line"><span class="string">CMakeFiles/Makefile2:67: recipe for target &#x27;</span>CMakeFiles/main.dir/all<span class="string">&#x27; failed</span></span><br><span class="line"><span class="string">make[1]: *** [CMakeFiles/main.dir/all] Error 2</span></span><br><span class="line"><span class="string">Makefile:83: recipe for target &#x27;</span>all<span class="string">&#x27; failed</span></span><br><span class="line"><span class="string">make: *** [all] Error 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>正解</strong>：在一个源文件中定义，在其余需要使该变量到的文件中使<strong>用<code>extern</code>声</strong>明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> string str ; </span><br><span class="line"><span class="comment">//  声明，而非定义。</span></span><br><span class="line"><span class="comment">//  声明在这个文件外面存在一个变量string str，来告知本文件中的代码。</span></span><br><span class="line"><span class="comment">//  这句我理解的是这个文件从外部链接了一个变量str。extern嘛 意思不就是外部。</span></span><br><span class="line"><span class="comment">//  如果extern string str = &quot;123&quot; 依旧会报错&quot;多次定义&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上述<code>string</code>换成<code>int</code>也一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a ;  <span class="comment">// ok </span></span><br><span class="line"><span class="comment">// 换成 int a = 9;</span></span><br><span class="line"><span class="comment">// int a;</span></span><br><span class="line"><span class="comment">// 都不可以 因为他们都是定义式，都会犯重复定义的错误。</span></span><br><span class="line"><span class="comment">// Scanning dependencies of target main</span></span><br><span class="line"><span class="comment">// [ 25%] Building CXX object CMakeFiles/main.dir/src/a.cpp.o</span></span><br><span class="line"><span class="comment">// [ 50%] Linking CXX executable main</span></span><br><span class="line"><span class="comment">// CMakeFiles/main.dir/src/b.cpp.o:/home/shc/code/mistake_try/src/b.cpp:4: `a&#x27;被多次定义</span></span><br><span class="line"><span class="comment">// CMakeFiles/main.dir/src/a.cpp.o:/home/shc/code/mistake_try/src/a.cpp:4：第一次在此定义</span></span><br><span class="line"><span class="comment">// collect2: error: ld returned 1 exit status</span></span><br><span class="line"><span class="comment">// CMakeFiles/main.dir/build.make:146: recipe for target &#x27;main&#x27; failed</span></span><br><span class="line"><span class="comment">// make[2]: *** [main] Error 1</span></span><br><span class="line"><span class="comment">// CMakeFiles/Makefile2:67: recipe for target &#x27;CMakeFiles/main.dir/all&#x27; failed</span></span><br><span class="line"><span class="comment">// make[1]: *** [CMakeFiles/main.dir/all] Error 2</span></span><br><span class="line"><span class="comment">// Makefile:83: recipe for target &#x27;all&#x27; failed</span></span><br><span class="line"><span class="comment">// make: *** [all] Error 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="静态变量：生命周期-程序生命周期"><a href="#静态变量：生命周期-程序生命周期" class="headerlink" title="静态变量：生命周期=程序生命周期"></a><strong>静态变量：生命周期=程序生命周期</strong></h3><ul>
<li>作用域与定义在哪里有关。</li>
</ul>
<h3 id="静态static全局变量：文件作用域-生命周期-程序生命周期"><a href="#静态static全局变量：文件作用域-生命周期-程序生命周期" class="headerlink" title="静态static全局变量：文件作用域  生命周期=程序生命周期"></a><strong>静态static全局变量：文件作用域  生命周期=程序生命周期</strong></h3><ul>
<li>全局静态变量的作用域只在<strong>本文件</strong>内有效。<ul>
<li>即：即便两个文件中定义了同名的全局静态变量，也<strong>不会发生冲突</strong>。<strong>他们是两个变量。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// extern string str = &quot;123&quot;;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Scanning dependencies of target main</span><br><span class="line">[ 25%] Building CXX object CMakeFiles/main.dir/src/a.cpp.o</span><br><span class="line">/home/shc/code/mistake_try/src/a.cpp:4:12: warning: ‘a’ defined but not used [-Wunused-variable]</span><br><span class="line"> static int a =9;</span><br><span class="line">            ^</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/main.dir/src/b.cpp.o</span><br><span class="line">/home/shc/code/mistake_try/src/b.cpp:4:12: warning: ‘a’ defined but not used [-Wunused-variable]</span><br><span class="line"> static int a = 9;</span><br><span class="line">            ^</span><br><span class="line">[ 75%] Linking CXX executable main</span><br><span class="line">[100%] Built target main</span><br></pre></td></tr></table></figure>

<h3 id="const全局变量：文件作用域-生命周期-程序生命周期"><a href="#const全局变量：文件作用域-生命周期-程序生命周期" class="headerlink" title="const全局变量：文件作用域 生命周期=程序生命周期"></a><strong>const全局变量：文件作用域 生命周期=程序生命周期</strong></h3><ul>
<li>经我实验应该是<strong>文件作用域</strong></li>
<li>即 作用域 , 生命周期 方面<strong>等同</strong><code>static</code>全局变量<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ 25%] Building CXX object CMakeFiles/main.dir/src/a.cpp.o</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/main.dir/src/b.cpp.o</span><br><span class="line">[ 75%] Building CXX object CMakeFiles/main.dir/main.cpp.o</span><br><span class="line">[100%] Linking CXX executable main</span><br><span class="line">[100%] Built target main</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="奇奇怪怪的想法（当然我知道这几乎不可能发生）"><a href="#奇奇怪怪的想法（当然我知道这几乎不可能发生）" class="headerlink" title="奇奇怪怪的想法（当然我知道这几乎不可能发生）"></a>奇奇怪怪的想法（当然我知道这几乎不可能发生）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完美无warning过编译</span></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a =<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;  <span class="comment">// 9 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何从文件中读取整型数据—istringstream使用"><a href="#如何从文件中读取整型数据—istringstream使用" class="headerlink" title="如何从文件中读取整型数据—istringstream使用"></a><strong>如何从文件中读取整型数据—<code>istringstream</code>使用</strong></h2><ul>
<li><p>文件 —<code>ifstream</code>流（绑定到文件上）—&gt; <code>string line</code> —<code>istringstream</code>流（绑定到刚读取的<code>line</code>上）—&gt; 要改变成的数据类型的变量</p>
</li>
<li><p><code>getline</code>的第一个参数：文件输入流<code>ifstream</code>或者标准输入流<code>istream</code>（反正<code>ifstream</code>也继承自<code>istream</code>）</p>
</li>
<li><p><code>istringstream</code>只能初始化时绑定 不能用<code>iss &lt;&lt; sstr</code>。（<code>stringstream</code>可以）</p>
</li>
<li><p>同一个<code>istringstream</code>对象重复使用前要<code>clear</code>。</p>
</li>
<li><p>第二个参数：<code>string</code></p>
</li>
<li><p>示例1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(file)</span></span>;     <span class="comment">// 文件流输入流（输入到内存）绑定到文件上</span></span><br><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ifs,line))    <span class="comment">//  从文件中读取一行到line中。（文件中无论原先是以int还是什么类型读进去的，都当作string读出来）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(line)</span></span>;    </span><br><span class="line">    <span class="comment">//  istringstream：从string中读取数据，再写出到别的变量中。（为了转换数据类型，或者去掉空格）</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span>(iss&gt;&gt;t) cout&lt;&lt;t&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="comment">//  转化时空格不会进入int型变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>示例2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,str);   <span class="comment">//  </span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;string:  &quot;</span>&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// istringstream iss;  //iss 只能初始化时绑定 不能用&lt;&lt;</span></span><br><span class="line">    <span class="comment">// iss&lt;&lt;str;</span></span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss&lt;&lt;str;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;part 1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">// ss流中的空格不会在转化时进入int型数据</span></span><br><span class="line">    <span class="keyword">while</span>(ss&gt;&gt;x) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;past 2&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(iss&gt;&gt;x) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">string:  3 4</span><br><span class="line">part 1</span><br><span class="line">3 4 </span><br><span class="line">past 2</span><br><span class="line">3 4 </span><br></pre></td></tr></table></figure>

<ul>
<li><code>sudoku</code>中代码片段<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read the archive(r kai v)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CScene::init</span><span class="params">(<span class="keyword">const</span> std::string&amp; file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(file)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> _map_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(ifs,line))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::istringstream <span class="title">ss</span><span class="params">(line)</span></span>;    <span class="comment">//  !!!!! attached the iss to the line we read just now</span></span><br><span class="line">        <span class="keyword">if</span>(!flag)   <span class="comment">// read the cur_point</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> x,y;</span><br><span class="line">            ss&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            <span class="built_in">assert</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;<span class="number">9</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;<span class="number">9</span>);</span><br><span class="line">            <span class="built_in">setCurPoint</span>(x,y);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(_map_idx&lt;MAX_SIZE)   <span class="comment">//read the _map</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> para[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(t&lt;<span class="number">2</span>&amp;&amp;ss&gt;&gt;para[t]&amp;&amp;_map_idx&lt;MAX_SIZE)    <span class="comment">//sstringstream transform str to int or others</span></span><br><span class="line">                ++t;</span><br><span class="line">            _map[_map_idx] = <span class="built_in">point_feature</span>(para[<span class="number">0</span>],<span class="built_in">State</span>(para[<span class="number">1</span>]));</span><br><span class="line">            ++_map_idx;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//read the ccommand</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> para[<span class="number">4</span>];    <span class="comment">//use the array seems better than the before</span></span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">0</span>;    </span><br><span class="line">            <span class="keyword">while</span>(ss&gt;&gt;para[idx]&amp;&amp;idx&lt;<span class="number">4</span>)</span><br><span class="line">                ++idx;</span><br><span class="line">            com.<span class="built_in">push_back</span>(<span class="built_in">my_point</span>(<span class="built_in">coordinate</span>(para[<span class="number">0</span>],para[<span class="number">1</span>]),<span class="built_in">point_feature</span>(para[<span class="number">2</span>],<span class="built_in">State</span>(para[<span class="number">3</span>]))));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="enum-class"><a href="#enum-class" class="headerlink" title="enum class"></a><strong>enum class</strong></h2><ul>
<li><p>枚举类型使我们可以将一组整型常量组织在一起，和类一样，每个枚举类型定义了一种新的类型。枚举属于字面值常量类型。</p>
</li>
<li><p>枚举类型</p>
<ul>
<li>**限定作用域(enum class / enum struct)**：<code>c++11</code>引入<ul>
<li><code>enum class open_modes&#123;input , output , append&#125;;</code></li>
</ul>
</li>
<li><strong>不限定作用域(enum)</strong><ul>
<li><code>enum color&#123;red , yellow , green&#125;</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>限定</strong>作用域的枚举类型中，枚举成员的名字<strong>遵循常规的作用域准则</strong>，并且在枚据类型的作用域外不可访问枚举成员的名字。</p>
</li>
<li><p><strong>不限定</strong>作用域的枚举类型中，枚举成员的作用域<strong>与枚举类型本身的作用域相同。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span>red,yellow,green&#125;;   <span class="comment">// 不限定作用域的枚举类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">stoplight</span>&#123;</span>red,yellow,green&#125;;   <span class="comment">//error 重复定义枚举成员</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">xxx</span>&#123;</span>red,yellow,green&#125;; <span class="comment">//ok 限定作用域</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果我们没有显示的提供初始值，则当前枚举成员的值等于之前的枚举成员值+1</p>
</li>
<li><p>指定<code>enum</code>的<strong>底层类型</strong></p>
<ul>
<li>默认情况下限定作用域的<code>enum</code>成员类型为<code>int</code></li>
<li><code>enum class value:double&#123;...&#125;</code></li>
<li>不限定作用域的不存在默认类型。</li>
</ul>
</li>
<li><p><strong>限定作用域的枚举类型不可以隐式转换</strong></p>
<ul>
<li><strong>只能使用<code>static_cast&lt;&gt;()</code></strong></li>
<li><code>int val = static&lt;int&gt;(A::enum_int_1);</code></li>
<li>传统不限定作用域的枚举类型会发生隐式转换</li>
</ul>
</li>
</ul>
<h2 id="输出枚举类型"><a href="#输出枚举类型" class="headerlink" title="输出枚举类型"></a><strong>输出枚举类型</strong></h2><ul>
<li><a href="https://blog.csdn.net/kid1ing/article/details/74785999?utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.no_search_link">参考博客</a></li>
<li>待研究 <code>template</code>语法还是不太熟悉。。。</li>
<li>获取枚举类的底层数据<ul>
<li><code>enum class Enumeration:unsigned long &#123;...&#125;</code></li>
<li><code>std::underlying_type&lt;Enumeration&gt;::type</code></li>
</ul>
</li>
<li><strong>函数模板</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Enumeration</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> std::underlying_type&lt;Enumeration&gt;::<span class="function">type <span class="title">as_integer</span> <span class="params">(<span class="keyword">const</span> Enumeration&amp; re)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;Enumeration&gt;::type&gt;(re);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用<ul>
<li><code>cout&lt;&lt;as_integer(Color)&lt;&lt;endl;</code></li>
</ul>
</li>
</ul>
<h2 id="检验文件是否存在：-access函数"><a href="#检验文件是否存在：-access函数" class="headerlink" title="检验文件是否存在： access函数"></a><strong>检验文件是否存在： access函数</strong></h2><ul>
<li>头文件：<code>unistd.h</code></li>
<li>功 能: 确定文件或文件夹的访问权限。即，检查某个文件的存取方式，比如说是只读方式、只写方式等。如果指定的存取方式<strong>有效</strong>，则函数返回<strong>0</strong>，<strong>否则</strong>函数返<strong>回-1</strong>。</li>
<li>用 法: <code>int access(const char *filenpath, int mode); 或者int _access( const char *path, int mode );</code></li>
<li><code>mode</code><ul>
<li>00 只存在,  02 写权限,  04 读权限,  06 读和写权限<ul>
<li>C++文档</li>
</ul>
</li>
</ul>
</li>
<li>使用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="comment">//  check whether the file exists</span></span><br><span class="line"><span class="comment">//  true -- exists </span></span><br><span class="line"><span class="comment">//  false -- not exist</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFileExists_access</span><span class="params">(std::string&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">access</span>(name.<span class="built_in">c_str</span>(), F_OK ) == <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Linux下改变字体颜色"><a href="#Linux下改变字体颜色" class="headerlink" title="Linux下改变字体颜色"></a><strong>Linux下改变字体颜色</strong></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\033[0m 关闭所有属性 </span><br><span class="line">\033[1m 高亮</span><br><span class="line">\033[2m 亮度减半</span><br><span class="line">\033[3m 斜体</span><br><span class="line">\033[4m 下划线 </span><br><span class="line">\033[5m 闪烁 </span><br><span class="line">\033[6m 快闪</span><br><span class="line">\033[7m 反显 </span><br><span class="line">\033[8m 消隐 </span><br><span class="line">\033[9m 中间一道横线</span><br><span class="line">10-19 关于字体的</span><br><span class="line">21-29 基本与1-9正好相反</span><br><span class="line">30-37 设置前景色</span><br><span class="line">40-47 设置背景色</span><br><span class="line">30:黑</span><br><span class="line">31:红</span><br><span class="line">32:绿</span><br><span class="line">33:黄</span><br><span class="line">34:蓝色</span><br><span class="line">35:紫色</span><br><span class="line">36:深绿</span><br><span class="line">37:白色</span><br><span class="line">38 打开下划线,设置默认前景色 </span><br><span class="line">39 关闭下划线,设置默认前景色 </span><br><span class="line">40 黑色背景 </span><br><span class="line">41 红色背景 </span><br><span class="line">42 绿色背景 </span><br><span class="line">43 棕色背景 </span><br><span class="line">44 蓝色背景 </span><br><span class="line">45 品红背景 </span><br><span class="line">46 孔雀蓝背景 </span><br><span class="line">47 白色背景 </span><br><span class="line">48 不知道什么东西</span><br><span class="line">49 设置默认背景色</span><br><span class="line">50-89 没用</span><br><span class="line">90-109 又是设置前景背景的，比之前的颜色浅</span><br><span class="line">\033[nA 光标上移n行 </span><br><span class="line">\033[nB 光标下移n行 </span><br><span class="line">\033[nC 光标右移n行 </span><br><span class="line">\033[nD 光标左移n行 </span><br><span class="line">\033[y;xH设置光标位置 </span><br><span class="line">\033[2J 清屏 </span><br><span class="line">\033[K 清除从光标到行尾的内容 </span><br><span class="line">\033[s 保存光标位置 </span><br><span class="line">\033[u 恢复光标位置 </span><br><span class="line">\033[?25l 隐藏光标 </span><br><span class="line">\033[?25h 显示光标</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用举例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;\033[35m&quot;</span>&lt;&lt;<span class="string">&quot;紫色&quot;</span>&lt;&lt;<span class="string">&quot;\033[0m&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">// 输出紫色字体的 紫色</span></span><br></pre></td></tr></table></figure></li>
<li><p>本<code>sudoku demo</code>代码中将他们设置为枚举类</p>
</li>
<li><p><code>color.h</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span>:</span><span class="keyword">int</span></span><br><span class="line">&#123;</span><br><span class="line">    BOLD = <span class="number">1</span>,</span><br><span class="line">    RESET = <span class="number">0</span>,</span><br><span class="line">    BG_BLUE = <span class="number">44</span>,</span><br><span class="line">    BG_DEFAULT = <span class="number">49</span>,</span><br><span class="line">    BG_GREEN = <span class="number">42</span>,</span><br><span class="line">    BG_RED = <span class="number">41</span>,</span><br><span class="line">    FG_BLACK = <span class="number">30</span>,</span><br><span class="line">    FG_BLUE = <span class="number">34</span>,</span><br><span class="line">    FG_CYAN = <span class="number">36</span>,</span><br><span class="line">    FG_DARK_GRAY = <span class="number">90</span>,</span><br><span class="line">    FG_DEFAULT = <span class="number">39</span>,</span><br><span class="line">    FG_GREEN = <span class="number">32</span>,</span><br><span class="line">    FG_LIGHT_BLUE = <span class="number">94</span>,</span><br><span class="line">    FG_LIGHT_CYAN = <span class="number">96</span>,</span><br><span class="line">    FG_LIGHT_GRAY = <span class="number">37</span>,</span><br><span class="line">    FG_LIGHT_GREEN = <span class="number">92</span>,</span><br><span class="line">    FG_LIGHT_MAGENTA = <span class="number">95</span>,</span><br><span class="line">    FG_LIGHT_RED = <span class="number">91</span>,</span><br><span class="line">    FG_LIGHT_YELLOW = <span class="number">93</span>,</span><br><span class="line">    FG_MAGENTA = <span class="number">35</span>,</span><br><span class="line">    FG_RED = <span class="number">31</span>,</span><br><span class="line">    FG_WHITE = <span class="number">97</span>,</span><br><span class="line">    FG_YELLOW = <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出修饰类 功能：1. 负责改变输出流颜色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modifier</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Modifier&amp;);    <span class="comment">//  由于重载的&lt;&lt;()函数需要访问内部数据，所以声明为友元函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Modifier</span>(<span class="keyword">const</span> Color &amp;t):<span class="built_in">c</span>(t)&#123;&#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Color c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><code>color.cpp</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;color.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;common.h&quot;</span></span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="keyword">const</span> Modifier&amp; md)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// cout  &lt;&lt; &quot;\033[&quot;&lt;&lt;34&lt;&lt;&quot;m&quot; ;  // static_cast&lt;int&gt;()</span></span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;\033[&quot;</span> &lt;&lt; <span class="built_in">as_integer</span>(md.c) &lt;&lt; <span class="string">&quot;m&quot;</span>;  <span class="comment">// 颜色控制开启 写入输出流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="inl"><a href="#inl" class="headerlink" title="inl"></a><code>inl</code></h3><ul>
<li><p>在内联函数较多的情况下，为了避免头文件过长、版面混乱，可以将所有的内联函数定义移到一个单独的文件中去，然后再 用<code>#include</code>指令将它包含到类声明的后面（类的头文件的底部）。这样的文件称为一个内联函数定义文件。</p>
</li>
<li><p><code>inl</code>文件中也可以包含头文件的，因为内联函数中可能包含其他文件中定义的东西。</p>
</li>
</ul>
<ul>
<li>按照惯例， 应该将这个文件命名为<code>filename.inl</code>，其中<code>filename</code>与相应的头文件和实现文件相同。</li>
</ul>
<h3 id="段错误（核心已转储）"><a href="#段错误（核心已转储）" class="headerlink" title="段错误（核心已转储）"></a>段错误（核心已转储）</h3><ul>
<li><code>segmentation fault</code></li>
<li>直接<code>gdb ./a.out</code>，然后<code>run</code> 。在哪里停下就是哪里错误。</li>
</ul>
<h2 id="一些命名习惯"><a href="#一些命名习惯" class="headerlink" title="一些命名习惯"></a>一些命名习惯</h2><ul>
<li>类：一般以大写字母<code>C</code>开头</li>
<li>函数：每个单词首字母大写</li>
</ul>
<h2 id="Dancing-link"><a href="#Dancing-link" class="headerlink" title="Dancing link"></a>Dancing link</h2><ul>
<li>有时间再整吧</li>
</ul>
<h2 id="静态全局函数和全局函数"><a href="#静态全局函数和全局函数" class="headerlink" title="静态全局函数和全局函数"></a>静态全局函数和全局函数</h2><ul>
<li><p><code>static</code>修饰的全局函数</p>
<ul>
<li>作用域：本.c文件中，不会被其他文件看见。在其他.c文件中可以命名同名的函数。</li>
</ul>
</li>
<li><p>非<code>static</code>修饰的全局函数：</p>
<ul>
<li>作用域：整个工程。其他.c文件中不能有同名的。不然链接时会<code>redefition</code>。</li>
</ul>
</li>
</ul>
<h3 id="static函数出现在类中"><a href="#static函数出现在类中" class="headerlink" title="static函数出现在类中"></a><code>static</code>函数出现在类中</h3><ul>
<li><p>表示这个函数属于这个类而非某一对象，可通过类名直接访问</p>
</li>
<li><p>在该<code>static</code>函数中不可以访问类内非静态成员（变量和函数）。</p>
<ul>
<li>因为在类加载内存时就会给类内<code>static</code>成员分配内存</li>
<li>而在产生对象时才会给非静态成员分配内存。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>玩具</category>
      </categories>
      <tags>
        <tag>玩具</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/11/04/test/</url>
    <content><![CDATA[<p>这是摘要</p>
<span id="more"></span>
<p>以下是正文</p>
<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><p>1</p>
<h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><p>1.1</p>
<h3 id="子子标题1"><a href="#子子标题1" class="headerlink" title="子子标题1"></a>子子标题1</h3><p>1.1.1</p>
<h1 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h1><p>2</p>
<h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><p>2.2</p>
<h3 id="子子标题2"><a href="#子子标题2" class="headerlink" title="子子标题2"></a>子子标题2</h3><p>2.2.2</p>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title>test02</title>
    <url>/2021/11/04/test02/</url>
    <content><![CDATA[<p>如何插入图片</p>
<span id="more"></span>
<p><img src="/2021/11/04/test02/2021-11-04-21-26-16.png"></p>
<h1 id="如何插入图片"><a href="#如何插入图片" class="headerlink" title="如何插入图片"></a>如何插入图片</h1><ul>
<li>过程<ul>
<li><code>hexo new xxx</code><ul>
<li>会生成一个同名文件夹</li>
</ul>
</li>
<li><code>ctrl + alt + v</code>  <ul>
<li>图片会自动到同名文件夹下。</li>
</ul>
</li>
</ul>
</li>
<li>有用插件 <ul>
<li><code>hexo-asset-image</code></li>
<li><code>hexo-renderer-ejs</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title>vim</title>
    <url>/2022/05/24/vim/</url>
    <content><![CDATA[<p>vim快捷键</p>
<span id="more"></span>

<ul>
<li>快捷键<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">功能：</span><br><span class="line">    (1) 命令行模式下的文本编辑器。</span><br><span class="line">    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</span><br><span class="line">    (3) 使用方式：vim filename</span><br><span class="line">        如果已有该文件，则打开它。</span><br><span class="line">        如果没有该文件，则打开个一个新的文件，并命名为filename</span><br><span class="line">模式：</span><br><span class="line">    (1) 一般命令模式</span><br><span class="line">        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</span><br><span class="line">    (2) 编辑模式</span><br><span class="line">        在一般命令模式里按下i，会进入编辑模式。</span><br><span class="line">        按下ESC会退出编辑模式，返回到一般命令模式。</span><br><span class="line">    (3) 命令行模式</span><br><span class="line">        在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。</span><br><span class="line">        可以查找、替换、保存、退出、配置编辑器等。</span><br><span class="line">操作：</span><br><span class="line">    (1) i：进入编辑模式</span><br><span class="line">    (2) ESC：进入一般命令模式</span><br><span class="line">    (3) h 或 左箭头键：光标向左移动一个字符</span><br><span class="line">    (4) j 或 向下箭头：光标向下移动一个字符</span><br><span class="line">    (5) k 或 向上箭头：光标向上移动一个字符</span><br><span class="line">    (6) l 或 向右箭头：光标向右移动一个字符</span><br><span class="line">    (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</span><br><span class="line">    (8) 0 或 功能键[Home]：光标移动到本行开头</span><br><span class="line">    (9) $ 或 功能键[End]：光标移动到本行末尾</span><br><span class="line">    (10) G：光标移动到最后一行</span><br><span class="line">    (11) :n 或 nG：n为数字，光标移动到第n行</span><br><span class="line">    (12) gg：光标移动到第一行，相当于1G</span><br><span class="line">    (13) n&lt;Enter&gt;：n为数字，光标向下移动n行</span><br><span class="line">    (14) /word：向光标之下寻找第一个值为word的字符串。</span><br><span class="line">    (15) ?word：向光标之上寻找第一个值为word的字符串。</span><br><span class="line">    (16) n：重复前一个查找操作</span><br><span class="line">    (17) N：反向重复前一个查找操作</span><br><span class="line">    (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</span><br><span class="line">    (19) :1,<span class="variable">$s</span>/word1/word2/g：将全文的word1替换为word2</span><br><span class="line">    (20) :1,<span class="variable">$s</span>/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。</span><br><span class="line">    (21) v：选中文本</span><br><span class="line">    (22) d：删除选中的文本</span><br><span class="line">    (23) dd: 删除当前行</span><br><span class="line">    (24) y：复制选中的文本</span><br><span class="line">    (25) yy: 复制当前行</span><br><span class="line">    (26) p: 将复制的数据在光标的下一行/下一个位置粘贴</span><br><span class="line">    (27) u：撤销</span><br><span class="line">    (28) Ctrl + r：取消撤销</span><br><span class="line">    (29) 大于号 &gt;：将选中的文本整体向右缩进一次</span><br><span class="line">    (30) 小于号 &lt;：将选中的文本整体向左缩进一次</span><br><span class="line">    (31) :w 保存</span><br><span class="line">    (32) :w! 强制保存</span><br><span class="line">    (33) :q 退出</span><br><span class="line">    (34) :q! 强制退出</span><br><span class="line">    (35) :wq 保存并退出</span><br><span class="line">    (36) :<span class="built_in">set</span> paste 设置成粘贴模式，取消代码自动缩进</span><br><span class="line">    (37) :<span class="built_in">set</span> nopaste 取消粘贴模式，开启代码自动缩进</span><br><span class="line">    (38) :<span class="built_in">set</span> nu 显示行号</span><br><span class="line">    (39) :<span class="built_in">set</span> nonu 隐藏行号</span><br><span class="line">    (40) gg=G：将全文代码格式化</span><br><span class="line">    (41) :noh 关闭查找关键词高亮</span><br><span class="line">    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</span><br><span class="line">异常处理：</span><br><span class="line">    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。</span><br><span class="line">    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</span><br><span class="line">        (1) 找到正在打开该文件的程序，并退出</span><br><span class="line">        (2) 直接删掉该swp文件即可</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技能 &amp; 工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>内存对齐</title>
    <url>/2022/05/01/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/tutorial/10018/446a7a7f8eaf41749573a0d187efda47">https://www.nowcoder.com/tutorial/10018/446a7a7f8eaf41749573a0d187efda47</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.内存对齐的作用是什么？</span><br><span class="line">答案：提升性能：减少CPU读取内存的次数，提升程序执行的效率</span><br><span class="line">图片标题</span><br><span class="line"></span><br><span class="line">上图是CPU和几种存储之间的存取速度在这30多年的发展对比（图片来自CMU的深入理解计算机系统课程）。内存就是上述的DRAM存储，CPU的速度和内存 的速度之间差距接近1000倍，3个数量级的差距。可见如果能够减少对内存的读取次数可以极大的提升程序的执 行效率。移植原因：有的硬件体系不支持非对齐内存地址的电路系统.当遇到非对齐内存地址的存取时,它将抛出一个异常，可能导致程序崩溃。</span><br><span class="line"></span><br><span class="line">4.内存对齐的原则是什么？</span><br><span class="line">答：三原则:</span><br><span class="line">结构体变量的起始地址能够被其最宽的成员大小整除；</span><br><span class="line">结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充空白字节；</span><br><span class="line">结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充空白字节；</span><br><span class="line">分析：编译器在编译的时候是可以指定对齐大小的，实际使用的有效对齐其实是取指定大小和自身大小的最小值，一般默认的对齐大小是4。可以通过预编译命令#pragma pack(n)。除了上述3原则之外还有其他的对齐规则：计算机体系结构当中缓存是很重要的一环，CPU不是直接读取内存而是读取缓存：高速缓冲存储器。其作用是为了更好的利用局部性原理，减少CPU访问主存的次数。因为存取内存相对存取缓存是慢很多的，cache也可以看做是一种空间换时间的做法。实际读取内存的是缓存。所以内存对齐有的时候还需要考虑缓存更新的读取策略，一些规则如下：</span><br><span class="line">1.对较大结构体进行cache line对齐：Cache与内存交换的最小单位为cache line。一个cache line大小以64字节为例。当我们的结构体大小没有与64字节对齐时，一个结构体可能就要占用比原本需要更多的cache line,同时还会带来错误共享问题，大家可以自行google。</span><br><span class="line"></span><br><span class="line">2.对只读字段和读写字段分离对齐： 只读字段和读写字段分离对齐的目的是为了让只读字段和读写字段分别存储在缓存的不同cache line中，使得读写字段的淘汰尽量少的影响只读字段，因为只读字段不会被改变所以应该尽量少的被缓存换出。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.什么是指令乱序？</span><br><span class="line">答：从编译器的角度其实是对我们写的代码的一种优化，按照机器的角度讲一些指令代码执行顺序进行改变，优化程序实际执行的效率。</span><br><span class="line">分析：之所以出现编译器乱序优化是因为编译器能在很大范围内进行代码分析,从而做出更优的执行策略,可以充分利用处理器的乱序执行功能。</span><br><span class="line">指令乱序的问题：编译器优化产生的指令乱序可能会导致多线程程序产生意外的结果。</span><br><span class="line"></span><br><span class="line">6.如何解决指令乱序问题？</span><br><span class="line">答：内存屏障。</span><br><span class="line">分析：内存屏障，是一类同步指令，是对内存随机访问的操作中的一个同步点。此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。因为指令乱序执行的存在，就需要内存屏障保证程序执行的可靠。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>待做</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>tiny_webserver</title>
    <url>/2022/03/02/tiny-webserver/</url>
    <content><![CDATA[<ul>
<li>为什么ET模式需要将文件设置为非阻塞</li>
</ul>
<p>为什么管道写端要非阻塞？</p>
<p>send是将信息发送给套接字缓冲区，如果缓冲区满了，则会阻塞，这时候会进一步增加信号处理函数的执行时间，为此，将其修改为非阻塞。</p>
<p>没有对非阻塞返回值处理，如果阻塞是不是意味着这一次定时事件失效了？</p>
<p>是的，但定时事件是非必须立即处理的事件，可以允许这样的情况发生。</p>
]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>单核cpu_多线程</title>
    <url>/2022/05/06/%E5%8D%95%E6%A0%B8cpu-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/xueyijin/article/details/114272164">https://blog.csdn.net/xueyijin/article/details/114272164</a></p>
]]></content>
      <categories>
        <category>待做</category>
      </categories>
  </entry>
  <entry>
    <title>动态库/静态库</title>
    <url>/2022/05/04/%E5%8A%A8%E6%80%81%E5%BA%93_%E9%9D%99%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<ul>
<li>请看程序员自我修养</li>
</ul>
<p><a href="https://www.cnblogs.com/TenosDoIt/p/3203137.html">window</a><br><a href="https://blog.csdn.net/weixin_45157820/article/details/115789297">linux</a><br>linux 静态库和动态库都需要头文件.h</p>
]]></content>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>别人问题</title>
    <url>/2022/05/02/%E5%88%AB%E4%BA%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li><p>可以继承vector吗？</p>
<ul>
<li>尽量不要，因为vector的虚构函数不是virtual。构造函数顺序：先父后子；析构函数顺序：先子后父。继承的常见用法是父类vector指针指向子类对象。那么如果这样的话，构造函数无问题，先父后子。<strong>在析构时，父类指针不会调用到子类析构函数</strong>，那么当子类有指针指向外部资源时，子类并没有释放它，造成内存泄漏。</li>
<li>如果非要继承vector，那么不要用父类指针指向子类对象！否则子类对象的部分无法被释放！（我认为子类对象连栈上的内存（成员变量）都无法释放）<ul>
<li>系统隐式调用析构函数的时候，会加入释放栈内存的动作（而堆内存则由用户手工的释放）</li>
<li>用户显式调用析构函数的时候，只是单纯执行析构函数内的语句，不会释放栈内存，摧毁对象</li>
</ul>
</li>
<li>我认为可以采用聚合的方式，vector对象作为类的成员变量。<ul>
<li>聚合是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</li>
</ul>
</li>
</ul>
</li>
<li><p>virtual析构函数复习</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="keyword">int</span> x) :<span class="built_in">pa</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(x)) </span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Base *pa= &quot;</span> &lt;&lt; *pa &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	 ~<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Base&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span> pa;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span>* pa;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子类指针指向父类对象</span></span><br><span class="line"><span class="comment">// Derive* p = new Base(1); 编译不过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  父类指针指向子类对象</span></span><br><span class="line">Base* p = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// Base *pa= 1</span></span><br><span class="line"><span class="comment">// Derive *pb= 2</span></span><br><span class="line"><span class="comment">// ~Base</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类引用子类对象  ok</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Derive <span class="title">d</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    Base&amp; r = d;	<span class="comment">//  引用就是个别名。对对象类型、生命周期啥的不起作用。这两句就相当于Derive d(1,2);</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// Base *pa= 1</span></span><br><span class="line"><span class="comment">// Derive *pb= 2</span></span><br><span class="line"><span class="comment">// ~Derive</span></span><br><span class="line"><span class="comment">// ~Base</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类指针指向子类对象  ok</span></span><br><span class="line">&#123;</span><br><span class="line">    Derive* p = <span class="keyword">new</span> <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// Base *pa= 1</span></span><br><span class="line"><span class="comment">// Derive *pb= 2</span></span><br><span class="line"><span class="comment">// ~Derive</span></span><br><span class="line"><span class="comment">// ~Base</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  子类对象  ok</span></span><br><span class="line">&#123;</span><br><span class="line">    Derive d = <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>);	<span class="comment">//  相当于 Derive d(1,2);</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// Base *pa= 1</span></span><br><span class="line"><span class="comment">// Derive *pb= 2</span></span><br><span class="line"><span class="comment">// ~Derive</span></span><br><span class="line"><span class="comment">// ~Base</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> Base &amp;r = <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//  ?</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// Base *pa= 1</span></span><br><span class="line"><span class="comment">// Derive *pb= 2</span></span><br><span class="line"><span class="comment">// ~Derive</span></span><br><span class="line"><span class="comment">// ~Base</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    Base r = <span class="built_in">Derive</span>(<span class="number">1</span>, <span class="number">2</span>);		<span class="comment">//  触发异常 </span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line"><span class="comment">// Base *pa= 1</span></span><br><span class="line"><span class="comment">// Derive *pb= 2</span></span><br><span class="line"><span class="comment">// ~Derive</span></span><br><span class="line"><span class="comment">// ~Base</span></span><br><span class="line"><span class="comment">// ~Base</span></span><br><span class="line"><span class="comment">// ++++++++++++++++++++</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>为什么即使父类析构不屑virtual：父类引用变量引用子类对象、子类指针指向子类对象、和子类对象也都ok呢？</p>
<ul>
<li>因为构造函数时，<code>Derive():Base()...&#123;&#125;</code>已经写出了会先调用子类构造（即使不写，c++编译器编译之后也会在这个位置隐式生成这句<code>Base()</code>）</li>
<li>析构时，根据对象析构规则，在子类析构函数结束时，子类会自动去找父类的析构函数进行析构。</li>
</ul>
</li>
<li><p>为什么父类指针指向子类对象，析构不ok呢？</p>
<ul>
<li>构造ok是必然。因为构造时是new Derive()。会先Base()再Derive()。</li>
<li>析构不ok也是必然！因为父类析构没写virtual，父类指针只会执行那个父类的析构函数。</li>
<li>只有父类析构写了virtual，父类才会向下去找子类重写的析构函数，执行子类重写的析构函数。而子类重写的析构函数的机制就是，执行完函数体之后，自动执行父类的析构函数。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>别人问题</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希</title>
    <url>/2022/05/06/%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<p><a href="https://xiaolincoding.com/os/8_network_system/hash.html#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9%E6%8F%90%E9%AB%98%E5%9D%87%E8%A1%A1%E5%BA%A6">哈希和一致性哈希</a></p>
<p>nginx的一致性哈希</p>
]]></content>
      <categories>
        <category>待做</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器</title>
    <url>/2022/05/05/%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<p>存储器 唐书</p>
<span id="more"></span>

<h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><ul>
<li>按存取方式分类<ul>
<li>存取时间与物理地址无关（随机访问）<ul>
<li>随机存取存储器：在程序的执行过程中  可读可写</li>
<li>只读存储器：在程序的执行过程中  只读</li>
</ul>
</li>
<li>存取时间与物理地址有关（串行访问）<ul>
<li>顺序存取存储器，如磁带</li>
<li>直接存取存储器，如磁盘</li>
</ul>
</li>
</ul>
</li>
<li>按在计算机中的作用分类<ul>
<li>主存储器<ul>
<li>RAM：Random Access Memory。随机存取存储器<ul>
<li>静态RAM</li>
<li>动态RAM</li>
</ul>
</li>
<li>ROM：Read-Only Memory。只读存储器<ul>
<li>MROM</li>
<li>PROM</li>
<li>EPROM</li>
<li>EEPROM</li>
</ul>
</li>
</ul>
</li>
<li>闪存存储器（Flash Memory）<ul>
<li>U盘、固态硬盘（SSD）</li>
</ul>
</li>
<li>高速缓冲存储器 / 缓存（Cache）<ul>
<li>CPU寄存器和主存储器之间</li>
</ul>
</li>
<li>辅存<ul>
<li>磁盘、磁带、光盘</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><blockquote>
<p><img src="/2022/05/05/%E5%AD%98%E5%82%A8%E5%99%A8/2022-05-05-09-22-31.png"><br><img src="/2022/05/05/%E5%AD%98%E5%82%A8%E5%99%A8/2022-05-05-10-36-10.png"></p>
</blockquote>
<ul>
<li>程序运行的局部性原理<ul>
<li>在一小段时间内，最近被访问过的程序和数据很可能再次被访问.</li>
<li>在空间上这些被访问的程序和数据往往集中在一小片存储区</li>
<li>在访问顺序上，指令顺序执行比转移执行的可能性大(大约5:1)</li>
<li>合理地把程序和数据分配在不同存储介质中<ul>
<li>可以将最近被访问过的程序或数据放入高速缓存中，当CPU再次访问这些程序或数据时，访问速度就可以大大提高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h2><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><ul>
<li>大端模式：低地址放高位</li>
<li>小端模式：低地址放低位</li>
<li>x86是小端模式</li>
<li>unsigned int val = 0x12345678</li>
</ul>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>小端模式</th>
<th>大端模式</th>
</tr>
</thead>
<tbody><tr>
<td>0x4000</td>
<td>0x78</td>
<td>0x12</td>
</tr>
<tr>
<td>0x4001</td>
<td>0x56</td>
<td>0x34</td>
</tr>
<tr>
<td>0x4002</td>
<td>0x34</td>
<td>0x56</td>
</tr>
<tr>
<td>0x4003</td>
<td>0x12</td>
<td>0x78</td>
</tr>
</tbody></table>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><ul>
<li>寻址方式不同（存储单元的大小不同），寻址范围也即不同，总容量一致。</li>
<li>16MB存储器。（16MB = 16*1024*1024*8bit = 2^27bit)</li>
<li>按字节寻址<ul>
<li>寻址范围：2^24个地址；</li>
<li>容量：2^24 * 2^3 = 2^27bit</li>
</ul>
</li>
<li>按字(16位)寻址<ul>
<li>寻址范围：2^23个地址；</li>
<li>容量：2^23 * 2^4 = 2^27bit</li>
</ul>
</li>
<li>按字(32位)寻址<ul>
<li>寻址范围：2^22个地址；</li>
<li>容量：2^22 * 2^5 = 2^27bit</li>
</ul>
</li>
</ul>
<p><img src="/2022/05/05/%E5%AD%98%E5%82%A8%E5%99%A8/2022-05-05-10-46-25.png"></p>
<ul>
<li>例子<ul>
<li>地址线10条，即能寻2^10个地址</li>
<li>数据线4条，即一个地址一次可以读写4位</li>
<li>所以，芯片容量为 2^10 * 4 bit = 1K * 4 位</li>
</ul>
</li>
</ul>
<h3 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h3><h3 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h3><ul>
<li><a href="https://blog.csdn.net/qq_43610614/article/details/105660357">动态RAM刷新</a></li>
</ul>
<h3 id="只读存储器-ROM"><a href="#只读存储器-ROM" class="headerlink" title="只读存储器 ROM"></a>只读存储器 ROM</h3><h2 id="存储器和cpu相连"><a href="#存储器和cpu相连" class="headerlink" title="存储器和cpu相连"></a>存储器和cpu相连</h2><p><img src="/2022/05/05/%E5%AD%98%E5%82%A8%E5%99%A8/2022-05-10-10-00-53.png"></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>计组里考试的寻址范围：是指存储器的寻址范围,是指按照字长/字节编址，能够实际找到地址(存储单元)的个数。<ul>
<li>计算方法 ： 用存储器的容量 / 按字长/字节寻址的单元大小</li>
</ul>
</li>
<li>csapp里提及的寻址范围，也即我们写代码经常认为的寻址范围：是指虚拟地址的范围。<ul>
<li>计算方法 ： 每台计算机都有一个字长。字长即为指针数据的位数.也因此,字长决定了虚拟地址空间的最大大小.因为,对于一个字长为w位的机器来说,虚拟地址范围是 : [0,2^w-1] . 程序最多方位 2^w个字节</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>学校考试</tag>
      </tags>
  </entry>
  <entry>
    <title>BUG</title>
    <url>/2021/09/04/%E5%B0%8F%E7%99%BDBug/</url>
    <content><![CDATA[<h1 id="BUG-小白的锌酸历程"><a href="#BUG-小白的锌酸历程" class="headerlink" title="BUG (小白的锌酸历程)"></a><strong>BUG (小白的锌酸历程)</strong></h1><h2 id="heap-corruption-detected"><a href="#heap-corruption-detected" class="headerlink" title="heap corruption detected"></a><strong>heap corruption detected</strong></h2><p><a href="https://blog.csdn.net/fjz13/article/details/2535126">https://blog.csdn.net/fjz13/article/details/2535126</a></p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a><strong>1</strong></h2><ul>
<li><code>.h</code>头文件上来记得加<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> xxx  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxx </span></span><br><span class="line">..... </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-0-multiple-definition-redefinition-xxx-already-defined-in-adsasd-obj"><a href="#2-0-multiple-definition-redefinition-xxx-already-defined-in-adsasd-obj" class="headerlink" title="2.0  multiple definition / redefinition / xxx already defined in adsasd.obj"></a><strong>2.0  multiple definition / redefinition / xxx already defined in adsasd.obj</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;c.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>&gt;c.obj : error LNK2005: <span class="string">&quot;void __cdecl func1(void)&quot;</span> (?func1@@YAXXZ) already defined in a.obj</span><br><span class="line"><span class="number">1</span>&gt;C:\Users\de<span class="number">&#x27;l</span><span class="number">&#x27;l</span>\VSProjects\MistakeTry\Debug\MistakeTry.exe : fatal error LNK1169: one <span class="keyword">or</span> more multiply defined symbols found</span><br><span class="line"><span class="number">1</span>&gt;Done building project <span class="string">&quot;MistakeTry.vcxproj&quot;</span> -- FAILED.</span><br></pre></td></tr></table></figure>
<ul>
<li>养成<strong>不要在头<code>.h</code>文件中定义非类成员函数以及非内联函数</strong>的习惯。</li>
<li>养成<strong>在类相应源<code>.cpp</code>文件中定义函数</strong>的习惯</li>
<li>非类的成员函数的定义尽量放在<code>.cpp</code>文件中<ul>
<li>因为c++采用单独编译，就是将每个<code>.cpp</code>文件编译成对应的<code>.o</code>文件，最后链接器再将多个<code>.obj</code>文件链接成可执行程序。</li>
<li>所以本例，从各个<code>cpp</code>文件看，编译成.o文件时没有任何问题（在main中也没有问题，因为有<code>#pargma once </code>,<code>a.h</code>只会在<code>main</code>中<code>include</code>一次，但是在<code>c.cpp</code>和<code>a.cpp</code>和文件中都<code>include</code>了<code>a.h</code>文件</li>
<li>(宏的定义域只局限于一个文件) </li>
<li>而<code>a.h</code>文件中又定义了<code>print</code>函数，即与预处理过后，在c和a源文件中都定义了<code>print</code>函数，重复定义，即会有<code>one or more multiply defined symbols found</code>或者 <code>....already defined in ..obj</code>的错误</li>
</ul>
</li>
<li>有人可能会问，既然是从同一份文件<code>include</code>过来的函数<code>hhh()</code>，那么定义都是同一份，为什么编译器不会智能的处理一下，让链接时候不报错呢？<ul>
<li>其实编译器链接的时候，并不知道<code>b.cpp</code>中定义的<code>hhh</code>与<code>c.cpp</code>中定义的<code>hhh</code>是同一个文件<code>include</code>过来的，它只会认为如果有两份定义，而且这两份定义如果实现不同，那么到底以哪个为准呢？既然决定不了，那就干脆报错好了。</li>
<li>这段引自博客,链接我真没找到。。</li>
</ul>
</li>
</ul>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a><strong>例外</strong></h3><ul>
<li><strong><code>inline</code></strong> 函数定义在头文件中<ul>
<li>C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个<code>cpp</code>中只出现一次就行。</li>
</ul>
</li>
<li><strong><code>class</code></strong> 成员函数可在头文件中定义</li>
<li><a href="https://jiadebin.github.io/2017/04/03/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84multiple-definition/">参考 感谢作者</a></li>
</ul>
<h2 id="2-1-inline函数要定义在头文件内。"><a href="#2-1-inline函数要定义在头文件内。" class="headerlink" title="2.1 inline函数要定义在头文件内。"></a><strong>2.1 <code>inline</code>函数要定义在头文件内。</strong></h2><ul>
<li>若定义在<code>.cpp</code>文件则会<ul>
<li><strong><code>undefined reference to &#39;CScene::CScene()&#39;</code></strong></li>
<li><strong><code>main.obj : error LNK2019: unresolved external symbol &quot;public: __thiscall CScene::CScene(void)&quot; (??0CScene@@QAE@XZ) referenced in function _main</code></strong></li>
</ul>
</li>
<li><ol>
<li>大多数环境在编译期间进行<code>inline</code>，而为了将一个<code>函数调用</code>替换为<code>被调用的函数的本体</code>，编译器必须知道那个函数长什么样子。</li>
</ol>
</li>
<li><ol start="2">
<li>与非<code>inline</code>函数不同，<code>inline</code>函数必须在调用该函数的每个文件中定义。（为了完成上一句话的要求）</li>
</ol>
</li>
<li><ol start="3">
<li>对于同一程序的不同文件，同一<code>inline</code>函数的定义应当相同。</li>
</ol>
</li>
<li>因此，<strong>应把<code>inline</code>函数的定义放入头文件</strong>，在<strong>每个</strong>调用了该<code>inline</code>函数的地方<code>include</code>该头文件 （为了完成2），这种方法*<strong>保证了每个<code>inline</code>函数只有一个定义</strong>，且程序员无需复制代码，并且不可能在程序的生命周期引起无意不匹配的事情。</li>
</ul>
<ul>
<li>static<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static修饰全局变量和全局函数就不说了，这里主要讨论修饰类的成员函数和成员变量。</span><br><span class="line">当类的编写者在头文件中编写一个类声明的时候，他必须明确告诉将要使用这个类的人这个类的用法，比如哪些变量和类是public的。</span><br><span class="line">static成员也是，编写者如果想要让一个成员变量在所有对象之间共享，那就用static告诉类的使用者，后续类的使用者就可以用类名::变量名来使用这个变量了。</span><br><span class="line">所以static在修饰成员变量和成员函数时，是向外明确接口的，必须要写在声明里。至于定义的时候要不要static，这不重要，各自编译器决定定义时写static的行为就好了</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-2-const作用域"><a href="#2-2-const作用域" class="headerlink" title="2.2 const作用域"></a><strong>2.2 <code>const作用域</code></strong></h2><h3 id="问题：会不会出现编译器没有把我们在-h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple-definition的情况？"><a href="#问题：会不会出现编译器没有把我们在-h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple-definition的情况？" class="headerlink" title="问题：会不会出现编译器没有把我们在.h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple definition的情况？"></a>问题：会不会出现编译器没有把我们在<code>.h</code>文件中定义的内联函数当作<code>inline</code>函数，而我们又到处<code>include</code>，造成<code>multiple definition</code>的情况？</h3><ul>
<li>qs是出现了。。。。md。。。。我的解决方法：<ul>
<li>直接在那个<code>.h</code>文件的类内定义该成员函数</li>
<li>或者取消把他内联的想法。交给编译器，听他的。</li>
</ul>
</li>
</ul>
<h2 id="3-相互包含头文件"><a href="#3-相互包含头文件" class="headerlink" title="3.  相互包含头文件"></a><strong>3.  相互包含头文件</strong></h2><ul>
<li>两个头文件相互包含</li>
<li>若在B的头文件中：<ul>
<li><ol>
<li><strong>要定义使用<code>A对象</code>或<code>A对象</code>作为返回值的函数则要<code>include A.h</code></strong></li>
</ol>
</li>
<li><ol start="2">
<li><strong>使用<code>A类型</code>作为指针则在定义<code>A*</code>前声明<code>class A</code>即可</strong></li>
</ol>
</li>
<li>另外，若为<strong>情况2</strong>，<strong>则在<code>B.cpp</code>文件中，为了使用A类的成员函数，则要<code>include A.h</code></strong></li>
<li><ol start="3">
<li>两个类中互相使用了对方的指针，这样的情况很简单，分别在各自的头文件中声明一下使用的类，而在各自的源文件中包含对方的头文件即可。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-There-is-no-matching-member-for-call-to-‘find’"><a href="#4-There-is-no-matching-member-for-call-to-‘find’" class="headerlink" title="4. There is no matching member for call to ‘find’"></a><strong>4. There is no matching member for call to ‘find’</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; m = &#123;&#123;<span class="string">&quot;I&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;IV&quot;</span>,<span class="number">4</span>&#125;,&#123;<span class="string">&quot;V&quot;</span>,<span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;IX&quot;</span>,<span class="number">9</span>&#125;,&#123;<span class="string">&quot;X&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;XL&quot;</span>,<span class="number">40</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;L&quot;</span>,<span class="number">50</span>&#125;,&#123;<span class="string">&quot;XC&quot;</span>,<span class="number">90</span>&#125;,&#123;<span class="string">&quot;C&quot;</span>,<span class="number">100</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;CD&quot;</span>,<span class="number">400</span>&#125;,&#123;<span class="string">&quot;D&quot;</span>,<span class="number">500</span>&#125;,&#123;<span class="string">&quot;CM&quot;</span>,<span class="number">900</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;M&quot;</span>,<span class="number">1000</span>&#125;&#125;;</span><br><span class="line">string s = <span class="string">&quot;MCD&quot;</span>;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; ::iterator iter = m.<span class="built_in">find</span>(s[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(iter!=s.<span class="built_in">end</span>()) ...  </span><br></pre></td></tr></table></figure>
<p><code>There is no matching member for call to &#39;find&#39;</code></p>
<ul>
<li><strong>原因</strong><ul>
<li><code>unordered_map&lt;string,int&gt;</code>的<code>key type</code>是 <code>std::string</code>,但是我们传入的是一个字符<code>char</code>给<code>find()</code>函数.<code>std::string</code>没有一个可以接收一个<code>char</code>的<code>constructor</code>.因此<code>error</code>.</li>
</ul>
</li>
<li><strong>解决</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">find</span>(&#123;s[<span class="number">0</span>]&#125;);</span><br><span class="line">m.<span class="built_in">find</span>(<span class="built_in">string</span>()+s[<span class="number">0</span>]); <span class="comment">//一个string型字符串和一个char相加,会将char先转化为string,再相加</span></span><br><span class="line">m.<span class="built_in">find</span>(<span class="built_in">string</span>(<span class="number">1</span>,s[<span class="number">0</span>]));<span class="comment">//string构造函数 string(n,char);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-关于（几乎就是不可以）返回局部变量的引用"><a href="#5-关于（几乎就是不可以）返回局部变量的引用" class="headerlink" title="5. 关于（几乎就是不可以）返回局部变量的引用"></a><strong>5. 关于（几乎就是不可以）返回局部变量的引用</strong></h2><ul>
<li>函数<strong>返回local variable引用</strong>（<strong>无论是否是常量引用</strong>）是<strong>不可以</strong>的。(条件是函数调用处并<strong>没有用常量引用来接收</strong>)<ul>
<li>理解：编译器根据 <code>local</code> 变量造了一个<code>const</code>局部临时量 让<code>const</code>引用绑定在这个临时变量上，<strong>可这个变量还是一个局部变量</strong>。函数结束这个局部的临时量时该销毁还是销毁了。</li>
</ul>
</li>
<li>对于函数中的一个变量，如果<strong>不是局部变量</strong>，而是函数传参传入的一个引用，那么返回时当然<strong>可以</strong>返回该变量的引用（无论是否常），因为这个变量在函数结束时并不会被销毁。</li>
<li>图片来自<a href="https://blog.csdn.net/u012814856/article/details/84099328">博客</a><br><img src="/2021/09/04/%E5%B0%8F%E7%99%BDBug/2021-11-24-09-12-38.png"></li>
</ul>
<h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a><strong>特例</strong></h4><ul>
<li><del>如果在函数调用处使用了const引用来接收返回的引用/常量引用，那么是ok的</del>。</li>
<li>经实验，没有特例，无论是不是用常量引用接收，就是不能返回局部变量的常引。如果是一些容器类的话，可能不止是警告，还有编译error。</li>
<li>如果返回一个值的话，函数调用处用一个<code>const</code>引用接收当然可以延长生命周期。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj02 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; c = <span class="built_in">func1</span>(a, b);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; d = <span class="built_in">func2</span>(a, b);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; e = <span class="built_in">func1</span>(a, b);</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jj02::<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>运行结果<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6492220</span><br><span class="line">6509462</span><br><span class="line">6492220</span><br><span class="line"></span><br><span class="line">C:\Users\de<span class="string">&#x27;l&#x27;</span>l\VSProjects\MistakeTry\Debug\MistakeTry.exe (process 20256) exited with code 0.</span><br><span class="line">To automatically close the console when debugging stops, <span class="built_in">enable</span> Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console when debugging stops.</span><br><span class="line">Press any key to close this window . . .</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">19999</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">1121332</span>;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = jj01::<span class="built_in">func1</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">88</span>;</span><br><span class="line">	<span class="keyword">int</span> b = jj01::<span class="built_in">g</span>();</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C:\Users\de&#x27;l&#x27;l\VSProjects\MistakeTry\main.cpp(80): warning C4172: returning address of local variable or temporary: b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1&gt;C:\Users\de&#x27;l&#x27;l\VSProjects\MistakeTry\main.cpp(74): warning C4172: returning address of local variable or temporary: a</span></span><br></pre></td></tr></table></figure>


<h2 id="6-vector类内初始化"><a href="#6-vector类内初始化" class="headerlink" title="6. vector类内初始化"></a><strong>6. vector类内初始化</strong></h2><ul>
<li><code>vector</code>容器对象在类内定义时不允许指定大小(编译器会认为这是定义了一个函数)，只能通过<strong>列表初始化</strong>指定大小。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">// error 编译器会认为这是定义了一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> n):<span class="built_in">v</span>(n)&#123;&#125;		<span class="comment">//  列表初始化 ok</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-静态成员函数指针-非静态成员函数指针"><a href="#7-静态成员函数指针-非静态成员函数指针" class="headerlink" title="7. 静态成员函数指针 非静态成员函数指针"></a>7. <strong>静态成员函数指针 非静态成员函数指针</strong></h2><ul>
<li><strong>问题：</strong> 在使用<code>sort()</code>函数时，第三个函数只能是 <strong>全局函数指针</strong>或者<strong>静态成员函数指针</strong>，不能是<strong>非静态成员函数指针</strong>。</li>
<li><strong>解释：</strong> 非静态成员函数的参数中有一个<strong>隐式绑定的this指针</strong>(因为非静态成员函数需要由具体对象来调用)，而<code>sort</code>第三个参数需要得是一个接受两个参数的函数指针，所以不可。如果是静态成员函数的话，<code>sort</code>时直接使用<code>cmp</code>即可，无需依赖于实际对象。</li>
<li>感觉这话题好像挺大的，之后再研究研究。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 贴个合并区间的代码hhhh</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span>  <span class="comment">// 成员函数指针 静态函数指针 全局函数指针 整理。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);    <span class="comment">// 按照左端点排序</span></span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;r) </span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">                l=intervals[i][<span class="number">0</span>],r=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;r) r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：猪啊猪</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/file_system/file/content/whole/index/content/2974707/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="string相关"><a href="#string相关" class="headerlink" title="string相关"></a><strong><code>string</code>相关</strong></h2><ul>
<li>可以<code>+</code>不可以<code>-</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;012345&quot;</span>;</span><br><span class="line">s += <span class="string">&#x27;6&#x27;</span>; <span class="comment">// s = &quot;0123456&quot;</span></span><br><span class="line">s += <span class="string">&quot;6&quot;</span>; <span class="comment">// s = &quot;0123456&quot;</span></span><br><span class="line">s -= <span class="string">&quot;6&quot;</span>; <span class="comment">//error</span></span><br><span class="line">s -= <span class="string">&#x27;6&#x27;</span>; <span class="comment">//error</span></span><br><span class="line">no viable loaded <span class="string">&#x27;-=&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对pthread-create未定义的引用"><a href="#对pthread-create未定义的引用" class="headerlink" title="对pthread_create未定义的引用"></a><strong>对<code>pthread_create</code>未定义的引用</strong></h2><ul>
<li><code>gcc</code>编译时加上参数 <code>-lpthread</code></li>
<li>原因：<code>pthread</code>不是<code>Linux</code>默认的库。（毕竟<code>Linux</code>最开始本身没有线程），所以要链接上这个动态库</li>
</ul>
<h2 id="c-类成员是引用时"><a href="#c-类成员是引用时" class="headerlink" title="c++类成员是引用时"></a>c++类成员是引用时</h2><ul>
<li>记住引用只是个别名。</li>
<li>引用类型必须在构造列表初始化(因为引用必须初始化)</li>
<li>且构造函数的相应形参必须是引用</li>
<li><a href="https://blog.csdn.net/bluemaths/article/details/8651868?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&utm_relevant_index=1">博客</a></li>
</ul>
<h2 id="模板的定义和声明最好放在同一文件中"><a href="#模板的定义和声明最好放在同一文件中" class="headerlink" title="模板的定义和声明最好放在同一文件中"></a>模板的定义和声明最好放在同一文件中</h2><ul>
<li><a href="https://www.jianshu.com/p/dc94f0cbfcf7">https://www.jianshu.com/p/dc94f0cbfcf7</a></li>
</ul>
<h2 id="不懂？？"><a href="#不懂？？" class="headerlink" title="不懂？？"></a>不懂？？</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In file included from main.cpp:1:0:</span><br><span class="line">threadpool.h: In instantiation of ‘void threadpool&lt;T&gt;::run() [with T = int]’:</span><br><span class="line">threadpool.h:96:13:   required from ‘static void* threadpool&lt;T&gt;::worker(void*) [with T = int]’</span><br><span class="line">threadpool.h:53:26:   required from ‘threadpool&lt;T&gt;::threadpool(int, int) [with T = int]’</span><br><span class="line">main.cpp:9:33:   required from here</span><br></pre></td></tr></table></figure>

<h2 id="try-catch-…"><a href="#try-catch-…" class="headerlink" title="try{}catch(…){}"></a>try{}catch(…){}</h2><h2 id="new数组-是否初始化"><a href="#new数组-是否初始化" class="headerlink" title="new数组 是否初始化"></a>new数组 是否初始化</h2><p><a href="https://blog.csdn.net/baidu_41388533/article/details/106560988#:~:text=c%2B%2B%20%E4%BD%BF%E7%94%A8%20new%20%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%20%E6%95%B0%E7%BB%84%20%EF%BC%8C%E5%88%86%E4%B8%BA%20%E6%95%B0%E7%BB%84%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%A4%E7%A7%8D%E6%83%85%E5%BD%A2%EF%BC%9A,c%2B%2B%20new%20delete%20new%20%5B%5D%20delete%20%5B%5D%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">https://blog.csdn.net/baidu_41388533/article/details/106560988#:~:text=c%2B%2B%20%E4%BD%BF%E7%94%A8%20new%20%E5%88%86%E9%85%8D%E4%B8%80%E4%B8%AA%20%E6%95%B0%E7%BB%84%20%EF%BC%8C%E5%88%86%E4%B8%BA%20%E6%95%B0%E7%BB%84%20%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%A4%E7%A7%8D%E6%83%85%E5%BD%A2%EF%BC%9A,c%2B%2B%20new%20delete%20new%20%5B%5D%20delete%20%5B%5D%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0</a></p>
<h2 id="关于默认参数"><a href="#关于默认参数" class="headerlink" title="关于默认参数"></a>关于默认参数</h2><ul>
<li>默认参数只能指定一次。在函数的声明和定义中只能在一处指定参数的默认值。如果两处都指定为非法；</li>
<li>编译器把这种情况作为非法处理的原因是：在声明和定义中如果指定了不同的默认值，编译器将无法判断采用哪个值作为参数的默认值。</li>
</ul>
<h2 id="EPOLLRDHUP"><a href="#EPOLLRDHUP" class="headerlink" title="EPOLLRDHUP"></a>EPOLLRDHUP</h2><p>这两个事件其实是一个东西，分别对应poll和epoll，通常用来判断对端是否关闭，但是当你对某个socket注册POLLIN和POLLRDHUP(EPOLLIN和EPOLLRDHUP)时，在对端关闭时，对于poll来说会一直触发POLLIN + POLLRDHUP事件，epoll也会触发EPOLLIN + EPOLLRDHUP事件，是否一直触发要看epoll是工作在LT模式下还是ET模式下。</p>
<p>所以，当我们使用POLLRDHUP（EPOLLRDHUP）事件来判断对端是否关闭时，POLLRDHUP（EPOLLRDHUP）事件的处理应放在POLLIN（EPOLLIN）事件的前面，避免将对端关闭当做一次读事件，而无法处理POLLRDHUP（EPOLLRDHUP）事件<br>————————————————<br>版权声明：本文为CSDN博主「城南花已开.jpg」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_39781096/article/details/106980232">https://blog.csdn.net/qq_39781096/article/details/106980232</a></p>
<h2 id="c-枚举"><a href="#c-枚举" class="headerlink" title="c++ 枚举"></a>c++ 枚举</h2><p><a href="https://www.runoob.com/w3cnote/cpp-enum-intro.html">https://www.runoob.com/w3cnote/cpp-enum-intro.html</a></p>
<h2 id="回车-换行"><a href="#回车-换行" class="headerlink" title="回车 换行"></a>回车 换行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\r ：将当前位置移到本行开头。又叫回车，对应键盘上的return键</span><br><span class="line">\n：将当前位置移到下一行开头。又叫换行，newline。</span><br><span class="line">Linux中\n表示回车并换行；</span><br><span class="line">Windows中\r\n表示回车并换行。</span><br><span class="line">Mac中\r表示回车并换行。</span><br><span class="line"></span><br><span class="line">Linux下打开windows文件，每行末尾会多出一个^M</span><br><span class="line">windows下打开Linux文件，会变成一行。</span><br></pre></td></tr></table></figure>


<h2 id="writev"><a href="#writev" class="headerlink" title="writev"></a>writev</h2><p><a href="https://blog.51cto.com/laoxu/1441205">https://blog.51cto.com/laoxu/1441205</a><br><a href="https://blog.csdn.net/weixin_36750623/article/details/84579243">https://blog.csdn.net/weixin_36750623/article/details/84579243</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// writevex.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str0 = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">&quot;world\n&quot;</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = str0;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(str0) + <span class="number">1</span>;  <span class="comment">// str+&#x27;\0&#x27; 7   [base,base+str_len) 即[&#x27;h&#x27;&#x27;&#x27;e&#x27;&#x27;l&#x27;&#x27;l&#x27;&#x27;o&#x27;&#x27;\0&#x27;]</span></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = str1;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(str1) + <span class="number">1</span>;  <span class="comment">//  str+&#x27;\0&#x27; 7</span></span><br><span class="line"></span><br><span class="line">    nwritten = <span class="built_in">writev</span>(STDOUT_FILENO, iov, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld bytes written.\n&quot;</span>, nwritten);   <span class="comment">//14</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ————————————————</span></span><br><span class="line"><span class="comment">// 版权声明：本文为CSDN博主「粪逗er」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span></span><br><span class="line"><span class="comment">// 原文链接：https://blog.csdn.net/weixin_36750623/article/details/84579243shc@shc-virtual-machine:~/code/linux_network/TCP_IP$ ./test_writev.out </span></span><br><span class="line">hello world</span><br><span class="line"><span class="number">14</span> bytes written.</span><br></pre></td></tr></table></figure>


<h2 id="ET模式下-写触发"><a href="#ET模式下-写触发" class="headerlink" title="ET模式下 写触发"></a>ET模式下 写触发</h2><ul>
<li><a href="https://www.zhihu.com/question/263931629">https://www.zhihu.com/question/263931629</a></li>
</ul>
<h2 id="忙等待-与-阻塞"><a href="#忙等待-与-阻塞" class="headerlink" title="忙等待 与 阻塞"></a>忙等待 与 阻塞</h2><ul>
<li>忙等待占用cpu，阻塞不占用cpu<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻塞等待，阻塞期间不占用cpu</span></span><br><span class="line"><span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 忙等待，虽然也是在等待信号，但是一直占用cpu</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sem_trywait</span>(&amp;sem) == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;trywait error&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><ul>
<li>实现互斥的p操作一定要放在实现同步的p操作之后（防止死锁）</li>
<li>互斥：信号量初始为1，同步：信号量初始为0(或者n)</li>
</ul>
<h2 id="定义-声明"><a href="#定义-声明" class="headerlink" title="定义 声明"></a>定义 声明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">同一个文件下：</span><br><span class="line">对于变量而言，在同一个文件里面，很少使用声明这个说法，一般没有人去说我要声明一个变量，然后定义这个变量。或者说，声明与定义没有明显的区别。就好比 <span class="keyword">int</span> a；我们可以说这是一个声明，也可以说这是一个定义，因为当程序执行到这句话的时候就完成了内存分配。数据类型，变量名，对应的内存单元就已经明确了。</span><br><span class="line">多个文件下：</span><br><span class="line">在同一个工程，在多个文件中变量的声明和定义才有区别(比如说在first.c文件中先定义了一个<span class="keyword">int</span> a;我在second.c中要访问这个a,这时我们需要在second.c这个文件中声明一下);</span><br><span class="line">declaration 声明：</span><br><span class="line">声明 说明了变量的名字和类型，但并不分配存储空间。</span><br><span class="line">definition 定义：</span><br><span class="line">定义 也说明了变量的名字和类型，而且还为它分配了存储空间。并不一定要填充初始值</span><br><span class="line">initialization 初始化：</span><br><span class="line">初始化 是一种特殊的定义，初始化 = 定义的同时并赋初始值。</span><br><span class="line">assignment 赋值：</span><br><span class="line">将某一个数值 赋值 给一个变量的过程，赋值只针对于已分配存储空间的的变量而言。可以多次进行。在对类成员变量在构造函数内部赋值和在初始值列表中初始化而言，二者具有一些差异，这会影响程序的效率。</span><br><span class="line">变量能且只能被定义一次，但是可以被多次声明。</span><br><span class="line">任何包含了 显示初始化 的 声明 即成为了定义。如果想对一个变量进行声明那么就在变量前加<span class="keyword">extern</span>关键字，而且不要显示的初始化变量。</span><br><span class="line"></span><br><span class="line">作者：有心人</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/solution/content/63191/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 </span><br></pre></td></tr></table></figure>


<h2 id="指针-引用-指向指针的引用"><a href="#指针-引用-指向指针的引用" class="headerlink" title="指针 引用 指向指针的引用"></a>指针 引用 指向指针的引用</h2><p><a href="https://blog.csdn.net/fatfish_/article/details/86768887">https://blog.csdn.net/fatfish_/article/details/86768887</a></p>
<h2 id="数组的元素不能是引用"><a href="#数组的元素不能是引用" class="headerlink" title="数组的元素不能是引用"></a>数组的元素不能是引用</h2><ul>
<li>[]优先级高于&amp;和*</li>
<li><code>int &amp;a[10]</code>：非法，大小为10的数组，元素都是引用。</li>
<li><code>int (&amp;)a[10]</code></li>
</ul>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p><a href="https://www.jianshu.com/p/6fc9cea6daa2">https://www.jianshu.com/p/6fc9cea6daa2</a></p>
<ul>
<li>由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">  <span class="keyword">using</span> pos = std::string::size_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="C语言预定义宏"><a href="#C语言预定义宏" class="headerlink" title="C语言预定义宏"></a>C语言预定义宏</h2><ul>
<li>__LINE__：在源代码中插入当前源代码行号；</li>
<li>__FILE__：在源文件中插入当前源文件名；</li>
<li>__DATE__：在源文件中插入当前的编译日期</li>
<li>__TIME__：在源文件中插入当前编译时间；</li>
<li><strong>TIMESTAMP</strong>:当前源文件的最近一次的修改日期和时间，格式是Ddd Mmm Date hh:mm:ss yyyy 。该宏当做字符串对待</li>
<li>__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为1；</li>
<li><strong>__cplusplus</strong>：当编写C++程序时该标识符被定义。</li>
</ul>
<h2 id="计时函数-clock"><a href="#计时函数-clock" class="headerlink" title="计时函数 clock"></a><a href="https://zhuanlan.zhihu.com/p/152680520#:~:text=clock%20%28%29%E6%98%AFC%2FC%2B%2B%E4%B8%AD%E7%9A%84%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8E%E5%85%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%98%AFclock_t%EF%BC%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E6%98%AFtime.h%2Fctime%E3%80%82%20clock,%28%29%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%EF%BC%9A%E8%BF%94%E5%9B%9E%E4%BB%8E%E2%80%9C%E5%BC%80%E5%90%AF%E8%BF%99%E4%B8%AA%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E2%80%9D%E5%88%B0%E2%80%9C%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8clock%20%28%29%E5%87%BD%E6%95%B0%E2%80%9D%E6%97%B6%E4%B9%8B%E9%97%B4%E7%9A%84CPU%E6%97%B6%E9%92%9F%E8%AE%A1%E6%97%B6%E5%8D%95%E5%85%83%E6%95%B0%EF%BC%88clock%20tick%EF%BC%89%E3%80%82">计时函数 clock</a></h2>]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>BUG</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编</title>
    <url>/2022/03/26/%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<ul>
<li>dword ptr[地址]<ul>
<li>[地址]中的地址指向一个双字节数据<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dword   双字 就是四个字节</span><br><span class="line">ptr     pointer缩写 即指针</span><br><span class="line">[]里的数据是一个地址值，这个地址指向一个双字型数据</span><br><span class="line">比如mov eax, dword ptr [<span class="number">12345678</span>]  把内存地址<span class="number">12345678</span>中的双字型（<span class="number">32</span>位）数据赋给eax</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">汇编</span><br><span class="line">https:<span class="comment">//xiaotaoguo.com/p/cpp-move-semantics/#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC</span></span><br><span class="line"></span><br><span class="line">dword   双字 就是四个字节</span><br><span class="line">ptr     pointer缩写 即指针</span><br><span class="line">[]里的数据是一个地址值，这个地址指向一个双字型数据</span><br><span class="line">比如mov eax, dword ptr [<span class="number">12345678</span>]  把内存地址<span class="number">12345678</span>中的双字型（<span class="number">32</span>位）数据赋给eax </span><br><span class="line"></span><br><span class="line">mov eax,esi 	esi是寄存器。寄存器内部存的就是我们要取的值</span><br><span class="line">将esi中的数据传送到eax中</span><br><span class="line"></span><br><span class="line">mov eax,[esi] 	esi是寄存器，寄存器内部存的是我们要取的值的地址</span><br><span class="line">esi中是地址，将内存中该地址的数据传送到eax中，也就是间接寻址</span><br><span class="line"></span><br><span class="line">mov eax, dword ptr [esi] </span><br><span class="line">dword表示的是双字，四字节。esi中保存的是为内存中的地址。将该地址处的<span class="number">4</span>字节数据传送到eax中。</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">EAX可称为数据寄存器，你除了直接访问外，还可分别对其高十六位和低十六位进行访问。它们的低十六位就是把它们前边儿的E去掉，即EAX的低十六位就是AX。而且它们的低十六位又可以分别进行八位访问，也就是说，AX还可以再进行分解，即AX还可分为AH（高八位）AL（低八位）。</span><br><span class="line">eax, ebx, ecx, edx, esi, edi, ebp, esp等都是X86 汇编语言中CPU上的通用寄存器的名称，是<span class="number">32</span>位的寄存器。如果用C语言来解释，可以把这些寄存器当作变量看待。</span><br><span class="line"></span><br><span class="line">lea是“load effective address”的缩写，</span><br><span class="line">简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，</span><br><span class="line">例如：lea eax,[ebx+<span class="number">8</span>]就是将ebx+<span class="number">8</span>这个值直接赋给eax，而不是把ebx+<span class="number">8</span>处的内存地址里的数据赋给eax。</span><br><span class="line">而mov指令则恰恰相反，例如：mov eax,[ebx+<span class="number">8</span>]则是把内存地址为ebx+<span class="number">8</span>处的数据赋给eax。</span><br></pre></td></tr></table></figure>

<p>寻址方法<br><a href="https://blog.csdn.net/u012206617/article/details/86554855">https://blog.csdn.net/u012206617/article/details/86554855</a></p>
<p>ret call 汇编<br><a href="https://blog.csdn.net/qq_37340753/article/details/81585083">https://blog.csdn.net/qq_37340753/article/details/81585083</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lea     rax, [rbp-28]</span><br><span class="line">mov     QWORD PTR [rbp-24], rax</span><br><span class="line">显然，&amp;a 结果存放在 rax 寄存器中，不能稳定保存，是右值。p 存放在 rbp-24 对应的栈空间上，能够稳定保存。因此是左值。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>杂记</tag>
        <tag>x86</tag>
      </tags>
  </entry>
  <entry>
    <title>网络小白</title>
    <url>/2022/03/09/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%99%BD/</url>
    <content><![CDATA[<p>IP地址分为局域网内网IP及外网公共IP。同一个局域网两台不同的电脑，它们的外网公共IP是共用相同的IP，但局域网内网IP是不同的。。。</p>
<ul>
<li>在我学网络之前的一些问题。</li>
</ul>
<h2 id="路由器和光猫"><a href="#路由器和光猫" class="headerlink" title="路由器和光猫"></a>路由器和光猫</h2><ul>
<li>真想拆个路由器和光猫看看</li>
<li>关系<blockquote>
<p><img src="/2022/03/09/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%99%BD/2022-03-21-15-44-48.png"><br><img src="/2022/03/09/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%99%BD/2022-03-21-15-29-18.png"><br><img src="/2022/03/09/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%99%BD/2022-03-21-15-49-10.png"></p>
</blockquote>
</li>
</ul>
<h3 id="作用？路由器？？"><a href="#作用？路由器？？" class="headerlink" title="作用？路由器？？"></a>作用？路由器？？</h3><ul>
<li>光猫：Optical（光学的） modern（音译）<ul>
<li>光猫又称光调制调解器，它主要为了信号转换，把光信号转换成数字信号。</li>
</ul>
</li>
<li>路由器：传达室。负责把握内网和外网？<ul>
<li>内网 -&gt; 路由器 -&gt; 外网？<br><a href="https://www.lemei.net/post/47054.html">路由器和光猫1</a><br><a href="https://www.zhihu.com/question/363714770">路由器和光猫2</a></li>
</ul>
</li>
</ul>
<h2 id="私有ip和公有ip？-解决"><a href="#私有ip和公有ip？-解决" class="headerlink" title="私有ip和公有ip？ 解决"></a>私有ip和公有ip？ 解决</h2><ul>
<li><p>公有ip：又叫做 公网ip，互联网ip</p>
<ul>
<li>一般称公网中的IP地址为公有地址。公有地址由Inter NIC（因特网信息中心）负责，这些IP地址分配给注册并向Inter NIC提出申请的组织机构。公有地址是全球唯一的，公网中不可能存在两个相同的IP地址。</li>
</ul>
</li>
<li><p>私有ip：又叫做 私网ip、子网ip、局域网ip</p>
<ul>
<li>局域网的ip地址</li>
</ul>
</li>
<li><p>ifconfig和ipconfig查询到的是本机的ip地址，也就是私有ip，此类地址只在局域网内使用，不能联通外网。</p>
<ul>
<li>```bash<br>ipconfig查询局域网ip<br>ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<pre><code>    inet **192.168.147.188**  netmask 255.255.255.0  broadcast 192.168.147.255
    inet6 fe80::caba:d7fb:58e0:ff62  prefixlen 64  scopeid 0x20&lt;link&gt;
    ether 00:0c:29:58:7e:e5  txqueuelen 1000  (以太网)
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  - **inet 192.168.147.188**。是私有ip</span><br><span class="line">  - &gt;![](IP/2022-05-07-15-29-35.png)</span><br><span class="line">- ip138查询的ip地址是公有ip，这不是我们本机的ip，而是运营商分配给我们的ip，即是ISP路由器的ip。一般是所在子网最顶层的交换机/路由器的ip。这个ip会暴露用户的地理位置。（因为这个一般是中心交换机，是公网ip），没办法很精准，但是基本可以确定城市甚至是区。BAT这种大公司除了基于GPS的定位数据，基本都会有一个庞大的ip库，用来地理定位，当拿不到手机GPS权限，也没办法通过基站信号定位的时候，这个很管用。（这就是开放ip地址的原理？）</span><br><span class="line">  - 您的iP地址是：[223.73.111.165] 来自：中国广东深圳南山区 移动</span><br><span class="line">  - &gt;![](IP/2022-05-07-15-24-17.png) </span><br><span class="line">- 私有ip地址范围</span><br><span class="line">  - A类IP地址中：10.0.0.0--10.255.255.255 (大型公司局域网中使用)</span><br><span class="line">  - B类IP地址中：172.16.0.0--172.31.255.255 （中型公司局域网中使用）</span><br><span class="line">  - C类IP地址中：192.168.0.0--192.168.255.255 （家用/小企业公司局域网中使用）</span><br><span class="line">  - 私有地址与公有地址不同，并不是由Internet分配的，是不允许出现在Internet中的，我们在公网中是看不到私有IP的，并且公有地址也不会使用上述用作私有ip的地址。所以，私有地址是不能直接与Internet连接的。</span><br><span class="line">- 私有地址如何与Internet连接来访问公网</span><br><span class="line">  - &gt;![](IP/2022-03-21-17-01-32.png)</span><br><span class="line">  - &gt;![](IP/2022-03-21-16-59-36.png)</span><br><span class="line">  - 需要将私有IP地址转换成公网IP地址，与外部连接。</span><br><span class="line">  - 所以，路由器中会装有一个叫做 NAT（网络地址转换） 的软件，我们的路由器中会至少会有一个有效的公网IP，NAT会将我们的私有ip地址转成路由器中的公网ip与外部Internet连接。而同样的，因为使用的是路由器中的公共的公网IP来连接Internet，所以这个内网中的PC在Internet中显示的都是路由器的公共IP，这样做不仅提供了一定程度的安全，也可以有效的减缓可用的IP地址空间的枯竭问题。（像我们学校或者公司的内网一般都是这么做的）</span><br><span class="line"></span><br><span class="line">### 本地ip访问问题？半解决</span><br><span class="line">- 我在用本地的IP地址访问自己的webserver时，数据包进入公网了吗？甚至离开本机了吗？还是说像回环地址一样，还没出本机就被截获了？（本机-&gt;局域网-&gt;广域网)</span><br><span class="line">  - 我实验的时候，是不需要联网，就可以通过本机ip192.168...来访问（网站）对应端口。</span><br><span class="line">- 本机调本地的IP地址，不是localhost，会经过交换机吗</span><br><span class="line">  - 比如：本地地址：192.168.31.5，如果使用本地有一个程序访问192.168.31.5。会离开网卡吗？会离开局域网吗？还是说直接就在ip层获取了，并没有离开本机？</span><br><span class="line">&gt;这种情况下，不会经过本地网卡。建议看看tcp/ip详解卷一的2.7节。</span><br><span class="line">- 不会离开，经实验。</span><br><span class="line">  - [tracert追踪指令](https://www.cnblogs.com/godtrue/p/5882541.html)</span><br><span class="line">  - &gt;![](IP/2022-03-21-18-47-53.png)</span><br><span class="line">  - 在电脑没有连wifi的情况下，也可以成功访问192.168.xx.xx。</span><br><span class="line">    - 连wifi就是接入局域网。ifi是实现WLAN（无线局域网）的一种方式！没连wifi自然也就没接入局域网。</span><br><span class="line">- 群友：</span><br><span class="line">  - 本地发报文不需要联网</span><br><span class="line">  - 网卡之间有数据线链接就能发送报文成功</span><br><span class="line">- [找到一个硬核回答](https://www.zhihu.com/question/43590414/answer/1928842338)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## WIFI和局域网？解决</span><br><span class="line">### 总结</span><br><span class="line">&gt;![](IP/2022-05-07-16-07-58.png)</span><br><span class="line">### WAN LAN</span><br><span class="line">- WAN：World Area Network。广域网、外网，公网</span><br><span class="line">  - 一种地域范围覆盖广的计算机网络的集合，通常所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家。由于其超长的覆盖范围，发送介质主要是政府或者大型企业部署的电话线或光纤，</span><br><span class="line">- LAN: Local Area NetWork。局域网、内网、私网</span><br><span class="line">  - 主要是指在某一区域的计算机互联网络。“某一区域”指的是同一办公室、同一建筑物、同一公司和同一学校等，一般是方圆几千米以内。</span><br><span class="line"></span><br><span class="line">### 局域网</span><br><span class="line">- 局域网又分成有线局域网和无线局域网</span><br><span class="line">  - 无线局域网（WLAN）：不使用任何导线或传输电缆连接的局域网，其使用无线电波或电场与磁场作为数据传送的介质，传送距离一般只有几十米。</span><br><span class="line">  - 有线局域网：是使用导线或传输电缆连接的局域网，传送距离可达几千米</span><br><span class="line"></span><br><span class="line">#### WIFI和无线局域网</span><br><span class="line">- WLAN：Wireless Local Area Network </span><br><span class="line">- 实现无线局域网技术：</span><br><span class="line">  - WiFi、蓝牙等</span><br><span class="line">  - WiFi是无线保真（Wireless Fidelity）的英文缩写，是WLAN中的一种通信标准之一。该标准由于其实现技术相对简单、通信可靠、灵活性高和实现成本相对较低等特点，成为了WLAN的主流技术标准。</span><br><span class="line"></span><br><span class="line">- [参考](https://blog.csdn.net/wangyx1234/article/details/113444581)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 补充 localhost、127.0.0.1和0.0.0.0和本机IP</span><br><span class="line">- 127.0.0.1</span><br><span class="line">  - &gt;![](IP/2022-05-07-15-38-24.png)</span><br><span class="line">- 0.0.0.0</span><br><span class="line">  - &gt;![](网络小白/2022-05-07-18-51-56.png)</span><br><span class="line"></span><br><span class="line">[博客3.22](https://www.jianshu.com/p/ad7cd1d5be45)</span><br><span class="line">```txt</span><br><span class="line">localhost、127.0.0.1和0.0.0.0和本机IP的区别</span><br><span class="line">localhost</span><br><span class="line">localhost其实是域名，一般windows系统默认将localhost指向127.0.0.1，但是localhost并不等于127.0.0.1，localhost指向的IP地址是可以配置的</span><br><span class="line"></span><br><span class="line">127.0.0.1</span><br><span class="line">首先我们要先知道一个概念，凡是以127开头的IP地址，都是回环地址（Loop back address），其所在的回环接口一般被理解为虚拟网卡，并不是真正的路由器接口。</span><br><span class="line"></span><br><span class="line">所谓的回环地址，通俗的讲，就是我们在主机上发送给127开头的IP地址的数据包会被发送的主机自己接收，根本传不出去，外部设备也无法通过回环地址访问到本机。</span><br><span class="line"></span><br><span class="line">小说明：正常的数据包会从IP层进入链路层，然后发送到网络上；而给回环地址发送数据包，数据包会直接被发送主机的IP层获取，后面就没有链路层他们啥事了。</span><br><span class="line"></span><br><span class="line">而127.0.0.1作为&#123;127&#125;集合中的一员，当然也是个回环地址。只不过127.0.0.1经常被默认配置为localhost的IP地址。</span><br><span class="line">一般会通过ping 127.0.0.1来测试某台机器上的网络设备是否工作正常。</span><br><span class="line"></span><br><span class="line">0.0.0.0</span><br><span class="line">首先，0.0.0.0是不能被ping通的。在服务器中，0.0.0.0并不是一个真实的的IP地址，它表示本机中所有的IPV4地址。监听0.0.0.0的端口，就是监听本机中所有IP的端口。</span><br><span class="line"></span><br><span class="line">本机IP</span><br><span class="line">本机IP通常仅指在同一个局域网内，能同时被外部设备访问和本机访问的那些IP地址（可能不止一个）。像127.0.0.1这种一般是不被当作本机IP的。本机IP是与具体的网络接口绑定的，比如以太网卡、无线网卡或者PPP/PPPoE拨号网络的虚拟网卡，想要正常工作都要绑定一个地址，否则其他设备就不知道如何访问它。</span><br><span class="line"></span><br><span class="line">小例子剧场（帮助理解本机IP、127.0.0.1和0.0.0.0）</span><br><span class="line">现在有两台pc在同一个局域网内，分别为pc1与pc2，pc1上有一个网卡，IP地址为192.168.10.128</span><br><span class="line"></span><br><span class="line">pc1中sever监听127.0.0.1，则pc1中的client可以连上127.0.0.1，192.168.10.128连不上；而pc2中client都连不上。</span><br><span class="line">pc1中sever监听192.168.10.128，则pc1中的client可以连上192.168.10.128，127.0.0.1连不上；而pc2中client能连上192.168.10.128。</span><br><span class="line">pc1中sever监听0.0.0.0，则pc1中的client可以连上127.0.0.1和192.168.10.128，pc2中的client能连上192.168.10.128。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="进入公网？？"><a href="#进入公网？？" class="headerlink" title="进入公网？？"></a>进入公网？？</h2><ul>
<li>所以数据包是从哪里开始离开局域网的？：交换机（isp路由器呢？）</li>
</ul>
<h2 id="ip是否可以告诉别人？"><a href="#ip是否可以告诉别人？" class="headerlink" title="ip是否可以告诉别人？"></a>ip是否可以告诉别人？</h2><ul>
<li><blockquote>
<p>ipv4就那么多ip，世界上90%以上的设备是没有公网ip的，都是子网ip，这个ip除非别人正好跟你在一个子网，而且能路由到，否则没有太大意义。</p>
</blockquote>
</li>
<li><a href="https://www.zhihu.com/question/381339068/answer/1166898626">电脑IP地址能否告诉别人? - 车小胖的回答 - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/381339068/answer/1113294817">电脑IP地址能否告诉别人? - 大海的回答 - 知乎</a></li>
</ul>
<hr>
<ul>
<li>光猫图片（从小时候就困扰我，猫到底是啥。。。）<blockquote>
<p><img src="/2022/03/09/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%99%BD/2022-05-07-15-05-26.png"><br><img src="/2022/03/09/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%99%BD/2022-05-07-15-05-51.png"><br><img src="/2022/03/09/%E7%BD%91%E7%BB%9C%E5%B0%8F%E7%99%BD/2022-05-07-15-06-12.png"></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>小白问题</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统（预习）</title>
    <url>/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>预习杂记</p>
<span id="more"></span>

<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="cpu如何执行程序"><a href="#cpu如何执行程序" class="headerlink" title="cpu如何执行程序"></a>cpu如何执行程序</h2><h3 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h3><ul>
<li><p>计算机基本结构为 5 个部分，分别是<strong>运算器、控制器、存储器、输入设备、输出设备</strong><br><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-02-08-14-02.png"></p>
</li>
<li><p>有内存了为什么还要寄存器？</p>
<ul>
<li>内存离 CPU远，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，所以计算速度快。</li>
</ul>
</li>
<li><p>线路位宽：一次能传送多少位数据（我理解的）</p>
</li>
<li><p>cpu位宽：能控制多少条线路（我理解的）</p>
</li>
</ul>
<p><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-04-20-45-30.png"></p>
<ul>
<li>ELF：Executable and Linkable Format。<ul>
<li>可执行文件链接</li>
</ul>
</li>
</ul>
<h2 id="物理内存-硬盘-虚拟内存"><a href="#物理内存-硬盘-虚拟内存" class="headerlink" title="物理内存 硬盘 虚拟内存"></a>物理内存 硬盘 虚拟内存</h2><ul>
<li>volatile</li>
<li>缓存 寄存器 ？</li>
</ul>
<p><a href="https://blog.csdn.net/haoranhaoshi/article/details/94620751">csdn</a></p>
<ul>
<li><p>硬件构成维度：</p>
<ul>
<li>存储器包括内部存储器（内存）、外部存储器（外存）、寄存器。</li>
<li>内存包括只读存储器（ROM，Read Only memory）（只读，断电后数据保留）、随机存取存储器（RAM，Random Access Memory）（主存）（内存条）（可读可写，断电后数据丢失）、高速缓冲存储器（CACHE）。</li>
<li>外存（辅存）包括磁盘、光盘、U盘等。</li>
<li>磁盘分硬盘和软盘。软盘容量小，在光盘时代被淘汰。光盘写入数据需光盘刻录机，在U盘时代被淘汰。</li>
<li>硬盘分为机械硬盘、固态硬盘、混合硬盘。</li>
<li>寄存器是CPU（Central Processing Unit）的组成部分。</li>
<li>从功能方面来看，CPU内部由寄存器，控制器，运算器和时钟四部分构成，各部分之间由总线上的电流信号相互连通。总线分数据总线、控制总线、状态总线三种。</li>
</ul>
</li>
<li><p>程序运行维度：</p>
<ul>
<li>32位系统最多只能用4G内存（虚拟内存）：32位系统，即内存地址长度为32，最多映射2^32=2^2*2^30=4G个字节。</li>
<li>**物理内存即随机存取存储器空间。虚拟内存即硬盘一部分空间映射虚拟的内存。物理内存已满时从物理内存碎片甚至硬盘按需取用空间?**。虚拟内存对应的存储文件pagefile.sys在系统盘根目录下，默认隐藏。</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。<br><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-13-08-04-33.png"></p>
</blockquote>
<hr>
<p><a href="https://www.zhihu.com/question/353552689/answer/2213783608">知乎</a></p>
<ul>
<li>RAM：内存<ul>
<li>RAM：随机存储器。就是我们平时所说的“内存”，也就是手机/电脑等电子设备的运行空间。这地方可以类比“菜鸟驿站”，数据被调用，暂时存储此地，然而一定会被使用的。当然要是遇到爆仓，您的手机就很卡了</li>
</ul>
</li>
<li>ROM:只读存储器。PC机的硬件自检信息等涉及底层操作的玩意在里面呆着呢，用户无法对其执行删除操作。类似SD卡的写保护开关关闭状态吧。<blockquote>
<p>我有一个较为严谨的定义：该计算机体系(哈佛或者普林斯顿)内CPU地址总线(不管是各自独立的程序/数据地址总线，还是统一地址总线)所能直接寻址到的存储空间，都是该计算机的“内存空间”。不属于该范畴的存储空间，都是“外存空间”。进一步讲，负责物理实现计算机内存空间存储单元的器件(不管是ROM的还是RAM的)，就是该计算机系统的内存储器(当然前提要要合规的)。否则，就是外存储器。纯个人总结，欢迎评论。</p>
</blockquote>
</li>
</ul>
<p><a href="https://www.zhihu.com/question/443750102">知乎</a></p>
<ul>
<li><p>1<br>物理内存, 内存, 主存,这些说的都是一般长这样的玩意<br><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-13-07-41-31.png"><br>内存是计算机系统的中心, 主要作用就是临时放点数据, 给别的地方用, 有个很关键的数据, 是内存的容量, 你的是4G, </p>
<p>硬盘, 固态硬盘, 机械硬盘, 磁盘, 外存, 辅存, 一般这些个叫法, 举例机械硬盘一般长这样 <img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-13-07-41-49.png"><br>然后硬盘是存放数据用的, 你下载的电影啥的都放在这里面. 也有个指标是容量, 你的C盘剩余20G, 不改变其它条件下, 你还可以在C盘存20G的电影</p>
<p>物理内存和硬盘有很多区别, 而且实际上也不是同一种东西, 虽然实现的功能有点类似吧. 对你来说, 主要区别就是, 硬盘是你的货仓, 里面有你的冰箱, 拖鞋, 螺丝刀等等等等你愿意放在里面的东西. 需要了就拿来放里, 不需要了就拿出去扔掉. 就是这么用的, 内存是你的桌子, 你有个习惯, 无论用什么都不直接在货仓用, 必须拿出来放到桌子上, 用的时候从桌子上面取. (这么类比有些不对, 但不影响你理解, 实际上内存从硬盘拿东西是复制一份出来);为什么内存不足卡, 因为你桌子堆的太满, 找东西比较费时,怎么清理, 关掉应用, 只要你用某样东西, 它就会在桌子上占着一部分空间, 你用螺丝刀, 它就在桌子上, 你不用了想着把关闭了, 桌子就把螺丝刀扔出去了, 你就又有了一部分桌面空间, 可以放咖啡机什么的了.</p>
</li>
</ul>
<hr>
<ul>
<li>2<br>内存 物理硬盘 虚拟地址<br>内存是工作台，磁盘（硬盘）是仓库。工作台上能放的东西少但是伸手就能拿到但是毕竟空间有限，仓库的东西就要一路跑去货架上找来用。[虚拟内存就是给仓库的一排货架上贴个标签充当工作台，比起真工作台还是慢的多。?这对吗。说得不对吧。虚拟内存不是取物理内存的碎片吗]</li>
</ul>
<p><a href="https://xiaolincoding.com/os/3_memory/vmem.html#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5">内存</a></p>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><blockquote>
<p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：<br>第一个就是<strong>内存碎片</strong>的问题。<br>第二个就是<strong>内存交换的效率低</strong>的问题。<br>接下来，说说为什么会有这两个问题。</p>
</blockquote>
<blockquote>
<p>我们先来看看，分段为什么会产生<strong>内存碎片</strong>的问题？<br>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：<br>游戏占用了 512MB 内存<br>浏览器占用了 128MB 内存<br>音乐占用了 256 MB 内存。<br>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。<br>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。<br><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-13-10-01-21.png"><br>这里的内存碎片的问题共有两处地方：<br>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；<br>内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；<br>针对上面两种内存碎片的问题，解决的方式会有所不同。</p>
</blockquote>
<blockquote>
<p>解决<strong>外部内存碎片</strong>的问题就是<strong>内存交换</strong>。<br>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。<br>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。<br>我认为这个swap空间就是网上所谓的将一部分硬盘空间视作内存吧。</p>
</blockquote>
<blockquote>
<p>再来看看，分段为什么会导致内存交换效率低的问题？<br>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。<br>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。<br>所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</p>
</blockquote>
<blockquote>
<p>为了解决内存分段的<strong>内存碎片</strong>和<strong>内存交换效率低</strong>的问题，就出现了内存分页。</p>
</blockquote>
<h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><blockquote>
<p>内存分页<br>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。<br>要解决这些问题，那么就要想出能<br>  【1】少出现一些内存碎片的办法。<br>另外，当需要进行内存交换的时候，<br>  【2】让需要交换写入或者从磁盘装载的数据更少一点，<br>这样就可以解决问题了。这个办法，也就是内存分页（Paging）。<br>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB。<br>虚拟地址与物理地址之间通过页表来映射，如下图：<br><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-13-09-57-19.png"><br>页表是存储在内存里的，内存管理单元 （MMU）就做将虚拟内存地址转换成物理地址的工作。<br>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
</blockquote>
<blockquote>
<p>分页是怎么解决分段的<strong>内存碎片</strong>、<strong>内存交换效率低</strong>的问题？<br><strong>内存碎片</strong><br>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。<br><strong>内存交换</strong><br>我：可以不用一次把整个进程的内存交换到物理硬盘上。而是只把正在运行进程的某部分最近没被用到过的内存页面释放掉。，这样子交换的内存数据少，效率提高。（从物理内存到硬盘的优化）。<br>如果内存空间不够，操作系统会把<strong>其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所</strong>以，一次性写入磁盘的也只有<strong>少数的一个页或者几个页</strong>，不会花太多时间，内存交换的效率就相对比较高。<br><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-13-09-55-54.png"><br><strong>更进一步地</strong>，<br>我：之前是一下子把整个程序的虚拟地址各个部分都按照页表对应的指向加载到物理内存中。现在是可以只加载一部分。（从虚拟内存到物理内存的优化）<br>分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，<strong>而是只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存（中对应的位置）里面去</strong>。</p>
</blockquote>
<p>我问题：<br>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。</p>
<p>我问题：一个进程无用了，需要按页释放，同一页里要是有别的还在运行的进程怎么办？</p>
<p>不会的，分页是把每个进程的整个虚拟分成4KB一页一页的，然后经由MMU内存管理单元映射到物理内存上的一页一页上。每个进程都有自己的虚拟地址，又不是共享一个虚拟内存，所以每个进程的页当然不是一个的（从虚拟内存上看就不是一个）。MMU映射到物理地址时也当然会避免映射到同一块物理内存。（物理内存上更不可能是同一个）<br>进程的页面的一部分被用到了，一部分没被用到，那这个内存页面就是最近被使用了，不会被释放掉。</p>
<blockquote>
<p>林哥，关于内存分页，我有两个小问题没太理解，刚开始学，问的可能有些小白😭。有空的时候可以帮忙解答下嘛😭。谢谢林哥<br>（1）”由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。”<br>对这句话我不太能理解，每个页的大小只有4KB。感觉挺小的啊。按页为单元释放，不是也会产生内存碎片吗？（4Kb不小吗，我看控制面板上的进程起码都是论MB算的呀）<br>（2）”当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常“。其中所说的”查不到“，是指虚拟内存和物理内存的页之间的映射已经建立好，但是还没有加载到物理内存中吗？还是说根本没有建立映射？（是前者吧）<br>（3）纠错：“分段机制下的虚拟地址由两部分组成，段选择子和段内偏移量”。“段选择因子”少打一个“因”子。</p>
</blockquote>
<blockquote>
<p>分段是需要一片连续的内存，如果此时内存只有一个10MB连续的内存，那么如果有个需要20MB内存大小的程序要执行，那么就会执行失败，此时这连续10MB就相当于是一个内存碎片（外部内存碎片）。但是分片就不一样的，内存不一定要连续的，只有内存有20MB的空间，也就是有20MB/4KB个分片的话，就可以运行这个程序，就不存在外部内存碎片的问题了。当然分片的话内部内存碎片还是存在的，比如明明只需要一个1kb的内存，但是还是划分了4kb的内存。<br>根本没有建立映射，也就是访问虚拟机地址对应页表中的页目录项找不到物理地址。</p>
</blockquote>
<blockquote>
<p>分页机制下，虚拟地址和物理地址是如何映射的？<br>…</p>
</blockquote>
<h2 id="条件变量-mutex-t实现生产者消费者"><a href="#条件变量-mutex-t实现生产者消费者" class="headerlink" title="条件变量 + mutex_t实现生产者消费者"></a>条件变量 + mutex_t实现生产者消费者</h2><p>…</p>
<h2 id="信号量-mutex-t实现生产者消费者"><a href="#信号量-mutex-t实现生产者消费者" class="headerlink" title="信号量+mutex_t实现生产者消费者"></a>信号量+mutex_t实现生产者消费者</h2><blockquote>
<p><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-21-08-27-13.png"><br><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-04-21-08-26-40.png"></p>
</blockquote>
<ul>
<li><p>正确</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">procducer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">P</span>(empty)  <span class="comment">//  等待空位</span></span><br><span class="line">    <span class="built_in">P</span>(mutex)  <span class="comment">//  进入临界区</span></span><br><span class="line">    生成数据</span><br><span class="line">    <span class="built_in">V</span>(mutex)  <span class="comment">//  离开</span></span><br><span class="line">    <span class="built_in">V</span>(full)   <span class="comment">//  数据数量+1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">consumer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">P</span>(full)   <span class="comment">//  等待数据</span></span><br><span class="line">    <span class="built_in">P</span>(mutex)  <span class="comment">//  进入临界区</span></span><br><span class="line">    消耗数据</span><br><span class="line">    <span class="built_in">V</span>(mutex)  <span class="comment">//  离开</span></span><br><span class="line">    <span class="built_in">V</span>(empty)  <span class="comment">//  增加空位</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>错误</p>
<ul>
<li>不能先加锁后控制信号量</li>
<li>如consumer是p(mutex)，然后P(full)阻塞，等待producer唤醒。但是producer进入不了临界区。因为锁已经被consumer拿住，没有释放。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">procducer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">P</span>(mutex)  <span class="comment">//  进入临界区</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">P</span>(empty)  <span class="comment">//  等待空位</span></span><br><span class="line">        生成数据</span><br><span class="line">        <span class="built_in">V</span>(full)   <span class="comment">//  数据数量+1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">V</span>(mutex)  <span class="comment">//  离开</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">consumer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">P</span>(mutex)  <span class="comment">//  进入临界区</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">P</span>(full)   <span class="comment">//  等待数据</span></span><br><span class="line">      消耗数据</span><br><span class="line">      <span class="built_in">V</span>(empty)  <span class="comment">//  增加空位</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">V</span>(mutex)  <span class="comment">//  离开</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>错误</p>
<ul>
<li>不能还没生产/消耗产品就操作信号量</li>
<li>consumer阻塞在P(full) ; producer P(empty) , V(full)唤醒consumer，consumer进入临界区想消耗数据，但是实际上数据还没产生。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">procducer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">P</span>(empty)  <span class="comment">//  等待空位</span></span><br><span class="line">    <span class="built_in">V</span>(full)   <span class="comment">//  数据数量+1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">P</span>(mutex)  <span class="comment">//  进入临界区</span></span><br><span class="line">    生成数据</span><br><span class="line">    <span class="built_in">V</span>(mutex)  <span class="comment">//  离开</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">consumer</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">P</span>(full)   <span class="comment">//  等待数据</span></span><br><span class="line">    <span class="built_in">V</span>(empty)  <span class="comment">//  增加空位</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">P</span>(mutex)  <span class="comment">//  进入临界区</span></span><br><span class="line">    消耗数据</span><br><span class="line">    <span class="built_in">V</span>(mutex)  <span class="comment">//  离开</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-05-01-14-55-25.png"></p>
<ul>
<li><p>问题</p>
</li>
<li><p>系统调用的cpu上下文开销？</p>
</li>
<li><p>文件结构：超级块？</p>
</li>
<li><p>阻塞与非阻塞 I/O VS 同步与异步 I/O</p>
<ul>
<li><a href="https://xiaolincoding.com/os/6_file_system/file_system.html#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5-i-o">https://xiaolincoding.com/os/6_file_system/file_system.html#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5-i-o</a><br><img src="/2022/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2022-05-03-09-06-33.png"></li>
</ul>
</li>
<li><p>在前面我们知道了，I/O 是分为两个过程的：</p>
<ul>
<li>1，数据准备的过程</li>
<li>2，数据从内核空间拷贝到用户进程缓冲区的过程</li>
<li>阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。</li>
<li>异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。</li>
</ul>
</li>
<li><p>阻塞、非阻塞是指是否等待内核准备数据。但是无论阻塞、非阻塞，都需要等待从内核拷贝到用户的这个过程。因而也都属于同步。</p>
</li>
<li><p>非阻塞与异步区别</p>
<ul>
<li>非阻塞IO：先epoll监听（省去了等待内核准备数据的过程），然后应用程序再主动调用read（需要等待数据从内核空间拷贝到用户进程缓冲区），read完成后才能得到数据。也就是说必须要有应用程序必须主动发出read这一动作。</li>
<li>异步IO：直接aio_read，当内核完成时，通知应用程序。这样应用程序不必等待1，也不必主动调用read等待2。当内核通知应用程序时，就代表数据已经可用，即应用程序已经得到这些数据。这个过程中应用程序没有任何等待，只是进行了一个aio_read，之后就可以去干自己想干的其他事情了。过一阵子得到通知后直接使用得到的数据即可。</li>
</ul>
</li>
<li><p><a href="https://xiaolincoding.com/os/8_network_system/zero_copy.html"><strong>零拷贝</strong></a></p>
</li>
</ul>
<p><strong>PageCache作用</strong></p>
<ul>
<li><strong>大文件传输</strong><ul>
<li>不用零拷贝！</li>
</ul>
</li>
</ul>
<p>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O。通常，对于磁盘，异步 I/O 只支持直接 I/O。</p>
<p>插个题外话，网上文章不少说，epoll_wait 返回时，对于就绪的事件，epoll使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。</p>
<p>这是错的！看过 epoll 内核源码的都知道，压根就没有使用共享内存这个玩意。你可以从下面这份代码看到， epoll_wait 实现的内核代码中调用了 __put_user 函数，这个函数就是将数据从内核拷贝到用户空间。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><p>多线程比单线程快吗？为什么？</p>
<ul>
<li><a href="https://www.cnblogs.com/yaomaomao/p/11969674.html">https://www.cnblogs.com/yaomaomao/p/11969674.html</a></li>
<li>我写的mysql数据库连接池是多线程快于单线程</li>
</ul>
</li>
<li><p>是不是说cpu有几个核心，系统就最多能有几个进程处于执行状态</p>
<ul>
<li><a href="https://bbs.csdn.net/topics/390950384">https://bbs.csdn.net/topics/390950384</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>补码原码反码运算</title>
    <url>/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>原码、补码、反码运算</p>
<span id="more"></span>

<h1 id="原码-反码-补码"><a href="#原码-反码-补码" class="headerlink" title="原码 反码 补码"></a>原码 反码 补码</h1><ul>
<li><p>先说好我的看法</p>
<ul>
<li>根本就没有所谓的原码和反码，补码也不应该叫做补码，不知道是谁起的名字，还不如叫做真码。(计算机内部真正是以什么样的01序列存储的对应数)</li>
</ul>
</li>
<li><p><strong>补码：一个数在计算机中真正的编码形式。真正是以什么样的01序列存储的（也就是所谓的补码表示法）</strong>。计算机里就是这么表示的，根本没有什么原码和反码。</p>
</li>
<li><p>原码：我们数学人为计算的 一个数的二进制表示，再加上一个符号位。这也就是所谓的原码表示法。</p>
</li>
<li><p>计算机内部为什么将数编码成真码（补码表示法）这样的01序列。（最早最早的时候或许用过原码表示法） </p>
<ul>
<li>为了使得n位01序列 所能表示的&gt;=0的数和 其所表示的负数个数相同。</li>
<li>为了让0不会有多种编码方式表示。</li>
<li>也就是在原码表示法下，0才有正0和负0，计算机真正使用的编码方式（补码表示法）根本就没有负0</li>
</ul>
</li>
<li><p><strong>而所谓的原码到反码再到补码的转换方法，不过是为了让我们人类可以快速人工计算出一个数在计算机内部是以什么样的01序列存储的。</strong></p>
</li>
<li><p>原码 -&gt; 补码</p>
<ul>
<li><code>&gt;=0 原码就是补码</code></li>
<li><code>&lt;0 补码 = 原码取反 + 1</code>（注意符号位不取反）</li>
</ul>
</li>
<li><p>补码 -&gt; 原码</p>
<ul>
<li><code>&gt;=0 原码就是补码</code></li>
<li><code>&lt;0 原码 = 补码取反 + 1</code>（注意符号位不取反）</li>
</ul>
</li>
<li><p>（移码 = 补码的符号位取反，表示范围和补码一致）</p>
</li>
<li><p>我们来看看所谓的原码表示法（有符号定点整数）</p>
<h3 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h3></li>
</ul>
<table>
<thead>
<tr>
<th>原码</th>
<th align="center">表示的数</th>
</tr>
</thead>
<tbody><tr>
<td>0 1111111</td>
<td align="center">2^7-1</td>
</tr>
<tr>
<td>…</td>
<td align="center">…</td>
</tr>
<tr>
<td>0 0000001</td>
<td align="center">1</td>
</tr>
<tr>
<td>0 0000000</td>
<td align="center">0</td>
</tr>
<tr>
<td>1 0000000</td>
<td align="center">-0</td>
</tr>
<tr>
<td>1 0000001</td>
<td align="center">-1</td>
</tr>
<tr>
<td>1 0000010</td>
<td align="center">-2</td>
</tr>
<tr>
<td>…</td>
<td align="center">…</td>
</tr>
<tr>
<td>1 1111111</td>
<td align="center">-(2^7-1)</td>
</tr>
</tbody></table>
<ul>
<li>可以看出 表示<strong>原码整数范围</strong> <code>[-2^7-1,2^7-1]</code>。  —&gt; <strong><code>[-2^n-1,2^n-1]</code></strong><ul>
<li><code>负数：[-2^7-1,-0]</code> —&gt; <code>[-2^n-1,-0]</code></li>
<li><code>&gt;=0：[0,2^7-1]</code>。  —&gt; <code>[0,2^n-1]</code></li>
</ul>
</li>
<li><strong>原码小数的范围是 <code>– (1–2^–n) ≤ x ≤ 1–2^–n</code>（n是数值位数）</strong></li>
</ul>
<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-10-17-21.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-10-17-15.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-10-16-30.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-10-16-40.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-10-29-47.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-10-35-10.png"></p>
</blockquote>
<h2 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a><strong>补码</strong>表示法</h2><table>
<thead>
<tr>
<th>补码</th>
<th align="center">表示的数</th>
</tr>
</thead>
<tbody><tr>
<td>0 1111111</td>
<td align="center">2^7-1</td>
</tr>
<tr>
<td>…</td>
<td align="center">…</td>
</tr>
<tr>
<td>0 0000001</td>
<td align="center">1</td>
</tr>
<tr>
<td>0 0000000</td>
<td align="center">0</td>
</tr>
<tr>
<td>1 1111111</td>
<td align="center">-1</td>
</tr>
<tr>
<td>1 1111110</td>
<td align="center">-2</td>
</tr>
<tr>
<td>1 1111101</td>
<td align="center">-3</td>
</tr>
<tr>
<td>…</td>
<td align="center">…</td>
</tr>
<tr>
<td>1 1111111</td>
<td align="center">-(2^7-1)</td>
</tr>
<tr>
<td>1 0000000</td>
<td align="center">-2^7</td>
</tr>
</tbody></table>
<ul>
<li>可以看出 范围<code>[-2^7,2^7-1]</code>   —&gt; <strong>n+1位（数值位为n位）补码表示定点整数范围：<code>[-2^n,2^n-1]</code></strong><ul>
<li><code>负数：[-2^7,-1]</code>   —&gt;  <code>[-2^n,-1]</code></li>
<li><code>&gt;=0 ：[0,2^7-1]</code>   —&gt;  <code>[0,2^n-1]</code></li>
</ul>
</li>
<li>多么美好！负数<code>2^8</code>个，<code>&gt;=0</code>的有<code>2^8</code>个</li>
<li>表示的也很自然啊！<ul>
<li><code>[00000000,01111111]</code>有2^8个，首位为0，为非负数</li>
<li><code>[10000000,11111111]</code>有2^8个，首位为1，为负数</li>
</ul>
</li>
<li>所以由<code>01111111</code>到<code>10000000</code>时再循环的表示回来 （如表）</li>
</ul>
<p>同理 <strong>n+1位（数值位为n位）补码表示定点小数范围：<code>[-1,1-2^(-n)];</code></strong></p>
<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-10-40-33.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-10-44-05.png"></p>
</blockquote>
<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-15-15.png"></p>
</blockquote>
<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-38-12.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-38-22.png"></p>
</blockquote>
<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><ul>
<li>快速求补码的相反数 -x补 x补<ul>
<li>符号位和数值位全部取反，末尾加1。（正常应该补-&gt;原-&gt;符号位取反-&gt;补）<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-03-13-32-18.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-03-13-32-28.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-03-13-32-33.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-24-20.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-23-55.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-26-24.png"></p>
</blockquote>
<h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-50-38.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-56-01.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-11-56-28.png"></p>
</blockquote>
<h2 id="补码作用：用补码把减法变成加法。"><a href="#补码作用：用补码把减法变成加法。" class="headerlink" title="补码作用：用补码把减法变成加法。"></a>补码作用：用补码把减法变成加法。</h2><ul>
<li><strong>原码计算</strong>：<strong>一个数的原码 - 一个负数的原码 = 一个数的原码 + 这个负数的补码 = 答案的原码</strong>。</li>
<li>先说好 计算套路：A - B = A的原码 + （-B）的补码 。其中符号位参与运算，并把结果溢出的位舍去（最高位可能溢出）。得到的结果就是答案的原码。</li>
<li>补码原生定义：模 - a的绝对值 = a的补码</li>
<li>为什么要把减法转化成加法？<ul>
<li>因为如果是减法的话机器会变得复杂。</li>
</ul>
</li>
<li>那么如何把减法变成加法？<ul>
<li>利用补码。</li>
<li>a + ((-b)的原码) = （a - |-b|的原码） = a + （-b）的补码 = 答案的原码</li>
<li>a - b的运算 ，将 -b看作一个整体，变成 a + (-b)<br>那么-b如何处理？就是把b由原码转化成补码 b = ~b + 1<br>之后a + b即可 得到正确结果</li>
</ul>
</li>
<li>原理：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">88</span> ： <span class="number">01011000</span></span><br><span class="line"><span class="number">66</span> ： <span class="number">01000010</span></span><br><span class="line"></span><br><span class="line"><span class="number">88</span> +（- <span class="number">66</span>）</span><br><span class="line">即</span><br><span class="line">  <span class="number">01011000</span>      <span class="number">88</span></span><br><span class="line">+ <span class="number">11000010</span>   -  <span class="number">66</span></span><br><span class="line">————————————</span><br><span class="line"></span><br><span class="line"><span class="comment">//  88 - 66</span></span><br><span class="line"><span class="comment">//  01011000</span></span><br><span class="line"><span class="comment">//- 01000010</span></span><br><span class="line"><span class="comment">//————————————</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">-66</span>      -- 模-|<span class="number">-66</span>|的绝对值---&gt; 补数 <span class="number">290</span></span><br><span class="line"><span class="number">11000010</span> -- 除了符号位外取反+<span class="number">1</span>---&gt; 补码 <span class="number">10111110</span></span><br><span class="line"></span><br><span class="line">补码即补数的原码。补码的原生定义就是 模 - a的绝对值 =  a的补码。（易知模就是<span class="number">8</span>位能表示的最大值，一定比<span class="number">8</span>位数a的绝对值大）</span><br><span class="line"></span><br><span class="line">注意 加法操作 符号位也参与运算！详情见数论！</span><br><span class="line"></span><br><span class="line">  <span class="number">01011000</span>      <span class="number">88</span></span><br><span class="line">+ <span class="number">10111110</span>   +  <span class="number">290</span></span><br><span class="line">———————————— ————————</span><br><span class="line"><span class="number">1</span> <span class="number">00010110</span>      <span class="number">378</span></span><br><span class="line"></span><br><span class="line">最高位的<span class="number">1</span>属于溢出，舍弃 即 <span class="number">378</span> % <span class="number">256</span> = <span class="number">22</span> ；也即<span class="number">00010110</span> </span><br><span class="line"></span><br><span class="line">由于只有<span class="number">8</span>位，所以最高位<span class="number">1</span>舍弃。 剩下的就是<span class="number">00010110</span> 即<span class="number">22</span></span><br><span class="line">这可不是错误，这就是计算机内部在利用多余的位被舍弃来进行计算。</span><br></pre></td></tr></table></figure>
附带微信图片</li>
<li>原码加减<br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-18-22.png"></li>
</ul>
<h2 id="纯补码运算—加减"><a href="#纯补码运算—加减" class="headerlink" title="纯补码运算—加减"></a>纯补码运算—加减</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>计算时别忘了补码的符号位也占机器字长</li>
<li>符号位参与运算，符号位产生的进位自然丢掉</li>
<li>补码运算：计算时带着符号算，符号位产生的进位自动丢掉。<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-09-19-40.png"></p>
</blockquote>
</li>
<li>补码：<ul>
<li>正数同原码</li>
<li>负数补码中，<ul>
<li>最右边的1以及往右的数同原码 ：即<code>[100000]</code> 同原码</li>
<li>最右边的1往左与原码相反（不包括那个1）：即[xxxxxx1)与原码相反</li>
</ul>
</li>
</ul>
</li>
<li><strong>A补 + B补 = ans补，无论正负。</strong></li>
<li>[A+B]补 = A补 + B补</li>
<li>[A-B]补 = A补 + [-B]补</li>
<li>其真实结果（人类看的）记得要把补码转换为原码<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-09-22-48.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-09-30-41.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-09-40-40.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-18-21-29-14.png"></p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>/<span class="number">16</span> =  <span class="number">0.1001</span>  (<span class="number">01001</span>向右移动<span class="number">4</span>位)</span><br><span class="line"><span class="number">11</span>/<span class="number">16</span> = <span class="number">0.1011</span>  (<span class="number">01011</span>向右移动<span class="number">4</span>位)</span><br><span class="line"><span class="number">9</span>/<span class="number">16</span> 补码 -&gt; <span class="number">0.1001</span> (因为<span class="number">9</span>/<span class="number">16</span>&gt;<span class="number">0</span>)</span><br><span class="line">同理 <span class="number">11</span>/<span class="number">16</span> 补码 -&gt; <span class="number">0.1011</span></span><br><span class="line">  <span class="number">0.1001</span></span><br><span class="line">+ <span class="number">0.1011</span></span><br><span class="line">----------</span><br><span class="line">  <span class="number">1.0100</span></span><br><span class="line">ans补码 = <span class="number">1.0100</span></span><br><span class="line">所以 ans原码 = <span class="number">1.1100</span></span><br><span class="line">故ans = <span class="number">-12</span>/<span class="number">16</span></span><br><span class="line">可以看出溢出 那么怎么办？</span><br></pre></td></tr></table></figure>

<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><h4 id="一位判断"><a href="#一位判断" class="headerlink" title="一位判断"></a>一位判断</h4><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-09-49-44.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-18-21-48-21.png"></p>
</blockquote>
<h4 id="两位判断"><a href="#两位判断" class="headerlink" title="两位判断"></a>两位判断</h4><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-09-52-53.png"></p>
</blockquote>
<ul>
<li>例子<ul>
<li>10：负数+负数 下溢</li>
<li>01：正数+正数 上溢<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了判断“溢出”是否发生，可使用“双符号位法”来判断是否溢出，使用双符号位法需要遵循以下两个规则：</span><br><span class="line">1）两个符号位都看做数码一样参加运算；</span><br><span class="line">2）两数进行以2^n+2为模的加法，即最高符号位上产生的进位要丢掉；</span><br><span class="line"></span><br><span class="line">具体使用方法：</span><br><span class="line">1）x=+1100, y=+1000, 求x+y</span><br><span class="line">解答：</span><br><span class="line">x补=00 1100</span><br><span class="line">y补=00 1000</span><br><span class="line">x补+y补=01 0100</span><br><span class="line">结论：两个符号位出现01，表示正溢出</span><br><span class="line"></span><br><span class="line">2）x=-1100, y=-1000, 求x+y</span><br><span class="line">解答：</span><br><span class="line">x补=11 0100</span><br><span class="line">y补=11 1000</span><br><span class="line">x补+y补=101100（最高符号位进位已扔掉）</span><br><span class="line">结论：两符号位出现10，表示负溢出</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="乘"><a href="#乘" class="headerlink" title="乘"></a>乘</h2><h3 id="原码一位乘"><a href="#原码一位乘" class="headerlink" title="原码一位乘"></a>原码一位乘</h3><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-18-22-28-10.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-18-22-30-27.png"></p>
</blockquote>
<h3 id="补码一位乘-重点！"><a href="#补码一位乘-重点！" class="headerlink" title="补码一位乘 重点！"></a>补码一位乘 重点！</h3><ul>
<li>算数移位<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-20-10-16-43.png"></p>
</blockquote>
</li>
</ul>
<h3 id="booth"><a href="#booth" class="headerlink" title="booth"></a>booth</h3><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-20-10-39-41.png"></p>
</blockquote>
<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-20-10-48-46.png"></p>
</blockquote>
<h3 id="乘法小结"><a href="#乘法小结" class="headerlink" title="乘法小结"></a>乘法小结</h3><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-20-11-33-56.png"></p>
</blockquote>
<h2 id="除"><a href="#除" class="headerlink" title="除"></a>除</h2><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-20-11-48-51.png"></p>
</blockquote>
<h3 id="不恢复余数法"><a href="#不恢复余数法" class="headerlink" title="不恢复余数法"></a>不恢复余数法</h3><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-20-15-28-28.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-20-15-28-43.png"></p>
</blockquote>
<h2 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h2><h3 id="算数移位：只移动数值位"><a href="#算数移位：只移动数值位" class="headerlink" title="算数移位：只移动数值位"></a>算数移位：只移动数值位</h3><ul>
<li><p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-08-25-06.png"></p>
</li>
<li><p>原码算术移位</p>
<ul>
<li>左移：低位补0、高位舍弃</li>
<li>右移：高位补0、低位舍弃</li>
</ul>
</li>
<li><p>反码算数移位</p>
<ul>
<li>负数<ul>
<li>左：低位补1、高位舍弃</li>
<li>右：高位补1、低位舍弃</li>
</ul>
</li>
<li>正数<ul>
<li>同原码</li>
</ul>
</li>
</ul>
</li>
<li><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-15-12-09-16.png"></p>
</blockquote>
</li>
<li><p>例子</p>
<ul>
<li><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-08-33-20.png"></p>
</blockquote>
</li>
<li><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-08-39-58.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>硬件</p>
<ul>
<li><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-09-00-59.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>补码左移时丢1相当于原码左移时丢0，不会影响精度</p>
</li>
<li><p>补码右移时丢0相当于原码右移时丢0，不会影响精度</p>
</li>
<li><p>例子</p>
<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-31-12-05-52.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-31-12-05-34.png"></p>
</blockquote>
</li>
</ul>
<h3 id="逻辑移位：所有位都移动"><a href="#逻辑移位：所有位都移动" class="headerlink" title="逻辑移位：所有位都移动"></a>逻辑移位：所有位都移动</h3><ul>
<li><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-19-09-09-15.png"></p>
</blockquote>
</li>
<li>左移：低位补0、高位舍弃</li>
<li>右移：高位补0、低位舍弃</li>
</ul>
<h3 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h3><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-15-12-13-03.png"></p>
</blockquote>
<hr>
<h1 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h1><p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-16-20-31.png"></p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-08-55-22.png"></p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-08-55-04.png"></p>
<ul>
<li>阶码和尾数都用原码表示<br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-17-03-08.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-16-20-31.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-18-41-57.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-20-04-50.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-18-31-41.png"></li>
</ul>
<h2 id="规格化浮点数"><a href="#规格化浮点数" class="headerlink" title="规格化浮点数"></a>规格化浮点数</h2><p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-04-17.png"></p>
<ul>
<li>尾数部分：小数点左边为符号位，右边为数值位 </li>
<li>解码部分：左侧为符号位，右侧为数值位</li>
<li>规格化：最高数值位为有效值<ul>
<li>原码：无论正负，最高位数值位 = 1</li>
<li>补码：最高数值位和符号位相反<ul>
<li>正数：最高位数值位 = 1</li>
<li>负数：最高位数值位 = 0</li>
</ul>
</li>
</ul>
</li>
<li>确定真值时，一定要先把补码转化成原码，再求出范围。</li>
<li><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-04-43.png"><ul>
<li>规格化<code>0.110 ； 1.1110100</code><ul>
<li>由于尾数用补码表示，所以数值最高位应该和符号位不同，所以算数左移3位，移到1。阶码因此-3.</li>
</ul>
</li>
<li>结果：<code>0.011 ； 1.0100000</code><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-07-22.png"></li>
</ul>
</li>
<li>阶码用补数表示的情况的阶码范围，就和前面说的补数本身的范围一样。<ul>
<li><strong>n+1位（数值位为n位）补码表示定点整数范围：<code>[-2^n,2^n -1]</code></strong><ul>
<li>故 阶码最小是 <code>2^(-2^n);</code></li>
<li>最大时<code>2^(2^n - 1);</code></li>
</ul>
</li>
<li><strong>n+1位（数值位为n位）原码表示定点整数范围：<code>[-2^n-1,2^n-1]</code></strong><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-15-52.png"></li>
</ul>
</li>
</ul>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-21-35-32.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-21-50-56.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-21-51-32.png"></p>
</blockquote>
<h2 id="机器0"><a href="#机器0" class="headerlink" title="机器0"></a>机器0</h2><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-22-03-43.png"></p>
</blockquote>
<h2 id="移码-1"><a href="#移码-1" class="headerlink" title="移码"></a>移码</h2><ul>
<li>移码 = 真值 + 偏置值。（令偏置值 = 2^n-1 -1 = 127 = 0111 1111 B）</li>
<li>阶码真值 = 移码 - 偏置值<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-26-55.png"></p>
</blockquote>
</li>
<li><strong>这些减法最后都会mod 2^8</strong>(因为总共只有8位)<ul>
<li>真值 = -128 = -1000 0000B</li>
<li>移码 = -1000 0000 + 0111 1111 = 1111 1111</li>
<li>0111 1111 + 1 0000 0000 = 1 0111 1111 （要保证被减数&gt;减数）</li>
<li>1 0111 1111 - 1000 0000 = 1111 1111</li>
</ul>
</li>
</ul>
<h2 id="IEE754"><a href="#IEE754" class="headerlink" title="IEE754"></a>IEE754</h2><blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-17-22-07-00.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-47-00.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-53-08.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-09-58-48.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-10-14-37.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-10-17-18.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-10-22-23.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-10-22-30.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-10-24-32.png"><br><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-10-10-25-29.png"></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算机组成原理.关于浮点数阶码和尾数的问题.给位可以给我耐心说一下么.1．设 24 位长</span><br><span class="line">计算机组成原理.关于浮点数阶码和尾数的问题.给位可以给我耐心说一下么.1．设 24 位长</span><br><span class="line">计算机组成原理.关于浮点数阶码和尾数的问题.给位可以给我耐心说一下么.</span><br><span class="line">1．设 24 位长的浮点数,其中阶符 1 位,阶码 5 位,数符 1 位,尾数 17 位,阶码和尾数均用补码表示,且尾数采用规格化形式,则它能表示最大正数真值是【】非零最小正数真值是【】绝对值最大的负数真值是【】绝对值最小的负数真值是【】（均用十进制表示） .</span><br><span class="line"></span><br><span class="line">哈工大的教材,太亲切了!因为书上说的不是补码规格化,这本只是唐朔飞的教材,找学习指导那本书,第六章有一个表写的很详细.此题答案如下：</span><br><span class="line">最大正数：2^31*（1-2^-17） 0,11111；0.11······1</span><br><span class="line">最小正数：（2^-32）*（2^-1） 1,00000；0.10······0</span><br><span class="line">最大负数：-（2^-32）*（2^-1+2^-17) 1,00000；1.011·····1</span><br><span class="line">最小负数：2^31*（-1） 0,11111；1.00·······0</span><br><span class="line">以上四个数为没有取绝对值的,取绝对值只需把后两个位置换一下即可.</span><br><span class="line">其中阶码可以对称记忆较为方便,希望对你有帮助!</span><br></pre></td></tr></table></figure>





<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><h3 id="边界对齐"><a href="#边界对齐" class="headerlink" title="边界对齐"></a>边界对齐</h3><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><ul>
<li><a href="https://www.cnblogs.com/Mayfly-nymph/p/11102136.html">补码一位乘法</a></li>
<li><a href="https://blog.csdn.net/kai8wei/article/details/44308557">补码一位乘法</a></li>
<li><a href="https://blog.csdn.net/qq_43355372/article/details/100139844">补码一位乘法</a></li>
</ul>
<h1 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1008 jal ra , sum</span><br><span class="line">1012 ....</span><br><span class="line"></span><br><span class="line">2000 sum:...</span><br><span class="line">2004 jr ra</span><br><span class="line"></span><br><span class="line">jal ra, sum:</span><br><span class="line">1. ra = ra + 4; //  将原本的下一条指令保存在ra处 (ra=1012，为了调用函数后返回)</span><br><span class="line">2. jump to sum  //  跳转到sum处   (跳到2000处)</span><br><span class="line"></span><br><span class="line">jr ra</span><br><span class="line">jump register to ra</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-03-24-12-37-57.png"></p>
</blockquote>
<h2 id="存储器-内存"><a href="#存储器-内存" class="headerlink" title="存储器 内存"></a>存储器 内存</h2><ul>
<li>1.概念问题，内存是存储器的一种类型，可以说是内部存储器。就当前电脑的概念来说，内存是比较直接的让CPU操作的部分（包括CPU里面的一级二级等等缓存）。有个特点，就是通常是带电操作的读写存储器。（寄存器也算是一种，那就更直接的操作了）。而存储器种类就多样了，内存是一种，硬盘，U盘，光盘磁带等等都是的啦。</li>
<li><a href="https://blog.csdn.net/qq_42103479/article/details/89743061">https://blog.csdn.net/qq_42103479/article/details/89743061</a></li>
<li><a href="https://blog.csdn.net/qq_42103479/article/details/89743061">https://blog.csdn.net/qq_42103479/article/details/89743061</a></li>
</ul>
<h2 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h2><ul>
<li>CPU的工作分为 5 个阶段：取指令阶段、指令译码阶段、执行指令阶段、访存取数和结果写回。<ul>
<li>1、取指令（IF，instruction fetch），即将一条指令从主存储器中取到指令寄存器的过程。</li>
<li>2、指令译码阶段（ID，instruction decode），取出指令后，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类 别以及各种获取操作数的方法。</li>
<li>3、执行指令阶段（EX，execute），具体实现指令的功能。CPU的不同部分被连接起来，以执行所需的操作。</li>
<li>4、访存取数阶段（MEM，memory），根据指令需要访问主存、读取操作数，CPU得到操作数在主存中的地址，并从主存中读取该操作数用于运算。</li>
<li>5、结果写回阶段（WB，write back），作为最后一个阶段，结果写回阶段把执行指令阶段的运行结果数据“写回”到某种存储形式。</li>
</ul>
</li>
</ul>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-26-10-51-15.png"></p>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-26-10-37-16.png"></p>
<p><img src="/2022/03/03/%E8%A1%A5%E7%A0%81%E5%8E%9F%E7%A0%81%E5%8F%8D%E7%A0%81%E8%BF%90%E7%AE%97/2022-04-26-11-32-05.png"></p>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>学校考试</tag>
      </tags>
  </entry>
  <entry>
    <title>单一职责模式</title>
    <url>/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单一职责模式：装饰模式、桥模式</p>
<span id="more"></span>

<h1 id="单一职责模式"><a href="#单一职责模式" class="headerlink" title="单一职责模式"></a>单一职责模式</h1><ul>
<li>在软件组件的设计中，如果<strong>责任划分的不清晰</strong>，使用<strong>继承</strong>得到的结果往往是随着需求的变化，子类急剧膨胀，同时<strong>充斥着重复代码</strong>，这时候的关键是<strong>划清责任。</strong><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2>把编译时的事情延迟到运行时去做<br>设计模式真谛：编译时让他复用；需求，变化都放到运行时。</li>
</ul>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul>
<li>在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于<strong>继承为类型引入的静态特质</strong>（写死的语句），使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。</li>
<li>如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-09-04-00.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>通过<strong>采用组合而非继承的</strong>手法， Decorator模式实现了在运行时<strong>动态扩展对象功能</strong>的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</li>
<li>Decorator类在<strong>接口上</strong>表现为is-a Component的<strong>继承</strong>关系，即 Decorator类继承了Component类所具有的接口。但在<strong>实现上又 表现为</strong>has-a Component的<strong>组合</strong>关系，即Decorator类又使用了另外一个Component类。</li>
<li>Decorator模式的目的并非解决“多子类衍生的多继承”问题， <strong>Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义</strong></li>
</ul>
<p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-09-13-46.png"></p>
<ul>
<li>装饰者的继承：为了完善接口规范<ul>
<li><code>class Deractor : public Base&#123;&#125;</code> </li>
</ul>
</li>
<li>装饰者的组合：为了实现支持将来实现类的调用<ul>
<li><code>&#123;Base * b&#125;</code></li>
</ul>
</li>
<li>看到一个class A 他既继承自父类Base，又有父类Base*成员，那么，基本上就是装饰者模式了。</li>
<li>同时继承和组合，基本上就是装饰者模式。</li>
</ul>
<h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><ul>
<li>最开始 总共有 <code>1 + n + n*m!</code> 个类<br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-09-01-38.png">、</li>
<li>有最普通的读，有加密的读，有缓存的读，有缓存+加密的读<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  重复代码</span></span><br><span class="line"><span class="comment">//  加密操作是一样的</span></span><br><span class="line"><span class="comment">//  缓冲操作是一样的</span></span><br><span class="line"><span class="comment">//  read seek write操作不同类不同，但是都继承自Stream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoFileStream</span> :</span><span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Read</span>(number);<span class="comment">//读文件流     //  继承引入的静态机制！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoNetworkStream</span> :</span> :<span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Read</span>(number);<span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位网络流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        NetworkStream::<span class="built_in">Write</span>(data);<span class="comment">//写网络流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoMemoryStream</span> :</span> <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Read</span>(number);<span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位内存流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        MemoryStream::<span class="built_in">Write</span>(data);<span class="comment">//写内存流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedFileStream</span> :</span> <span class="keyword">public</span> FileStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedNetworkStream</span> :</span> <span class="keyword">public</span> NetworkStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedMemoryStream</span> :</span> <span class="keyword">public</span> MemoryStream&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoBufferedFileStream</span> :</span><span class="keyword">public</span> FileStream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">        FileStream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        <span class="comment">//额外的缓冲操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//编译时装配</span></span><br><span class="line">    CryptoFileStream *fs1 = <span class="keyword">new</span> <span class="built_in">CryptoFileStream</span>();</span><br><span class="line">    BufferedFileStream *fs2 = <span class="keyword">new</span> <span class="built_in">BufferedFileStream</span>();</span><br><span class="line">    CryptoBufferedFileStream *fs3 =<span class="keyword">new</span> <span class="built_in">CryptoBufferedFileStream</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>一个类 继承自Stream 且与Stream类组合</li>
<li><code>class CryptoStream :public Stream &#123; Stream* stream ...&#125;</code></li>
<li>继承原因：为了实现基类的接口规范</li>
<li>组合原因：为了实现功能<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  【2】继承自Stream ，为了继承Stream的接口 (virtual Read...)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> Stream &#123;     </span><br><span class="line">    <span class="comment">//  FileStream / NetworkStream / MemoryStream</span></span><br><span class="line">    <span class="comment">//  运行时依赖</span></span><br><span class="line">    <span class="comment">//  【1】与Stream类组合，实现功能</span></span><br><span class="line">    Stream* stream;<span class="comment">//...    </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* stm):<span class="built_in">stream</span>(stm)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> :</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream* stm):<span class="built_in">stream</span>(stm)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配 即编译时依赖优化成运行时依赖</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1);      <span class="comment">//  加密    Stream* 接收 FileStream*</span></span><br><span class="line">    BufferedStream* s3=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s1);  <span class="comment">//  缓冲</span></span><br><span class="line">    BufferedStream* s4=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s2);  <span class="comment">//  加密 + 缓冲 Stream* 接收 CryptoStream*</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果多个子类有相同字段时，那么要将这个字段往上（往父类或者新建一个这种字段的中间类）提。 --马丁</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-08-55-22.png"></p>
<ul>
<li>Decorator装饰类</li>
<li>如果多个子类有相同字段时，那么要将这个字段往上（往父类或者新建一个这种字段的中间类）提。 –马丁</li>
<li><code>class Decorator : public Stream&#123;Stream *stream&#125;</code><ul>
<li><code>stream*</code>：用组合来代替继承实现多态<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//业务操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stream</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Stream</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写文件流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写网络流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStream</span> :</span><span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//读内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定位内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//写内存流</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展操作类</span></span><br><span class="line"><span class="comment">//  DacoratorStream：要将CryptoStream以及BufferedStream的相同字段Stream*提出来。而放在Stream基类中发现不合适（主题类不需要Stream*字段）。因此，构造一个中间类。</span></span><br><span class="line"><span class="comment">//  用组合的方式，引出对多态的支持</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoratorStream</span>:</span> <span class="keyword">public</span> Stream&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Stream* stream; <span class="comment">//核心！！！</span></span><br><span class="line">    <span class="built_in">DecoratorStream</span>(Stream * stm):<span class="built_in">stream</span>(stm)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CryptoStream</span>:</span> <span class="keyword">public</span> DecoratorStream &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CryptoStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span> <span class="title">Read</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream-&gt;<span class="built_in">Read</span>(number);<span class="comment">//读文件流     组合的动态特质</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Seek</span>(position);<span class="comment">//定位文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Write</span><span class="params">(byte data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">        stream::<span class="built_in">Write</span>(data);<span class="comment">//写文件流</span></span><br><span class="line">        <span class="comment">//额外的加密操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedStream</span> :</span> <span class="keyword">public</span> DecoratorStream&#123;</span><br><span class="line">    Stream* stream;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferedStream</span>(Stream* stm):<span class="built_in">DecoratorStream</span>(stm)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    FileStream* s1=<span class="keyword">new</span> <span class="built_in">FileStream</span>();</span><br><span class="line">    CryptoStream* s2=<span class="keyword">new</span> <span class="built_in">CryptoStream</span>(s1);</span><br><span class="line">    BufferedStream* s3=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s1);</span><br><span class="line">    BufferedStream* s4=<span class="keyword">new</span> <span class="built_in">BufferedStream</span>(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h3><ul>
<li>装饰器模式 <code>Decorator</code><ul>
<li>通过子类实现功能增强的问题：为了增强现有类的功能，通过实现子类的方式，</li>
<li>重写接口，是可以完成功能扩展的，但是代码中有太多的子类添加进来了</li>
</ul>
</li>
<li> 车 A ,B ,C</li>
<li> 这些车，有的功能只有<code>base</code> ， 有的有<code>brake ， hasten ， boom</code> 以及他们的组合<br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-28-10-17-24.png"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by dell on 2022-03-28.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  车 A ,B ,C</span></span><br><span class="line"><span class="comment">//  这些车，有的功能只有base ， 有的有brake ， hasten ， boom 以及他们的组合</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACar</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A car : base , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BCar</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B car : base , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;C car : base , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span>:</span><span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Decorator</span>(Car *p):<span class="built_in">p_car</span>(p)&#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Car *p_car;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator1</span> :</span> <span class="keyword">public</span> Decorator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorator1</span>(Car* p_car):<span class="built_in">Decorator</span>(p_car)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p_car-&gt;<span class="built_in">show</span>();  <span class="comment">//  父类的show (原先就有的功能)</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;hasten , &quot;</span>;  <span class="comment">//  添加功能</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator2</span> :</span> <span class="keyword">public</span> Decorator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteDecorator2</span>(Car *p): <span class="built_in">Decorator</span>(p)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span>    <span class="comment">//  添加功能</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p_car-&gt;<span class="built_in">show</span>();  <span class="comment">//  父类的show</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;brake , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator3</span> :</span> <span class="keyword">public</span> Decorator&#123;</span><br><span class="line">    <span class="built_in">ConcreteDecorator3</span>(Car *p): <span class="built_in">Decorator</span>(p)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span>    <span class="comment">//  添加功能</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p_car-&gt;<span class="built_in">show</span>();</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;boom , &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  一个ACar 加上了装饰器1的功能hasten 之后就可以通过pA来调用这个加上了装饰器1功能的Acar对象</span></span><br><span class="line">    ConcreteDecorator1 *pA =  <span class="keyword">new</span> <span class="built_in">ConcreteDecorator1</span>(<span class="keyword">new</span> <span class="built_in">ACar</span>());</span><br><span class="line">    pA-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  一个BCar pB-&gt; &#123;装饰器1功能 + 装饰器2功能 + BCar对象&#125;</span></span><br><span class="line">    ConcreteDecorator2 *pB = <span class="keyword">new</span> <span class="built_in">ConcreteDecorator2</span>(<span class="keyword">new</span> <span class="built_in">ConcreteDecorator1</span>(<span class="keyword">new</span> <span class="built_in">BCar</span>()));</span><br><span class="line">    pB-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  不添加装饰器功能</span></span><br><span class="line">    CCar *pC = <span class="keyword">new</span> <span class="built_in">CCar</span>();</span><br><span class="line">    pC-&gt;<span class="built_in">show</span>();</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A car : base , hasten ,</span><br><span class="line">B car : base , hasten , brake ,</span><br><span class="line">C car : base ,</span><br></pre></td></tr></table></figure>

<h2 id="桥模式"><a href="#桥模式" class="headerlink" title="桥模式"></a>桥模式</h2><ul>
<li>一个类中要实现两种不同维度的功能，就把这个类分成两个类，把两个不同维度的功能分开。</li>
<li>把继承变组合实现多态</li>
<li>几个子类中有公共字段，那么要把这个字段向上提。<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3></li>
<li>由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度乃至多个纬度的变化。</li>
<li>如何应对这种“多维度的变化”？如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度？</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>将<strong>抽象部分(业务功能)<strong>与</strong>实现部分(平台实现)<strong>分离，使它们都可以</strong>独立</strong>地变化。</li>
</ul>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-29-15-10-49.png"></p>
<h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul>
<li><p>Bridge模式使用<strong>s“对象间的组合关系”s</strong>解耦了抽象和实现之间固 有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”他们。</p>
</li>
<li><p>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背 单一职责原则（即一个类只有一个变化的原因），复用性比较差。<strong>Bridge模式是比多继承方案更好的解决方法。</strong></p>
</li>
<li><p>Bridge模式的应用一般在“<strong>两个非常强的变化维度</strong>”，有时一个 类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。</p>
<h3 id="重构-1"><a href="#重构-1" class="headerlink" title="重构"></a>重构</h3></li>
<li><p>初始</p>
</li>
<li><p>要实现的类：<code>1+n+n*m</code><br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-29-15-04-36.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//平台实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerBase</span> :</span> <span class="keyword">public</span> Messager&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerLite</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerPerfect</span> :</span> <span class="keyword">public</span> PCMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        PCMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        PCMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerLite</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerPerfect</span> :</span> <span class="keyword">public</span> MobileMessagerBase &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        MobileMessagerBase::<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        MobileMessagerBase::<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编译时装配</span></span><br><span class="line">        Messager *m =</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">MobileMessagerPerfect</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>重构后</p>
</li>
<li><p>1+n+m</p>
</li>
</ul>
<p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E6%A8%A1%E5%BC%8F/2022-03-29-15-04-13.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Messager</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">     MessagerImp* messagerImp;<span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Messager</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerImp</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MessagerImp</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//平台实现 n</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PCMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MobileMessagerImp</span> :</span> <span class="keyword">public</span> MessagerImp&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PlaySound</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawShape</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//==========</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//业务抽象 m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类的数目：1+n+m</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerLite</span> :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessagerPerfect</span>  :</span><span class="keyword">public</span> Messager &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Login</span><span class="params">(string username, string password)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">Connect</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendMessage</span><span class="params">(string message)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">WriteText</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SendPicture</span><span class="params">(Image image)</span></span>&#123;</span><br><span class="line">        messagerImp-&gt;<span class="built_in">PlaySound</span>();</span><br><span class="line">        <span class="comment">//********</span></span><br><span class="line">        messagerImp-&gt;<span class="built_in">DrawShape</span>();</span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//运行时装配</span></span><br><span class="line">    MessagerImp* mImp=<span class="keyword">new</span> <span class="built_in">PCMessagerImp</span>();</span><br><span class="line">    Messager *m =<span class="keyword">new</span> <span class="built_in">MessagerLite</span>(mImp);    <span class="comment">//  实现 PCMessageImp平台 + MessagerLite业务 组合   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>设计模式</p>
<span id="more"></span>

<h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><h2 id="面向对象设计原则-1"><a href="#面向对象设计原则-1" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h3><ul>
<li>高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖于抽象(稳定) 。</li>
<li>抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于抽象(稳定)。</li>
</ul>
<h3 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h3><ul>
<li>对扩展开放，对更改封闭。</li>
<li>类模块应该是可扩展的，但是不可修改。</li>
<li>应该尽量通过扩展的方式来支持未来的变化，而不是直接改源代码来支持变化。</li>
</ul>
<h3 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h3><ul>
<li>一个类应该仅有一个引起它变化的原因。</li>
<li>变化的方向隐含着类的责任。</li>
</ul>
<h3 id="Liskov-替换原则（LSP）"><a href="#Liskov-替换原则（LSP）" class="headerlink" title="Liskov 替换原则（LSP）"></a>Liskov 替换原则（LSP）</h3><ul>
<li>子类必须能够替换它们的基类(IS-A)。</li>
<li>继承表达类型抽象。</li>
</ul>
<h3 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h3><ul>
<li>不应该强迫客户程序依赖它们不用的方法。</li>
<li>接口应该小而完备。</li>
</ul>
<h3 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h3><ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li>
<li>而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。</li>
</ul>
<h3 id="封装变化点"><a href="#封装变化点" class="headerlink" title="封装变化点"></a>封装变化点</h3><ul>
<li>使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</li>
</ul>
<h3 id="针对接口编程，而不是针对实现编程"><a href="#针对接口编程，而不是针对实现编程" class="headerlink" title="针对接口编程，而不是针对实现编程"></a>针对接口编程，而不是针对实现编程</h3><ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li>
<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</li>
<li>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案</li>
</ul>
<h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ul>
<li>我们所要减少的依赖是编译时依赖，而非运行时依赖</li>
</ul>
<h3 id="类的关系"><a href="#类的关系" class="headerlink" title="类的关系"></a>类的关系</h3><p><a href="https://blog.csdn.net/weixin_42927264/article/details/82963556">类的关系</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>面向对象设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>进程虚拟地址空间</title>
    <url>/2022/03/26/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h1><ul>
<li>编程语言 -》 产生两种东西：指令和数据</li>
<li>编译生成.exe之后，放在磁盘上，运行时要加载到内存里。（不可能直接加载到物理内存的！）</li>
<li>环境：x86 32位linux</li>
<li>linux会给当前进程分配2^32byte大小的一块空间。4GB = 4 * 1GB = 4 * 2^30 Byte = 2^32 Byte </li>
<li>分配的这个空间称为 进程的<strong>虚拟</strong>地址空间</li>
<li>什么是虚拟？<ul>
<li><strong>它存在，你能看见，它是物理的</strong></li>
<li><strong>它存在，你看不见，它是透明的</strong></li>
<li><strong>它不存在，你看得见，他是虚拟的</strong></li>
<li><strong>它不存在，你也看不见，他被删除了</strong></li>
</ul>
</li>
</ul>
<ul>
<li>代码编译后的指令存放在<code>.text</code>段（也即二进制可执行代码）</li>
<li>数据存放在<code>.rodata , .data , .bss</code>段上</li>
<li>全局变量、全局静态变量，局部静态变量，都是数据，存放在<code>.rodata . data .bss</code>上</li>
<li>理解局部自动变量存放在栈上<ul>
<li>函数中的<code>int a = 12</code> 是指令而非数据</li>
<li><code>mov dword ptr[a地址],0Ch</code>：将数据0Ch移动到内存的地址中，这个地址是a的地址，是一个双字（4字节）。</li>
<li>这条指令存放在.text段，而a地址，是在stack段处，这也就是所谓的，普通局部变量在栈中。</li>
<li>当没有执行这条指令（比如代码改成 <code>int a;</code> 和 <code>a = 12;</code>，只执行完<code>int a</code>）时，<code>cout&lt;&lt;a&lt;&lt;endl;</code>得到的是无效值。因为此时栈中的那块a变量要用的地址还没被赋值。</li>
</ul>
</li>
<li>栈段的大小一般是8Mb<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  这些都是数据</span></span><br><span class="line"><span class="keyword">int</span> gdata1 = <span class="number">10</span>;        <span class="comment">//  .data段：初始化且值不为0</span></span><br><span class="line"><span class="keyword">int</span> gdata2 = <span class="number">0</span>;         <span class="comment">//  .bss段：未初始化或初始化为0</span></span><br><span class="line"><span class="keyword">int</span> gdata3;             <span class="comment">//  .bss段：未初始化或初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata4 = <span class="number">11</span>; <span class="comment">//  .data段：初始化且值不为0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata5 = <span class="number">0</span>;  <span class="comment">//  .bss段：未初始化或初始化为0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> gdata6;      <span class="comment">//  .bss段：未初始化或初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  这些自动局部变量不是数据，是指令！存放在.text上。而非</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12</span>;         <span class="comment">//  mov dword ptr[a],0Ch</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> e = <span class="number">13</span>;  <span class="comment">//  .data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> f = <span class="number">0</span>;   <span class="comment">//  .bss</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> g;       <span class="comment">//  .bss</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>堆和栈之间的那个是文件映射段：包括动态库、共享内存等；从低地址向高地址增长。</li>
<li>这7个内存段，堆和文件映射段的内存是动态分配的。比如<code>C</code>的<code>malloc()</code> 和 <code>mmap()</code>，就可以分别在堆和文件映射段动态分配内存。<br><img src="/2022/03/26/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/2022-03-26-11-39-56.png"></li>
</ul>
<p><img src="/2022/03/26/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/2022-03-26-11-41-03.png"></p>
<ul>
<li><strong>每一个进程的用户空间是私有的，但是内核空间是共享的！</strong><ul>
<li>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</li>
</ul>
</li>
</ul>
<p><img src="/2022/03/26/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/2022-03-26-11-29-52.png"></p>
<p><img src="/2022/03/26/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/2022-03-26-11-38-55.png"></p>
<ul>
<li><a href="http://lishiwen4.github.io/linux/linux-process-memory-location">博客</a></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>dns(预习)</title>
    <url>/2022/05/04/%E7%BD%91%E7%BB%9C_dns/</url>
    <content><![CDATA[<p>dns与知乎图片</p>
<span id="more"></span>


<ul>
<li><a href="https://www.zhihu.com/question/35862960">知乎图片挂掉</a><ul>
<li>dns原因，改host文件</li>
</ul>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/106002231">https://zhuanlan.zhihu.com/p/106002231</a></p>
<ul>
<li>站长之家<br><img src="/2022/05/04/%E7%BD%91%E7%BB%9C_dns/2022-05-04-19-20-30.png"></li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>小白问题</tag>
      </tags>
  </entry>
  <entry>
    <title>组件协作模式</title>
    <url>/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>组件协作模式：模板方法、策略模式、观察者模式</p>
<span id="more"></span>

<ul>
<li>前言<ul>
<li>设计模式的假定条件：必须有一个稳定点！</li>
<li>所有都是变化的，那么没有任何一个设计莫斯是有用的</li>
<li>所有都是稳定的，那么就没有必要用设计模式了。</li>
<li>设计模式就是在稳定和变化中寻求隔离</li>
<li>大多数设计模式都追求：稳定中有变化<h1 id="组件协作模式"><a href="#组件协作模式" class="headerlink" title="组件协作模式"></a>组件协作模式</h1></li>
</ul>
</li>
</ul>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul>
<li>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作<br>结构，但各个子步骤却有很多改变的需求，或者由于固有的原因<br>（比如框架与应用之间的关系）而无法和任务的整体结构同时实现  </li>
<li>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变<br>化或者晚期实现需求</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>定义一个操作中的算法的**骨架 (稳定)<strong>，而将一些步骤</strong>延迟(变化)<strong>到子类中。Template Method使得子类可以</strong>不改变(复用)**一个算法的结构即可重定义(override 重写)该算法的<br>某些特定步骤<ul>
<li>延迟到子类：让子类实现或override父类的virtual</li>
<li>如果没有稳定的骨架（Run）怎么办？那么前提就不成立了，就要换一种设计模式</li>
</ul>
</li>
</ul>
<h3 id="早-晚绑定"><a href="#早-晚绑定" class="headerlink" title="早/晚绑定"></a>早/晚绑定</h3><p><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-24-18-08-37.png"></p>
<ul>
<li><strong>反向控制结构</strong><br><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-24-18-08-12.png"></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul>
<li>稳定的函数：设非虚</li>
<li>变化的函数：设virtual<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序库开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  非虚函数Run：稳定</span></span><br><span class="line"><span class="comment">//  虚函数：变化(step3,step4)</span></span><br><span class="line">	<span class="comment">//稳定 template method</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Step2</span>()) &#123; <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">            <span class="built_in">Step3</span>(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">Step4</span>(); <span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Step5</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;<span class="comment">//稳定</span></span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123; <span class="comment">//稳定</span></span><br><span class="line">		<span class="comment">//.....</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//变化</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>=<span class="number">0</span>; <span class="comment">//变化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> Library &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//... 子类重写实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	    Library* pLib=<span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">	    lib-&gt;<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">delete</span> pLib;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-24-18-13-29.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>Template Method</code>模式是一种非常基础性的设计模式，在面向对<br>象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）<br>为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本<br>实现结构。</li>
<li>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用<br>你”的<strong>反向控制结构</strong>是<code>Template Method</code>的典型应用。</li>
<li>在具体实现方面，被<code>Template Method</code>调用的虚方法可以具有实<br>现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将<br>它们设置为<code>protected</code>方法（一般在父类所写的核心流程里的上下文中调用才有意义，类外调用没意义）。</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-29-15-35-48.png"></p>
<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><ul>
<li>在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担</li>
<li>如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>定义一系列算法，把它们一个个封装起来，并且使它们可<strong>互相替换（变化）</strong>。该模式使得算法可<strong>独立于</strong>使用它的<strong>客户程序(稳定)<strong>而</strong>变化（扩展，子类化）</strong>。</li>
</ul>
<h3 id="什么是复用，什么是扩展-修改？"><a href="#什么是复用，什么是扩展-修改？" class="headerlink" title="什么是复用，什么是扩展/修改？"></a>什么是复用，什么是扩展/修改？</h3><ul>
<li>扩展是为了实现复用.<h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4></li>
<li>拷贝粘贴不叫复用</li>
<li><strong>不是源代码级别的复用</strong></li>
<li><strong>复用</strong>而是<strong>编译</strong>、部署之后，<strong>二进制级别的复用</strong>。是编译部署之后，原封不动的。</li>
<li>所以，在一堆if-else后面再加一个if-else，是修改而不是扩展<ul>
<li><strong>不是扩展（改变了此文件的源代码,需要重新编译）</strong></li>
<li>因此没实现复用（复用之前的if-else？放屁！）</li>
</ul>
</li>
</ul>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul>
<li>不改变现有类的代码,而是通过新增加一个文件来增加一个类等.</li>
</ul>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><ul>
<li><p>修改现有类的源代码</p>
</li>
<li><p><strong>开闭原则</strong></p>
<ul>
<li>对扩展开放</li>
<li>对修改关闭</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TaxBase</span> &#123;</span></span><br><span class="line">	CN_Tax,</span><br><span class="line">	US_Tax,</span><br><span class="line">	DE_Tax,</span><br><span class="line">	FR_Tax       <span class="comment">//更改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  增加新算法时,需要修改代码(加if-else),违反开闭原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line">    TaxBase tax;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (tax == CN_Tax)&#123;</span><br><span class="line">            <span class="comment">//CN***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == US_Tax)&#123;</span><br><span class="line">            <span class="comment">//US***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == DE_Tax)&#123;</span><br><span class="line">            <span class="comment">//DE***********</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (tax == FR_Tax)&#123;  <span class="comment">//更改   </span></span><br><span class="line">        <span class="comment">// 这里叫做修改 而非扩展！！</span></span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><ul>
<li>扩展</li>
<li>如果有改变的话,我们新增文件FRTax.cpp , 在里面写要增加的类即可 , 其他类文件的代码不会改变 , 实现了(二进制级别的)复用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaxStrategy</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DETax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  扩展</span></span><br><span class="line"><span class="comment">//  如果有改变的话,我们新增文件FRTax.cpp , 在里面写要增加的类即可.</span></span><br><span class="line"><span class="comment">//  其他类文件的代码不会改变</span></span><br><span class="line"><span class="comment">//  实现了(二进制级别的)复用</span></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">		<span class="comment">//.........</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;  <span class="comment">//  常用指针而非引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;   <span class="comment">//  工厂</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="built_in">NewStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SalesOrder</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        Context context;</span><br><span class="line">        <span class="keyword">double</span> val = </span><br><span class="line">            strategy-&gt;<span class="built_in">Calculate</span>(context); <span class="comment">//多态调用</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C%E6%A8%A1%E5%BC%8F/2022-03-25-17-52-55.png"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>用扩展的方式,去面对需求的变化</strong></p>
</li>
<li><p>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在<strong>运行时</strong>方便地根据需要在各个算法之间进行切换 </p>
<ul>
<li>运行时:多态,虚函数调用 </li>
</ul>
</li>
<li><p>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。<strong>含有许多条件判断语句的代码通常都需要Strategy模式!!!</strong></p>
</li>
<li><p>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销.</p>
</li>
<li><p>出现很多if-else的地方,且可能需要增加改变时,就是我们需要用到策略模式的地方.</p>
</li>
<li><p><code>if-else : bad smile</code></p>
</li>
<li><p>实际上的算法远比上面的+-复杂。</p>
</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>策略模式仅仅封装算法</li>
<li>方便新的算法插入到已有系统中，以及老算法从系统中“退休”，实现方法替换</li>
<li>策略模式并不决定何时使用何种算法，什么情况下使用什么算法由用户决定。</li>
<li>策略模式的重心：策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</li>
<li>算法的平等性：策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的</li>
<li>运行时策略的唯一性：运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个</li>
<li>它把采取哪一种算法或采取哪一种行为的逻辑与算法本身分离，避免程序中使用多重条件转移语句，使系统更灵活，并易于扩展</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</li>
<li>由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">行为型模式：主要关注的是对象之间的通信</span></span><br><span class="line"><span class="comment">观察者模式Observer Pattern（发布-订阅模式）设计模式:主要关注的是对象的一对多的关系，也就是多个对象</span></span><br><span class="line"><span class="comment">都依赖一个对象，当该对象的状态发生改变时，其它对象都能够接收到相应的通知。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一组数据（数据对象）   =&gt;  通过这一组数据 =》  曲线图(对象1)/柱状图(对象2)/圆饼图(对象3)</span></span><br><span class="line"><span class="comment">当数据对象改变时，对象1、对象2、对象3应该及时的收到相应的通知！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Observer1  Observer2   Observer3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		   Subject（主题）主题有更改，应该及时通知相应的观察者，去处理相应的事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  观察者模式 / 监听者模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  发布-订阅</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者 Observer</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> :</span> <span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer1 recv 1 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer1 recv 2 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer1 recv unknown msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer2</span>:</span><span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer2 recv 1 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer2 recv unknown msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer3</span>:</span><span class="keyword">public</span> Observer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> msg)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(msg)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer3 recv 1 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer3 recv 2 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer3 recv 3 msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Observer3 recv unknown msg&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  主题类</span></span><br><span class="line"><span class="comment">//  记录了每个要观察的对象int msg和观察者Observe的关联情况</span></span><br><span class="line"><span class="comment">//  内含会发生变化的主体。也就是观察者要观察的东西</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer *obs,<span class="keyword">int</span> msg)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="comment">//        m_subMap[msg].push_back(obs);   //  原先没有：创建并加入；原先有：加入</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,list&lt;Observer*&gt;&gt; ::iterator iter = m_subMap.<span class="built_in">find</span>(msg);</span><br><span class="line">        <span class="keyword">if</span>(iter==m_subMap.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            m_subMap.insert(&#123;msg,list&lt;Observer*&gt;&#123;obs&#125;&#125;);</span></span><br><span class="line">            list&lt;Observer*&gt; l;</span><br><span class="line">            l.<span class="built_in">push_back</span>(obs);</span><br><span class="line">            m_subMap.<span class="built_in">insert</span>(&#123;msg,l&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_subMap[msg].<span class="built_in">push_back</span>(obs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  检测发生改变，通知相应观察者对象处理事件</span></span><br><span class="line">    <span class="comment">//  msg：要改变的对象（这里用int代替，实际上会是一个事件对象，对象内部的属性发生改变）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="keyword">int</span> msg)</span>       <span class="comment">//   派遣</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = m_subMap.<span class="built_in">find</span>(msg);</span><br><span class="line">        <span class="keyword">if</span>(iter==m_subMap.<span class="built_in">end</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span>(Observer *obs : iter-&gt;second)</span><br><span class="line">        &#123;</span><br><span class="line">            obs-&gt;<span class="built_in">handler</span>(msg);  <span class="comment">//  处理变化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,list&lt;Observer*&gt; &gt; m_subMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject s;</span><br><span class="line">    Observer1 obs1;</span><br><span class="line">    Observer2 obs2;</span><br><span class="line">    Observer3 obs3;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs1,<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs1,<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs2,<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs3,<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs3,<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">addObserver</span>(&amp;obs3,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;几号事件发生改变&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cin&gt;&gt;ch;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        s.<span class="built_in">dispatch</span>(ch);     <span class="comment">//  主体通知事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">鍑犲彿浜嬩欢鍙戠敓鏀瑰彉</span><br><span class="line"><span class="number">7</span></span><br><span class="line">鍑犲彿浜嬩欢鍙戠敓鏀瑰彉</span><br><span class="line"><span class="number">1</span></span><br><span class="line">Observer1 recv <span class="number">1</span> msg</span><br><span class="line">Observer2 recv <span class="number">1</span> msg</span><br><span class="line">Observer3 recv <span class="number">1</span> msg</span><br><span class="line">鍑犲彿浜嬩欢鍙戠敓鏀瑰彉</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Observer1 recv <span class="number">2</span> msg</span><br><span class="line">Observer3 recv <span class="number">2</span> msg</span><br><span class="line">鍑犲彿浜嬩欢鍙戠敓鏀瑰彉</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Observer3 recv <span class="number">3</span> msg</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>对象创建模式</title>
    <url>/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>对象创建模式：工厂模式、单例模式、原型模式</p>
<span id="more"></span>

<h1 id="对象创建模式"><a href="#对象创建模式" class="headerlink" title="对象创建模式"></a>对象创建模式</h1><ul>
<li>通过“对象创建” 模式绕开new，来避免对象创建（new）过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象之后的第一步工作。</li>
<li>典型模式<ul>
<li>Factory Method</li>
<li>Abstract Factory</li>
<li>Prototype</li>
<li>Builder</li>
</ul>
</li>
</ul>
<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><ul>
<li>简单工厂 Simple Factory : <ul>
<li>把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象</li>
</ul>
</li>
<li>好处（是个工厂都有这好处）：客户不用自己负责new对象，不用了解对象创建的详细过程</li>
<li>缺点：提供创建对象实例的接口函数不闭合，不能对修改关闭</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">简单工厂 Simple Factory : </span></span><br><span class="line"><span class="comment">把对象的创建封装在一个接口函数里面，通过传入不同的标识，返回创建的对象</span></span><br><span class="line"><span class="comment">客户不用自己负责new对象，不用了解对象创建的详细过程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提供创建对象实例的接口函数不闭合，不能对修改关闭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">工厂方法 Factory Method</span></span><br><span class="line"><span class="comment">Factory基类，提供了一个纯虚函数（创建产品），定义派生类（具体产品的工厂）负责创建对应的</span></span><br><span class="line"><span class="comment">产品，可以做到不同的产品，在不同的工厂里面创建，能够对现有工厂，以及产品的修改关闭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实际上，很多产品是有关联关系的，属于一个产品簇，不应该放在不同的工厂里面去创建，这样</span></span><br><span class="line"><span class="comment">一是不符合实际的产品对象创建逻辑，二是工厂类太多了，不好维护</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">抽象工厂 Abstract Factory</span></span><br><span class="line"><span class="comment">把有关联关系的，属于一个产品簇的所有产品创建的接口函数，放在一个抽象工厂里面AbstractFactory</span></span><br><span class="line"><span class="comment">，派生类（具体产品的工厂）应该负责创建该产品簇里面所有的产品</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">工厂模式：主要是封装了对象的创建</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系列产品1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name) :_name(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bmw</span> :</span> <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bmw</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取了一辆宝马汽车:&quot;</span> &lt;&lt; _name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> :</span> <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取了一辆奥迪汽车:&quot;</span> &lt;&lt; _name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CarType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	BMW,AUDI</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(CarType ct)</span> <span class="comment">// 不符合软件设计 “开-闭”</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (ct)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> BMW:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(<span class="string">&quot;X1&quot;</span>);</span><br><span class="line">		<span class="keyword">case</span> AUDI:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(<span class="string">&quot;A6&quot;</span>);</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cerr &lt;&lt; <span class="string">&quot;传入工厂的参数不正确:&quot;</span> &lt;&lt; ct &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">unique_ptr&lt;SimpleFactory&gt; <span class="title">factory</span><span class="params">(<span class="keyword">new</span> SimpleFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(factory-&gt;createCar(BMW))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(factory-&gt;createCar(AUDI))</span></span>;</span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>这也就是所谓工厂方法模式</p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul>
<li><p>在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型<strong>经常变化</strong>。</p>
</li>
<li><p>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li>
<li><p><strong>工厂定义一个用于创建对象的接口，让子类决定实例化哪一个类。<code>Factory Method</code>使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。</strong></p>
<h3 id="过程推演"><a href="#过程推演" class="headerlink" title="过程推演"></a>过程推演</h3></li>
<li><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-16-59-29.png"></p>
</li>
<li><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-13-24.png"></p>
</li>
<li><p>virtual：一种延迟，延迟绑定到运行时<br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-18-31.png"></p>
</li>
<li><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-26-57.png"></p>
</li>
<li><p>C++语言本身没有提供多态new，但是我们通过virtual和指针，创造出了多态new</p>
</li>
<li><p>虽然之后还会在类外面new 具体的 factory，但是 MainForm里面，再也没有对具体Factory的依赖了。</p>
</li>
<li><p><strong>设计模式的松耦合设计，很多时候并不是把变化消灭，也即：并不是把依赖具体类的这个事情消灭掉，而是把它们转移到某个局部的地方。</strong></p>
<ul>
<li><strong>也就是，把“变化”这只猫关进笼子里，而不是让他在代码里跳来跳去</strong></li>
</ul>
</li>
</ul>
<h3 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h3><ul>
<li><p>抽象类和工厂基类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SplitterFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">SplitterFactory</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>具体类和具体工厂</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitterFactory</span>:</span> <span class="keyword">public</span> SplitterFactory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">CreateSplitter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>依赖代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    SplitterFactory*  factory;<span class="comment">//工厂基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(SplitterFactory*  factory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;factory=factory;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ISplitter * splitter=</span><br><span class="line">            factory-&gt;<span class="built_in">CreateSplitter</span>(); <span class="comment">//多态new</span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>为什么要有一个抽象ISplitter基类？因为需要这样一个抽象引用去接收实际的具体对象。</p>
</li>
<li><p>为什么要有一个抽象factory基类？因为需要依赖于抽象去动态绑定。</p>
</li>
<li><p>原本<br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-43-02.png"></p>
</li>
<li><p>工厂模式之后，不再依赖于具体类（<strong>变化）</strong>，而是依赖于抽象类（<strong>稳定）</strong><br><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-42-00.png"></p>
</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-17-55-24.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Factory Method模式用于隔离类对象的使用者和具体类型之间的 耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。</li>
<li>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作<strong>延迟</strong>到子类（virtual函数），从而实现一种<strong>扩展（而非更改）</strong>的策略，较好地解决了这种紧耦合关系。</li>
<li>Factory Method模式解决“单个对象”的需求变化。缺点在于要 求创建方法/参数相同。</li>
</ul>
<h2 id="抽象工厂（家族工厂，这个工厂可以创造一家子相关操作）"><a href="#抽象工厂（家族工厂，这个工厂可以创造一家子相关操作）" class="headerlink" title="抽象工厂（家族工厂，这个工厂可以创造一家子相关操作）"></a>抽象工厂（家族工厂，这个工厂可以创造一家子相关操作）</h2><ul>
<li>工厂模式的基础上，将有关系的内容都放到一个工厂里，一起生产出来。<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3></li>
<li>在软件系统中，经常面临着“<strong>一系列相互依赖的对象</strong>”的创建工作；同时，由于需求的变化，往往<strong>存在更多系列对象的创建工作</strong>。（一系列：Oracle有一系列数据库访问操作，MySql有一系列数据库访问操作，其他甲数据库又有一系列数据库访问操作）</li>
<li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？</li>
</ul>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>提供一个接口，让该接口负责创建<strong>一系列“相关或者相互依赖的对象”</strong>，（如数据库访问的一系列关联操作），无需指定它们具体的类。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库访问有关的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnection</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommand</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReader</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  （创建数据库访问相关的）基类工厂（可创建一系列数据库访问，如SQL数据库访问，Oracle数据路访问）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//支持SQL Server</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SqlDBFactory</span>:</span><span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//支持Oracle的相关访问操作</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OracleConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OracleCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OracleDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  负责 创建Oracle数据库访问的一系列操作 的工厂</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">OracleDBFactory</span>:</span><span class="keyword">public</span> IDBFactory&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    <span class="comment">//  只需要一个基类工厂就可以。</span></span><br><span class="line">    IDBFactory* dbFactory;      <span class="comment">//  创建一系列操作的工厂（针对某一数据库的一系列访问操作）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection =</span><br><span class="line">            dbFactory-&gt;<span class="built_in">CreateDBConnection</span>();    <span class="comment">//  sql/oracle 工厂创建出 sql/oracle 连接操作 </span></span><br><span class="line">        connection-&gt;<span class="built_in">ConnectionString</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* command =</span><br><span class="line">            dbFactory-&gt;<span class="built_in">CreateDBCommand</span>();       <span class="comment">//  sql/oracle 工厂创建出 sql/oracle 命令操作</span></span><br><span class="line">        command-&gt;<span class="built_in">CommandText</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        command-&gt;<span class="built_in">SetConnection</span>(connection);     <span class="comment">//  体现出connection与command的关联性</span></span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = command-&gt;<span class="built_in">ExecuteReader</span>(); <span class="comment">//  command与reader的关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>())&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="结构总结"><a href="#结构总结" class="headerlink" title="结构总结"></a>结构总结</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-20-18-47-16.png"></p>
<h3 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h3><ul>
<li>如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。</li>
<li><strong>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖</strong>。</li>
<li>Abstract Factory模式主要在于<strong>应对“新系列”的需求</strong>变动。其缺点在于<strong>难以应对“新对象”的需求变动</strong><ul>
<li>也就是 工厂基类（IDBFactory）不能够增添操作（纯虚函数。）。因为我们假定他是稳定的，也就是这个模式就是在利用那个基类的稳定性，如果变了，那么我们该采用其他模式。</li>
</ul>
</li>
</ul>
<h3 id="工厂方法到抽象工厂"><a href="#工厂方法到抽象工厂" class="headerlink" title="工厂方法到抽象工厂"></a>工厂方法到抽象工厂</h3><ul>
<li>工厂模式是抽象工厂的一种特殊情况！（也即，工厂基类里的方法只有一个而非多个，只负责创建一个对象而非一系列相互依赖的对象）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库访问有关的基类 以及相应基类工厂</span></span><br><span class="line"><span class="comment">//  如果不用抽象工厂，那么，三个相关基类，三个相关工厂。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnection</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBConnectionFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBConnection* <span class="title">CreateDBConnection</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommand</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDBCommandFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDBCommand* <span class="title">CreateDBCommand</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReader</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataReaderFactory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IDataReader* <span class="title">CreateDataReader</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持SQL Server</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlConnectionFactory</span>:</span><span class="keyword">public</span> IDBConnectionFactory&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlCommandFactory</span>:</span><span class="keyword">public</span> IDBCommandFactory&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlDataReaderFactory</span>:</span><span class="keyword">public</span> IDataReaderFactory&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持Oracle</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleConnection</span>:</span> <span class="keyword">public</span> IDBConnection&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleFactory</span>:</span><span class="keyword">public</span> OralceFactory&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleCommand</span>:</span> <span class="keyword">public</span> IDBCommand&#123;&#125;;</span><br><span class="line">OracleCommand工厂</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OracleDataReader</span>:</span> <span class="keyword">public</span> IDataReader&#123;&#125;;</span><br><span class="line">OracleDataReader工厂</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeDAO</span>&#123;</span></span><br><span class="line">    <span class="comment">//  三个基类指针 指向 工厂</span></span><br><span class="line">    IDBConnectionFactory* dbConnectionFactory;</span><br><span class="line">    IDBCommandFactory* dbCommandFactory;</span><br><span class="line">    IDataReaderFactory* dataReaderFactory;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  可以看出这三个工厂所要创作的三个对象相互依赖相互关联。是一系列一系列的操作。因此，可以把他们放入同一工厂。由同一工厂生产。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;EmployeeDO&gt; <span class="title">GetEmployees</span><span class="params">()</span></span>&#123;</span><br><span class="line">        IDBConnection* connection =</span><br><span class="line">            dbConnectionFactory-&gt;<span class="built_in">CreateDBConnection</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">ConnectionString</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IDBCommand* command =</span><br><span class="line">            dbCommandFactory-&gt;<span class="built_in">CreateDBCommand</span>();</span><br><span class="line">        command-&gt;<span class="built_in">CommandText</span>(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">        command-&gt;<span class="built_in">SetConnection</span>(connection); <span class="comment">//关联性</span></span><br><span class="line"></span><br><span class="line">        IDBDataReader* reader = command-&gt;<span class="built_in">ExecuteReader</span>(); <span class="comment">//关联性</span></span><br><span class="line">        <span class="keyword">while</span> (reader-&gt;<span class="built_in">Read</span>())&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="最终代码-施磊"><a href="#最终代码-施磊" class="headerlink" title="最终代码(施磊)"></a>最终代码(施磊)</h3><ul>
<li>子类必须实现父类的纯虚函数，不然无法new<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系列产品1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Car</span>(string name) :_name(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Car</span>()&#123;&#125;        <span class="comment">//  基类的虚构函数写成虚的！</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bmw</span> :</span> <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Bmw</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取了一辆宝马汽车:&quot;</span> &lt;&lt; _name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Audi</span> :</span> <span class="keyword">public</span> Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Audi</span>(string name) :<span class="built_in">Car</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;获取了一辆奥迪汽车:&quot;</span> &lt;&lt; _name&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系列产品2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Light</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BmwLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;BMW light!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudiLight</span> :</span> <span class="keyword">public</span> Light</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Audi light!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法 =&gt; 抽象工厂(对有一组关联关系的产品簇提供产品对象的统一创建)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Car* <span class="title">createCar</span><span class="params">(string name)</span> </span>= <span class="number">0</span>; <span class="comment">// 工厂方法 创建汽车</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> Light* <span class="title">createCarLight</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 工厂方法 创建汽车关联的产品，车灯</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 宝马工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> :</span> <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bmw</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BmwLight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 奥迪工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> :</span> <span class="keyword">public</span> AbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Car* <span class="title">createCar</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Audi</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Light* <span class="title">createCarLight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudiLight</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 现在考虑产品  一类产品（有关联关系的系列产品）</span></span><br><span class="line">	<span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">bmwfty</span><span class="params">(<span class="keyword">new</span> BMWFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">audifty</span><span class="params">(<span class="keyword">new</span> AudiFactory())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p1</span><span class="params">(bmwfty-&gt;createCar(<span class="string">&quot;X6&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Car&gt; <span class="title">p2</span><span class="params">(audifty-&gt;createCar(<span class="string">&quot;A8&quot;</span>))</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Light&gt; <span class="title">l1</span><span class="params">(bmwfty-&gt;createCarLight())</span></span>;</span><br><span class="line">	<span class="function">unique_ptr&lt;Light&gt; <span class="title">l2</span><span class="params">(audifty-&gt;createCarLight())</span></span>;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">	l1-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	l2-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>讲给h<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">工厂模式：简要来说就是：一个抽象类（字母），以及诸多具体类（a,b,c,d）。+ 一个工厂基类，以及诸多具体工厂类（对应生产a,b,c,d）。当需要a对象时，在相应代码段处，通过工厂基类指针，使用a工厂来创建a对象，用抽象基类（字母类型来接收）</span><br><span class="line">宗旨：避免依赖具体的类（尽量依赖抽象类），将本要使用具体类的代码段和具体类分离开（通过使用抽象类和工厂）。</span><br><span class="line">情景：假设现在要在一个类的成员函数FUNC（）内使用对象a/b/c/d。但是，由于需求的变化，我们所要创建的对象的具体类型经常变化，所以，我们要找一个机制来避开常规的<span class="keyword">new</span>语句。</span><br><span class="line">因为，如果正常的<span class="keyword">new</span>，就意味着我们必须在这个函数的代码段内明确说出要创建的对象的类型，那么就会造成紧耦合（如 A *p = <span class="keyword">new</span> <span class="built_in">A</span>()，指明了=号左侧的A和右侧的A类型）。</span><br><span class="line">所以，对于a,b,c,d类，我们需要有一个他们的抽象基类：字母类，来接收具体的a、b、c对象。（因为抽象，所以稳定）。</span><br><span class="line">如 字母 *p = <span class="keyword">new</span> <span class="built_in">A</span>()。那么，=号的左边就解决了。使用抽象类来接收具体的对象。</span><br><span class="line">但是，在=号右边。我们还是要指明具体的A类型，也就是说还是依赖一个具体的类。</span><br><span class="line">所以，为了不依赖它，我们得把<span class="keyword">new</span> <span class="built_in">A</span>()这个语句从本函数拿出来。</span><br><span class="line">所以，我们新建一个类，把这个<span class="keyword">new</span>的任务交给那个新类去处理，那个新类就叫做a工厂类，称为AFactory，内有create方法。</span><br><span class="line">那么，现在的语句就变成 字母* p = pointer_to_AFactory-&gt;<span class="built_in">create</span>();	</span><br><span class="line">但是，此时我们还是需要指出，这个工厂的名字叫做AFactory。那么对于b，c，d来说，我们还是需要指出使用BFactory，CFactory...这还是需要依赖具体的类，所以还需要继续改进。</span><br><span class="line">所以，我们设置一个抽象基类 BaseFactory 里面有纯虚函数 <span class="built_in">create</span>()，BaseFactory的指针/引用，可以用来接收A/B/CFactory。</span><br><span class="line">那么，这条语句就变成 字母 *p = pointer_to_BaseFactory -&gt; <span class="built_in">create</span>();</span><br><span class="line">create（）函数的调用利用了多态的机制，将本应该编译时绑定的函数延迟到运行时进行绑定。</span><br><span class="line">（这也就是通过面向对象的手法，将所要创建的具体对象延迟到子类中去进行。（延迟到子类中的C++中的<span class="keyword">virtual</span>函数，Java中子类实现父类的函数），从而实现一种扩展（而非更改）的策略，较好地解决了原本的紧耦合关系）</span><br><span class="line">这个pointer_to_BaseFactory，就是调用本语句所在的函数时传入的参数。这样，在FUNC（）内，就不回依赖于具体的类（易变化），只依赖于抽象类（稳定）。</span><br><span class="line">将对具体类的依赖从本成员函数内转移到其他代码处。</span><br><span class="line"></span><br><span class="line">之前讲得工厂模式 是 一个工厂类里只负责一个对象的创建。</span><br><span class="line">抽象工厂，就是一个工厂类负责多个对象的创建。其中，这多个对象有相互依赖、相互影响的关系。</span><br><span class="line">如，我们要做访问数据库，对于每种数据库都会有三个操作，connection连接，read读取以及command发出命令。而connection又会影响read和command。</span><br><span class="line">但是，每种数据库之间的具体操作又不同，如Oracle和mySQL之间的connection，read，command方式不会相同。</span><br><span class="line">所以，我们可以看出，在要访问数据库时，我们需要生成负责connection的对象，负责read的对象和负责command的对象。</span><br><span class="line">而这些对象之间又相互依赖相互影响。也即，我们实际需要connection、read、command对象是一系列一系列的。（也可以说是一组一组的）</span><br><span class="line">所以，对于访问mySQL数据库，我们需要一个mySQLFactory&#123;&#125;，里面负责生成mySQL数据库系列的connection、read、command对象。</span><br><span class="line">对于Oralce数据库，同理，需要一个OracleFactory&#123;&#125;，里面负责生成Oracle数据库系列的connection、read、command对象。</span><br><span class="line"></span><br><span class="line">剩下的还是和工厂模式一样，一个数据库抽象基类，一个工厂的抽象基类，就是抽象工厂类负责一系列相关对象</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><ul>
<li>特殊的类，必须保证他们在系统中只存在一个实例，才能保证他们的逻辑正确性、以及良好的效率。</li>
</ul>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><ul>
<li>保证一个类仅有一个实例，并提供一个该实例的全局访问点</li>
</ul>
<h3 id="懒汉-推演"><a href="#懒汉-推演" class="headerlink" title="懒汉 推演"></a>懒汉 推演</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp; other);</span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;   </span><br><span class="line"><span class="comment">//  注意必须是静态！ 定义一个唯一的类的实例对象（不然就会依赖于对象）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  必须是静态！不然要调用非静态方法需要通过对象调用，但是对象还没有。</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance=<span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>单线程用这个即可。线程不安全<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程非安全版本</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>多线程最初：线程安全但性能差<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;          <span class="comment">//  当对象已经创建出来、多个线程都只需要读时，会付出不必要的代价来等待锁</span></span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;    </span><br><span class="line">        m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>多线程改进：<strong>双检查锁</strong>。看似正确，很有可能出<strong>reorder问题</strong>。<strong>不能用！！</strong><ul>
<li><strong>锁前检查</strong>：避免当两个线程都是读取操作时，发生不必要的上锁解锁以及等待来提高效率</li>
<li><strong>锁后检查</strong>：避免重复new对象。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            m_instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-22-13-36-54.png"></li>
</ul>
</li>
<li><strong>漏洞：</strong><ul>
<li>正常应该是 <ul>
<li>先malloc 再 构造 再返回地址给 m_instance，</li>
</ul>
</li>
<li>但是，编译器出于优化，可能会发生这样：<ul>
<li>先malloc，然后返回地址，之后再构造</li>
</ul>
</li>
<li>就会造成，假设有2个线程，一个进入 <code>m_instance = new Singleton</code>。但是编译器优化，返回了地址却没调用构造函数，就会出<strong>现<code>m_instance!=nullptr</code> 但是 <code>m_instance</code>指向的对象还没被构造</strong>，而另一个线程在锁前检查发现不是<code>nullptr</code>，就直接返回<code>m_instance</code>，也即<strong>返回了一个不能使用的对象</strong></li>
</ul>
</li>
<li>C++11之后支持<strong>volatile</strong><ul>
<li>volatile（vaoleitou） 易变的；无定性的；不稳定的</li>
<li>volatile是一个特征修饰符（type specifier）.volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。volatile是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。也即，编译器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。编译器会逐一地进行编译并产生相应的机器代码。</li>
<li><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">volatile</a></li>
</ul>
</li>
</ul>
<ul>
<li><p>volatile在多线程的作用。也是因为这个让编译器从内存读取变量的值而非寄存器/缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile作用在变量上。不把变量存储在寄存器中，每次使用该变量都从内存中读取。这样做的目的是告诉编译器该变量的值可能会随时改变，因此需要从内存中而非寄存器中读取以确保变量的值准确。</span><br><span class="line">在一些多线程的程序里一些全局变量可能会被其他线程修改，这时候要用volatile确保这个变量的值正确。(但是光用volatile也不够，但这就是另一个topic了)</span><br></pre></td></tr></table></figure></li>
<li><p>我总结：volatile的作用就是防止编译器对指令进行优化</p>
<ul>
<li>从而防止编译器从寄存器而非内存中读值（避免多线程情况下发生错误）</li>
<li>从而防止单例模式中new对象时改变指令顺序返回空对象</li>
</ul>
</li>
<li><p><strong>好博客：<a href="https://cloud.tencent.com/developer/article/1177406">博客</a></strong></p>
</li>
</ul>
<h3 id="懒汉最终：懒汉模式线程安全-有效率-无reorder"><a href="#懒汉最终：懒汉模式线程安全-有效率-无reorder" class="headerlink" title="懒汉最终：懒汉模式线程安全+有效率+无reorder"></a><strong>懒汉最终：懒汉模式线程安全+有效率+无reorder</strong></h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getSingleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>) <span class="comment">//  提高效率</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(m_instance==<span class="literal">nullptr</span>)     <span class="comment">//  防止重复new</span></span><br><span class="line">            &#123;</span><br><span class="line">                m_instance =  <span class="keyword">new</span> <span class="built_in">Singleton</span>();  <span class="comment">// 访问volatile变量 汇编指令顺序不变。保证先malloc，然后构造，最后返回。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton * <span class="keyword">volatile</span> m_instance;</span><br><span class="line">    <span class="comment">//  volatile：使得编译器在编译访问m_instance代码时，对指令（的顺序）就不再优化。也即m_instance = new Singleton()的汇编顺序不会改变</span></span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//  构造函数、拷贝构造、复制重载私有化或删除</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* <span class="keyword">volatile</span> Singleton:: m_instance = <span class="literal">nullptr</span>;  <span class="comment">//  static变量需要在类外初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="2（通过static局部变量）"><a href="#2（通过static局部变量）" class="headerlink" title="2（通过static局部变量）"></a>2（通过static局部变量）</h4><ul>
<li>对于static静态局部变量的初始化，编译器会自动对它的初始化进行加锁lock和解锁unlock控制，使静态局部变量的初始化成为线程安全的操作，不用担心多个线程都会初始化静态局部变量，因此如下的懒汉单例模式是线程安全的单例模式</li>
<li><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88544524?spm=1001.2014.3001.5502">shilei</a></li>
<li>static instance：C++11在static局部变量初始化时自动进行加锁和解锁控制</li>
<li>static 函数：为了在没有对象时就可调用<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  懒汉式单例模式另一种写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getSingleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//  static局部变量</span></span><br><span class="line">        <span class="comment">//  static：生命周期为全局</span></span><br><span class="line">        <span class="comment">//  static + 局部 ：汇编层面已经自动添加线程互斥指令</span></span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Single&amp; <span class="keyword">operator</span>=(Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="饿汉"><a href="#饿汉" class="headerlink" title="饿汉"></a>饿汉</h3><ul>
<li>饿汉不用考虑线程安全问题，天生线程安全。因为单例对象在线程产生时就已经创建出来了。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getSingleton</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Singleton Singleton:: m_instance;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-03-23-20-03-29.png"></li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li><ol>
<li>构造函数私有化</li>
</ol>
</li>
<li>2/3. 定义一个唯一的类的实例对象</li>
<li>3/2. 获取类的唯一实例对象的接口方法</li>
</ul>
<p>可重入：可以在多线程下运行，且不会发生静态条件。</p>
<h2 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 Prototype"></a>原型模式 Prototype</h2><p>一个小模式，不常用，是factory的变体</p>
<ul>
<li>为了获取相同状态的对象。</li>
<li>当对象的创建复杂繁琐时。</li>
</ul>
<h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-04-01-20-46-38.png"></p>
<h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-04-01-20-47-05.png"></p>
<h3 id="要点总结-1"><a href="#要点总结-1" class="headerlink" title="要点总结"></a>要点总结</h3><p><img src="/2022/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/2022-04-01-20-44-28.png"></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//  抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">//通过克隆自己来创建对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ISplitter</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  具体类</span></span><br><span class="line"><span class="comment">//  调用父类克隆函数</span></span><br><span class="line"><span class="comment">//  每回调用clone就是返回了一个clone欸到对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span> :</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinarySplitter</span>(*<span class="keyword">this</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TxtSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PictureSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PictureSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoSplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">VideoSplitter</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  用户代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span> :</span> <span class="keyword">public</span> Form</span><br><span class="line">&#123;</span><br><span class="line">    ISplitter*  prototype;<span class="comment">//原型对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>(ISplitter*  prototype)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prototype=prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ISplitter * splitter=</span><br><span class="line">            prototype-&gt;<span class="built_in">clone</span>(); <span class="comment">//克隆原型</span></span><br><span class="line">        splitter-&gt;<span class="built_in">split</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>项目web_server记录</title>
    <url>/2022/03/06/%E9%A1%B9%E7%9B%AEweb-server%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="1-0进度"><a href="#1-0进度" class="headerlink" title="1.0进度"></a>1.0进度</h1><h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><ul>
<li>主线程用EPOLL技术实现IO多路复用。监测读socket、写socket事件</li>
<li>处理模式：同步IO模拟Proactor模式<ul>
<li>难道不是<a href="https://xiaolincoding.com/os/8_network_system/reactor.html#%E5%8D%95-reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%BF%9B%E7%A8%8B">单reactor多线程</a></li>
</ul>
</li>
<li>使用有限状态机解析HTTP请求报文，可以解析GET 请求 //  和POST请求。</li>
<li>多线程，增加并发服务数量。</li>
</ul>
<h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><ul>
<li><p>实现线程池，提高吞吐量</p>
<ul>
<li>信号量实现对任务的互斥，互斥锁实现线程同步。</li>
</ul>
</li>
<li><p>主从状态机对HTTP报文进行解析</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2></li>
<li><p>进一步理解TCP三次握手以及四次挥手</p>
</li>
<li><p>对Web服务器服务过程有基本了解</p>
</li>
<li><p>学习了HTTP协议。</p>
</li>
<li><p>提高debug能力，提高C++代码能力，学习Linux系统编程以及网络编程，计网，操作系统知识</p>
</li>
<li><p><strong>理解什么是短连接</strong></p>
<ul>
<li><p><strong><a href="https://www.jianshu.com/p/3fc3646fad80">长连接短连接</a></strong></p>
</li>
<li><p>处理完一次client发来的请求并发送完响应之后就立刻断开连接，把负责连接的connection资源释放或者放入对象池。</p>
</li>
<li><p>本例这里将其放回对象池（就是一个先new出来的数组）。当新的（同一）client发来请求后，在server端看起来并没有区别，还是重新造一个conn连接对象。之前处理请求的相关数据都已不在。sever和client看起来就像没见过面一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  一开始</span></span><br><span class="line">client_data *users_timer = <span class="keyword">new</span> client_data[MAX_FD];     <span class="comment">//  用户资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  server监听到client连接时：新建立连接</span></span><br><span class="line"><span class="comment">//  使用对象池中的对象内存 覆盖上新数据</span></span><br><span class="line">users[connfd].<span class="built_in">init</span>(connfd,cliet_addr);   </span><br><span class="line"><span class="comment">//  这句话，可以接纳新的连接，并且填充在旧的被关闭的连接的http_conn对象上（因为那个之前断开的sockfd被close了，所以这个connfd一定是之前断开导致的空位（如果之前有连接关闭的画）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  server处理完一次client的请求后：断开连接，所有相关信息都不要。</span></span><br><span class="line"><span class="comment">//  即便是同一client再次连接，也会覆盖数据。</span></span><br><span class="line"><span class="keyword">if</span>(users[sockfd].<span class="built_in">write_conn</span>()==<span class="literal">false</span>)   <span class="comment">//  ==false代表使用短连接</span></span><br><span class="line">  users[sockfd].<span class="built_in">close_conn</span>();           <span class="comment">//  重置数据，并使其可以被覆盖</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  移除监听、重置conn相关数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::close_conn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_sockfd!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//  read_idx等在下次被覆盖</span></span><br><span class="line">        <span class="built_in">removefd</span>(m_epfd,m_sockfd);    <span class="comment">//  移除监听  </span></span><br><span class="line">        --m_user_cnt;</span><br><span class="line">        m_sockfd=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="先不整注册和登录了"><a href="#先不整注册和登录了" class="headerlink" title="先不整注册和登录了"></a>先不整注册和登录了</h2><h2 id="下一步目标"><a href="#下一步目标" class="headerlink" title="下一步目标"></a>下一步目标</h2><ul>
<li><p>vector<char></char></p>
</li>
<li><p>日志IO自己写</p>
</li>
<li><p>定时器用堆实现</p>
</li>
<li><p>正则表达式解析</p>
</li>
<li><p>学MySQL</p>
</li>
<li><p>epoll<br><a href="https://blog.csdn.net/zhizhengguan/article/details/120566355?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&utm_relevant_index=2">socket阻塞</a></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd = <span class="built_in">epoll_create</span>();</span><br><span class="line"><span class="built_in">addfd</span>(listening_fd);    <span class="comment">//  设置fd为非阻塞，并注册EPOLLIN | EPOLLET事件</span></span><br><span class="line"><span class="built_in">alarm</span>(TIMESLOT);        <span class="comment">//  唤醒定时器</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ev_num = <span class="built_in">epoll_wait</span>(epfd,events,MAX_EVENT_NUMEBR,<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;errno = %s&quot;</span>,<span class="built_in">strerror</span>(errno));</span><br><span class="line">  <span class="comment">//ET和LT下都会发生 errno = Resource temporarily unavailable 或者 alarm信号打断的Interrupted system call</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ev_num;++i) <span class="comment">//  处理发生的事件</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(events[i].fd==lfd) <span class="comment">//  接收连接</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">accept</span>(lfd,(sockaddr*)&amp;client_addr,&amp;client_len);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//  读socket事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//  写socket事件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//  信号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listening_fd 为LT 模式下</span><br><span class="line">$ ./webbench -c <span class="number">1000</span> -t <span class="number">60</span> http:<span class="comment">//192.168.147.180:12345/index.html</span></span><br><span class="line">Webbench - Simple Web Benchmark <span class="number">1.5</span></span><br><span class="line"><span class="built_in">Copyright</span> (c) Radim Kolar <span class="number">1997</span><span class="number">-2004</span>, GPL Open Source Software.</span><br><span class="line"></span><br><span class="line">Benchmarking: GET http:<span class="comment">//192.168.147.180:12345/index.html</span></span><br><span class="line"><span class="number">1000</span> clients, running <span class="number">60</span> sec.</span><br><span class="line"></span><br><span class="line">Speed=<span class="number">527795</span> pages/min, <span class="number">1407368</span> bytes/sec.</span><br><span class="line">Requests: <span class="number">527790</span> susceed, <span class="number">5</span> failed.</span><br><span class="line">===============================================================</span><br><span class="line">listening_fd 为ET模式下</span><br><span class="line">$ ./webbench -c <span class="number">1000</span> -t <span class="number">60</span> http:<span class="comment">//192.168.147.180:12345/index.html</span></span><br><span class="line">Webbench - Simple Web Benchmark <span class="number">1.5</span></span><br><span class="line"><span class="built_in">Copyright</span> (c) Radim Kolar <span class="number">1997</span><span class="number">-2004</span>, GPL Open Source Software.</span><br><span class="line"></span><br><span class="line">Benchmarking: GET http:<span class="comment">//192.168.147.180:12345/index.html</span></span><br><span class="line"><span class="number">1000</span> clients, running <span class="number">60</span> sec.</span><br><span class="line"></span><br><span class="line">Speed=<span class="number">11</span> pages/min, <span class="number">24</span> bytes/sec.</span><br><span class="line">Requests: <span class="number">11</span> susceed, <span class="number">0</span> failed.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ET<br><img src="/2022/03/06/%E9%A1%B9%E7%9B%AEweb-server%E8%AE%B0%E5%BD%95/2022-03-09-11-51-02.png"></p>
</li>
<li><p>LT<br><img src="/2022/03/06/%E9%A1%B9%E7%9B%AEweb-server%E8%AE%B0%E5%BD%95/2022-03-09-11-51-10.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>玩具</category>
      </categories>
      <tags>
        <tag>玩具</tag>
      </tags>
  </entry>
  <entry>
    <title>查表</title>
    <url>/2022/05/08/%E6%9F%A5%E8%A1%A8/</url>
    <content><![CDATA[<p>查表</p>
<span id="more"></span>

<ul>
<li>2次幂表 （因为我懒）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">0</span>=<span class="number">1</span></span><br><span class="line"><span class="number">2</span>^<span class="number">1</span>=<span class="number">2</span></span><br><span class="line"><span class="number">2</span>^<span class="number">2</span>=<span class="number">4</span></span><br><span class="line"><span class="number">2</span>^<span class="number">3</span>=<span class="number">8</span></span><br><span class="line"><span class="number">2</span>^<span class="number">4</span>=<span class="number">16</span></span><br><span class="line"><span class="number">2</span>^<span class="number">5</span>=<span class="number">32</span></span><br><span class="line"><span class="number">2</span>^<span class="number">6</span>=<span class="number">64</span></span><br><span class="line"><span class="number">2</span>^<span class="number">7</span>=<span class="number">128</span></span><br><span class="line"><span class="number">2</span>^<span class="number">8</span>=<span class="number">256</span></span><br><span class="line"><span class="number">2</span>^<span class="number">9</span>=<span class="number">512</span></span><br><span class="line"><span class="number">2</span>^<span class="number">10</span>=<span class="number">1024</span></span><br><span class="line"><span class="number">2</span>^<span class="number">11</span>=<span class="number">2048</span></span><br><span class="line"><span class="number">2</span>^<span class="number">12</span>=<span class="number">4096</span></span><br><span class="line"><span class="number">2</span>^<span class="number">13</span>=<span class="number">8192</span></span><br><span class="line"><span class="number">2</span>^<span class="number">14</span>=<span class="number">16384</span></span><br><span class="line"><span class="number">2</span>^<span class="number">15</span>=<span class="number">32768</span></span><br><span class="line"><span class="number">2</span>^<span class="number">16</span>=<span class="number">65536</span></span><br><span class="line"><span class="number">2</span>^<span class="number">17</span>=<span class="number">131072</span></span><br><span class="line"><span class="number">2</span>^<span class="number">18</span>=<span class="number">262144</span></span><br><span class="line"><span class="number">2</span>^<span class="number">19</span>=<span class="number">524288</span></span><br><span class="line"><span class="number">2</span>^<span class="number">20</span>=<span class="number">1048576</span></span><br><span class="line"><span class="number">2</span>^<span class="number">21</span>=<span class="number">2097152</span></span><br><span class="line"><span class="number">2</span>^<span class="number">22</span>=<span class="number">4194304</span></span><br><span class="line"><span class="number">2</span>^<span class="number">23</span>=<span class="number">8388608</span></span><br><span class="line"><span class="number">2</span>^<span class="number">24</span>=<span class="number">16777216</span></span><br><span class="line"><span class="number">2</span>^<span class="number">25</span>=<span class="number">33554432</span></span><br><span class="line"><span class="number">2</span>^<span class="number">26</span>=<span class="number">67108864</span></span><br><span class="line"><span class="number">2</span>^<span class="number">27</span>=<span class="number">134217728</span></span><br><span class="line"><span class="number">2</span>^<span class="number">28</span>=<span class="number">268435456</span></span><br><span class="line"><span class="number">2</span>^<span class="number">29</span>=<span class="number">536870912</span></span><br><span class="line"><span class="number">2</span>^<span class="number">30</span>=<span class="number">1073741824</span></span><br><span class="line"><span class="number">2</span>^<span class="number">31</span>=<span class="number">2147483648</span></span><br><span class="line"><span class="number">2</span>^<span class="number">32</span>=<span class="number">4294967296</span></span><br><span class="line"><span class="number">2</span>^<span class="number">33</span>=<span class="number">8589934592</span></span><br><span class="line"><span class="number">2</span>^<span class="number">34</span>=<span class="number">17179869184</span></span><br><span class="line"><span class="number">2</span>^<span class="number">35</span>=<span class="number">34359738368</span></span><br><span class="line"><span class="number">2</span>^<span class="number">36</span>=<span class="number">68719476736</span></span><br><span class="line"><span class="number">2</span>^<span class="number">37</span>=<span class="number">137438953472</span></span><br><span class="line"><span class="number">2</span>^<span class="number">38</span>=<span class="number">274877906944</span></span><br><span class="line"><span class="number">2</span>^<span class="number">39</span>=<span class="number">549755813888</span></span><br><span class="line"><span class="number">2</span>^<span class="number">40</span>=<span class="number">1099511627776</span></span><br><span class="line"><span class="number">2</span>^<span class="number">41</span>=<span class="number">2199023255552</span></span><br><span class="line"><span class="number">2</span>^<span class="number">42</span>=<span class="number">4398046511104</span></span><br><span class="line"><span class="number">2</span>^<span class="number">43</span>=<span class="number">8796093022208</span></span><br><span class="line"><span class="number">2</span>^<span class="number">44</span>=<span class="number">17592186044416</span></span><br><span class="line"><span class="number">2</span>^<span class="number">45</span>=<span class="number">35184372088832</span></span><br><span class="line"><span class="number">2</span>^<span class="number">46</span>=<span class="number">70368744177664</span></span><br><span class="line"><span class="number">2</span>^<span class="number">47</span>=<span class="number">140737488355328</span></span><br><span class="line"><span class="number">2</span>^<span class="number">48</span>=<span class="number">281474976710656</span></span><br><span class="line"><span class="number">2</span>^<span class="number">49</span>=<span class="number">562949953421312</span></span><br><span class="line"><span class="number">2</span>^<span class="number">50</span>=<span class="number">1125899906842624</span></span><br><span class="line"><span class="number">2</span>^<span class="number">51</span>=<span class="number">2251799813685248</span></span><br><span class="line"><span class="number">2</span>^<span class="number">52</span>=<span class="number">4503599627370496</span></span><br><span class="line"><span class="number">2</span>^<span class="number">53</span>=<span class="number">9007199254740992</span></span><br><span class="line"><span class="number">2</span>^<span class="number">54</span>=<span class="number">18014398509481984</span></span><br><span class="line"><span class="number">2</span>^<span class="number">55</span>=<span class="number">36028797018963968</span></span><br><span class="line"><span class="number">2</span>^<span class="number">56</span>=<span class="number">72057594037927936</span></span><br><span class="line"><span class="number">2</span>^<span class="number">57</span>=<span class="number">144115188075855872</span></span><br><span class="line"><span class="number">2</span>^<span class="number">58</span>=<span class="number">288230376151711744</span></span><br><span class="line"><span class="number">2</span>^<span class="number">59</span>=<span class="number">576460752303423488</span></span><br><span class="line"><span class="number">2</span>^<span class="number">60</span>=<span class="number">1152921504606846976</span></span><br><span class="line"><span class="number">2</span>^<span class="number">61</span>=<span class="number">2305843009213693952</span></span><br><span class="line"><span class="number">2</span>^<span class="number">62</span>=<span class="number">4611686018427387904</span></span><br><span class="line"><span class="number">2</span>^<span class="number">63</span>=<span class="number">9223372036854775808</span></span><br><span class="line"><span class="number">2</span>^<span class="number">64</span>=<span class="number">18446744073709551616</span></span><br><span class="line"><span class="number">2</span>^<span class="number">65</span>=<span class="number">36893488147419103232</span></span><br><span class="line"><span class="number">2</span>^<span class="number">66</span>=<span class="number">73786976294838206464</span></span><br><span class="line"><span class="number">2</span>^<span class="number">67</span>=<span class="number">147573952589676412928</span></span><br><span class="line"><span class="number">2</span>^<span class="number">68</span>=<span class="number">295147905179352825856</span></span><br><span class="line"><span class="number">2</span>^<span class="number">69</span>=<span class="number">590295810358705651712</span></span><br><span class="line"><span class="number">2</span>^<span class="number">70</span>=<span class="number">1180591620717411303424</span></span><br><span class="line"><span class="number">2</span>^<span class="number">71</span>=<span class="number">2361183241434822606848</span></span><br><span class="line"><span class="number">2</span>^<span class="number">72</span>=<span class="number">4722366482869645213696</span></span><br><span class="line"><span class="number">2</span>^<span class="number">73</span>=<span class="number">9444732965739290427392</span></span><br><span class="line"><span class="number">2</span>^<span class="number">74</span>=<span class="number">18889465931478580854784</span></span><br><span class="line"><span class="number">2</span>^<span class="number">75</span>=<span class="number">37778931862957161709568</span></span><br><span class="line"><span class="number">2</span>^<span class="number">76</span>=<span class="number">75557863725914323419136</span></span><br><span class="line"><span class="number">2</span>^<span class="number">77</span>=<span class="number">151115727451828646838272</span></span><br><span class="line"><span class="number">2</span>^<span class="number">78</span>=<span class="number">302231454903657293676544</span></span><br><span class="line"><span class="number">2</span>^<span class="number">79</span>=<span class="number">604462909807314587353088</span></span><br><span class="line"><span class="number">2</span>^<span class="number">80</span>=<span class="number">1208925819614629174706176</span></span><br><span class="line"><span class="number">2</span>^<span class="number">81</span>=<span class="number">2417851639229258349412352</span></span><br><span class="line"><span class="number">2</span>^<span class="number">82</span>=<span class="number">4835703278458516698824704</span></span><br><span class="line"><span class="number">2</span>^<span class="number">83</span>=<span class="number">9671406556917033397649408</span></span><br><span class="line"><span class="number">2</span>^<span class="number">84</span>=<span class="number">19342813113834066795298816</span></span><br><span class="line"><span class="number">2</span>^<span class="number">85</span>=<span class="number">38685626227668133590597632</span></span><br><span class="line"><span class="number">2</span>^<span class="number">86</span>=<span class="number">77371252455336267181195264</span></span><br><span class="line"><span class="number">2</span>^<span class="number">87</span>=<span class="number">154742504910672534362390528</span></span><br><span class="line"><span class="number">2</span>^<span class="number">88</span>=<span class="number">309485009821345068724781056</span></span><br><span class="line"><span class="number">2</span>^<span class="number">89</span>=<span class="number">618970019642690137449562112</span></span><br><span class="line"><span class="number">2</span>^<span class="number">90</span>=<span class="number">1237940039285380274899124224</span></span><br><span class="line"><span class="number">2</span>^<span class="number">91</span>=<span class="number">2475880078570760549798248448</span></span><br><span class="line"><span class="number">2</span>^<span class="number">92</span>=<span class="number">4951760157141521099596496896</span></span><br><span class="line"><span class="number">2</span>^<span class="number">93</span>=<span class="number">9903520314283042199192993792</span></span><br><span class="line"><span class="number">2</span>^<span class="number">94</span>=<span class="number">19807040628566084398385987584</span></span><br><span class="line"><span class="number">2</span>^<span class="number">95</span>=<span class="number">39614081257132168796771975168</span></span><br><span class="line"><span class="number">2</span>^<span class="number">96</span>=<span class="number">79228162514264337593543950336</span></span><br><span class="line"><span class="number">2</span>^<span class="number">97</span>=<span class="number">158456325028528675187087900672</span></span><br><span class="line"><span class="number">2</span>^<span class="number">98</span>=<span class="number">316912650057057350374175801344</span></span><br><span class="line"><span class="number">2</span>^<span class="number">99</span>=<span class="number">633825300114114700748351602688</span></span><br><span class="line"><span class="number">2</span>^<span class="number">100</span>=<span class="number">1267650600228229401496703205376</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技能 &amp; 工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
