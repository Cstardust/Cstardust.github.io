<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUG</title>
    <url>/2021/09/04/C-Bug/</url>
    <content><![CDATA[<h1 id="BUG-小白的锌酸历程"><a href="#BUG-小白的锌酸历程" class="headerlink" title="BUG (小白的锌酸历程)"></a><strong>BUG (小白的锌酸历程)</strong></h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a><strong>1</strong></h2><ul>
<li><code>.h</code>头文件上来记得加<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> xxx  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxx </span></span><br><span class="line">..... </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-0-multiple-definition-redefinition-xxx-already-defined-in-adsasd-obj"><a href="#2-0-multiple-definition-redefinition-xxx-already-defined-in-adsasd-obj" class="headerlink" title="2.0  multiple definition / redefinition / xxx already defined in adsasd.obj"></a><strong>2.0  multiple definition / redefinition / xxx already defined in adsasd.obj</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;c.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>&gt;c.obj : error LNK2005: <span class="string">&quot;void __cdecl func1(void)&quot;</span> (?func1@@YAXXZ) already defined in a.obj</span><br><span class="line"><span class="number">1</span>&gt;C:\Users\de<span class="number">&#x27;l</span><span class="number">&#x27;l</span>\VSProjects\MistakeTry\Debug\MistakeTry.exe : fatal error LNK1169: one <span class="keyword">or</span> more multiply defined symbols found</span><br><span class="line"><span class="number">1</span>&gt;Done building project <span class="string">&quot;MistakeTry.vcxproj&quot;</span> -- FAILED.</span><br></pre></td></tr></table></figure>
<ul>
<li>养成<strong>不要在头<code>.h</code>文件中定义非类成员函数以及非内联函数</strong>的习惯。</li>
<li>养成<strong>在类相应源<code>.cpp</code>文件中定义函数</strong>的习惯</li>
<li>非类的成员函数的定义尽量放在<code>.cpp</code>文件中<ul>
<li>因为c++采用单独编译，就是将每个<code>.cpp</code>文件编译成对应的<code>.o</code>文件，最后链接器再将多个<code>.obj</code>文件链接成可执行程序。</li>
<li>所以本例，从各个<code>cpp</code>文件看，编译成.o文件时没有任何问题（在main中也没有问题，因为有<code>#pargma once </code>,<code>a.h</code>只会在<code>main</code>中<code>include</code>一次，但是在<code>c.cpp</code>和<code>a.cpp</code>和文件中都<code>include</code>了<code>a.h</code>文件</li>
<li>(宏的定义域只局限于一个文件) </li>
<li>而<code>a.h</code>文件中又定义了<code>print</code>函数，即与预处理过后，在c和a源文件中都定义了<code>print</code>函数，重复定义，即会有<code>one or more multiply defined symbols found</code>或者 <code>....already defined in ..obj</code>的错误</li>
</ul>
</li>
<li>有人可能会问，既然是从同一份文件<code>include</code>过来的函数<code>hhh()</code>，那么定义都是同一份，为什么编译器不会智能的处理一下，让链接时候不报错呢？<ul>
<li>其实编译器链接的时候，并不知道<code>b.cpp</code>中定义的<code>hhh</code>与<code>c.cpp</code>中定义的<code>hhh</code>是同一个文件<code>include</code>过来的，它只会认为如果有两份定义，而且这两份定义如果实现不同，那么到底以哪个为准呢？既然决定不了，那就干脆报错好了。</li>
<li>这段引自博客,链接我真没找到。。</li>
</ul>
</li>
</ul>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a><strong>例外</strong></h3><ul>
<li><strong><code>inline</code></strong> 函数定义在头文件中<ul>
<li>C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个<code>cpp</code>中只出现一次就行。</li>
</ul>
</li>
<li><strong><code>class</code></strong> 成员函数可在头文件中定义</li>
<li><a href="https://jiadebin.github.io/2017/04/03/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84multiple-definition/">参考 感谢作者</a></li>
</ul>
<h2 id="2-1-inline函数要定义在头文件内。"><a href="#2-1-inline函数要定义在头文件内。" class="headerlink" title="2.1 inline函数要定义在头文件内。"></a><strong>2.1 <code>inline</code>函数要定义在头文件内。</strong></h2><ul>
<li>若定义在<code>.cpp</code>文件则会<ul>
<li><strong><code>undefined reference to &#39;CScene::CScene()&#39;</code></strong></li>
<li><strong><code>main.obj : error LNK2019: unresolved external symbol &quot;public: __thiscall CScene::CScene(void)&quot; (??0CScene@@QAE@XZ) referenced in function _main</code></strong></li>
</ul>
</li>
<li><ol>
<li>大多数环境在编译期间进行<code>inline</code>，而为了将一个<code>函数调用</code>替换为<code>被调用的函数的本体</code>，编译器必须知道那个函数长什么样子。</li>
</ol>
</li>
<li><ol start="2">
<li>与非<code>inline</code>函数不同，<code>inline</code>函数必须在调用该函数的每个文件中定义。（为了完成上一句话的要求）</li>
</ol>
</li>
<li><ol start="3">
<li>对于同一程序的不同文件，同一<code>inline</code>函数的定义应当相同。</li>
</ol>
</li>
<li>因此，<strong>应把<code>inline</code>函数的定义放入头文件</strong>，在<strong>每个</strong>调用了该<code>inline</code>函数的地方<code>include</code>该头文件 （为了完成2），这种方法*<strong>保证了每个<code>inline</code>函数只有一个定义</strong>，且程序员无需复制代码，并且不可能在程序的生命周期引起无意不匹配的事情。</li>
</ul>
<h3 id="问题：会不会出现编译器没有把我们在-h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple-definition的情况？"><a href="#问题：会不会出现编译器没有把我们在-h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple-definition的情况？" class="headerlink" title="问题：会不会出现编译器没有把我们在.h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple definition的情况？"></a>问题：会不会出现编译器没有把我们在<code>.h</code>文件中定义的内联函数当作<code>inline</code>函数，而我们又到处<code>include</code>，造成<code>multiple definition</code>的情况？</h3><ul>
<li>qs是出现了。。。。md。。。。我的解决方法：<ul>
<li>直接在那个<code>.h</code>文件的类内定义该成员函数</li>
<li>或者取消把他内联的想法。交给编译器，听他的。</li>
</ul>
</li>
</ul>
<h2 id="3-相互包含头文件"><a href="#3-相互包含头文件" class="headerlink" title="3.  相互包含头文件"></a><strong>3.  相互包含头文件</strong></h2><ul>
<li>两个头文件相互包含</li>
<li>若在B的头文件中：<ul>
<li><ol>
<li><strong>使用<code>A对象</code>或<code>A对象</code>作为返回值的则要<code>include A.h</code></strong></li>
</ol>
</li>
<li><ol start="2">
<li><strong>使用<code>A类型</code>作为指针则在定义<code>A*</code>前声明<code>class A</code>即可</strong></li>
</ol>
</li>
<li>另外，若为<strong>情况2</strong>，<strong>则在<code>B.cpp</code>文件中，为了使用A类的成员函数，则要<code>include A.h</code></strong></li>
<li><ol start="3">
<li>两个类中互相使用了对方的指针，这样的情况很简单，分别在各自的头文件中声明一下使用的类，而在各自的源文件中包含对方的头文件即可。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-There-is-no-matching-member-for-call-to-‘find’"><a href="#4-There-is-no-matching-member-for-call-to-‘find’" class="headerlink" title="4. There is no matching member for call to ‘find’"></a><strong>4. There is no matching member for call to ‘find’</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; m = &#123;&#123;<span class="string">&quot;I&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;IV&quot;</span>,<span class="number">4</span>&#125;,&#123;<span class="string">&quot;V&quot;</span>,<span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;IX&quot;</span>,<span class="number">9</span>&#125;,&#123;<span class="string">&quot;X&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;XL&quot;</span>,<span class="number">40</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;L&quot;</span>,<span class="number">50</span>&#125;,&#123;<span class="string">&quot;XC&quot;</span>,<span class="number">90</span>&#125;,&#123;<span class="string">&quot;C&quot;</span>,<span class="number">100</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;CD&quot;</span>,<span class="number">400</span>&#125;,&#123;<span class="string">&quot;D&quot;</span>,<span class="number">500</span>&#125;,&#123;<span class="string">&quot;CM&quot;</span>,<span class="number">900</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;M&quot;</span>,<span class="number">1000</span>&#125;&#125;;</span><br><span class="line">string s = <span class="string">&quot;MCD&quot;</span>;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; ::iterator iter = m.<span class="built_in">find</span>(s[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(iter!=s.<span class="built_in">end</span>()) ...  </span><br></pre></td></tr></table></figure>
<p><code>There is no matching member for call to &#39;find&#39;</code></p>
<ul>
<li><strong>原因</strong><ul>
<li><code>unordered_map&lt;string,int&gt;</code>的<code>key type</code>是 <code>std::string</code>,但是我们传入的是一个字符<code>char</code>给<code>find()</code>函数.<code>std::string</code>没有一个可以接收一个<code>char</code>的<code>constructor</code>.因此<code>error</code>.</li>
</ul>
</li>
<li><strong>解决</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">find</span>(&#123;s[<span class="number">0</span>]&#125;);</span><br><span class="line">m.<span class="built_in">find</span>(<span class="built_in">string</span>()+s[<span class="number">0</span>]); <span class="comment">//一个string型字符串和一个char相加,会将char先转化为string,再相加</span></span><br><span class="line">m.<span class="built_in">find</span>(<span class="built_in">string</span>(<span class="number">1</span>,s[<span class="number">0</span>]));<span class="comment">//string构造函数 string(n,char);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-关于（几乎就是不可以）返回局部变量的引用"><a href="#5-关于（几乎就是不可以）返回局部变量的引用" class="headerlink" title="5. 关于（几乎就是不可以）返回局部变量的引用"></a><strong>5. 关于（几乎就是不可以）返回局部变量的引用</strong></h2><ul>
<li>函数<strong>返回local variable引用</strong>（<strong>无论是否是常量引用</strong>）是<strong>不可以</strong>的。(条件是函数调用处并<strong>没有用常量引用来接收</strong>)<ul>
<li>理解：编译器根据 <code>local</code> 变量造了一个<code>const</code>局部临时量 让<code>const</code>引用绑定在这个临时变量上，<strong>可这个变量还是一个局部变量</strong>。函数结束这个局部的临时量时该销毁还是销毁了。</li>
</ul>
</li>
<li>对于函数中的一个变量，如果<strong>不是局部变量</strong>，而是函数传参传入的一个引用，那么返回时当然<strong>可以</strong>返回该变量的引用（无论是否常），因为这个变量在函数结束时并不会被销毁。</li>
<li>图片来自<a href="https://blog.csdn.net/u012814856/article/details/84099328">博客</a><br><img src="/2021/09/04/C-Bug/2021-11-24-09-12-38.png"></li>
</ul>
<h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a><strong>特例</strong></h4><ul>
<li><del>如果在函数调用处使用了const引用来接收返回的引用/常量引用，那么是ok的</del>。</li>
<li>经实验，没有特例，无论是不是用常量引用接收，就是不能返回局部变量的常引。如果是一些容器类的话，可能不止是警告，还有编译error。</li>
<li>如果返回一个值的话，函数调用处用一个<code>const</code>引用接收当然可以延长生命周期。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj02 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; c = <span class="built_in">func1</span>(a, b);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; d = <span class="built_in">func2</span>(a, b);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; e = <span class="built_in">func1</span>(a, b);</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jj02::<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>运行结果<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6492220</span><br><span class="line">6509462</span><br><span class="line">6492220</span><br><span class="line"></span><br><span class="line">C:\Users\de<span class="string">&#x27;l&#x27;</span>l\VSProjects\MistakeTry\Debug\MistakeTry.exe (process 20256) exited with code 0.</span><br><span class="line">To automatically close the console when debugging stops, <span class="built_in">enable</span> Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console when debugging stops.</span><br><span class="line">Press any key to close this window . . .</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">19999</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">1121332</span>;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = jj01::<span class="built_in">func1</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">88</span>;</span><br><span class="line">	<span class="keyword">int</span> b = jj01::<span class="built_in">g</span>();</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C:\Users\de&#x27;l&#x27;l\VSProjects\MistakeTry\main.cpp(80): warning C4172: returning address of local variable or temporary: b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1&gt;C:\Users\de&#x27;l&#x27;l\VSProjects\MistakeTry\main.cpp(74): warning C4172: returning address of local variable or temporary: a</span></span><br></pre></td></tr></table></figure>


<h2 id="6-vector类内初始化"><a href="#6-vector类内初始化" class="headerlink" title="6. vector类内初始化"></a><strong>6. vector类内初始化</strong></h2><ul>
<li><code>vector</code>容器对象在类内定义时不允许指定大小(编译器会认为这是定义了一个函数)，只能通过<strong>列表初始化</strong>指定大小。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">// error 编译器会认为这是定义了一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> n):<span class="built_in">v</span>(n)&#123;&#125;		<span class="comment">//  列表初始化 ok</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-静态成员函数指针-非静态成员函数指针"><a href="#7-静态成员函数指针-非静态成员函数指针" class="headerlink" title="7. 静态成员函数指针 非静态成员函数指针"></a>7. <strong>静态成员函数指针 非静态成员函数指针</strong></h2><ul>
<li><strong>问题：</strong> 在使用<code>sort()</code>函数时，第三个函数只能是 <strong>全局函数指针</strong>或者<strong>静态成员函数指针</strong>，不能是<strong>非静态成员函数指针</strong>。</li>
<li><strong>解释：</strong> 非静态成员函数的参数中有一个<strong>隐式绑定的this指针</strong>(因为非静态成员函数需要由具体对象来调用)，而<code>sort</code>第三个参数需要得是一个接受两个参数的函数指针，所以不可。如果是静态成员函数的话，<code>sort</code>时直接使用<code>cmp</code>即可，无需依赖于实际对象。</li>
<li>感觉这话题好像挺大的，之后再研究研究。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 贴个合并区间的代码hhhh</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span>  <span class="comment">// 成员函数指针 静态函数指针 全局函数指针 整理。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);    <span class="comment">// 按照左端点排序</span></span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;r) </span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">                l=intervals[i][<span class="number">0</span>],r=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;r) r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：猪啊猪</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/file_system/file/content/whole/index/content/2974707/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="string相关"><a href="#string相关" class="headerlink" title="string相关"></a><strong><code>string</code>相关</strong></h2><ul>
<li>可以<code>+</code>不可以<code>-</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;012345&quot;</span>;</span><br><span class="line">s += <span class="string">&#x27;6&#x27;</span>; <span class="comment">// s = &quot;0123456&quot;</span></span><br><span class="line">s += <span class="string">&quot;6&quot;</span>; <span class="comment">// s = &quot;0123456&quot;</span></span><br><span class="line">s -= <span class="string">&quot;6&quot;</span>; <span class="comment">//error</span></span><br><span class="line">s -= <span class="string">&#x27;6&#x27;</span>; <span class="comment">//error</span></span><br><span class="line">no viable loaded <span class="string">&#x27;-=&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对pthread-create未定义的引用"><a href="#对pthread-create未定义的引用" class="headerlink" title="对pthread_create未定义的引用"></a><strong>对<code>pthread_create</code>未定义的引用</strong></h2><ul>
<li><code>gcc</code>编译时加上参数 <code>-lpthread</code></li>
<li>原因：<code>pthread</code>不是<code>Linux</code>默认的库。（毕竟<code>Linux</code>最开始本身没有线程），所以要链接上这个动态库</li>
</ul>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>小白血泪史</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux I/O</title>
    <url>/2021/11/05/Linux-IO/</url>
    <content><![CDATA[<p>Unix I/O</p>
<span id="more"></span>

<h1 id="Unix基础知识"><a href="#Unix基础知识" class="headerlink" title="Unix基础知识"></a>Unix基础知识</h1><ul>
<li><p><strong>系统调用</strong></p>
<ul>
<li>写文件 ，即对磁盘操作。从用户空间进入内核空间，借助驱动，驱动磁盘工作。库函数没有办法直接使用驱动，应该通过系统函数来使用驱动完成对磁盘的操作。<br><img src="/2021/11/05/Linux-IO/2021-11-21-19-38-48.png"></li>
</ul>
</li>
<li><p><strong>预读入 缓输出</strong></p>
<ul>
<li><code>read  write : unbuffered I/O</code>。不带（用户区）缓冲的<code>I/O</code>。内核处有内核级别的缓冲区，默认大小4096B。 </li>
<li>为什么<code>write(fd,const char *,n);</code>比<code>fputc</code>慢。如图<br><img src="/2021/11/05/Linux-IO/2021-11-21-19-43-36.png"></li>
<li>在上图中的磁盘和<code>kernal</code>之间，采取预读入缓输出机制<ul>
<li>即从磁盘往<code>kernal</code>读东西的时候，一次读4096个字节，避免之后读取时多次与硬盘交互。</li>
<li>从<code>kernal</code>向磁盘写东西的时候，一次写4096个，避免多次与磁盘交互。 </li>
</ul>
</li>
</ul>
</li>
<li><p>所以</p>
<ul>
<li>即使学了系统调用，能使用库函数的地方，优先使用库函数    </li>
<li>那为什么要学系统函数，因为只用库函数可能会有逻辑上的障碍。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>阻塞与非阻塞</strong></p>
<ul>
<li>是所读文件的性质，不是<code>read write</code>的性质</li>
<li>读常规文件不会阻塞；读网络会阻塞</li>
<li>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</li>
<li>现在明确一下阻塞<code>（Block）</code>这个概念。当进程调用一个阻塞的系统函数时，该进程被置于睡眠（<code>Sleep</code>）状态，这时内核调度其它进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用 <code>sleep</code> 指定的睡眠时间到了）它才有可能继续运行。与睡眠状态相对的是运行（<code>Running</code>）状态，在 <code>Linux</code> 内核中，处于运行状态的进程分为两种情况：<ul>
<li>正在被调度执行。<code>CPU</code> 处于该进程的上下文环境中，程序计数器（<code>eip</code>）里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，正在读写该进程的地址空间。</li>
<li>就绪状态：该进程不需要等待什么事件发生，随时都可以执行，但 <code>CPU</code> 暂时还在执行另一个进程，所以该进程在一个就绪队列中等待被内核调度。系统中可能同时有多个就绪的进程，那么该调度谁执行呢？内核的调度算法是基于优先级和时间片的，而且会根据每个进程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到机会执行，同时要兼顾用户体验，不能让和用户交互的进程响应太慢</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>每一个进程都有如下结构</strong><br><img src="/2021/11/05/Linux-IO/2021-11-24-20-09-47.png"></p>
</li>
</ul>
<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="/2021/11/05/Linux-IO/2021-11-24-21-20-02.png"></p>
<h2 id="UNIX：文件相关数据结构"><a href="#UNIX：文件相关数据结构" class="headerlink" title="UNIX：文件相关数据结构"></a>UNIX：文件相关数据结构</h2><ul>
<li><p>每个进程在进程表都有成员变量 <code>file_struct *file</code> 指向文件描述符表</p>
<ul>
<li>进程表即 PCB进程控制块 <code>task_struct</code></li>
</ul>
</li>
<li><p>与每个fd相关联的是</p>
<ul>
<li>文件描述符标志</li>
<li>指向一个文件表项<code>（struct file&#123;&#125;）</code>的指针</li>
</ul>
</li>
<li><p>内核为所有打开文件维持一张文件表。每个文件表包含：</p>
<ul>
<li>文件状态标志<ul>
<li>读，写，添写，同步，非阻塞等</li>
</ul>
</li>
<li>当前文件偏移量</li>
<li>指向该文件v节点表项的指针</li>
</ul>
</li>
<li><p>每个<strong>打开</strong>文件都有一个<code>v</code>节点结构<code>v-node</code>。<code>v</code>节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，<code>v</code>节点还包含了i节点<code>（i-node）</code>。这些信息是在打开文件时从磁盘读入内存的。所以，文件的所有相关信息都是随时可用的。如，<code>i-node</code>包含了文件所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。</p>
</li>
<li><p>打开文件时的数据结构<br><img src="/2021/11/05/Linux-IO/2021-11-24-08-04-42.png"></p>
</li>
<li><p>注：Linux没有使用<code>v</code>节点。而是使用通用i节点结构。虽然实现略有不同，但在概念上<code>v</code>节点与<code>i</code>节点是一样的。两这都指向文件系统特有的<code>i</code>节点结构。</p>
</li>
</ul>
<p><img src="/2021/11/05/Linux-IO/2021-11-24-08-05-36.png"></p>
<ul>
<li>上图也说明了为什么多个进程可以打开同一文件：<ul>
<li>打开文件的每个进程都获得各自的一个文件表项，但对于给定的文件只有一个<code>v</code>节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使得每个进程都有它自己的对该文件的当前偏移量。</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/05/Linux-IO/2021-11-23-20-52-47.png"><br><img src="/2021/11/05/Linux-IO/2021-11-23-20-57-42.png"></p>
<ul>
<li>每个<code>i</code>节点中都有一个链接计数（对应<code>stat</code>结构中的<code>nlink_t</code>)，其值是指向该i节点的目录项。链接计数减少为0时，才可删除该文件，即释放该i节点指向的数据块。所以，删除目录项就做<code>unlink</code>而非<code>delete</code>。</li>
<li><code>i</code>节点中包含文件所有信息：文件类型，文件访问权限，文件长度，指向文件数据块的指针等。<code>stat</code>结构中大多信息来自i节点。只有文件名和i节点编号放在目录块中。<code>i</code>节点编号数据类型<code>：ino_t</code></li>
<li>为文件重命名时：文件内容并未移动，只要构造一个指向该文件的新目录项，并删除老目录项。</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li><code>stderr</code>是写到哪里？为什么和<code>stdout</code>一样也是显示在终端上？<ul>
<li>每当运行一个程序时，所有<code>shell</code>都为其打开三个文件描述符，即标准输入<code>STDIN_FILENO 0</code>，标准输出<code>STDOUT_FILENO 1</code> ，标准错误<code>STDERR_FILENO 2</code>。如果不做特殊处理，则这这3个文件描述符都连接到终端。</li>
</ul>
</li>
</ul>
<h2 id="一些IO函数"><a href="#一些IO函数" class="headerlink" title="一些IO函数"></a>一些IO函数</h2><h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a><code>lseek</code></h3><ul>
<li>文件空洞不要求在磁盘上占用存储区。但是如果在超出文件尾端时写了，就会占用。</li>
</ul>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a><code>unlink</code></h3><ul>
<li><code>int unlink (const char* pathname)</code></li>
<li>功能：删除目录块<code>dentry</code></li>
<li>当一个文件的硬链接计数减少至0时，该文件的数据块会被操作系统择机释放。</li>
<li>所以，我们删除文件，只是让文件具备了被释放的条件。</li>
<li><code>unlink</code>特征：解除对一个文件的链接时，如果文件的硬链接计数减小到0，无目录块dentry对应，但该文件i节点指向的数据块不会被立刻释放，而是等到所有打开该文件的进程关闭该文件，系统才会挑时间将他释放。</li>
</ul>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a><code>dup</code></h3><ul>
<li>保存文件描述符</li>
<li><code>int dup(int oldfd);</code><ul>
<li><code>oldfd：</code>已经打开的旧的描述符。</li>
<li><code>success: return a new fd</code>，新文件描述符指向旧文件描述符指向的文件。 </li>
<li>失败，-1 并设置 <code>errno</code></li>
</ul>
</li>
</ul>
<h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a><code>dup2</code></h3><ul>
<li>拷贝文件描述符，重定向文件描述符指向</li>
<li><code>int dup2(int oldfd,int newfd);</code><ul>
<li>将<code>oldfd</code>拷贝给<code>newfd</code>，使得下次操作<code>newfd</code>，实际上是对<code>oldfd</code>所指向的文件进行操作</li>
<li><code>success</code><ul>
<li><code>return a new fd</code>，如果oldfd有效，则返回的文件描述符与oldfd指向同一文件</li>
</ul>
</li>
<li><code>fail</code><ul>
<li><code>oldfd</code>无效，则失败，关闭<code>newfd</code>。返回-1，同时设置<code>errno</code>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="stat-lstat"><a href="#stat-lstat" class="headerlink" title="stat lstat"></a><code>stat lstat</code></h3><ul>
<li>查询文件信息，传入文件路径，信息保存在<code>struct stat</code>中传出</li>
<li><code>#include &lt;sys/stat.h&gt;</code></li>
<li><code>int stat(const char *filename,struct stat *statbuf)</code></li>
<li><code>int lstat(const char *filename,struct stat *statbuf)</code><ul>
<li><code>filename</code> ：文件路径+名称</li>
<li><strong><code>struct stat* statbuf</code>：结构体地址。文件信息将保存在这里。</strong></li>
<li>成功 <code>0</code> 失败 <code>-1</code></li>
<li><code>lstat</code>会获取软链接指向的文件的信息，<code>stat</code>会穿透软链接<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//      int fd = open(&quot;../rev.c&quot;,O_RDONLY|O_CREAT|O_TRUNC,0664);        //  有 则只读打开；没有，则以0664&amp;umask权限创建 </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span> </span><br><span class="line">        <span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>],&amp;sb);<span class="comment">// stat 穿透符号链接（软链接）lstat：不穿透符号链接 </span></span><br><span class="line">         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size = %ld\t&quot;</span>,sb.st_size); </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(sb.st_mode)) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a regular\n&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sb.st_mode)) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a directory\n&quot;</span>);    </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./stat_shc.out test01.txt</span><br><span class="line">size = <span class="number">0</span>	it<span class="number">&#x27;</span>s a regular</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./stat_shc.out ..</span><br><span class="line">size = <span class="number">4096</span>	it<span class="number">&#x27;</span>s a directory</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">stat</span> structure</span><br><span class="line">     All of these system calls <span class="built_in">return</span> a <span class="built_in">stat</span> structure, <span class="built_in">which</span> contains the following fields:</span><br><span class="line"></span><br><span class="line">         struct <span class="built_in">stat</span> &#123;</span><br><span class="line">             dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">             ino_t     st_ino;         /* Inode number */</span><br><span class="line">             mode_t    st_mode;        /* File <span class="built_in">type</span> and mode */</span><br><span class="line">             nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">             uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">             gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">             dev_t     st_rdev;        /* Device ID (<span class="keyword">if</span> special file) */</span><br><span class="line">             off_t     st_size;        /* Total size, <span class="keyword">in</span> bytes */</span><br><span class="line">             blksize_t st_blksize;     /* Block size <span class="keyword">for</span> filesystem I/O */</span><br><span class="line">             blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line"></span><br><span class="line">             /* Since Linux 2.6, the kernel supports nanosecond</span><br><span class="line">                precision <span class="keyword">for</span> the following timestamp fields.</span><br><span class="line">                For the details before Linux 2.6, see NOTES. */</span><br><span class="line"></span><br><span class="line">             struct timespec st_atim;  /* Time of last access */</span><br><span class="line">             struct timespec st_mtim;  /* Time of last modification */</span><br><span class="line">             struct timespec st_ctim;  /* Time of last status change */</span><br><span class="line"></span><br><span class="line">         <span class="comment">#define st_atime st_atim.tv_sec      /* Backward compatibility */</span></span><br><span class="line">         <span class="comment">#define st_mtime st_mtim.tv_sec</span></span><br><span class="line">         <span class="comment">#define st_ctime st_ctim.tv_sec</span></span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="模拟ls-l-fileName"><a href="#模拟ls-l-fileName" class="headerlink" title="模拟ls -l fileName"></a>模拟<code>ls -l fileName</code></h3><p><img src="/2021/11/05/Linux-IO/2021-11-24-08-45-45.png"></p>
<ul>
<li><p><strong><code>st_mode</code></strong></p>
<ul>
<li><p><strong><code>mode_t st_mode</code></strong>   —-&gt;  <strong><code>mode_t : unsigned int</code></strong></p>
</li>
<li><p><code>st_mode</code>中<code>[0,15]</code>位的二进制数起作用</p>
</li>
<li><p>如何求出文件类型 ?</p>
<ul>
<li><p><code>statbuf.st_mode &amp; S_IFMT</code><br>去除了<code>[11,0]</code>的表征其他性质的位(变成了<code>0</code>)<br>；将<code>[15,12]</code>位所有位为1的位都保留了下来。其他位都变成了<code>0</code></p>
</li>
<li><p>因此现在的<code>[15,0]</code>位所组成的值再与这些特征值比较 就可以得出该文件的类型（容易得知<code>[11,0]</code>一定均为<code>0</code>)<br><img src="/2021/11/05/Linux-IO/2021-11-24-09-04-54.png"></p>
</li>
<li><p>文件类型特征值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">S_IFSOCK 0140000 套接字</span><br><span class="line">S_IFLNK 0120000 符号链接（软链接）</span><br><span class="line">S_IFREG 0100000 普通文件</span><br><span class="line">S_IFBLK 0060000 块设备</span><br><span class="line">S_IFDIR 0040000 目录</span><br><span class="line">S_IFCHR 0020000 字符设备</span><br><span class="line">S_IFIFO 0010000 管道</span><br><span class="line">S_IFMT 0170000 掩码</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>权限特征值(<code>[9,0]</code>)</p>
<ul>
<li><code>usr</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S_IRUSR <span class="number">00400</span></span><br><span class="line">S_IWUSR <span class="number">00200</span></span><br><span class="line">S_IXUSR <span class="number">00100</span></span><br><span class="line">S_IRWXU <span class="number">00700</span></span><br></pre></td></tr></table></figure></li>
<li><code>group</code><ul>
<li>换成<code>S_I*GRP</code>即可</li>
</ul>
</li>
<li><code>other</code><ul>
<li>换成<code>S_I*OTH</code>即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>模拟代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/stat_learn$ gcc ls-l.c -o ls</span><br><span class="line">henry@henry:~/code/learn/stat_learn$ ./ls -l a.txt</span><br><span class="line">-rw-r--r-- 1d henry henry 10 Sat Oct 16 16:21:29 2021 a.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pwd.h&gt;</span>     <span class="comment">//  struct passwd *getpwuid(uid_t uid);     uid_t :unsigned int</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;grp.h&gt;</span>     <span class="comment">//  struct group *getgrgid(gid_t gid);</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mock ls -l filename</span></span><br><span class="line"><span class="comment">// ls -l a.txt</span></span><br><span class="line"><span class="comment">// -rw-r--r-- 1 henry henry 10 10月 16 16:21 a.txt</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argvs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  判断输入参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;=<span class="number">2</span>) <span class="comment">//argvs[0] : ./ls.out  ; argvs[1] : ./-l  ;  argvs[2] : File name at the same level</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s -l filename\n&quot;</span>,argvs[<span class="number">0</span>]);   <span class="comment">//  the name of ./ls.out + -l + filename</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取文件信息 文件信息存储在struct stat类型结构体 stub中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stb</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> res = stat(argvs[<span class="number">2</span>],&amp;stb);  <span class="comment">// argvs[1] </span></span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat get the information of the file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取文件类型 和 user group other的读写权限</span></span><br><span class="line">    <span class="comment">//  获取文件类型</span></span><br><span class="line">    <span class="keyword">char</span> info[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;     <span class="comment">// info : file class and the permissions</span></span><br><span class="line">    <span class="keyword">int</span> m = stb.st_mode &amp; S_IFMT;   </span><br><span class="line">    <span class="keyword">switch</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK:  <span class="comment">// IF : is file </span></span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取user group other的读写执行权限</span></span><br><span class="line">    <span class="comment">// USR : user</span></span><br><span class="line">    info[<span class="number">1</span>] = stb.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is read</span></span><br><span class="line">    info[<span class="number">2</span>] = stb.st_mode &amp; S_IWUSR ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is write</span></span><br><span class="line">    info[<span class="number">3</span>] = stb.st_mode &amp; S_IXUSR ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is x </span></span><br><span class="line">    <span class="comment">// info[3] = stb.st_mode &amp; S_IRWXU ? &#x27;1&#x27; : &#x27;0&#x27;;    // is read write x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GRP : group person</span></span><br><span class="line">    info[<span class="number">4</span>] = stb.st_mode &amp; S_IRGRP ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">5</span>] = stb.st_mode &amp; S_IWGRP ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">6</span>] = stb.st_mode &amp; S_IXGRP ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OTH : others </span></span><br><span class="line">    info[<span class="number">7</span>] = stb.st_mode &amp; S_IROTH ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">8</span>] = stb.st_mode &amp; S_IWOTH ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">9</span>] = stb.st_mode &amp; S_IXOTH ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  硬链接数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> linknum = stb.st_nlink;   <span class="comment">//  hard link</span></span><br><span class="line">    <span class="comment">//  user name</span></span><br><span class="line">    <span class="keyword">char</span> *fileUsr = getpwuid(stb.st_uid)-&gt;pw_name;    </span><br><span class="line">    <span class="comment">//  group name</span></span><br><span class="line">    <span class="keyword">char</span> *fileGrp = getgrgid(stb.st_gid)-&gt;gr_name;    </span><br><span class="line">    <span class="comment">//  文件大小</span></span><br><span class="line">    <span class="keyword">long</span> fileSize = stb.st_size;</span><br><span class="line">    <span class="comment">//  创建时间</span></span><br><span class="line">    <span class="comment">//  st_time:the time since 1970 ; ctime:convert the time to local time</span></span><br><span class="line">    <span class="keyword">char</span> *time = ctime(&amp;stb.st_mtime);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  去掉\n</span></span><br><span class="line">    <span class="keyword">char</span> time_buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//  strncpy不会自动补&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">strncpy</span>(time_buf,time,<span class="built_in">strlen</span>(time)<span class="number">-1</span>);  </span><br><span class="line">    time_buf[<span class="built_in">strlen</span>(time)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  sprintf写入buf</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s %lud %s %s %ld %s %s&quot;</span>,info,linknum,fileUsr,fileGrp,fileSize,time_buf,argvs[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- **`extern struct passwd *getpwuid(uid_t uid)`**</span></span><br><span class="line"><span class="comment">  - `uid_t uid`</span></span><br><span class="line"><span class="comment">    - `uid_t :unsigned int`</span></span><br><span class="line"><span class="comment">    - `uid: user id` </span></span><br><span class="line"><span class="comment">  - `passwd`</span></span><br><span class="line"><span class="comment">  The passwd structure.  </span></span><br><span class="line"><span class="comment">  struct passwd</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    char *pw_name;		/* Username.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_passwd;		<span class="comment">/* Password.  */</span></span><br><span class="line">    <span class="keyword">__uid_t</span> pw_uid;		<span class="comment">/* User ID.  */</span></span><br><span class="line">    <span class="keyword">__gid_t</span> pw_gid;		<span class="comment">/* Group ID.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_gecos;		<span class="comment">/* Real name.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_dir;			<span class="comment">/* Home directory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_shell;		<span class="comment">/* Shell program.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  - <span class="keyword">uid_t</span> uid从哪里来？</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stab</span></span></span><br><span class="line"><span class="class">      //   <span class="title">int</span> <span class="title">stat</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">pathname</span>, <span class="keyword">struct</span> <span class="title">stat</span> *<span class="title">statbuf</span>);</span></span><br><span class="line">  stat(文件名,stab);</span><br><span class="line">  <span class="comment">//stab.st_uid即为getpwuid所需要的参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> * <span class="title">pp</span> =</span> getpwuid(stab.st_uid);</span><br><span class="line">  <span class="keyword">char</span> * userName = pp -&gt; pw_name; </span><br><span class="line">  </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="manpage阅读"><a href="#manpage阅读" class="headerlink" title="manpage阅读"></a>manpage阅读</h2><ul>
<li><p><code>stat</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AME</span><br><span class="line">       <span class="built_in">stat</span>, fstat, lstat, fstatat - get file status</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line">       <span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line">       <span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">       int <span class="built_in">stat</span>(const char *pathname, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line">       int fstat(int fd, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line">       int lstat(const char *pathname, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line"></span><br><span class="line">       <span class="comment">#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */</span></span><br><span class="line">       <span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line">       int fstatat(int dirfd, const char *pathname, struct <span class="built_in">stat</span> *statbuf,</span><br><span class="line">                   int flags);</span><br><span class="line"></span><br><span class="line">   Feature Test Macro Requirements <span class="keyword">for</span> glibc (see feature_test_macros(7)):</span><br><span class="line"></span><br><span class="line">       lstat():</span><br><span class="line">           /* glibc 2.19 and earlier */ _BSD_SOURCE</span><br><span class="line">               || /* Since glibc 2.20 */ _DEFAULT_SOURCE</span><br><span class="line">               || _XOPEN_SOURCE &gt;= 500</span><br><span class="line">               || /* Since glibc 2.10: */ _POSIX_C_SOURCE &gt;= 200112L</span><br><span class="line"></span><br><span class="line">       fstatat():</span><br><span class="line">           Since glibc 2.10:</span><br><span class="line">               _POSIX_C_SOURCE &gt;= 200809L</span><br><span class="line">           Before glibc 2.10:</span><br><span class="line">               _ATFILE_SOURCE</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       These  <span class="built_in">functions</span>  <span class="built_in">return</span> information about a file, <span class="keyword">in</span> the buffer pointed to by statbuf.  No permissions are required on the file itself, but—<span class="keyword">in</span> the <span class="keyword">case</span> of <span class="built_in">stat</span>(), fstatat(), and lstat()—exe‐</span><br><span class="line">       cute (search) permission is required on all of the directories <span class="keyword">in</span> pathname that lead to the file.</span><br><span class="line"></span><br><span class="line">       <span class="built_in">stat</span>() and fstatat() retrieve information about the file pointed to by pathname; the differences <span class="keyword">for</span> fstatat() are described below.</span><br><span class="line"></span><br><span class="line">       lstat() is identical to <span class="built_in">stat</span>(), except that <span class="keyword">if</span> pathname is a symbolic link, <span class="keyword">then</span> it returns information about the link itself, not the file that it refers to.</span><br><span class="line"></span><br><span class="line">       fstat() is identical to <span class="built_in">stat</span>(), except that the file about <span class="built_in">which</span> information is to be retrieved is specified by the file descriptor fd.</span><br><span class="line">  The <span class="built_in">stat</span> structure</span><br><span class="line">       All of these system calls <span class="built_in">return</span> a <span class="built_in">stat</span> structure, <span class="built_in">which</span> contains the following fields:</span><br><span class="line"></span><br><span class="line">           struct <span class="built_in">stat</span> &#123;</span><br><span class="line">               dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">               ino_t     st_ino;         /* Inode number */</span><br><span class="line">               mode_t    st_mode;        /* File <span class="built_in">type</span> and mode */</span><br><span class="line">               nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">               uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">               gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">               dev_t     st_rdev;        /* Device ID (<span class="keyword">if</span> special file) */</span><br><span class="line">               off_t     st_size;        /* Total size, <span class="keyword">in</span> bytes */</span><br><span class="line">               blksize_t st_blksize;     /* Block size <span class="keyword">for</span> filesystem I/O */</span><br><span class="line">               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line"></span><br><span class="line">               /* Since Linux 2.6, the kernel supports nanosecond</span><br><span class="line">                  precision <span class="keyword">for</span> the following timestamp fields.</span><br><span class="line">                  For the details before Linux 2.6, see NOTES. */</span><br><span class="line"></span><br><span class="line">               struct timespec st_atim;  /* Time of last access */</span><br><span class="line">               struct timespec st_mtim;  /* Time of last modification */</span><br><span class="line">               struct timespec st_ctim;  /* Time of last status change */</span><br><span class="line"></span><br><span class="line">           <span class="comment">#define st_atime st_atim.tv_sec      /* Backward compatibility */</span></span><br><span class="line">           <span class="comment">#define st_mtime st_mtim.tv_sec</span></span><br><span class="line">           <span class="comment">#define st_ctime st_ctim.tv_sec</span></span><br><span class="line">           &#125;;</span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, zero is returned.  On error, -1 is returned, and errno is <span class="built_in">set</span> appropriately.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>unlink</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UNLINK(2)                                                                              Linux Programmer<span class="string">&#x27;s Manual                                                                             UNLINK(2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       unlink, unlinkat - delete a name and possibly the file it refers to</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int unlink(const char *pathname);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       #include &lt;fcntl.h&gt;           /* Definition of AT_* constants */</span></span><br><span class="line"><span class="string">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int unlinkat(int dirfd, const char *pathname, int flags);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       unlinkat():</span></span><br><span class="line"><span class="string">           Since glibc 2.10:</span></span><br><span class="line"><span class="string">               _POSIX_C_SOURCE &gt;= 200809L</span></span><br><span class="line"><span class="string">           Before glibc 2.10:</span></span><br><span class="line"><span class="string">               _ATFILE_SOURCE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">       unlink()  deletes  a  name from the filesystem.  If that name was the last link to a file and no processes have the file open, the file is deleted and the space it was using is made available</span></span><br><span class="line"><span class="string">       for reuse.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name was the last link to a file but any processes still have the file open, the file will remain in existence until the last file descriptor referring to it is closed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name referred to a symbolic link, the link is removed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name referred to a socket, FIFO, or device, the name for it is removed but processes which have the object open may continue to use it.</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-进程(1)</title>
    <url>/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>Linux进程</p>
<span id="more"></span>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ul>
<li>每个进程都会对应虚拟一个<strong>虚拟地址空间</strong><ul>
<li><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-11-45.png"></li>
</ul>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>程序<ul>
<li>编译好的二进制文件</li>
<li>死的，只占用磁盘空间</li>
</ul>
</li>
<li>进程<ul>
<li>活的，运行的程序，占用内存，cpu的系统资源。</li>
</ul>
</li>
<li>并发<code>(concurrency)</code><ul>
<li>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上（用户感觉）具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
</li>
<li>并行<code>(parallel)</code><ul>
<li>指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-25-21-10-16.png"></li>
</ul>
</li>
<li>单道程序设计<ul>
<li>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上极其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</li>
</ul>
</li>
<li>多道程序设计<ul>
<li>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</li>
<li>时钟中断即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</li>
<li>在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li>
<li>实质上，并发是宏观并行，微观串行。</li>
</ul>
</li>
<li><code>cpu</code><ul>
<li>预读器</li>
<li>译码器</li>
<li>算术逻辑单元</li>
<li><code>MMU</code><ul>
<li>虚拟物理内存映射</li>
<li><code>page 4K??</code></li>
<li>设置内存访问级别</li>
</ul>
</li>
</ul>
</li>
<li><code>PCB</code>进程控制块<ul>
<li>每个进程在<code>kernal</code>中都有一个进程控制块<code>PCB</code>来维护进程相关的信息。<code>Linux</code>的进程控制块是<code>struct task_struct</code>结构体</li>
<li><code>struct task_struct</code>主要内容<ul>
<li>**.<code>pid</code>.**：即进程<code>id</code>。类型为<code>C</code>中的<code>pid_t</code></li>
<li><strong>进程状态</strong>：就绪，运行，挂起（阻塞），停止</li>
<li>进程切换时需要保存和恢复一些cpu寄存器</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端信息</li>
<li><strong>当前目录位置</strong>（不同目录下（shell进程的目录位置不同）的ls结果不同）</li>
<li>umask掩码<ul>
<li>不同进程不同</li>
</ul>
</li>
<li><strong>文件描述表</strong>，包括很多指向file结构体的指针</li>
<li><strong>信号</strong>相关的信息</li>
<li><strong>用户id，组id</strong></li>
<li>会话和进程组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul>
<li>操作系统中用来指定运行环境的一些参数</li>
<li>是跟着进程走的<ul>
<li>本质：字符串</li>
<li>有统一格式：<code>name=value</code></li>
<li>值用来描述进程环境信息 </li>
</ul>
</li>
<li>常用<ul>
<li>PATH<ul>
<li>可执行文件搜索路径</li>
</ul>
</li>
<li>SHELL<ul>
<li>指定当前所使用的命令解析器</li>
</ul>
</li>
<li>TERM<ul>
<li>当前终端类型</li>
</ul>
</li>
<li>HOME<ul>
<li>用户主目录</li>
</ul>
</li>
</ul>
</li>
<li>存储形式<ul>
<li><code>extern char **environ</code></li>
<li>字符指针数组</li>
<li><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-10-45-58.png"></li>
</ul>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="pid-t-fork-void"><a href="#pid-t-fork-void" class="headerlink" title="pid_t fork(void);"></a><code>pid_t fork(void);</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>#include&lt;sys/types.h&gt;</code></li>
<li><code>#include&lt;unistd.h&gt;</code></li>
<li>创建子进程<ul>
<li>父子进程内容相同（用户区和内核区）相互独立</li>
<li><code>fork</code>在父进程返回一次<code>pid_t</code> ，在子进程返回一次<code>pid_t</code></li>
<li>成功：父进程返回子进程<code>pid_t</code>，子进程返回0</li>
<li>失败：父进程返回-1</li>
</ul>
</li>
<li>父子进程之间的关系：<ul>
<li>区别：<ul>
<li>fork函数的返回值</li>
<li>pcb进程控制块中的数据</li>
<li>进程创建时间</li>
<li>当前进程的<code>id，pid</code></li>
<li>当前进程的父进程的<code>id pid</code></li>
<li>信号集</li>
</ul>
</li>
<li>共同点<ul>
<li>data段，text段，堆，栈，环境变量，全局变量，宿主目录位置，进程工作目录位置，信号处理方式</li>
</ul>
</li>
<li>不同点<ul>
<li>进程<code>id</code>、返回值、各自的父进程、进程创建时间、闹钟、未决信号集。</li>
</ul>
</li>
<li>父子进程共享<ul>
<li><code>mmap</code>映射区(都有什么。。。)</li>
<li>文件描述符（打开的文件结构体）</li>
</ul>
</li>
</ul>
</li>
<li>特别的，<code>fork</code>之后父进程先执行还是子进程先执行不确定，取决于内核所使用的调度算法</li>
</ul>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a><strong>写时拷贝</strong></h3><ul>
<li><strong>读时共享，写时复制</strong></li>
</ul>
<h3 id="pid-t-getpid-void"><a href="#pid-t-getpid-void" class="headerlink" title="pid_t getpid(void)"></a><code>pid_t getpid(void)</code></h3><ul>
<li>返回当前进程<code>id</code></li>
</ul>
<h3 id="pid-t-getppid-void"><a href="#pid-t-getppid-void" class="headerlink" title="pid_t getppid(void)"></a><code>pid_t getppid(void)</code></h3><ul>
<li>返回父进程<code>id</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">// 实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">// 写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">// 内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">// 只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">// 也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">// 注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">// fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">// */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="争夺cpu模型"><a href="#争夺cpu模型" class="headerlink" title="争夺cpu模型"></a>争夺cpu模型</h3><p><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-16-46.png"><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-17-05.png"><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-19-52.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i!=<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent process id = %d\tthe parent parent process id = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process id = %d\tthe parent process id = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./fork_shc.out </span><br><span class="line">child process id = <span class="number">3221</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">child process id = <span class="number">3220</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">parent process id = <span class="number">3219</span>	the parent parent process id = <span class="number">2852</span></span><br><span class="line">child process id = <span class="number">3222</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">child process id = <span class="number">3223</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ child process id = <span class="number">3224</span>	the parent process id = <span class="number">2344</span></span><br></pre></td></tr></table></figure>


<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><ul>
<li><code>exec</code> 让子进程去执行其他程序</li>
<li><code>a./out</code>的父进程是<code>bash</code> 那么<code>bash</code>是如何做到开辟一个子进程去执行我们写的代码？就是用<code>exec</code>函数族</li>
<li><code>exec</code> 函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通<br>常我们直接在 <code>exec</code> 函数调用后直接调用 <code>perror()</code>和 <code>exit()</code>，无需 <code>if</code> 判断</li>
<li>调用<code>exec</code>并不创建新进程，所以前后的进程ID并未改变，<code>exec</code>只是用磁盘山东个一个新程序代替了当前进程的正文段，数据段，堆段，和栈段。</li>
<li>调用系统提供的，用<code>execlp</code></li>
<li>调用自己写的，用<code>execl</code><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-59-37.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">l (list) 命令行参数列表</span></span><br><span class="line"><span class="comment">p (path) 搜素 file 时使用 path 变量</span></span><br><span class="line"><span class="comment">v (vector) 使用命令行参数数组</span></span><br><span class="line"><span class="comment">e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运</span></span><br><span class="line"><span class="comment">行的环境变量</span></span><br><span class="line"><span class="comment">事实上，只有 execve 是真正的系统调用，其它五个函数最终都调用 execve，所以 execve</span></span><br><span class="line"><span class="comment">在 man 手册第 2 节，其它函数在 man 手册第 3 节。这些函数之间的关系如下图所示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="execl-const-char-path-const-char-arg"><a href="#execl-const-char-path-const-char-arg" class="headerlink" title="execl(const char *path,const char *arg, ...)"></a><code>execl(const char *path,const char *arg, ...)</code></h3><ul>
<li>第一个参数是：可执行文件的路径；</li>
<li>第二个参数是：可执行程序的程序名，</li>
<li>其余参数是命令函的参数，通常最后一个参数是一个空指针NULL(用来表示命令行数组的结尾).<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>) <span class="comment">//  父进程 调用fork失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)  <span class="comment">//  父进程调用fork成功 返回子进程pid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process , pid = %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-a&quot;,&quot;-h&quot;,&quot;-l&quot;,NULL);</span></span><br><span class="line">        <span class="comment">// execlp(&quot;date&quot;,&quot;date&quot;,NULL);</span></span><br><span class="line">        <span class="comment">// execl(&quot;./a.out&quot;,&quot;./a.out&quot;,NULL);</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>没加<code>sleep(1)</code>有可能会发生如下</li>
<li>本进程的子进程没有抢过本进程，本进程<code>(printf i am parent)</code>结束后（即该段程序变成的进程结束后），父进程<code>bash</code>先抢夺到<code>cpu</code>，先执行出<code>henry@henry:~/code/learn/exec_learn$</code>，然后再到<code>child process</code>执行<code>ls</code><ul>
<li>父进程结束后，<code>bash</code>就会去回收这个父进程<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/exec_learn$ gcc fork_exec.c -o fork_exec.out</span><br><span class="line">henry@henry:~/code/learn/exec_learn$ ./fork_exec.out </span><br><span class="line">i am parent process , pid = 3389</span><br><span class="line">henry@henry:~/code/learn/exec_learn$ 总用量 24K</span><br><span class="line">drwxrwxr-x 2 henry henry 4.0K 10月 20 12:23 .</span><br><span class="line">drwxr-xr-x 7 henry henry 4.0K 10月 20 12:16 ..</span><br><span class="line">-rw-rw-r-- 1 henry henry  424 10月 20 12:23 fork_exec.c</span><br><span class="line">-rwxrwxr-x 1 henry henry 8.4K 10月 20 12:23 fork_exec.out</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>加上<code>sleep(1)</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/exec_learn$ ./fork_exec.out </span><br><span class="line">总用量 24K</span><br><span class="line">drwxrwxr-x 2 henry henry 4.0K 10月 20 12:22 .</span><br><span class="line">drwxr-xr-x 7 henry henry 4.0K 10月 20 12:16 ..</span><br><span class="line">-rw-rw-r-- 1 henry henry  424 10月 20 12:23 fork_exec.c</span><br><span class="line">-rwxrwxr-x 1 henry henry 8.5K 10月 20 12:22 fork_exec.out</span><br><span class="line">i am parent process , pid = 3370</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><ul>
<li>父进程先终止，其子进程被送进<code>init</code>孤儿院</li>
<li>在一个进程终止时，内核逐渐检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程<code>ID</code>就更改为<code>1</code>（<code>init</code>的<code>pid</code>）。这种方法保证了每个进程有一个父进程</li>
</ul>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><ul>
<li>一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）。<ul>
<li>进程终止</li>
<li>内核区中残留着PCB</li>
<li>父进程没有回收这个子进程</li>
</ul>
</li>
<li><code>ps</code>中僵尸进程打印为<code>z</code></li>
<li>解决方法：<code>wait</code>而非<code>kill</code>，因为此进程已经死了。<ul>
<li><code>wait</code>回收的是内核区残留的东西而不是用户区的东西，用户区的东西在进程终止时就被释放。</li>
</ul>
</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li>一个由<code>init</code>收养的进程终止时是否会变成一个僵尸进程？<ul>
<li>不会。<code>init</code>被编写成，无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数取得其终止状态，这样也就防止了系统中塞满僵尸进程的情况。</li>
</ul>
</li>
<li><code>init的子进程</code><ul>
<li><code>init</code>产生的</li>
<li><code>init</code>收养的。</li>
</ul>
</li>
</ul>
<h2 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait/waitpid"></a><code>wait/waitpid</code></h2><h3 id="pid-t-wait-int-statloc"><a href="#pid-t-wait-int-statloc" class="headerlink" title="pid_t wait(int *statloc);"></a><code>pid_t wait(int *statloc);</code></h3><blockquote>
<p>一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的 PCB<br>还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终<br>止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用 wait 或 waitpid 获取<br>这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在 Shell 中用特殊<br>变量$?查看，因为 Shell 是它的父进程，当它终止时 Shell 调用 wait 或 waitpid 得到它的退出<br>状态同时彻底清除掉这个进程。      —黑马Linux讲义</p>
</blockquote>
<ul>
<li><code>wait</code>函数作用<ul>
<li>阻塞等待子进程退出</li>
<li>回收子进程残留资源</li>
<li>获取子进程结束状态(退出原因)。</li>
</ul>
</li>
<li><code>waitpid</code>相较于<code>wait</code>可以选择是否阻塞，以及回收特定的某一个子进程</li>
<li>一次 <code>wait</code> 或 <code>waitpid</code> 调用只能清理一个子进程</li>
</ul>
<blockquote>
<p>当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间<br>分配的内存。内核的 PCB 仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常<br>终止→终止信号)    —黑马Linux讲义</p>
</blockquote>
<ul>
<li><p><code>return</code></p>
<ul>
<li>成功回收：返回回收的进程的<code>pid</code>号</li>
<li>出错：调用<code>wait</code>的当前进程并没有任何子进程。则返回<code>-1</code>。</li>
</ul>
</li>
<li><p>宏函数判断终止原因。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WIFEXITED（status）宏判断为真 表示程序正常退出</span><br><span class="line">WEXITSTATUS(status)上一个宏判断为真 则返回状态值</span><br><span class="line">WIFSIGNALED(status) 宏判断为真 表示程序异常退出</span><br><span class="line">WTERMSIG(status) 上一个判断为真，则返回状态值</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">pid_t</span> target_pid;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">                                target_pid = pid; <span class="comment">//  注意用pid 不是getpid()</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">int</span> statloc;    <span class="comment">//  接收进程退出状态</span></span><br><span class="line">                <span class="keyword">pid_t</span> wpid = waitpid(target_pid,&amp;statloc,<span class="number">0</span>);    <span class="comment">//  阻塞回收 成功：返回进程id，错误：返回-1（一般是子进程不存在）</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;i am the parent process , wait for the child process id = %d\n&quot;</span>,wpid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;i am the child process id = %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./waitpid_shc.out </span><br><span class="line">i am the child process id = <span class="number">4306</span></span><br><span class="line">i am the child process id = <span class="number">4307</span></span><br><span class="line">i am the child process id = <span class="number">4309</span></span><br><span class="line">i am the child process id = <span class="number">4310</span></span><br><span class="line">i am the child process id = <span class="number">4308</span></span><br><span class="line">i am the parent process , wait <span class="keyword">for</span> the child process id = <span class="number">4308</span>  <span class="comment">//  回收i=2进程</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pid-t-waitpid-pid-t-pid-int-statloc-int-options"><a href="#pid-t-waitpid-pid-t-pid-int-statloc-int-options" class="headerlink" title="pid_t waitpid(pid_t pid,int *statloc,int options);"></a><code>pid_t waitpid(pid_t pid,int *statloc,int options);</code></h3><ul>
<li><p>传入参数</p>
<ul>
<li><code>pid_t pid</code><ul>
<li><code>&gt;0 </code>指定进程号</li>
<li><code>=-1</code> 回收任意子进程，相当于<code>wait</code>。<code>waitpid(-1,&amp;status,0) &lt;-&gt; wait(&amp;status);</code></li>
<li><code>=0</code> 回收和当前调用waitpid的进程的一个组的所有子进程（一般同一进程fork出的子进程默认同一组）</li>
<li><code>&lt;-1</code> 回收指定进程组的任意子进程</li>
</ul>
</li>
<li><code>int *statloc</code><ul>
<li>保存退出状态</li>
</ul>
</li>
<li><code>options</code><ul>
<li><code>WNOHANG</code> 非阻塞</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><p><code>return</code></p>
<ul>
<li>成功回收：返回回收的进程的<code>pid</code>号</li>
<li>出错：调用<code>waitpid</code>的当前进程并没有任何子进程。则返回<code>-1</code>。</li>
<li>如果使用了<code>WNOHANG</code>非阻塞参数，且没有子进程已经终止、可以回收，那么就返回<code>0</code>.</li>
</ul>
</li>
<li><p>回收指定进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> target_pid;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">			sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">				target_pid = pid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> statloc;	<span class="comment">//  接收进程退出状态</span></span><br><span class="line">		<span class="keyword">pid_t</span> wpid = waitpid(target_pid,&amp;statloc,<span class="number">0</span>);	<span class="comment">//  阻塞回收 成功：返回进程id，错误：返回-1（一般是子进程不存在）</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			sys_err(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;i am the parent process , wait for the child process id = %d\n&quot;</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am the child process id = %d\n&quot;</span>,getpid());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i am the child process id = <span class="number">4538</span></span><br><span class="line">i am the child process id = <span class="number">4539</span></span><br><span class="line">i am the child process id = <span class="number">4541</span></span><br><span class="line">i am the child process id = <span class="number">4540</span></span><br><span class="line">i am the child process id = <span class="number">4542</span></span><br><span class="line">i am the parent process , wait <span class="keyword">for</span> the child process id = <span class="number">4540</span></span><br></pre></td></tr></table></figure></li>
<li><p>回收所有进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> wpid  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// while((wpid=waitpid(-1,NULL,0)!=-1))</span></span><br><span class="line">                <span class="comment">//         printf(&quot;i wait the child id = %d hhhh\n&quot;,wpid);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//  这样循环使用WNOHANG 的 waitpid的效果和上面直接使用 阻塞的 waitpid的效果一样（我认为）</span></span><br><span class="line">               <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))!=<span class="number">-1</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                        <span class="comment">//  非阻塞 且没有结束的子进程时 返回0</span></span><br><span class="line">                        <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;i wait the child id = %d\n&quot;</span>,wpid);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                usleep(<span class="number">1</span>);      <span class="comment">//  父进程睡眠 让出cpu  </span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; parent die\n &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;i am the %d th child process id = %d\n&quot;</span>,i,getpid());</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// i am the 0 th child process id = 4407</span></span><br><span class="line"><span class="comment">// i am the 1 th child process id = 4408</span></span><br><span class="line"><span class="comment">// i am the 3 th child process id = 4410</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i am the 2 th child process id = 4409</span></span><br><span class="line"><span class="comment">// i am the 4 th child process id = 4411</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">//  parent die</span></span><br><span class="line"></span><br><span class="line">i am the <span class="number">1</span> th child process id = <span class="number">4381</span></span><br><span class="line">i am the <span class="number">0</span> th child process id = <span class="number">4380</span></span><br><span class="line">i am the <span class="number">3</span> th child process id = <span class="number">4383</span></span><br><span class="line">i wait the child id = <span class="number">4380</span></span><br><span class="line">i wait the child id = <span class="number">4381</span></span><br><span class="line">i am the <span class="number">2</span> th child process id = <span class="number">4382</span></span><br><span class="line">i am the <span class="number">4</span> th child process id = <span class="number">4384</span></span><br><span class="line">i wait the child id = <span class="number">4382</span></span><br><span class="line">i wait the child id = <span class="number">4383</span></span><br><span class="line">i wait the child id = <span class="number">4384</span></span><br><span class="line"> parent die</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-进程2</title>
    <url>/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/</url>
    <content><![CDATA[<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><ul>
<li>半双工<ul>
<li>半双工通信是指可以双向流动，但不能同时。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Linux命令常识</title>
    <url>/2021/11/05/Linux%E5%91%BD%E4%BB%A4%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<ul>
<li><code>od -c 文件</code><ul>
<li><code>od</code> 观察文件实际内容</li>
<li><code>-c</code>以字符方式打印文件内容</li>
</ul>
</li>
<li><code>ln -s</code><ul>
<li>创建软链接，又称符号链接。建议采用绝对路径。</li>
<li><code>shc@shc-virtual-machine:~/code/revier$ ln -s test02.txt ./soft_test02</code></li>
</ul>
</li>
<li><code>ln</code> <ul>
<li>创建硬链接。</li>
<li><code>shc@shc-virtual-machine:~/code/revier$ ln test01.txt ./test01_hard</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ReStart</title>
    <url>/2021/11/04/ReStart/</url>
    <content><![CDATA[<p><img src="/2021/11/04/ReStart/2021-11-04-22-11-58.png"></p>
<h1 id="重新搭建的小窝"><a href="#重新搭建的小窝" class="headerlink" title="重新搭建的小窝"></a>重新搭建的小窝</h1><ul>
<li><code>Dell</code>的硬盘坏掉了，来来回回修了快一个月</li>
<li>什么环境都没得了，幸好笔记还都在</li>
<li>虽然怕麻烦，不过重建一个自己的新窝还是很开心的。</li>
<li>继续记录吧。</li>
</ul>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
<span id="more"></span>

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/11/04/test/</url>
    <content><![CDATA[<p>这是摘要</p>
<span id="more"></span>
<p>以下是正文</p>
<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><p>1</p>
<h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><p>1.1</p>
<h3 id="子子标题1"><a href="#子子标题1" class="headerlink" title="子子标题1"></a>子子标题1</h3><p>1.1.1</p>
<h1 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h1><p>2</p>
<h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><p>2.2</p>
<h3 id="子子标题2"><a href="#子子标题2" class="headerlink" title="子子标题2"></a>子子标题2</h3><p>2.2.2</p>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/14/static-library-And-shared-object/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>test02</title>
    <url>/2021/11/04/test02/</url>
    <content><![CDATA[<p>如何插入图片</p>
<span id="more"></span>
<p><img src="/2021/11/04/test02/2021-11-04-21-26-16.png"></p>
<h1 id="如何插入图片"><a href="#如何插入图片" class="headerlink" title="如何插入图片"></a>如何插入图片</h1><ul>
<li>过程<ul>
<li><code>hexo new xxx</code><ul>
<li>会生成一个同名文件夹</li>
</ul>
</li>
<li><code>ctrl + alt + v</code>  <ul>
<li>图片会自动到同名文件夹下。</li>
</ul>
</li>
</ul>
</li>
<li>有用插件 <ul>
<li><code>hexo-asset-image</code></li>
<li><code>hexo-renderer-ejs</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
</search>
