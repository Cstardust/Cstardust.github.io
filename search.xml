<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUG</title>
    <url>/2021/09/04/C-Bug/</url>
    <content><![CDATA[<h1 id="BUG-小白的锌酸历程"><a href="#BUG-小白的锌酸历程" class="headerlink" title="BUG (小白的锌酸历程)"></a><strong>BUG (小白的锌酸历程)</strong></h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a><strong>1</strong></h2><ul>
<li><code>.h</code>头文件上来记得加<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> xxx  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxx </span></span><br><span class="line">..... </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-0-multiple-definition-redefinition-xxx-already-defined-in-adsasd-obj"><a href="#2-0-multiple-definition-redefinition-xxx-already-defined-in-adsasd-obj" class="headerlink" title="2.0  multiple definition / redefinition / xxx already defined in adsasd.obj"></a><strong>2.0  multiple definition / redefinition / xxx already defined in adsasd.obj</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;c.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;c.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>&gt;c.obj : error LNK2005: <span class="string">&quot;void __cdecl func1(void)&quot;</span> (?func1@@YAXXZ) already defined in a.obj</span><br><span class="line"><span class="number">1</span>&gt;C:\Users\de<span class="number">&#x27;l</span><span class="number">&#x27;l</span>\VSProjects\MistakeTry\Debug\MistakeTry.exe : fatal error LNK1169: one <span class="keyword">or</span> more multiply defined symbols found</span><br><span class="line"><span class="number">1</span>&gt;Done building project <span class="string">&quot;MistakeTry.vcxproj&quot;</span> -- FAILED.</span><br></pre></td></tr></table></figure>
<ul>
<li>养成<strong>不要在头<code>.h</code>文件中定义非类成员函数以及非内联函数</strong>的习惯。</li>
<li>养成<strong>在类相应源<code>.cpp</code>文件中定义函数</strong>的习惯</li>
<li>非类的成员函数的定义尽量放在<code>.cpp</code>文件中<ul>
<li>因为c++采用单独编译，就是将每个<code>.cpp</code>文件编译成对应的<code>.o</code>文件，最后链接器再将多个<code>.obj</code>文件链接成可执行程序。</li>
<li>所以本例，从各个<code>cpp</code>文件看，编译成.o文件时没有任何问题（在main中也没有问题，因为有<code>#pargma once </code>,<code>a.h</code>只会在<code>main</code>中<code>include</code>一次，但是在<code>c.cpp</code>和<code>a.cpp</code>和文件中都<code>include</code>了<code>a.h</code>文件</li>
<li>(宏的定义域只局限于一个文件) </li>
<li>而<code>a.h</code>文件中又定义了<code>print</code>函数，即与预处理过后，在c和a源文件中都定义了<code>print</code>函数，重复定义，即会有<code>one or more multiply defined symbols found</code>或者 <code>....already defined in ..obj</code>的错误</li>
</ul>
</li>
<li>有人可能会问，既然是从同一份文件<code>include</code>过来的函数<code>hhh()</code>，那么定义都是同一份，为什么编译器不会智能的处理一下，让链接时候不报错呢？<ul>
<li>其实编译器链接的时候，并不知道<code>b.cpp</code>中定义的<code>hhh</code>与<code>c.cpp</code>中定义的<code>hhh</code>是同一个文件<code>include</code>过来的，它只会认为如果有两份定义，而且这两份定义如果实现不同，那么到底以哪个为准呢？既然决定不了，那就干脆报错好了。</li>
<li>这段引自博客,链接我真没找到。。</li>
</ul>
</li>
</ul>
<h3 id="例外"><a href="#例外" class="headerlink" title="例外"></a><strong>例外</strong></h3><ul>
<li><strong><code>inline</code></strong> 函数定义在头文件中<ul>
<li>C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个<code>cpp</code>中只出现一次就行。</li>
</ul>
</li>
<li><strong><code>class</code></strong> 成员函数可在头文件中定义</li>
<li><a href="https://jiadebin.github.io/2017/04/03/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84multiple-definition/">参考 感谢作者</a></li>
</ul>
<h2 id="2-1-inline函数要定义在头文件内。"><a href="#2-1-inline函数要定义在头文件内。" class="headerlink" title="2.1 inline函数要定义在头文件内。"></a><strong>2.1 <code>inline</code>函数要定义在头文件内。</strong></h2><ul>
<li>若定义在<code>.cpp</code>文件则会<ul>
<li><strong><code>undefined reference to &#39;CScene::CScene()&#39;</code></strong></li>
<li><strong><code>main.obj : error LNK2019: unresolved external symbol &quot;public: __thiscall CScene::CScene(void)&quot; (??0CScene@@QAE@XZ) referenced in function _main</code></strong></li>
</ul>
</li>
<li><ol>
<li>大多数环境在编译期间进行<code>inline</code>，而为了将一个<code>函数调用</code>替换为<code>被调用的函数的本体</code>，编译器必须知道那个函数长什么样子。</li>
</ol>
</li>
<li><ol start="2">
<li>与非<code>inline</code>函数不同，<code>inline</code>函数必须在调用该函数的每个文件中定义。（为了完成上一句话的要求）</li>
</ol>
</li>
<li><ol start="3">
<li>对于同一程序的不同文件，同一<code>inline</code>函数的定义应当相同。</li>
</ol>
</li>
<li>因此，<strong>应把<code>inline</code>函数的定义放入头文件</strong>，在<strong>每个</strong>调用了该<code>inline</code>函数的地方<code>include</code>该头文件 （为了完成2），这种方法*<strong>保证了每个<code>inline</code>函数只有一个定义</strong>，且程序员无需复制代码，并且不可能在程序的生命周期引起无意不匹配的事情。</li>
</ul>
<h3 id="问题：会不会出现编译器没有把我们在-h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple-definition的情况？"><a href="#问题：会不会出现编译器没有把我们在-h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple-definition的情况？" class="headerlink" title="问题：会不会出现编译器没有把我们在.h文件中定义的内联函数当作inline函数，而我们又到处include，造成multiple definition的情况？"></a>问题：会不会出现编译器没有把我们在<code>.h</code>文件中定义的内联函数当作<code>inline</code>函数，而我们又到处<code>include</code>，造成<code>multiple definition</code>的情况？</h3><ul>
<li>qs是出现了。。。。md。。。。我的解决方法：<ul>
<li>直接在那个<code>.h</code>文件的类内定义该成员函数</li>
<li>或者取消把他内联的想法。交给编译器，听他的。</li>
</ul>
</li>
</ul>
<h2 id="3-相互包含头文件"><a href="#3-相互包含头文件" class="headerlink" title="3.  相互包含头文件"></a><strong>3.  相互包含头文件</strong></h2><ul>
<li>两个头文件相互包含</li>
<li>若在B的头文件中：<ul>
<li><ol>
<li><strong>使用<code>A对象</code>或<code>A对象</code>作为返回值的则要<code>include A.h</code></strong></li>
</ol>
</li>
<li><ol start="2">
<li><strong>使用<code>A类型</code>作为指针则在定义<code>A*</code>前声明<code>class A</code>即可</strong></li>
</ol>
</li>
<li>另外，若为<strong>情况2</strong>，<strong>则在<code>B.cpp</code>文件中，为了使用A类的成员函数，则要<code>include A.h</code></strong></li>
<li><ol start="3">
<li>两个类中互相使用了对方的指针，这样的情况很简单，分别在各自的头文件中声明一下使用的类，而在各自的源文件中包含对方的头文件即可。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-There-is-no-matching-member-for-call-to-‘find’"><a href="#4-There-is-no-matching-member-for-call-to-‘find’" class="headerlink" title="4. There is no matching member for call to ‘find’"></a><strong>4. There is no matching member for call to ‘find’</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; m = &#123;&#123;<span class="string">&quot;I&quot;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&quot;IV&quot;</span>,<span class="number">4</span>&#125;,&#123;<span class="string">&quot;V&quot;</span>,<span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;IX&quot;</span>,<span class="number">9</span>&#125;,&#123;<span class="string">&quot;X&quot;</span>,<span class="number">10</span>&#125;,&#123;<span class="string">&quot;XL&quot;</span>,<span class="number">40</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;L&quot;</span>,<span class="number">50</span>&#125;,&#123;<span class="string">&quot;XC&quot;</span>,<span class="number">90</span>&#125;,&#123;<span class="string">&quot;C&quot;</span>,<span class="number">100</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;CD&quot;</span>,<span class="number">400</span>&#125;,&#123;<span class="string">&quot;D&quot;</span>,<span class="number">500</span>&#125;,&#123;<span class="string">&quot;CM&quot;</span>,<span class="number">900</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;M&quot;</span>,<span class="number">1000</span>&#125;&#125;;</span><br><span class="line">string s = <span class="string">&quot;MCD&quot;</span>;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; ::iterator iter = m.<span class="built_in">find</span>(s[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(iter!=s.<span class="built_in">end</span>()) ...  </span><br></pre></td></tr></table></figure>
<p><code>There is no matching member for call to &#39;find&#39;</code></p>
<ul>
<li><strong>原因</strong><ul>
<li><code>unordered_map&lt;string,int&gt;</code>的<code>key type</code>是 <code>std::string</code>,但是我们传入的是一个字符<code>char</code>给<code>find()</code>函数.<code>std::string</code>没有一个可以接收一个<code>char</code>的<code>constructor</code>.因此<code>error</code>.</li>
</ul>
</li>
<li><strong>解决</strong><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m.<span class="built_in">find</span>(&#123;s[<span class="number">0</span>]&#125;);</span><br><span class="line">m.<span class="built_in">find</span>(<span class="built_in">string</span>()+s[<span class="number">0</span>]); <span class="comment">//一个string型字符串和一个char相加,会将char先转化为string,再相加</span></span><br><span class="line">m.<span class="built_in">find</span>(<span class="built_in">string</span>(<span class="number">1</span>,s[<span class="number">0</span>]));<span class="comment">//string构造函数 string(n,char);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-关于（几乎就是不可以）返回局部变量的引用"><a href="#5-关于（几乎就是不可以）返回局部变量的引用" class="headerlink" title="5. 关于（几乎就是不可以）返回局部变量的引用"></a><strong>5. 关于（几乎就是不可以）返回局部变量的引用</strong></h2><ul>
<li>函数<strong>返回local variable引用</strong>（<strong>无论是否是常量引用</strong>）是<strong>不可以</strong>的。(条件是函数调用处并<strong>没有用常量引用来接收</strong>)<ul>
<li>理解：编译器根据 <code>local</code> 变量造了一个<code>const</code>局部临时量 让<code>const</code>引用绑定在这个临时变量上，<strong>可这个变量还是一个局部变量</strong>。函数结束这个局部的临时量时该销毁还是销毁了。</li>
</ul>
</li>
<li>对于函数中的一个变量，如果<strong>不是局部变量</strong>，而是函数传参传入的一个引用，那么返回时当然<strong>可以</strong>返回该变量的引用（无论是否常），因为这个变量在函数结束时并不会被销毁。</li>
<li>图片来自<a href="https://blog.csdn.net/u012814856/article/details/84099328">博客</a><br><img src="/2021/09/04/C-Bug/2021-11-24-09-12-38.png"></li>
</ul>
<h4 id="特例"><a href="#特例" class="headerlink" title="特例"></a><strong>特例</strong></h4><ul>
<li><del>如果在函数调用处使用了const引用来接收返回的引用/常量引用，那么是ok的</del>。</li>
<li>经实验，没有特例，无论是不是用常量引用接收，就是不能返回局部变量的常引。如果是一些容器类的话，可能不止是警告，还有编译error。</li>
<li>如果返回一个值的话，函数调用处用一个<code>const</code>引用接收当然可以延长生命周期。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> jj02 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; c = <span class="built_in">func1</span>(a, b);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; d = <span class="built_in">func2</span>(a, b);</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>&amp; e = <span class="built_in">func1</span>(a, b);</span><br><span class="line">		cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jj02::<span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>运行结果<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6492220</span><br><span class="line">6509462</span><br><span class="line">6492220</span><br><span class="line"></span><br><span class="line">C:\Users\de<span class="string">&#x27;l&#x27;</span>l\VSProjects\MistakeTry\Debug\MistakeTry.exe (process 20256) exited with code 0.</span><br><span class="line">To automatically close the console when debugging stops, <span class="built_in">enable</span> Tools-&gt;Options-&gt;Debugging-&gt;Automatically close the console when debugging stops.</span><br><span class="line">Press any key to close this window . . .</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> jj01</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">19999</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span>&amp; <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">1121332</span>;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = jj01::<span class="built_in">func1</span>();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">88</span>;</span><br><span class="line">	<span class="keyword">int</span> b = jj01::<span class="built_in">g</span>();</span><br><span class="line">	cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C:\Users\de&#x27;l&#x27;l\VSProjects\MistakeTry\main.cpp(80): warning C4172: returning address of local variable or temporary: b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1&gt;C:\Users\de&#x27;l&#x27;l\VSProjects\MistakeTry\main.cpp(74): warning C4172: returning address of local variable or temporary: a</span></span><br></pre></td></tr></table></figure>


<h2 id="6-vector类内初始化"><a href="#6-vector类内初始化" class="headerlink" title="6. vector类内初始化"></a><strong>6. vector类内初始化</strong></h2><ul>
<li><code>vector</code>容器对象在类内定义时不允许指定大小(编译器会认为这是定义了一个函数)，只能通过<strong>列表初始化</strong>指定大小。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">// error 编译器会认为这是定义了一个函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="keyword">int</span> n):<span class="built_in">v</span>(n)&#123;&#125;		<span class="comment">//  列表初始化 ok</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-静态成员函数指针-非静态成员函数指针"><a href="#7-静态成员函数指针-非静态成员函数指针" class="headerlink" title="7. 静态成员函数指针 非静态成员函数指针"></a>7. <strong>静态成员函数指针 非静态成员函数指针</strong></h2><ul>
<li><strong>问题：</strong> 在使用<code>sort()</code>函数时，第三个函数只能是 <strong>全局函数指针</strong>或者<strong>静态成员函数指针</strong>，不能是<strong>非静态成员函数指针</strong>。</li>
<li><strong>解释：</strong> 非静态成员函数的参数中有一个<strong>隐式绑定的this指针</strong>(因为非静态成员函数需要由具体对象来调用)，而<code>sort</code>第三个参数需要得是一个接受两个参数的函数指针，所以不可。如果是静态成员函数的话，<code>sort</code>时直接使用<code>cmp</code>即可，无需依赖于实际对象。</li>
<li>感觉这话题好像挺大的，之后再研究研究。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 贴个合并区间的代码hhhh</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;b)</span>  <span class="comment">// 成员函数指针 静态函数指针 全局函数指针 整理。</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);    <span class="comment">// 按照左端点排序</span></span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> r = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;r) </span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">                l=intervals[i][<span class="number">0</span>],r=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;r) r = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：猪啊猪</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/file_system/file/content/whole/index/content/2974707/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="string相关"><a href="#string相关" class="headerlink" title="string相关"></a><strong><code>string</code>相关</strong></h2><ul>
<li>可以<code>+</code>不可以<code>-</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;012345&quot;</span>;</span><br><span class="line">s += <span class="string">&#x27;6&#x27;</span>; <span class="comment">// s = &quot;0123456&quot;</span></span><br><span class="line">s += <span class="string">&quot;6&quot;</span>; <span class="comment">// s = &quot;0123456&quot;</span></span><br><span class="line">s -= <span class="string">&quot;6&quot;</span>; <span class="comment">//error</span></span><br><span class="line">s -= <span class="string">&#x27;6&#x27;</span>; <span class="comment">//error</span></span><br><span class="line">no viable loaded <span class="string">&#x27;-=&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对pthread-create未定义的引用"><a href="#对pthread-create未定义的引用" class="headerlink" title="对pthread_create未定义的引用"></a><strong>对<code>pthread_create</code>未定义的引用</strong></h2><ul>
<li><code>gcc</code>编译时加上参数 <code>-lpthread</code></li>
<li>原因：<code>pthread</code>不是<code>Linux</code>默认的库。（毕竟<code>Linux</code>最开始本身没有线程），所以要链接上这个动态库</li>
</ul>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>小白血泪史</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux I/O</title>
    <url>/2021/11/05/Linux-IO/</url>
    <content><![CDATA[<p>Unix I/O</p>
<span id="more"></span>


<ul>
<li>参考 APUE，牛客以及黑马讲义</li>
</ul>
<h1 id="Unix基础知识"><a href="#Unix基础知识" class="headerlink" title="Unix基础知识"></a>Unix基础知识</h1><ul>
<li><p><strong>系统调用</strong></p>
<ul>
<li>写文件 ，即对磁盘操作。从用户空间进入内核空间，借助驱动，驱动磁盘工作。库函数没有办法直接使用驱动，应该通过系统函数来使用驱动完成对磁盘的操作。<br><img src="/2021/11/05/Linux-IO/2021-11-21-19-38-48.png"></li>
</ul>
</li>
<li><p><strong>预读入 缓输出</strong></p>
<ul>
<li><code>read  write : unbuffered I/O</code>。不带（用户区）缓冲的<code>I/O</code>。内核处有内核级别的缓冲区，默认大小4096B。 </li>
<li>为什么<code>write(fd,const char *,n);</code>比<code>fputc</code>慢。如图<br><img src="/2021/11/05/Linux-IO/2021-11-21-19-43-36.png"></li>
<li>在上图中的磁盘和<code>kernal</code>之间，采取预读入缓输出机制<ul>
<li>即从磁盘往<code>kernal</code>读东西的时候，一次读4096个字节，避免之后读取时多次与硬盘交互。</li>
<li>从<code>kernal</code>向磁盘写东西的时候，一次写4096个，避免多次与磁盘交互。 </li>
</ul>
</li>
</ul>
</li>
<li><p>所以</p>
<ul>
<li>即使学了系统调用，能使用库函数的地方，优先使用库函数    </li>
<li>那为什么要学系统函数，因为只用库函数可能会有逻辑上的障碍。</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>阻塞与非阻塞</strong></p>
<ul>
<li>是所读文件的性质，不是<code>read write</code>的性质</li>
<li>读常规文件不会阻塞；读网络会阻塞</li>
<li>同样，写常规文件是不会阻塞的，而向终端设备或网络写则不一定。</li>
<li>现在明确一下阻塞<code>（Block）</code>这个概念。当进程调用一个阻塞的系统函数时，该进程被置于睡眠（<code>Sleep</code>）状态，这时内核调度其它进程运行，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用 <code>sleep</code> 指定的睡眠时间到了）它才有可能继续运行。与睡眠状态相对的是运行（<code>Running</code>）状态，在 <code>Linux</code> 内核中，处于运行状态的进程分为两种情况：<ul>
<li>正在被调度执行。<code>CPU</code> 处于该进程的上下文环境中，程序计数器（<code>eip</code>）里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，正在读写该进程的地址空间。</li>
<li>就绪状态：该进程不需要等待什么事件发生，随时都可以执行，但 <code>CPU</code> 暂时还在执行另一个进程，所以该进程在一个就绪队列中等待被内核调度。系统中可能同时有多个就绪的进程，那么该调度谁执行呢？内核的调度算法是基于优先级和时间片的，而且会根据每个进程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到机会执行，同时要兼顾用户体验，不能让和用户交互的进程响应太慢</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>每一个进程都有如下结构</strong><br><img src="/2021/11/05/Linux-IO/2021-11-24-20-09-47.png"></p>
</li>
</ul>
<h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="/2021/11/05/Linux-IO/2021-11-24-21-20-02.png"></p>
<h2 id="UNIX：文件相关数据结构"><a href="#UNIX：文件相关数据结构" class="headerlink" title="UNIX：文件相关数据结构"></a>UNIX：文件相关数据结构</h2><ul>
<li><p>每个进程在进程表都有成员变量 <code>file_struct *file</code> 指向文件描述符表</p>
<ul>
<li>进程表即 PCB进程控制块 <code>task_struct</code></li>
</ul>
</li>
<li><p>与每个fd相关联的是</p>
<ul>
<li>文件描述符标志</li>
<li>指向一个文件表项<code>（struct file&#123;&#125;）</code>的指针</li>
</ul>
</li>
<li><p>内核为所有打开文件维持一张文件表。每个文件表包含：</p>
<ul>
<li>文件状态标志<ul>
<li>读，写，添写，同步，非阻塞等</li>
</ul>
</li>
<li>当前文件偏移量</li>
<li>指向该文件v节点表项的指针</li>
</ul>
</li>
<li><p>每个<strong>打开</strong>文件都有一个<code>v</code>节点结构<code>v-node</code>。<code>v</code>节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，<code>v</code>节点还包含了i节点<code>（i-node）</code>。这些信息是在打开文件时从磁盘读入内存的。所以，文件的所有相关信息都是随时可用的。如，<code>i-node</code>包含了文件所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。</p>
</li>
<li><p>打开文件时的数据结构<br><img src="/2021/11/05/Linux-IO/2021-11-24-08-04-42.png"></p>
</li>
<li><p>注：Linux没有使用<code>v</code>节点。而是使用通用i节点结构。虽然实现略有不同，但在概念上<code>v</code>节点与<code>i</code>节点是一样的。两这都指向文件系统特有的<code>i</code>节点结构。</p>
</li>
</ul>
<p><img src="/2021/11/05/Linux-IO/2021-11-24-08-05-36.png"></p>
<ul>
<li>上图也说明了为什么多个进程可以打开同一文件：<ul>
<li>打开文件的每个进程都获得各自的一个文件表项，但对于给定的文件只有一个<code>v</code>节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使得每个进程都有它自己的对该文件的当前偏移量。</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/05/Linux-IO/2021-11-23-20-52-47.png"><br><img src="/2021/11/05/Linux-IO/2021-11-23-20-57-42.png"></p>
<ul>
<li>每个<code>i</code>节点中都有一个链接计数（对应<code>stat</code>结构中的<code>nlink_t</code>)，其值是指向该i节点的目录项。链接计数减少为0时，才可删除该文件，即释放该i节点指向的数据块。所以，删除目录项就做<code>unlink</code>而非<code>delete</code>。</li>
<li><code>i</code>节点中包含文件所有信息：文件类型，文件访问权限，文件长度，指向文件数据块的指针等。<code>stat</code>结构中大多信息来自i节点。只有文件名和i节点编号放在目录块中。<code>i</code>节点编号数据类型<code>：ino_t</code></li>
<li>为文件重命名时：文件内容并未移动，只要构造一个指向该文件的新目录项，并删除老目录项。</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li><code>stderr</code>是写到哪里？为什么和<code>stdout</code>一样也是显示在终端上？<ul>
<li>每当运行一个程序时，所有<code>shell</code>都为其打开三个文件描述符，即标准输入<code>STDIN_FILENO 0</code>，标准输出<code>STDOUT_FILENO 1</code> ，标准错误<code>STDERR_FILENO 2</code>。如果不做特殊处理，则这这3个文件描述符都连接到终端。</li>
</ul>
</li>
<li>困惑，在程序中这样创建了一个本不存在的文件，那么在本程序中对他的读写权限是？？？已经确定第一项改成<code>O_RDWR</code>一定可以读写<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;./test_mmap3.txt&quot;</span>,O_RDONLY|O_CREAT|O_TRUNC,<span class="number">0664</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="一些IO函数"><a href="#一些IO函数" class="headerlink" title="一些IO函数"></a>一些IO函数</h2><h3 id="open"><a href="#open" class="headerlink" title="open"></a><code>open</code></h3><ul>
<li>作用：打开已有文件/创建新文件</li>
<li><code>打开：int open(const char *pathname, int flags);</code></li>
<li><code>创建：int open(const char *pathname, int flags, mode_t mode);</code></li>
<li>例子<ul>
<li><code>int fd = open(&quot;xxx&quot;,O_RDWR|O_TRUNC|O_CREAT,0664);</code> <ul>
<li>若文件存在，以读写且截断方式打开</li>
<li>若文件不存在，以0664权限创建<h3 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a><code>lseek</code></h3></li>
</ul>
</li>
</ul>
</li>
<li>作用：移动文件指针，仅仅移动文件指针，不进行IO操作</li>
<li>文件空洞不要求在磁盘上占用存储区。但是如果在超出文件尾端时写了，就会占用。</li>
<li><code>off_t lseek(int fd,off_t offset,int whence)</code><ul>
<li><code>offset</code>是偏移量，<code>whence</code>是偏移量的基准位置</li>
<li><code>whence</code> <ul>
<li><code>SEEK_SET</code></li>
<li><code>SEEK_END</code></li>
<li><code>SEEK_CUR</code></li>
</ul>
</li>
</ul>
</li>
<li><code>RETURN VALUE    Upon  successful completion, lseek() returns the resulting offset location as measured in bytes from the beginning of the file.  On error, the value (off_t) -1 is returned and errno is set to    indicate the error.</code><ul>
<li>成功</li>
<li>返回从文件最开始的位置 到 文件<code>whence</code>（何处）向后偏移<code>offset</code>个字节的距离。（单位字节）</li>
<li>失败</li>
<li>返回-1</li>
</ul>
</li>
<li>应用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件扩容10字节</span></span><br><span class="line"> lseek(fd,<span class="number">9</span>,SEEK_END);   <span class="comment">//  将文件指针从SEEK_END向后移动9个字节</span></span><br><span class="line"> write(fd,<span class="string">&quot;\0&quot;</span>,<span class="number">1</span>);   <span class="comment">//  再写一个 </span></span><br><span class="line"> <span class="comment">// 等价于</span></span><br><span class="line"> ftruncate(fd,<span class="number">10</span>);</span><br><span class="line"> <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END); <span class="comment">//  返回从文件起始到 SEEK_END再向后便宜0字节的大小，即文件大小</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a><code>unlink</code></h3><ul>
<li><code>int unlink (const char* pathname)</code></li>
<li>功能：删除目录块<code>dentry</code>（让文件具备了被释放的条件）</li>
<li>当一个文件的硬链接计数减少至0时，该文件的数据块会被操作系统择机释放。</li>
<li><code>unlink</code>特征：解除对一个文件的链接时，如果文件的硬链接计数减小到0，无目录块dentry对应，但该文件i节点指向的数据块不会被立刻释放，而是等到所有打开该文件的进程关闭该文件，系统才会挑时间将他释放。</li>
<li><code>int ret = unlink(&quot;xx&quot;);</code></li>
</ul>
<h3 id="dup"><a href="#dup" class="headerlink" title="dup"></a><code>dup</code></h3><ul>
<li>保存文件描述符</li>
<li><code>int dup(int oldfd);</code><ul>
<li><code>oldfd：</code>已经打开的旧的描述符。</li>
<li><code>success: return a new fd</code>，新文件描述符指向旧文件描述符指向的文件。 </li>
<li>失败，-1 并设置 <code>errno</code></li>
</ul>
</li>
</ul>
<h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a><code>dup2</code></h3><ul>
<li>拷贝文件描述符，重定向文件描述符指向</li>
<li><code>int dup2(int oldfd,int newfd);</code><ul>
<li>将<code>oldfd</code>拷贝给<code>newfd</code>，使得下次操作<code>newfd</code>，实际上是对<code>oldfd</code>所指向的文件进行操作</li>
<li><code>success</code><ul>
<li><code>return a new fd</code>，如果oldfd有效，则返回的文件描述符与oldfd指向同一文件</li>
</ul>
</li>
<li><code>fail</code><ul>
<li><code>oldfd</code>无效，则失败，关闭<code>newfd</code>。返回-1，同时设置<code>errno</code>  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="stat-lstat"><a href="#stat-lstat" class="headerlink" title="stat lstat"></a><code>stat lstat</code></h3><ul>
<li>查询文件信息，传入文件路径，信息保存在<code>struct stat</code>中传出</li>
<li><code>#include &lt;sys/stat.h&gt;</code></li>
<li><code>int stat(const char *filename,struct stat *statbuf)</code></li>
<li><code>int lstat(const char *filename,struct stat *statbuf)</code><ul>
<li><code>filename</code> ：文件路径+名称</li>
<li><strong><code>struct stat* statbuf</code>：结构体地址。文件信息将保存在这里。</strong></li>
<li>成功 <code>0</code> 失败 <code>-1</code></li>
<li><code>lstat</code>会获取软链接指向的文件的信息，<code>stat</code>会穿透软链接<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="comment">//      int fd = open(&quot;../rev.c&quot;,O_RDONLY|O_CREAT|O_TRUNC,0664);        //  有 则只读打开；没有，则以0664&amp;umask权限创建 </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span> </span><br><span class="line">        <span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>],&amp;sb);<span class="comment">// stat 穿透符号链接（软链接）lstat：不穿透符号链接 </span></span><br><span class="line">         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;size = %ld\t&quot;</span>,sb.st_size); </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(S_ISREG(sb.st_mode)) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a regular\n&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(sb.st_mode)) </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;it&#x27;s a directory\n&quot;</span>);    </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./stat_shc.out test01.txt</span><br><span class="line">size = <span class="number">0</span>	it<span class="number">&#x27;</span>s a regular</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./stat_shc.out ..</span><br><span class="line">size = <span class="number">4096</span>	it<span class="number">&#x27;</span>s a directory</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The <span class="built_in">stat</span> structure</span><br><span class="line">     All of these system calls <span class="built_in">return</span> a <span class="built_in">stat</span> structure, <span class="built_in">which</span> contains the following fields:</span><br><span class="line"></span><br><span class="line">         struct <span class="built_in">stat</span> &#123;</span><br><span class="line">             dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">             ino_t     st_ino;         /* Inode number */</span><br><span class="line">             mode_t    st_mode;        /* File <span class="built_in">type</span> and mode */</span><br><span class="line">             nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">             uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">             gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">             dev_t     st_rdev;        /* Device ID (<span class="keyword">if</span> special file) */</span><br><span class="line">             off_t     st_size;        /* Total size, <span class="keyword">in</span> bytes */</span><br><span class="line">             blksize_t st_blksize;     /* Block size <span class="keyword">for</span> filesystem I/O */</span><br><span class="line">             blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line"></span><br><span class="line">             /* Since Linux 2.6, the kernel supports nanosecond</span><br><span class="line">                precision <span class="keyword">for</span> the following timestamp fields.</span><br><span class="line">                For the details before Linux 2.6, see NOTES. */</span><br><span class="line"></span><br><span class="line">             struct timespec st_atim;  /* Time of last access */</span><br><span class="line">             struct timespec st_mtim;  /* Time of last modification */</span><br><span class="line">             struct timespec st_ctim;  /* Time of last status change */</span><br><span class="line"></span><br><span class="line">         <span class="comment">#define st_atime st_atim.tv_sec      /* Backward compatibility */</span></span><br><span class="line">         <span class="comment">#define st_mtime st_mtim.tv_sec</span></span><br><span class="line">         <span class="comment">#define st_ctime st_ctim.tv_sec</span></span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="模拟ls-l-fileName"><a href="#模拟ls-l-fileName" class="headerlink" title="模拟ls -l fileName"></a>模拟<code>ls -l fileName</code></h3><p><img src="/2021/11/05/Linux-IO/2021-11-24-08-45-45.png"></p>
<ul>
<li><p><strong><code>st_mode</code></strong></p>
<ul>
<li><p><strong><code>mode_t st_mode</code></strong>   —-&gt;  <strong><code>mode_t : unsigned int</code></strong></p>
</li>
<li><p><code>st_mode</code>中<code>[0,15]</code>位的二进制数起作用</p>
</li>
<li><p>如何求出文件类型 ?</p>
<ul>
<li><p><code>statbuf.st_mode &amp; S_IFMT</code><br>去除了<code>[11,0]</code>的表征其他性质的位(变成了<code>0</code>)<br>；将<code>[15,12]</code>位所有位为1的位都保留了下来。其他位都变成了<code>0</code></p>
</li>
<li><p>因此现在的<code>[15,0]</code>位所组成的值再与这些特征值比较 就可以得出该文件的类型（容易得知<code>[11,0]</code>一定均为<code>0</code>)<br><img src="/2021/11/05/Linux-IO/2021-11-24-09-04-54.png"></p>
</li>
<li><p>文件类型特征值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">S_IFSOCK 0140000 套接字</span><br><span class="line">S_IFLNK 0120000 符号链接（软链接）</span><br><span class="line">S_IFREG 0100000 普通文件</span><br><span class="line">S_IFBLK 0060000 块设备</span><br><span class="line">S_IFDIR 0040000 目录</span><br><span class="line">S_IFCHR 0020000 字符设备</span><br><span class="line">S_IFIFO 0010000 管道</span><br><span class="line">S_IFMT 0170000 掩码</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>权限特征值(<code>[9,0]</code>)</p>
<ul>
<li><code>usr</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S_IRUSR <span class="number">00400</span></span><br><span class="line">S_IWUSR <span class="number">00200</span></span><br><span class="line">S_IXUSR <span class="number">00100</span></span><br><span class="line">S_IRWXU <span class="number">00700</span></span><br></pre></td></tr></table></figure></li>
<li><code>group</code><ul>
<li>换成<code>S_I*GRP</code>即可</li>
</ul>
</li>
<li><code>other</code><ul>
<li>换成<code>S_I*OTH</code>即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>模拟代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/stat_learn$ gcc ls-l.c -o ls</span><br><span class="line">henry@henry:~/code/learn/stat_learn$ ./ls -l a.txt</span><br><span class="line">-rw-r--r-- 1d henry henry 10 Sat Oct 16 16:21:29 2021 a.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pwd.h&gt;</span>     <span class="comment">//  struct passwd *getpwuid(uid_t uid);     uid_t :unsigned int</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;grp.h&gt;</span>     <span class="comment">//  struct group *getgrgid(gid_t gid);</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mock ls -l filename</span></span><br><span class="line"><span class="comment">// ls -l a.txt</span></span><br><span class="line"><span class="comment">// -rw-r--r-- 1 henry henry 10 10月 16 16:21 a.txt</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argvs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  判断输入参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(argc&lt;=<span class="number">2</span>) <span class="comment">//argvs[0] : ./ls.out  ; argvs[1] : ./-l  ;  argvs[2] : File name at the same level</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s -l filename\n&quot;</span>,argvs[<span class="number">0</span>]);   <span class="comment">//  the name of ./ls.out + -l + filename</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取文件信息 文件信息存储在struct stat类型结构体 stub中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stb</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> res = stat(argvs[<span class="number">2</span>],&amp;stb);  <span class="comment">// argvs[1] </span></span><br><span class="line">    <span class="keyword">if</span>(res==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat get the information of the file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取文件类型 和 user group other的读写权限</span></span><br><span class="line">    <span class="comment">//  获取文件类型</span></span><br><span class="line">    <span class="keyword">char</span> info[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;     <span class="comment">// info : file class and the permissions</span></span><br><span class="line">    <span class="keyword">int</span> m = stb.st_mode &amp; S_IFMT;   </span><br><span class="line">    <span class="keyword">switch</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK:  <span class="comment">// IF : is file </span></span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            info[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取user group other的读写执行权限</span></span><br><span class="line">    <span class="comment">// USR : user</span></span><br><span class="line">    info[<span class="number">1</span>] = stb.st_mode &amp; S_IRUSR ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is read</span></span><br><span class="line">    info[<span class="number">2</span>] = stb.st_mode &amp; S_IWUSR ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is write</span></span><br><span class="line">    info[<span class="number">3</span>] = stb.st_mode &amp; S_IXUSR ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;    <span class="comment">// is x </span></span><br><span class="line">    <span class="comment">// info[3] = stb.st_mode &amp; S_IRWXU ? &#x27;1&#x27; : &#x27;0&#x27;;    // is read write x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// GRP : group person</span></span><br><span class="line">    info[<span class="number">4</span>] = stb.st_mode &amp; S_IRGRP ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">5</span>] = stb.st_mode &amp; S_IWGRP ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">6</span>] = stb.st_mode &amp; S_IXGRP ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// OTH : others </span></span><br><span class="line">    info[<span class="number">7</span>] = stb.st_mode &amp; S_IROTH ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">8</span>] = stb.st_mode &amp; S_IWOTH ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    info[<span class="number">9</span>] = stb.st_mode &amp; S_IXOTH ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  硬链接数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> linknum = stb.st_nlink;   <span class="comment">//  hard link</span></span><br><span class="line">    <span class="comment">//  user name</span></span><br><span class="line">    <span class="keyword">char</span> *fileUsr = getpwuid(stb.st_uid)-&gt;pw_name;    </span><br><span class="line">    <span class="comment">//  group name</span></span><br><span class="line">    <span class="keyword">char</span> *fileGrp = getgrgid(stb.st_gid)-&gt;gr_name;    </span><br><span class="line">    <span class="comment">//  文件大小</span></span><br><span class="line">    <span class="keyword">long</span> fileSize = stb.st_size;</span><br><span class="line">    <span class="comment">//  创建时间</span></span><br><span class="line">    <span class="comment">//  st_time:the time since 1970 ; ctime:convert the time to local time</span></span><br><span class="line">    <span class="keyword">char</span> *time = ctime(&amp;stb.st_mtime);   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  去掉\n</span></span><br><span class="line">    <span class="keyword">char</span> time_buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//  strncpy不会自动补&#x27;\0&#x27;</span></span><br><span class="line">    <span class="built_in">strncpy</span>(time_buf,time,<span class="built_in">strlen</span>(time)<span class="number">-1</span>);  </span><br><span class="line">    time_buf[<span class="built_in">strlen</span>(time)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  sprintf写入buf</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">&quot;%s %lud %s %s %ld %s %s&quot;</span>,info,linknum,fileUsr,fileGrp,fileSize,time_buf,argvs[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  输出结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- **`extern struct passwd *getpwuid(uid_t uid)`**</span></span><br><span class="line"><span class="comment">  - `uid_t uid`</span></span><br><span class="line"><span class="comment">    - `uid_t :unsigned int`</span></span><br><span class="line"><span class="comment">    - `uid: user id` </span></span><br><span class="line"><span class="comment">  - `passwd`</span></span><br><span class="line"><span class="comment">  The passwd structure.  </span></span><br><span class="line"><span class="comment">  struct passwd</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    char *pw_name;		/* Username.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_passwd;		<span class="comment">/* Password.  */</span></span><br><span class="line">    <span class="keyword">__uid_t</span> pw_uid;		<span class="comment">/* User ID.  */</span></span><br><span class="line">    <span class="keyword">__gid_t</span> pw_gid;		<span class="comment">/* Group ID.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_gecos;		<span class="comment">/* Real name.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_dir;			<span class="comment">/* Home directory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *pw_shell;		<span class="comment">/* Shell program.  */</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  - <span class="keyword">uid_t</span> uid从哪里来？</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stab</span></span></span><br><span class="line"><span class="class">      //   <span class="title">int</span> <span class="title">stat</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">pathname</span>, <span class="keyword">struct</span> <span class="title">stat</span> *<span class="title">statbuf</span>);</span></span><br><span class="line">  stat(文件名,stab);</span><br><span class="line">  <span class="comment">//stab.st_uid即为getpwuid所需要的参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> * <span class="title">pp</span> =</span> getpwuid(stab.st_uid);</span><br><span class="line">  <span class="keyword">char</span> * userName = pp -&gt; pw_name; </span><br><span class="line">  </span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="manpage阅读"><a href="#manpage阅读" class="headerlink" title="manpage阅读"></a>manpage阅读</h2><ul>
<li><p><code>stat</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AME</span><br><span class="line">       <span class="built_in">stat</span>, fstat, lstat, fstatat - get file status</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line">       <span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line">       <span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">       int <span class="built_in">stat</span>(const char *pathname, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line">       int fstat(int fd, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line">       int lstat(const char *pathname, struct <span class="built_in">stat</span> *statbuf);</span><br><span class="line"></span><br><span class="line">       <span class="comment">#include &lt;fcntl.h&gt;           /* Definition of AT_* constants */</span></span><br><span class="line">       <span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line">       int fstatat(int dirfd, const char *pathname, struct <span class="built_in">stat</span> *statbuf,</span><br><span class="line">                   int flags);</span><br><span class="line"></span><br><span class="line">   Feature Test Macro Requirements <span class="keyword">for</span> glibc (see feature_test_macros(7)):</span><br><span class="line"></span><br><span class="line">       lstat():</span><br><span class="line">           /* glibc 2.19 and earlier */ _BSD_SOURCE</span><br><span class="line">               || /* Since glibc 2.20 */ _DEFAULT_SOURCE</span><br><span class="line">               || _XOPEN_SOURCE &gt;= 500</span><br><span class="line">               || /* Since glibc 2.10: */ _POSIX_C_SOURCE &gt;= 200112L</span><br><span class="line"></span><br><span class="line">       fstatat():</span><br><span class="line">           Since glibc 2.10:</span><br><span class="line">               _POSIX_C_SOURCE &gt;= 200809L</span><br><span class="line">           Before glibc 2.10:</span><br><span class="line">               _ATFILE_SOURCE</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       These  <span class="built_in">functions</span>  <span class="built_in">return</span> information about a file, <span class="keyword">in</span> the buffer pointed to by statbuf.  No permissions are required on the file itself, but—<span class="keyword">in</span> the <span class="keyword">case</span> of <span class="built_in">stat</span>(), fstatat(), and lstat()—exe‐</span><br><span class="line">       cute (search) permission is required on all of the directories <span class="keyword">in</span> pathname that lead to the file.</span><br><span class="line"></span><br><span class="line">       <span class="built_in">stat</span>() and fstatat() retrieve information about the file pointed to by pathname; the differences <span class="keyword">for</span> fstatat() are described below.</span><br><span class="line"></span><br><span class="line">       lstat() is identical to <span class="built_in">stat</span>(), except that <span class="keyword">if</span> pathname is a symbolic link, <span class="keyword">then</span> it returns information about the link itself, not the file that it refers to.</span><br><span class="line"></span><br><span class="line">       fstat() is identical to <span class="built_in">stat</span>(), except that the file about <span class="built_in">which</span> information is to be retrieved is specified by the file descriptor fd.</span><br><span class="line">  The <span class="built_in">stat</span> structure</span><br><span class="line">       All of these system calls <span class="built_in">return</span> a <span class="built_in">stat</span> structure, <span class="built_in">which</span> contains the following fields:</span><br><span class="line"></span><br><span class="line">           struct <span class="built_in">stat</span> &#123;</span><br><span class="line">               dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">               ino_t     st_ino;         /* Inode number */</span><br><span class="line">               mode_t    st_mode;        /* File <span class="built_in">type</span> and mode */</span><br><span class="line">               nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">               uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">               gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">               dev_t     st_rdev;        /* Device ID (<span class="keyword">if</span> special file) */</span><br><span class="line">               off_t     st_size;        /* Total size, <span class="keyword">in</span> bytes */</span><br><span class="line">               blksize_t st_blksize;     /* Block size <span class="keyword">for</span> filesystem I/O */</span><br><span class="line">               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line"></span><br><span class="line">               /* Since Linux 2.6, the kernel supports nanosecond</span><br><span class="line">                  precision <span class="keyword">for</span> the following timestamp fields.</span><br><span class="line">                  For the details before Linux 2.6, see NOTES. */</span><br><span class="line"></span><br><span class="line">               struct timespec st_atim;  /* Time of last access */</span><br><span class="line">               struct timespec st_mtim;  /* Time of last modification */</span><br><span class="line">               struct timespec st_ctim;  /* Time of last status change */</span><br><span class="line"></span><br><span class="line">           <span class="comment">#define st_atime st_atim.tv_sec      /* Backward compatibility */</span></span><br><span class="line">           <span class="comment">#define st_mtime st_mtim.tv_sec</span></span><br><span class="line">           <span class="comment">#define st_ctime st_ctim.tv_sec</span></span><br><span class="line">           &#125;;</span><br><span class="line">RETURN VALUE</span><br><span class="line">       On success, zero is returned.  On error, -1 is returned, and errno is <span class="built_in">set</span> appropriately.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>unlink</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UNLINK(2)                                                                              Linux Programmer<span class="string">&#x27;s Manual                                                                             UNLINK(2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">NAME</span></span><br><span class="line"><span class="string">       unlink, unlinkat - delete a name and possibly the file it refers to</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SYNOPSIS</span></span><br><span class="line"><span class="string">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int unlink(const char *pathname);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       #include &lt;fcntl.h&gt;           /* Definition of AT_* constants */</span></span><br><span class="line"><span class="string">       #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       int unlinkat(int dirfd, const char *pathname, int flags);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       unlinkat():</span></span><br><span class="line"><span class="string">           Since glibc 2.10:</span></span><br><span class="line"><span class="string">               _POSIX_C_SOURCE &gt;= 200809L</span></span><br><span class="line"><span class="string">           Before glibc 2.10:</span></span><br><span class="line"><span class="string">               _ATFILE_SOURCE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">       unlink()  deletes  a  name from the filesystem.  If that name was the last link to a file and no processes have the file open, the file is deleted and the space it was using is made available</span></span><br><span class="line"><span class="string">       for reuse.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name was the last link to a file but any processes still have the file open, the file will remain in existence until the last file descriptor referring to it is closed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name referred to a symbolic link, the link is removed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       If the name referred to a socket, FIFO, or device, the name for it is removed but processes which have the object open may continue to use it.</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-三级映射</title>
    <url>/2021/12/03/Linux-%E4%B8%89%E7%BA%A7%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>Linux三级映射（未完）</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-信号</title>
    <url>/2021/11/30/Linux-%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<p>Linux信号</p>
<span id="more"></span>

<ul>
<li>参考 APUE，牛客以及黑马讲义</li>
</ul>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a><strong>信号</strong></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>特点：简单 ； 不能携带大量信息 ； 满足某个特设条件才发送</li>
<li>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉</li>
<li>每个进程收到的所有信号，都是由内核负责发送的，内核处理。</li>
<li>递达：递送并且到达进程。</li>
<li>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。</li>
<li>产生信号: <ul>
<li> 按键产生，如：<code>Ctrl+c、Ctrl+z、Ctrl+\</code></li>
<li> 系统调用产生，如：<code>kill、raise、abort</code></li>
<li> 软件条件产生，如：定时器 <code>alarm</code></li>
<li> 硬件异常产生，如：非法访问内存(段错误)、除 0(浮点数例外)、内存对齐出错(总线错误)</li>
<li> 命令产生，如：<code>kill</code> 命令</li>
</ul>
</li>
<li><strong>信号的处理方式:</strong><ul>
<li><strong>执行默认动作</strong><ul>
<li><code>Term：</code>终止进程</li>
<li> <code>Ign：</code> 忽略信号 (默认即时对该种信号忽略操作)</li>
<li> <code>Core</code>：终止进程，生成 Core 文件。(查验进程死亡原因， 用于 <code>gdb</code> 调试)</li>
<li> <code>Stop：</code>停止（暂停）进程</li>
<li> <code>Cont</code>：继续运行进程</li>
</ul>
</li>
<li><strong>忽略(丢弃)</strong></li>
<li> <strong>捕捉(调用户处理函数)</strong><h2 id="信号要素"><a href="#信号要素" class="headerlink" title="信号要素"></a>信号要素</h2></li>
</ul>
</li>
<li><strong>信号4要素</strong><ul>
<li>编号  </li>
<li>名称 </li>
<li>事件 </li>
<li>默认处理动作<ul>
<li> <code>Term：</code>终止进程</li>
<li> <code>Ign：</code> 忽略信号 (默认即时对该种信号忽略操作)</li>
<li> <code>Core</code>：终止进程，生成 Core 文件。(查验进程死亡原因， 用于 <code>gdb</code> 调试)</li>
<li> <code>Stop：</code>停止（暂停）进程</li>
<li> <code>Cont</code>：继续运行进程</li>
</ul>
</li>
</ul>
</li>
<li> 1~31常规信号  </li>
<li> <code>9 SIGKILL ; 19 SIGSTOP</code> 信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。</li>
<li> 只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ <span class="built_in">kill</span> -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 2) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">1)  SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">2)  SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">3)  SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">4)  SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">5)  SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">6)  SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">7)  SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">8)  SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">9)  SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">10) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">11) SIGRTMAX-1	64) SIGRTMAX	</span><br></pre></td></tr></table></figure></li>
<li>常规信号的编号，名称，对应事件，默认处理动作。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) SIGHUP: 当用户退出 shell 时，由该 shell 启动的所有进程将收到这个信号，默认动作为终止进程</span><br><span class="line"><span class="number">2</span>) SIGINT：当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。</span><br><span class="line"><span class="number">3</span>) SIGQUIT：当用户按下&lt;ctrl+\&gt;组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。</span><br><span class="line"><span class="number">4</span>) SIGILL：CPU 检测到某进程执行了非法指令。默认动作为终止进程并产生 core 文件</span><br><span class="line"><span class="number">5</span>) SIGTRAP：该信号由断点指令或其他 trap 指令产生。默认动作为终止里程 并产生 core 文件。</span><br><span class="line"><span class="number">6</span>) SIGABRT: 调用 abort 函数时产生该信号。默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">7</span>) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">8</span>) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 <span class="number">0</span> 等所有的算法错误。</span><br><span class="line">默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">9</span>) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了</span><br><span class="line">可以杀死任何进程的方法。</span><br><span class="line"><span class="number">10</span>) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line"><span class="number">11</span>) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">12</span>) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。</span><br><span class="line"><span class="number">13</span>) SIGPIPE：Broken pipe 向一个没有读端的管道写数据。默认动作为终止进程。</span><br><span class="line">北京市昌平区建材城西路金燕龙办公楼一层 电话：<span class="number">400</span><span class="number">-618</span><span class="number">-9090</span></span><br><span class="line"><span class="number">14</span>) SIGALRM: 定时器超时，超时的时间 由系统调用 alarm 设置。默认动作为终止进程。</span><br><span class="line"><span class="number">15</span>) SIGTERM：程序结束信号，与 SIGKILL 不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。</span><br><span class="line">执行 shell 命令 Kill 时，缺省产生这个信号。默认动作为终止进程。</span><br><span class="line"><span class="number">16</span>) SIGSTKFLT：Linux 早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。</span><br><span class="line"><span class="number">17</span>) SIGCHLD：子进程状态发生变化时，父进程会收到这个信号。默认动作为忽略这个信号。</span><br><span class="line"><span class="number">18</span>) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。</span><br><span class="line"><span class="number">19</span>) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。</span><br><span class="line"><span class="number">20</span>) SIGTSTP：停止终端交互进程的运行。按下&lt;ctrl+z&gt;组合键时发出这个信号。默认动作为暂停进程。</span><br><span class="line"><span class="number">21</span>) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。</span><br><span class="line"><span class="number">22</span>) SIGTTOU: 该信号类似于 SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。</span><br><span class="line"><span class="number">23</span>) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外</span><br><span class="line">数据到达，默认动作为忽略该信号。</span><br><span class="line"><span class="number">24</span>) SIGXCPU：进程执行时间超过了分配给该进程的 CPU 时间 ，系统产生该信号并发送给该进程。默认动作为</span><br><span class="line">终止进程。</span><br><span class="line"><span class="number">25</span>) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。</span><br><span class="line"><span class="number">26</span>) SIGVTALRM：虚拟时钟超时时产生该信号。类似于 SIGALRM，但是该信号只计算该进程占用 CPU 的使用时</span><br><span class="line">间。默认动作为终止进程。</span><br><span class="line"><span class="number">27</span>) SGIPROF：类似于 SIGVTALRM，它不公包括该进程占用 CPU 时间还包括执行系统调用时间。默认动作为终止</span><br><span class="line">进程。</span><br><span class="line"><span class="number">28</span>) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。</span><br><span class="line"><span class="number">29</span>) SIGIO：此信号向进程指示发出了一个异步 IO 事件。默认动作为忽略。</span><br><span class="line"><span class="number">30</span>) SIGPWR：关机。默认动作为终止进程。</span><br><span class="line"><span class="number">31</span>) SIGSYS：无效的系统调用。默认动作为终止进程并产生 core 文件。</span><br><span class="line"><span class="number">34</span>) SIGRTMIN ～ (<span class="number">64</span>) SIGRTMAX：LINUX 的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时</span><br><span class="line">信号的默认动作都为终止进程。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="阻塞信号集（信号屏蔽字）；未决信号集"><a href="#阻塞信号集（信号屏蔽字）；未决信号集" class="headerlink" title="阻塞信号集（信号屏蔽字）；未决信号集"></a>阻塞信号集（信号屏蔽字）；未决信号集</h2><ul>
<li><p>阻塞信号集(信号屏蔽字)</p>
<ul>
<li>将某些信号加入集合，屏蔽他们。当收到x信号时，不处理x信号，直到对x的屏蔽解除后才处理。</li>
</ul>
</li>
<li><p>未决信号集</p>
<ul>
<li>信号产生，未决信号集中描述该信号的位立刻翻转为 1，表信号处于未决状态。当信号被处理对应位翻转回为 0。这一时刻往往非常短暂。</li>
<li>信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，<br>信号一直处于未决状态</li>
</ul>
</li>
<li><p>我们可以通过修改信号屏蔽字，来影响未决信号集。</p>
</li>
<li><p>其实就是加要屏蔽的信号加入信号屏蔽字，目的就是造成某些信号被屏蔽。<br>  <img src="/2021/11/30/Linux-%E4%BF%A1%E5%8F%B7/2021-11-30-18-43-32.png"></p>
<p>  <img src="/2021/11/30/Linux-%E4%BF%A1%E5%8F%B7/2021-11-30-18-45-07.png"></p>
</li>
</ul>
<h2 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h2><ul>
<li><p>按键</p>
<ul>
<li><code>Ctrl+c : SIGINT</code>。终端、中断。<code>interrupt</code></li>
<li><code>Ctrl+z : SIGTSTP</code>。暂停、停止。<code>terminal stop</code></li>
<li><code>Ctrl+\ : SIGQUIT</code></li>
</ul>
</li>
<li><p><code>kill</code> 命令</p>
<ul>
<li><code>kill -SIGKILL pid</code></li>
</ul>
</li>
<li><p><code>kill</code> 函数</p>
<ul>
<li>给指定进程发送指定信号(不一定杀死)</li>
<li><code>int kill(pid_t pid, int sig);</code></li>
<li> 成功：0；失败：-1 (ID 非法，信号非法，普通用户杀 init 进程等权级问题)，设置 errno</li>
<li>参数<ul>
<li> <code>sig</code>：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。</li>
<li><code>pid</code><ul>
<li> <code>pid &gt; 0</code>: 发送信号给指定的进程。</li>
<li> <code>pid = 0</code>: 发送信号给 与调用 kill 函数进程属于同一进程组的所有进程。</li>
<li> <code>pid &lt; 0</code>: 取<code>|pid|</code>发给对应进程组。</li>
<li> <code>pid = -1</code>：发送给进程有权限发送的系统中所有进程。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组 ID 与进程组长 ID 相同。</p>
</li>
<li><p>权限保护：<code>super</code> 用户(<code>root</code>)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 <code>kill -9 (root 用户的 pid)</code> 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发<br>送信号。普通用户基本规则是：发送者实际或有效用户 <code>ID</code> == 接收者实际或有效用户 ID</p>
</li>
<li><p><code>alarm</code> 函数</p>
<ul>
<li><code>unsigned int alarm(unsigned int seconds);</code> 返回 0 或剩余的秒数，无失败。 </li>
<li>设置定时器(闹钟)。在指定 <code>seconds</code> 后，内核会给当前进程发送 <code>14）SIGALRM</code> 信号。进程收到该信号，默认动作终止。</li>
<li>每个进程都有且只有唯一个定时器。</li>
<li><code>alarm(0)</code>：取消定时器，返回就闹钟剩余秒数</li>
<li>如果<code>fork</code>了 <code>alarm</code>好像只会让内核把信号发给子进程？？</li>
</ul>
</li>
<li><p><code>setitimer</code> 函数（比alarm精细）</p>
<ul>
<li><code>int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);</code> </li>
<li>日后补充<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">  <span class="built_in">which</span>：	ITIMER_REAL： 采用自然计时。 ——&gt; SIGALRM</span><br><span class="line"></span><br><span class="line">    ITIMER_VIRTUAL: 采用用户空间计时  ---&gt; SIGVTALRM</span><br><span class="line"></span><br><span class="line">    ITIMER_PROF: 采用内核+用户空间计时 ---&gt; SIGPROF</span><br><span class="line">  </span><br><span class="line">  new_value：定时秒数</span><br><span class="line"></span><br><span class="line">              类型：struct itimerval &#123;</span><br><span class="line"></span><br><span class="line">                    struct timeval &#123;</span><br><span class="line">                      time_t      tv_sec;         /* seconds */</span><br><span class="line">                      suseconds_t tv_usec;        /* microseconds */</span><br><span class="line"></span><br><span class="line">                &#125;it_interval;---&gt; 周期定时秒数</span><br><span class="line"></span><br><span class="line">                      struct timeval &#123;</span><br><span class="line">                      time_t      tv_sec;         </span><br><span class="line">                      suseconds_t tv_usec;        </span><br><span class="line"></span><br><span class="line">                &#125;it_value;  ---&gt; 第一次定时秒数  </span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">  old_value：传出参数，上次定时剩余时间。</span><br><span class="line"></span><br><span class="line">  e.g.</span><br><span class="line">    struct itimerval new_t;	</span><br><span class="line">    struct itimerval old_t;	</span><br><span class="line"></span><br><span class="line">    new_t.it_interval.tv_sec = 0;</span><br><span class="line">    new_t.it_interval.tv_usec = 0;</span><br><span class="line">    new_t.it_value.tv_sec = 1;</span><br><span class="line">    new_t.it_value.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">    int ret = setitimer(&amp;new_t, &amp;old_t);  定时1秒</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">  成功： 0</span><br><span class="line"></span><br><span class="line">  失败： -1 errno</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其他几个发信号函数：</p>
<ul>
<li><code>int raise(int sig);</code></li>
<li><code>void abort(void);</code></li>
</ul>
</li>
</ul>
<h2 id="信号屏蔽字操作函数"><a href="#信号屏蔽字操作函数" class="headerlink" title="信号屏蔽字操作函数"></a>信号屏蔽字操作函数</h2><ul>
<li><p>信号集操作函数 </p>
<ul>
<li>内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字 mask 可以影响未决信号集。而我们可以在程序中自定义 set 来改变 mask。已达到屏蔽指定信号的目的。</li>
</ul>
</li>
<li><p>修改自己预备的信号屏蔽字set</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//  修改自己的希望设置的信号屏蔽字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>; <span class="comment">//  信号屏蔽字啥也不屏蔽</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;  <span class="comment">//  信号屏蔽字啥都屏蔽</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;   <span class="comment">//  信号屏蔽字屏蔽signum</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;   <span class="comment">//  信号屏蔽字解除屏蔽signum</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  看这个信号集set（一般是未决信号集）里面 是否有signum信号（看signum信号是否没被处理）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p><code>sigprocmask</code>。修改<code>PCB</code>中的信号屏蔽字<code>mask</code></p>
<ul>
<li>用来<strong>屏蔽信号、解除屏蔽</strong>。其本质，读取或修改进程的信号屏蔽字(PCB 中)</li>
<li>严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。</li>
<li><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code> <ul>
<li>成功：0；</li>
<li>失败：-1，设置 <code>errno</code></li>
</ul>
</li>
<li>参数：<ul>
<li><code>set</code>：传入自己预先准备好的信号屏蔽字。是一个位图，<code>set</code> 中哪位置 1，就表示当前进程屏蔽/解除哪个信号。</li>
<li><code>oldset</code>：传出参数，保存旧的信号屏蔽集。</li>
<li><code>how</code> 参数取值： 假设当前的信号屏蔽字为 <code>mask</code><ul>
<li><code>SIG_BLOCK</code>: 当 <code>how</code> 设置为此值，<code>set</code> 表示需要屏蔽的信号。相当于 <code>mask = mask|set</code></li>
<li><code>SIG_UNBLOCK</code>: 当 <code>how</code> 设置为此，<code>set</code> 表示需要解除屏蔽的信号。相当于 <code>mask = mask &amp; ~set</code></li>
<li><code>SIG_SETMASK</code>: 当 <code>how</code> 设置为此，<code>set</code> 表示用于替代原始屏蔽及的新屏蔽集。相当于 <code>mask = set</code></li>
</ul>
</li>
</ul>
</li>
<li>若，调用 <code>sigprocmask</code> 解除了对当前若干个信号的阻塞，则在 <code>sigprocmask</code> 返回前，至少将其中一个信号递达。</li>
</ul>
</li>
<li><p><code>sigpending</code></p>
<ul>
<li><code>int sigpending(sigset_t *set);</code></li>
<li>读取当前未决信号集合 </li>
</ul>
</li>
<li><p>例子：当前进程屏蔽<code>SIGINT</code>以及<code>SIGQUIT</code>，观察未决信号集变化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* SYNOPSIS</span></span><br><span class="line"><span class="comment">      #include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigemptyset(sigset_t *set);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigfillset(sigset_t *set);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigaddset(sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigdelset(sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      int sigismember(const sigset_t *set, int signum);</span></span><br><span class="line"><span class="comment">sigset_t</span></span><br><span class="line"><span class="comment">struct</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  unsigned long int __val[_SIGSET_NWORDS];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_pending_set</span><span class="params">(<span class="keyword">sigset_t</span> *pending_set)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;++i)	<span class="comment">//  看前31种信号</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(sigismember(pending_set,i))	</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sigset_t</span></span><br><span class="line"><span class="comment">信号屏蔽字操作函数</span></span><br><span class="line"><span class="comment">sigemptyset</span></span><br><span class="line"><span class="comment">sigaddset</span></span><br><span class="line"><span class="comment">sigprocmask</span></span><br><span class="line"><span class="comment">sigpending</span></span><br><span class="line"><span class="comment">sigismember</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//  set 我们希望制造的信号屏蔽字</span></span><br><span class="line">  <span class="keyword">sigset_t</span> <span class="built_in">set</span>;	</span><br><span class="line">  <span class="keyword">sigset_t</span> oldset;</span><br><span class="line">  sigemptyset(&amp;<span class="built_in">set</span>);	<span class="comment">//  清0</span></span><br><span class="line">  sigaddset(&amp;<span class="built_in">set</span>,SIGINT);	<span class="comment">//  屏蔽 SIGINT</span></span><br><span class="line">  sigaddset(&amp;<span class="built_in">set</span>,SIGQUIT);<span class="comment">//  屏蔽 SIGQUIT</span></span><br><span class="line">  <span class="comment">//  这些信号被加入了set，而后set又被添加进PCB的信号屏蔽字，因此如果之后内核对这个进程发出了SIGINT 和 SIGQUIT信号，内核不会处理。因此未决信号集中会出现这两个信号</span></span><br><span class="line">  <span class="keyword">int</span> ret = sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,&amp;oldset);	<span class="comment">//  SIG_BLOCK 向PCB中的信号屏蔽字加入set</span></span><br><span class="line">  <span class="keyword">if</span>(ret==<span class="number">-1</span>) sys_err(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">  <span class="keyword">sigset_t</span> pending_set;	<span class="comment">//  未决信号集</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    sigpending(&amp;pending_set);	<span class="comment">// 读取当前进程的未决信号集</span></span><br><span class="line">    print_pending_set(&amp;pending_set);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./sig_shc.out </span><br><span class="line"><span class="number">0000000000000000000000000000000</span></span><br><span class="line"><span class="number">0000000000000000000000000000000</span></span><br><span class="line">^C0100000000000000000000000000000 ctrl + c  SIGINT</span><br><span class="line"><span class="number">0100000000000000000000000000000</span></span><br><span class="line">^\<span class="number">0110000000000000000000000000000</span> ctrl + \  SIGQUI</span><br><span class="line"><span class="number">0110000000000000000000000000000</span></span><br><span class="line">^Z                                 ctrl + z SIGTSTP</span><br><span class="line">[<span class="number">4</span>]+  已停止               ./sig_shc.out</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="捕捉"><a href="#捕捉" class="headerlink" title="捕捉"></a>捕捉</h2><h3 id="内核实现捕捉过程"><a href="#内核实现捕捉过程" class="headerlink" title="内核实现捕捉过程"></a>内核实现捕捉过程</h3><p><img src="/2021/11/30/Linux-%E4%BF%A1%E5%8F%B7/2021-12-01-09-40-14.png"></p>
<ul>
<li><code>signal signaction</code> 注册。捕捉的动作不是他完成的</li>
</ul>
<h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><ul>
<li><code>sighandler_t signal(int signum, sighandler_t handler);</code><ul>
<li><code>signum：</code>要捕捉信号</li>
<li><code>handler：</code>相应处理函数</li>
<li><code>return：</code>上一个处理函数</li>
</ul>
</li>
<li><code>typedef void (*sighandler_t)(int)</code><ul>
<li>先看<code>sighandler_t</code> ：是一个指针变量。并且是函数指针，指向返回类型为void 参数为int的一个函数。</li>
<li><code>typedef</code>：前面有一个<code>typedef</code>，就将这个指针变量定义成一个指针类型而不再是一个变量，类型的名字就叫<code>sighandler_t</code>，返回void 参数int。</li>
</ul>
</li>
</ul>
<h3 id="signaction"><a href="#signaction" class="headerlink" title="signaction"></a>signaction</h3><ul>
<li><code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact);</code></li>
<li><code>sigaction</code>结构体<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">The sigaction structure is defined as something like:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); abandon</span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;           一般为<span class="number">0</span>   用来设置捕捉信号期间的信号屏蔽字   </span><br><span class="line">    <span class="keyword">int</span>        sa_flags;          一般为<span class="number">0</span>   默认屏蔽当前捕捉信号</span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);  abandon</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>使用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">#include &lt;signal.h&gt;</span></span><br><span class="line"><span class="comment">signal + action </span></span><br><span class="line"><span class="comment">注册捕捉信号的函数</span></span><br><span class="line"><span class="comment">int sigaction(int signum, const struct sigaction *act,</span></span><br><span class="line"><span class="comment">                struct sigaction *oldact);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct sigaction &#123;</span></span><br><span class="line"><span class="comment">    void     (*sa_handler)(int);</span></span><br><span class="line"><span class="comment">    void     (*sa_sigaction)(int, siginfo_t *, void *); // abandon</span></span><br><span class="line"><span class="comment">    sigset_t   sa_mask;</span></span><br><span class="line"><span class="comment">    int        sa_flags;</span></span><br><span class="line"><span class="comment">    void     (*sa_restorer)(void);  // abandon</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// printf(&quot;kkkkkkk\n&quot;);</span></span><br><span class="line">    <span class="keyword">if</span>(signo==SIGQUIT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch SIGQUI\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(signo==SIGINT)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch SIGINT\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,<span class="title">oldact</span>;</span></span><br><span class="line">    <span class="comment">//  准备act</span></span><br><span class="line">    act.sa_handler = <span class="keyword">catch</span>;    <span class="comment">// 回调函数</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;  <span class="comment">// 设置默认属性, 本信号自动屏蔽</span></span><br><span class="line">    sigemptyset(&amp;act.sa_mask); <span class="comment">// 设置捕捉函数执行期间屏蔽字 一般为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  注册捕捉SIGQUIT信号</span></span><br><span class="line">    <span class="keyword">int</span> ret = sigaction(SIGQUIT,&amp;act,&amp;oldact);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)&#123;perror(<span class="string">&quot;sigaction&quot;</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="comment">//  注册捕捉SIGINT信号</span></span><br><span class="line">    sigaction(SIGINT,&amp;act,&amp;oldact);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./sigaction_shc.out </span><br><span class="line">^Ccatch SIGINT</span><br><span class="line">^\<span class="keyword">catch</span> SIGQUI</span><br><span class="line">^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^Ccatch SIGINT</span><br><span class="line">^\<span class="keyword">catch</span> SIGQUI</span><br><span class="line">^\^\^\^\^\^\^C^C^C^C^Ccatch SIGQUI</span><br><span class="line"><span class="keyword">catch</span> SIGINT</span><br><span class="line">^Ccatch SIGINT</span><br><span class="line">^\<span class="keyword">catch</span> SIGQUI</span><br><span class="line">^Z</span><br><span class="line">[<span class="number">2</span>]+  已停止               ./sigaction_shc.out</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><strong>信号捕捉特性：</strong><ul>
<li>捕捉函数执行期间，信号屏蔽字 由 <code>PCB</code>控制块中的<code>mask --&gt; sigaction</code>结构体中的<code>sa_mask</code> , 捕捉函数执行结束。 恢复为<code>mask</code></li>
<li>捕捉函数执行期间，本信号自动被屏蔽—<code>(sa_flags = 0)</code>.</li>
<li>信号<strong>不支持排队</strong>，捕捉函数执行期间，被屏蔽信号多次发送，解除屏蔽后只处理一次。</li>
</ul>
</li>
</ul>
<h2 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h2><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><ul>
<li><p>子进程终止时</p>
</li>
<li><p>子进程接收到 <code>SIGSTOP</code> 信号停止时</p>
</li>
<li><p>子进程处在停止态，接受到 <code>SIGCONT</code> 后唤醒时</p>
<h3 id="利用SIGCHLD回收子进程"><a href="#利用SIGCHLD回收子进程" class="headerlink" title="利用SIGCHLD回收子进程"></a>利用SIGCHLD回收子进程</h3></li>
<li><p> 回收子进程常见方案，一定要会： 利用信号机制去回收子进程，防止使用execlp等而无法回收子线程的情况</p>
</li>
<li><p><strong>思路1：</strong></p>
<ul>
<li> 直接设置<code>signal(SIGCHLD,SIG_IGN)</code>忽略这个信号即可。系统就懂了我们不需要残留的信息，直接释放残留资源。</li>
</ul>
</li>
<li><p><strong>思路2：</strong></p>
<ul>
<li> 在父进程中注册<code>SIGCHLD</code>信号，回调函数里负责循环回收死掉的子进程。</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>回收用<code>while</code>不用<code>if</code><ul>
<li> 使用<code>while</code>，防止僵尸进程 如果使用<code>if</code>的话，在处理一个进程A死亡的<code>SIGHCLD</code>信号时，可能会有另几个进程B,C,D死亡也使得内核发送<code>SIGCHLD</code>信号，这时<code>SIGCHLD</code>信号已经被屏蔽，所以进程B,C,D的<code>SIGCHLD</code>信号在未决信号集中只有一次（信号不支持排队）。所以之后如果用if也只能处理掉BCD中的一个进程，所以会出现僵尸进程。</li>
</ul>
</li>
<li>改进<ul>
<li> 如果在父进程还没有注册这个信号的处理函数时，子进程就全部死亡，之后就是注册了也不会有<code>SIGCHLD</code>去激活这个函数，那么就不会起到回收子进程的作用，怎么办？</li>
<li> 在注册之前，屏蔽<code>（SIG_BLOCK)SIGCHLD</code>，使得如果有<code>SIGCHLD</code>产生，那么就一直不处理，留在未决信号集中，等到注册完毕，解除<code>(SIG_UNBLOCK)</code>对<code>SIGCHLD</code>的屏蔽即可。</li>
</ul>
</li>
</ul>
</li>
<li><p>一些问题</p>
<ul>
<li> <code>wait waitpid</code>阻塞等待时会让出cpu资源么？</li>
<li> 那么在这里这样看是不是阻塞要比waitpid非阻塞好？waitpid不会阻塞，会一直while循环，不让出cpu资源。</li>
</ul>
</li>
<li><p>代码</p>
<ul>
<li><p>无注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  回收子进程比较好的方案，一定要会！！： 利用信号机制去回收子进程，防止使用execlp而无法回收子线程的情况</span></span><br><span class="line"><span class="comment">//  利用的信号：SIGCHLD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> signo)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">// while((wpid=wait(&amp;status)))</span></span><br><span class="line">    <span class="comment">// while((wpid=waitpid(-1,&amp;status,0)!=-1))</span></span><br><span class="line">    <span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG))!=<span class="number">-1</span>)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(wpid==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d exit with %d\n&quot;</span>,wpid,WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d killed with %d\n&quot;</span>,wpid,WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  设置PCB中的mask屏蔽字屏蔽SIGCHLD</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//  在进行主函数逻辑之前</span></span><br><span class="line">        <span class="comment">//  注册信号处理函数 来 处理捕捉信号</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  准备act</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_handler = <span class="keyword">catch</span>;    </span><br><span class="line">        act.sa_flags = <span class="number">0</span>;  </span><br><span class="line">        sigemptyset(&amp;act.sa_mask); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注册捕捉信号的处理函数  </span></span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解除屏蔽</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  模拟后序逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child id = %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./signal_to_catch_child.out </span><br><span class="line">i am child id = 8585</span><br><span class="line">i am child id = 8586</span><br><span class="line">i am child id = 8589</span><br><span class="line">i am child id = 8588</span><br><span class="line">i am child id = 8587</span><br><span class="line">i am child id = 8590</span><br><span class="line">i am child id = 8593</span><br><span class="line">i am child id = 8591</span><br><span class="line">i am child id = 8594</span><br><span class="line">i am child id = 8592</span><br><span class="line">child 8585 <span class="built_in">exit</span> with 0</span><br><span class="line">child 8586 <span class="built_in">exit</span> with 1</span><br><span class="line">child 8587 <span class="built_in">exit</span> with 2</span><br><span class="line">child 8588 <span class="built_in">exit</span> with 3</span><br><span class="line">child 8589 <span class="built_in">exit</span> with 4</span><br><span class="line">child 8590 <span class="built_in">exit</span> with 5</span><br><span class="line">child 8591 <span class="built_in">exit</span> with 6</span><br><span class="line">child 8592 <span class="built_in">exit</span> with 7</span><br><span class="line">child 8593 <span class="built_in">exit</span> with 8</span><br><span class="line">child 8594 <span class="built_in">exit</span> with 9</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></li>
<li><p>注释</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  回收子进程比较好的方案，一定要会！！： 利用信号机制去回收子进程，防止使用execlp而无法回收子线程的情况</span></span><br><span class="line"><span class="comment">//  利用的信号：SIGCHLD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch</span><span class="params">(<span class="keyword">int</span> signo)</span>   <span class="comment">//  signo 当前处理的信号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="comment">// while((wpid=wait(&amp;status)))</span></span><br><span class="line">    <span class="comment">// while((wpid=waitpid(-1,&amp;status,0)!=-1))</span></span><br><span class="line">    <span class="keyword">while</span>((wpid=waitpid(<span class="number">-1</span>,&amp;status,WNOHANG))!=<span class="number">-1</span>)   <span class="comment">//  使用while，防止僵尸进程 如果使用if的话，在处理一个进程A死亡的SIGHCLD信号时，可能会有另几个进程B,C,D死亡也使得内核发送SIGCHLD信号，这时SIGCHLD信号已经被屏蔽，所以进程B,C,D的SIGCHLD信号在未决信号集中只有一次（信号不支持排队）。所以之后如果用if也只能处理掉BCD中的一个进程，所以会出现僵尸进程。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(wpid==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d exit with %d\n&quot;</span>,wpid,WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child %d killed with %d\n&quot;</span>,wpid,WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( ;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((pid=fork())==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  设置PCB中的mask屏蔽字屏蔽SIGCHLD</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>,SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//  在进行主函数逻辑之前</span></span><br><span class="line">        <span class="comment">//  注册信号处理函数 来 处理捕捉信号</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  准备act</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_handler = <span class="keyword">catch</span>;    <span class="comment">//  设置处理函数</span></span><br><span class="line">        act.sa_flags = <span class="number">0</span>;  <span class="comment">//  默认属性 屏蔽当前捕捉信号</span></span><br><span class="line">        sigemptyset(&amp;act.sa_mask); <span class="comment">//  设置处理信号期间屏蔽字</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注册捕捉信号的处理函数  </span></span><br><span class="line">        sigaction(SIGCHLD,&amp;act,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解除屏蔽</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK,&amp;<span class="built_in">set</span>,<span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  模拟后序逻辑</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child id = %d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  改进</span></span><br><span class="line"><span class="comment">//  如果在父进程还没有注册这个信号的处理函数时，子进程就全部死亡，之后就是注册了也不会有SIGCHLD去激活这个函数，那么就不会起到回收子进程的作用，怎么办？</span></span><br><span class="line"><span class="comment">//  在注册之前，屏蔽调SIGCHLD，使得如果有SIGCHLD产生，那么就一直不处理，留在未决信号集中，等到注册完毕，解除(sigdel)对SIGCHLD的屏蔽即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  一些问题</span></span><br><span class="line"><span class="comment">//  wait waitpid阻塞等待时会让出cpu资源么？</span></span><br><span class="line"><span class="comment">//  那么在这里这样看是不是阻塞要比waitpid非阻塞好？waitpid不会阻塞，会一直while循环</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果不先屏蔽<code>SIGCHLD</code>，那么结果如下。只有父进程死亡后，整个地址空间都会被销毁，僵尸子进程才没了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./signal_to_catch_child2.out</span><br><span class="line">i am child id = 8875</span><br><span class="line">i am child id = 8876</span><br><span class="line">i am child id = 8878</span><br><span class="line">i am child id = 8879</span><br><span class="line">i am child id = 8877</span><br><span class="line">i am child id = 8880</span><br><span class="line">i am child id = 8883</span><br><span class="line">i am child id = 8881</span><br><span class="line">i am child id = 8884</span><br><span class="line">i am child id = 8882</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">ps ajx</span><br><span class="line">Z：僵尸。defunct：僵尸</span><br><span class="line">  8371   8874   8874   8371 pts/1      8874 R+    1000   0:42 ./signal_to_catch_child2.out</span><br><span class="line">  8874   8875   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8876   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8877   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8878   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8879   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8880   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8881   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8882   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8883   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line">  8874   8884   8874   8371 pts/1      8874 Z+    1000   0:00 [signal_to_catch] &lt;defunct&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>SIGCHLD</code> 信号注意问题</p>
<ul>
<li>子进程继承父进程的信号屏蔽字和信号处理动作，但子进程没有继承未决信号集 <code>pending。</code></li>
<li>注意注册信号捕捉函数的位置。</li>
<li>应该在 <code>fork</code> 之前，阻塞 <code>SIGCHLD</code> 信号。注册完捕捉函数后解除阻塞。</li>
</ul>
</li>
</ul>
<ul>
<li><blockquote>
<p><strong>子进程结束 对status的如何处理</strong></p>
</blockquote>
<ul>
<li><code>pid_t waitpid(pid_t pid, int *status, int options)</code></li>
<li><code>options</code>：<ul>
<li><code>WNOHANG</code>：没有子进程结束，立即返回</li>
<li><code>WUNTRACED</code>：如果子进程由于被停止产生的 <code>SIGCHLD</code>，<code>waitpid</code> 则立即返回</li>
<li><code>WCONTINUED</code>：如果子进程由于被 <code>SIGCONT</code> 唤醒而产生的 <code>SIGCHLD，waitpid</code> 则立即返回</li>
</ul>
</li>
<li><code>status：</code><ul>
<li><code>WIFEXITED(status)</code>：子进程正常 <code>exit</code> 终止，返回真</li>
<li><code>WEXITSTATUS(status)</code>：返回子进程正常退出值</li>
<li><code>WIFSIGNALED(status)</code>：子进程被信号终止，返回真</li>
<li><code>WTERMSIG(status)</code>：返回终止子进程的信号值</li>
<li><code>WIFSTOPPED(status)</code>：子进程被停止，返回真</li>
<li><code>WSTOPSIG(status)</code>：返回停止子进程的信号值</li>
<li><code>WIFCONTINUED(status)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="了解：中断系统调用"><a href="#了解：中断系统调用" class="headerlink" title="了解：中断系统调用"></a>了解：中断系统调用</h2><ul>
<li><p>系统调用可分为两类：慢速系统调用和其他系统调用。</p>
<ul>
<li>慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，<code>read、write、pause、wait...</code></li>
<li>其他系统调用：<code>getpid、getppid、fork...</code></li>
</ul>
</li>
<li><p>结合 <code>pause</code>，回顾慢速系统调用：</p>
<ul>
<li>慢速系统调用被中断的相关行为，实际上就是 <code>pause</code> 的行为： 如，<code>read</code></li>
<li>① 想中断 <code>pause</code>，信号不能被屏蔽。</li>
<li>② 信号的处理方式必须是捕捉 (默认、忽略都不可以)</li>
<li>③ 中断后返回-1， 设置 <code>errno</code> 为 <code>EINTR</code>(表“被信号中断”)</li>
<li>可修改 <code>sa_flags</code> 参数来设置被信号中断后系统调用是否重<ul>
<li><code>SA_INTERRURT</code> 不重启。 <code>SA_RESTART</code> 重启。</li>
</ul>
</li>
</ul>
</li>
<li><p>扩展了解：<br><code>sa_flags</code> 还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该<br>信号，可将 <code>sa_flags</code> 设置为 <code>SA_NODEFER</code>，除非 <code>sa_mask</code> 中包含该信号</p>
</li>
<li><p>以上了解摘自牛客讲义,APUE上也有，好多，有时间再看吧</p>
</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li>一些问题<ul>
<li> <code>wait</code> <code>waitpid</code>阻塞等待时会让出<code>cpu</code>资源么？</li>
<li> 那么在这里这样看是不是阻塞要比<code>waitpid</code>非阻塞好？<code>waitpid</code>不会阻塞，会一直<code>while</code>循环，不让出<code>cpu</code>资源</li>
</ul>
</li>
<li><code>wait(NULL)</code>与<code>signal(SIGCHLD,SIG_IGN)</code>区别？<ul>
<li>我认为，前者可以保证子进程一定会运行完再进行主进程，后者子进程不一定运行完，父进程就结束了。</li>
</ul>
</li>
</ul>
<h2 id="关于SIG-ING处理SIGCHLD不会造成僵尸"><a href="#关于SIG-ING处理SIGCHLD不会造成僵尸" class="headerlink" title="关于SIG_ING处理SIGCHLD不会造成僵尸"></a>关于SIG_ING处理SIGCHLD不会造成僵尸</h2><ul>
<li><code>SIGCHLD</code>默认处理方式是忽略，但是我们还是要显示写出来<code>signal(SIGCHLD,SIG_IGN)</code>才可以</li>
<li>所以那在处理死去的进程时，如果不需要获取这个死去进程的信息，就不需要<code>wait</code>。直接<code>signal(SIGCHLD，SIG_IGN)</code>就可以让这个死去的子进程被释放残留资源从而不变成僵尸进程</li>
<li><code>wait notes</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT flag is set for SIGCHLD [signal(SIGCHLD,SIG_IGN)](see</span><br><span class="line">    sigaction(2)), then children that terminate do not become zombies and a call to wait() or  waitpid()  will  block  until  all</span><br><span class="line">    children  have terminated, and then fail with errno set to ECHILD. </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	signal(SIGCHLD,SIG_IGN);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; i am parent \n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am %d child\n&quot;</span>,i);</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d die\n&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps ajx也没有僵尸进程</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./test01_wait.out </span><br><span class="line">i am <span class="number">0</span> child</span><br><span class="line">i am <span class="number">1</span> child</span><br><span class="line"> i am parent </span><br><span class="line">i am <span class="number">2</span> child</span><br><span class="line">i am <span class="number">3</span> child</span><br><span class="line">i am <span class="number">4</span> child</span><br><span class="line"><span class="number">0</span> die</span><br><span class="line"><span class="number">1</span> die</span><br><span class="line"><span class="number">2</span> die</span><br><span class="line"><span class="number">3</span> die</span><br><span class="line"><span class="number">4</span> die</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-守护进程</title>
    <url>/2021/12/02/Linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>Linux守护进程</p>
<span id="more"></span>

<ul>
<li>参考APUE、<a href="https://www.cnblogs.com/ybf-yyj/p/9104412.html">博客园</a></li>
</ul>
<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><ul>
<li>&amp;<ul>
<li><code>./a.out &amp;</code> ：释放对终端的占用。在后台运行</li>
</ul>
</li>
<li>jobs<ul>
<li>列出在后台运行的进程：<code>running stopped terminated</code>。jobs -l可以列出pid</li>
</ul>
</li>
<li>ctrl + z  挂起<ul>
<li>用户终端向正在运行中的由该终端启动的程序发出SIGTSTP信号。默认动作为暂停进程（并未结束）。并将该进程放到后台。（停止终端交互进程的运行。）</li>
</ul>
</li>
<li>bg<ul>
<li>启动在后台暂停的运行，并使得其在后台运行。</li>
<li>如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)</li>
<li>将任务转移到后台运行：先ctrl + z；再bg，这样进程就被移到后台运行，终端还能继续接受命令。</li>
</ul>
</li>
<li>fg<ul>
<li>将在后台暂停/运行的进程，调到前台来，使其占据终端。</li>
</ul>
</li>
<li>ctrl + c 终止<ul>
<li>用户终端向正在运行中的由该终端启动的程序发出SIGINT信号。默认动作为终止进程。</li>
</ul>
</li>
<li>ctrl + \ 退出<ul>
<li>用户终端向正在运行中的由该终端启动的程序发出SIGQUIT。默认动作为终止进程。</li>
</ul>
</li>
<li>ctrl + d<ul>
<li>输入文件结束符EOF</li>
</ul>
</li>
<li>pstree<ul>
<li>查看进程树</li>
</ul>
</li>
<li>概念：当前任务<ul>
<li>如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]” 的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”和“stop”等命令时，如果不加任何引号，则所变动的均是当前任务</li>
</ul>
</li>
<li>参考<a href="https://www.cnblogs.com/ybf-yyj/p/9104412.html">博客园</a></li>
</ul>
<h2 id="进程组与会话"><a href="#进程组与会话" class="headerlink" title="进程组与会话"></a>进程组与会话</h2><ul>
<li>进程组是一堆相关进程的集合；会话是一堆相关进程组的集合。</li>
</ul>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><ul>
<li>进程组是一个或者多个进程的集合。通常他们在同一作业中结合起来。</li>
<li>同一进程组的各进程接收来自同一终端的各种信号。每个进程组有位移的进程组ID。函数<code>pid_t getpgrp(void);</code>可以返回调用进程的进程组ID。</li>
<li>每个进程组有一个组长进程。<strong>进程组ID等于其组长进程的进程ID</strong></li>
<li>进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要进程组中有一个进程存在，那么这个进程组就存在，与组长进程是否终止无关。</li>
<li>进程调用setpgid可以加入一个现有的进程组或者创建一个新进程组。<ul>
<li><code>int setpgid(pid_t pid,pid_t pgid)</code></li>
<li>该函数将pid进程的进程组号设置为pgid，如果pid=pgid，则该pid进程成为组长进程。如果pid=0，即为getpid()；pgid-0，即为pid作为进程组pgid。</li>
<li>成功0，失败-1。</li>
</ul>
</li>
<li>一个进程只能为他或者他的子进程设置组进程pgid。在它的子进程调用exec后，他就不再更改子进程的进程组ID<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ps ajx</span><br><span class="line">  PPID    PID   PGID    SID TTY       TPGID STAT   UID   TIME COMMAND</span><br><span class="line">     <span class="number">0</span>      <span class="number">1</span>      <span class="number">1</span>      <span class="number">1</span> ?            <span class="number">-1</span> Ss       <span class="number">0</span>   <span class="number">0</span>:<span class="number">03</span> /sbin/init splash</span><br><span class="line"></span><br><span class="line">PPID：是程序的父进程号。</span><br><span class="line"></span><br><span class="line">PID：进程的唯一标识。如果一个进程含有多个线程，所有线程调用 getpid 函数会返回相同的值。</span><br><span class="line"></span><br><span class="line">PGID：进程组 ID。每个进程都会有进程组 ID，表示该进程所属的进程组。默认情况下新创建的进程会继承父进程的进程组 ID。</span><br><span class="line"></span><br><span class="line">SID：会话 ID。每个进程也都有会话 ID。默认情况下，新创建的进程会继承父进程的会话 ID。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><ul>
<li>会话是一个或者多个进程组的集合。<br><img src="/2021/12/02/Linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/2021-12-02-14-09-28.png"></li>
<li><code>pid_t setsid(void);</code><ul>
<li>如果调用此函数的进程不是一个进程组组长，那么此函数创建一个新会话。<ul>
<li>该进程会变成新会话的会话首进程（会话首进程是创建该会话的进程）。此时，该进程是新会话中的唯一进程。</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如果在调用setsid之前改进昵称有一个控制终端，那么这种联系也被切断。<ul>
<li>即会话首进程不占有控制终端。只有会话中的前台进程组才占有终端。！</li>
</ul>
</li>
</ul>
</li>
<li>如果该调用进程是一个进程组组长，则此函数返回出错。</li>
<li>所以通常先fork，使其父进程终止，而子进程继续，因为子进程继承父进程的进程组ID，而其进程ID是新分配的，两者不可能相等，这就保证了子进程不是一个进程组组长。</li>
</ul>
</li>
<li>Single UNIX 没有类似于进程组ID的会话ID，由于会话首进程是具有唯一进程ID的单个进程，所以可以将会话首进程的进程ID视为会话ID。</li>
<li>SVR4引入会话ID。<ul>
<li><code>pid_t getsid(pid_t pid);</code></li>
<li>返回pid进程的会话首进程的进程组ID。pid=0，则返回调用进程的。</li>
<li>若pid不属于调用者所在会话，那么就不能得到会话ID。</li>
</ul>
</li>
<li>尽量避免使用“会话ID”，而是称其为“会话首进程的进程组ID”。会话首进程总是一个进程组的组长进程，素以两者等价。</li>
</ul>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><ul>
<li>一般情况下 session 和终端是一对一的关系，当我们打开多个终端窗口时，实际上就创建了多个 session。</li>
<li><code>./a.out &amp;</code>。表示将命令放入后台执行。这样该命令对应的进程组即为后台进程组。</li>
<li>shell 中可以存在多个进程组，无论是前台进程组还是后台进程组，它们或多或少存在一定的联系，为了更好地控制这些进程组（或者称为作业），系统引入了会话的概念。</li>
<li><strong>会话（Session）的意义在于将很多的工作集中在一个终端，选取其中一个作为前台来直接接收终端的输入及信号，其他的工作则放在后台执行。</strong></li>
<li>以上几点参考<a href="https://rongweihe.github.io/">博客.io</a><br><img src="/2021/12/02/Linux-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/2021-12-02-14-31-39.png"></li>
<li>一个会话可以有一个控制终端（ controlling terminal）。这通常是我们在其上登录的终端设备（终端登录情况）或伪终端设备（网络登录情况）。</li>
<li>建立与控制终端连接的会话首进程，被称之为控制进程（controlling process）。</li>
<li><strong>一个会话的几个进程组可被分成一个前台进程组（foreground process group）以及一个或几个后台进程组（background process group）。</strong><ul>
<li>在任意时刻，可能同时存在多个后台进程组，但是不管什么时候都只能有一个前台进程组。</li>
</ul>
</li>
<li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组则为后台进程组。</li>
<li>无论何时键入中断键（常常是DELETE或Ctrl - C）或退出键（常常是Ctrl - \），就会造成将中断信号或退出信号<strong>送至前台进程组的所有进程。</strong><ul>
<li><strong>只有在前台进程组中进程才能在控制终端读取输入</strong>。当用户在终端输入信号生成终端字符（如 ctrl+c、ctrl+z、ctr+\等）时，对应的信号只会发送给前台进程组。从前台进程组的输出也会显示在控制终端上。</li>
</ul>
</li>
<li>如果终端界面检测到调制解调器已经脱开连接，则将挂断信号送至控制进程（会话首进程。）</li>
</ul>
<h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><ul>
<li>作业：几个进程的集合，通常是一个进程管道<ul>
<li><code>vim main.c</code><ul>
<li>在前台起到了只有一个进程组成的作业。</li>
</ul>
</li>
<li><code>pr *.c | lpr &amp;       。      make all &amp;</code><ul>
<li>在后台启动两个作业。后台运行。</li>
<li>使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组</li>
</ul>
</li>
</ul>
</li>
<li>以后补充。</li>
</ul>
<h2 id="守护（daemon）进程"><a href="#守护（daemon）进程" class="headerlink" title="守护（daemon）进程"></a>守护（daemon）进程</h2><ul>
<li>系统引导装入时启动，系统关闭时终止。</li>
<li>由于无控制终端，所以说是在后台运行的。</li>
</ul>
<ul>
<li>创建守护进程<ul>
<li>关键<ul>
<li>创建会话Session</li>
</ul>
</li>
<li>流程<ul>
<li>fork之后，父进程exit。<ul>
<li>进程组组长不能创建会话</li>
</ul>
</li>
<li>setsid子进程创建会话。<ul>
<li><code>pid_t setsid()</code></li>
<li>子进程成为新的会话的首进程</li>
<li>子进程成为一个新进程组的组长</li>
<li>子进程脱离控制终端，在后台运行</li>
</ul>
</li>
<li>chdir更改工作目录<ul>
<li><code>int chdir(const char *path);</code></li>
<li>root用户才有权限</li>
</ul>
</li>
<li>umask设置文件权限掩码<ul>
<li><code>mode_t umask(mode_t mask);</code></li>
<li>将文件模式创建屏蔽字设置为一个已知值。（通常为0）。由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限。</li>
</ul>
</li>
<li>关闭非必要文件描述符<ul>
<li>继承的打开文件不会用到，浪费系统资源，无法卸载</li>
</ul>
</li>
<li>某些进程打开/dev/null 赋值给 stdin ，stdout ，stderr。<ul>
<li><blockquote>
<p>任何一个试图读取标准输入、写标准输出或标准错误的库例程都不会产生任何效果。因为守护进程不予终端设备相关联，所以其输出无处显示，也无处从交互式用户那里接收输入。</p>
</blockquote>
</li>
<li><blockquote>
<p>即使守护进程是从交互式会话启动的，但是守护进程是在后台运行的，所以登录会话的终止不会影响守护进程。如果其他用户在同一终端设备上登录，我们不希望再该终端上见到守护进程的输出，用户也不期望他们在终端上的输入被守护进程读取。</p>
</blockquote>
</li>
<li><blockquote>
<p>APUE</p>
</blockquote>
</li>
</ul>
</li>
<li>开始执行守护进程核心工作守护进程退出处理程序模型</li>
</ul>
</li>
</ul>
</li>
<li><strong>问题？</strong><ul>
<li>守护进程处理SIGCHLD信号。</li>
<li><blockquote>
<p>处理SIGCHLD信号<br>处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果<strong>父进程不对残留信息进行处理</strong>，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程wait子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。</p>
</blockquote>
</li>
<li><code>signal(SIGCHLD,SIG_IGN);</code></li>
<li>SIG_IGN即我们不关心这个信号，系统也就懂了我们不关心它的死法。子进程死亡的话则直接释放资源即可。没死的话，也是忽略。</li>
<li>详情见进程–<code>wait</code>和信号–<code>SIGCHLD</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. fork，父进程exit。（为了创建会话）</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  2. setsid()创建会话。当前子进程成为会话首进程，接着成为新进程族的组长进程，并且没有控制终端</span></span><br><span class="line">    <span class="comment">//  为了满足dameon的”在后台运行” 。（由于会话首进程无控制终端，所以说是在后台运行的。）</span></span><br><span class="line">    pid = setsid();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>) </span><br><span class="line">        sys_err(<span class="string">&quot;pid error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  3. 改变工作目录。防止被卸载。</span></span><br><span class="line">    <span class="comment">//  为了满足daemon进程的“系统引导装入时启动，系统关闭时终止。”</span></span><br><span class="line">    <span class="comment">//  sudo 只有根目录才有权限切换</span></span><br><span class="line">    <span class="comment">//  并且我实验当前虚拟机关机重启之后那个dameon进程就没了</span></span><br><span class="line">    <span class="comment">//  感觉因为守护进程在系统引导装入时启动，系统关闭时终止。</span></span><br><span class="line">    <span class="comment">//  而如果是一个用户远程登陆linux系统的话，那么这个用户退出登陆之后，不会影响这个daemon进程</span></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(<span class="string">&quot;/root&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>)</span><br><span class="line">       sys_err(<span class="string">&quot;chdir error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4.  改变权限</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  5.  关闭文件描述符</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  6.  打开null，重定向文件描述符号</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">    dup2(fd,STDOUT_FILENO);</span><br><span class="line">    dup2(fd,STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);   <span class="comment">//  模拟守护进程业务</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ sudo ./daemon_shc.out </span><br><span class="line">[sudo] shc 的密码： </span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ps ajx</span><br><span class="line">  <span class="number">1624</span>   <span class="number">2730</span>   <span class="number">2730</span>   <span class="number">2730</span> ?            <span class="number">-1</span> Rs       <span class="number">0</span>   <span class="number">0</span>:<span class="number">20</span> ./daemon_shc.out</span><br></pre></td></tr></table></figure>

<h2 id="manpage阅读"><a href="#manpage阅读" class="headerlink" title="manpage阅读"></a>manpage阅读</h2><ul>
<li>umask<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       <span class="built_in">umask</span> - <span class="built_in">set</span> file mode creation mask</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line">       <span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line">       mode_t <span class="built_in">umask</span>(mode_t mask);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       <span class="built_in">umask</span>() sets the calling process<span class="string">&#x27;s file mode creation mask (umask) to mask &amp; 0777 (i.e., only the file permission bits of mask are used), and returns the previous value of the mask.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The  umask  is  used  by  open(2), mkdir(2), and other system calls that create files to modify the permissions placed on newly created files or directories.  Specifically, permissions in the</span></span><br><span class="line"><span class="string">       umask are turned off from the mode argument to open(2) and mkdir(2).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Alternatively, if the parent directory has a default ACL (see acl(5)), the umask is ignored, the default ACL is inherited, the permission bits are set based on the inherited ACL, and  permis‐</span></span><br><span class="line"><span class="string">       sion bits absent in the mode argument are turned off.  For example, the following default ACL is equivalent to a umask of 022:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           u::rwx,g::r-x,o::r-x</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       Combining the effect of this default ACL with a mode argument of 0666 (rw-rw-rw-), the resulting file permissions would be 0644 (rw-r--r--).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The constants that should be used to specify mask are described in inode(7).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       The typical default value for the process umask is S_IWGRP | S_IWOTH (octal 022).  In the usual case where the mode argument to open(2) is specified as:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       (octal 0666) when creating a new file, the permissions on the resulting file will be:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       (because 0666 &amp; ~022 = 0644; i.e., rw-r--r--).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RETURN VALUE</span></span><br><span class="line"><span class="string">       This system call always succeeds and the previous value of the mask is returned.</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程补充"><a href="#进程补充" class="headerlink" title="进程补充"></a>进程补充</h2><ul>
<li>进程是系统分配资源的最小单位。</li>
<li><code>pstree</code>查看进程家族树<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemd─┬─ModemManager───2*[&#123;ModemManager&#125;]</span><br><span class="line">        ├─NetworkManager─┬─dhclient</span><br><span class="line">        │                └─2*[&#123;NetworkManager&#125;]</span><br><span class="line">        ├─VGAuthService</span><br><span class="line">        ├─accounts-daemon───2*[&#123;accounts-daemon&#125;]</span><br><span class="line">        ├─acpid</span><br><span class="line">        ├─avahi-daemon───avahi-daemon</span><br><span class="line">        ├─boltd───2*[&#123;boltd&#125;]</span><br><span class="line">        ├─colord───2*[&#123;colord&#125;]</span><br><span class="line">        ├─cron</span><br><span class="line">        ├─cups-browsed───2*[&#123;cups-browsed&#125;]</span><br><span class="line">        ├─cupsd</span><br><span class="line">        ├─dbus-daemon</span><br><span class="line">        ├─fwupd───4*[&#123;fwupd&#125;]</span><br><span class="line">        ├─gdm3─┬─gdm-session-wor─┬─gdm-wayland-ses─┬─gnome-session-b─┬─gnome-shell─┬─Xwayland───8*[&#123;Xwayland&#125;]</span><br><span class="line">        │      │                 │                 │                 │             ├─ibus-daemon─┬─ibus-dconf───3*[&#123;ibus-dconf&#125;]</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-线程</title>
    <url>/2021/12/03/Linux-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>Linux线程（未完）</p>
<span id="more"></span>

<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>线程间共享<ul>
<li>bss。全局变量？、</li>
</ul>
</li>
<li>线程间不共享</li>
</ul>
<h2 id="控制原语"><a href="#控制原语" class="headerlink" title="控制原语"></a>控制原语</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><h4 id="pthread-ceate"><a href="#pthread-ceate" class="headerlink" title="pthread_ceate"></a><code>pthread_ceate</code></h4><ul>
<li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg)</code></li>
<li><code>pthread_t *thread</code>：传出参数，表新创建的子线程 id</li>
<li><code>const pthread_attr_t *attr</code>：线程属性。传 NULL 表使用默认属性。</li>
<li><code>void *(*start_routine) (void *)</code>：新线程的线程体。</li>
<li><code>void *arg</code>：线程体的参数。没有的话，传<code>NULL</code><ul>
<li>如果有多个参数，需要将他们放入结构体，然后把结构体地址作为<code>arg</code>参数传入。</li>
</ul>
</li>
<li>返回值：成功：0</li>
<li>失败：直接返回错误码，而非设置<code>errno</code></li>
</ul>
<h4 id="pthread-t-pthread-self-void"><a href="#pthread-t-pthread-self-void" class="headerlink" title="pthread_t pthread_self(void);"></a><code>pthread_t pthread_self(void);</code></h4><ul>
<li><p>获取线程<code>ID</code>。其作用对应进程中 <code>getpid()</code> 函数。</p>
</li>
<li><p>返回值：成功：0； </p>
</li>
<li><p>线程 <code>ID</code>：<code>pthread_t</code></p>
<ul>
<li><code>typedef unsigned long int pthread_t;</code></li>
</ul>
</li>
<li><p>线程 <code>ID </code>是进程内部，识别标志。(不同进程的线程<code>ID</code>可能相同)</p>
</li>
<li><p>检查出错</p>
<ul>
<li><code>fprintf(stderr, &quot;xxx error: %s\n&quot;, strerror(ret));</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                         void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printids</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = getpid();</span><br><span class="line">        <span class="keyword">pthread_t</span> tid = pthread_self();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%lu\n&quot;</span>,s,pid,tid);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">tfn</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        printids(<span class="string">&quot;new thread:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> err = pthread_create(&amp;tid,<span class="literal">NULL</span>,tfn,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        printids(<span class="string">&quot;main thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./pthread_create_shc.out </span><br><span class="line"><span class="keyword">new</span> thread:	<span class="number">3892</span>	<span class="number">139853047412480</span></span><br><span class="line">main thread	<span class="number">3892</span>	<span class="number">139853055936320</span></span><br></pre></td></tr></table></figure>
<ul>
<li>处理主线程和新线程之间关系</li>
<li>主线程休眠，防止新线程还没机会运行整个进程就结束了。</li>
<li>新线程获取<code>ID</code><ul>
<li>通过<code>pthread_self()</code>来获取自己的线程ID，</li>
<li>或者从线程的启动例程中以参数形式接收。</li>
<li>而不是利用<code>pthread_create</code>的第一个参数从共享内存（全局变量<code>tid</code>）读取。<ul>
<li>因为那样不安全。如果新线程在主线程的<code>pthread_create</code>返回前就运行了，那么读到的全局变量<code>tid</code>就是一个还没初始化的数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg)</code></li>
<li>最后一个参数是传给新线程函数体<code>start_routine</code>的参数</li>
<li>注意<code>arg</code>可能会在主线程中发生改变。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不可以 int* -&gt; void* -&gt; int* -&gt;提取int</span></span><br><span class="line"><span class="comment">//  因为传进i的地址 i会在主线城中改变</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  32位 int 4 Byte  指针 4 Byte</span></span><br><span class="line"><span class="comment">//     int -&gt; *  ok 不会丢失数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  64位 int 4 Byte  指针 8 Byte</span></span><br><span class="line"><span class="comment">//     int -&gt; *  ok 不会丢失数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="comment">// int i = *((int*)arg);    wrong！</span></span><br><span class="line">    sleep(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i am the %dth thread , pid = %d , tid = %lu\n&quot;</span>,i,getpid(),pthread_self());  <span class="comment">//pthread_self 返回当前线程ID</span></span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span>*)<span class="number">0</span>);  <span class="comment">//  这就是线程的退出码吧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i!=<span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不可以 int* -&gt; void* -&gt; int 因为传进i的地址 i会在主线城中改变</span></span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_function,(<span class="keyword">void</span>*)i);   </span><br><span class="line">        <span class="keyword">if</span>( ret!=<span class="number">0</span>)</span><br><span class="line">            sys_err(<span class="string">&quot;pthread error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main : i  = %d , pid = %d , tid = %ld\n&quot;</span>,i,getpid(),pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正解</span></span><br><span class="line">i am the <span class="number">0</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684367210240</span></span><br><span class="line">i am the <span class="number">1</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684358817536</span></span><br><span class="line">i am the <span class="number">2</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684350424832</span></span><br><span class="line">i am the <span class="number">3</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684342032128</span></span><br><span class="line">i am the <span class="number">4</span>th thread , pid = <span class="number">4916</span> , tid = <span class="number">140684333639424</span></span><br><span class="line">Main : i  = <span class="number">5</span> , pid = <span class="number">4916</span> , tid = <span class="number">140684375734080</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><ul>
<li>进程中的任意线程调用<code>exit</code>，那么整个进程都会终止。即，如果默认的动作是终止线程，那么发送到线程的信号就会终止整个进程</li>
<li>单个线程退出方式<ul>
<li>线程可以简单的从启动例程中返回，返回值是线程的退出码</li>
<li>线程可以被同一进程的其他线程取消</li>
<li>线程调用<code>pthread_exit</code></li>
</ul>
</li>
</ul>
<h4 id="void-pthread-exit-void-rval-ptr"><a href="#void-pthread-exit-void-rval-ptr" class="headerlink" title="void pthread_exit(void *rval_ptr)"></a><code>void pthread_exit(void *rval_ptr)</code></h4><ul>
<li><code>rval_ptr</code>：表示线程退出状态，通常传 <code>NULL</code></li>
<li><code>pthread_exit</code> 或者 <code>return</code> 返回的指针所指向的内存单元必须是全局的或者是用 <code>malloc</code> 分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。</li>
</ul>
<h4 id="int-pthread-join-pthread-t-thread-void-rval-ptr"><a href="#int-pthread-join-pthread-t-thread-void-rval-ptr" class="headerlink" title="int pthread_join(pthread_t thread, void **rval_ptr);"></a><code>int pthread_join(pthread_t thread, void **rval_ptr);</code></h4><ul>
<li>对比记忆<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程中：main 返回值、exit 参数--&gt;int；等待子进程结束 wait 函数参数--&gt;int *</span><br><span class="line">线程中：线程主函数返回值、pthread_exit--&gt;void *；等待线程结束 pthread_join 函数参数--&gt;void **</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>调用线程将一直阻塞，直到指定线程调用<code>pthread_exit</code>、从启动例程中返回或者被取消。<ul>
<li>如果调用<code>pthread_exit</code>，那么<code>rval_ptr</code>就包含<code>pthread_exit</code>送入的参数。</li>
<li>如果线程简单的从它的启动例程返回，<code>rval_ptr</code>就包含返回码。</li>
<li>如果线程被取消，由<code>rval_ptr</code>指定的内存单元就设置为<code>PTHREAD_CANCELED</code></li>
</ul>
</li>
<li>如果对线程返回值不感兴趣，<code>rval_ptr</code>就设置为<code>NULL</code></li>
<li>还可以通过<code>pthread_join</code>设置线程分离。</li>
<li>线程中不存在父子关系，只有新线程和主线程之分。任何一个线程得到另一个线程的<code>pid</code>之后都可以去<code>join</code></li>
<li>代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *err,<span class="keyword">const</span> <span class="keyword">int</span> ret)</span></span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s error: %s\n&quot;</span>, err,strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">        <span class="keyword">int</span> a; </span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">256</span>]; </span><br><span class="line">&#125;;       </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">pf</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct foo)); </span><br><span class="line">        pf-&gt;a = <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">strcpy</span>(pf-&gt;name,<span class="string">&quot;shc&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*) pf; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">tfn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">pf</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct foo)); </span><br><span class="line">        pf-&gt;a = <span class="number">2</span>; </span><br><span class="line">        <span class="built_in">strcpy</span>(pf-&gt;name,<span class="string">&quot;ssp&quot;</span>); </span><br><span class="line">        pthread_exit((<span class="keyword">void</span>*)pf); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="keyword">pthread_t</span> tid1,tid2; </span><br><span class="line">        <span class="keyword">int</span> err = pthread_create(&amp;tid1,<span class="literal">NULL</span>,tfn1,<span class="literal">NULL</span>); </span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>)  </span><br><span class="line">                sys_err(<span class="string">&quot;pthread_create&quot;</span>,err); </span><br><span class="line">        err = pthread_create(&amp;tid2,<span class="literal">NULL</span>,tfn2,<span class="literal">NULL</span>);      </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">void</span> *pret1,*pret2; </span><br><span class="line">        err = pthread_join(tid1,&amp;pret1);        <span class="comment">// &amp;pret1 即为 void ** pthread_join改变pret1的内容，即改变了pret1的指向。 </span></span><br><span class="line">        <span class="keyword">if</span>(err!=<span class="number">0</span>) </span><br><span class="line">                sys_err(<span class="string">&quot;pthread_join&quot;</span>,err); </span><br><span class="line">        err = pthread_join(tid2,&amp;pret2); </span><br><span class="line">         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>,((struct foo*)pret1)-&gt;a,((struct foo*)pret1)-&gt;name); </span><br><span class="line">                 </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>,((struct foo*)pret2)-&gt;a,((struct foo*)pret2)-&gt;name);    </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./pthread_join_shc.out </span><br><span class="line">1 shc</span><br><span class="line">2 ssp</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-进程(1)</title>
    <url>/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>Linux进程</p>
<span id="more"></span>


<ul>
<li>参考 APUE，牛客以及黑马讲义</li>
</ul>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><ul>
<li>每个进程都会对应虚拟一个<strong>虚拟地址空间</strong><ul>
<li><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-11-45.png"></li>
</ul>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>程序<ul>
<li>编译好的二进制文件</li>
<li>死的，只占用磁盘空间</li>
</ul>
</li>
<li>进程<ul>
<li>活的，运行的程序，占用内存，cpu的系统资源。</li>
</ul>
</li>
<li>并发<code>(concurrency)</code><ul>
<li>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上（用户感觉）具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。</li>
</ul>
</li>
<li>并行<code>(parallel)</code><ul>
<li>指在同一时刻，有多条指令在多个处理器上同时执行。</li>
<li><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-25-21-10-16.png"></li>
</ul>
</li>
<li>单道程序设计<ul>
<li>所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上极其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。</li>
</ul>
</li>
<li>多道程序设计<ul>
<li>在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有硬件基础作为保证。</li>
<li>时钟中断即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。</li>
<li>在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li>
<li>实质上，并发是宏观并行，微观串行。</li>
</ul>
</li>
<li><code>cpu</code><ul>
<li>预读器</li>
<li>译码器</li>
<li>算术逻辑单元</li>
<li><code>MMU</code><ul>
<li>虚拟物理内存映射</li>
<li><code>page 4K??</code></li>
<li>设置内存访问级别</li>
</ul>
</li>
</ul>
</li>
<li><code>PCB</code>进程控制块<ul>
<li>每个进程在<code>kernal</code>中都有一个进程控制块<code>PCB</code>来维护进程相关的信息。<code>Linux</code>的进程控制块是<code>struct task_struct</code>结构体</li>
<li><code>struct task_struct</code>主要内容<ul>
<li>**.<code>pid</code>.**：即进程<code>id</code>。类型为<code>C</code>中的<code>pid_t</code></li>
<li><strong>进程状态</strong>：就绪，运行，挂起（阻塞），停止</li>
<li>进程切换时需要保存和恢复一些cpu寄存器</li>
<li>描述虚拟地址空间的信息</li>
<li>描述控制终端信息</li>
<li><strong>当前目录位置</strong>（不同目录下（shell进程的目录位置不同）的ls结果不同）</li>
<li>umask掩码<ul>
<li>不同进程不同</li>
</ul>
</li>
<li><strong>文件描述表</strong>，包括很多指向file结构体的指针</li>
<li><strong>信号</strong>相关的信息</li>
<li><strong>用户id，组id</strong></li>
<li>会话和进程组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul>
<li>操作系统中用来指定运行环境的一些参数</li>
<li>是跟着进程走的<ul>
<li>本质：字符串</li>
<li>有统一格式：<code>name=value</code></li>
<li>值用来描述进程环境信息 </li>
</ul>
</li>
<li>常用<ul>
<li>PATH<ul>
<li>可执行文件搜索路径</li>
</ul>
</li>
<li>SHELL<ul>
<li>指定当前所使用的命令解析器</li>
</ul>
</li>
<li>TERM<ul>
<li>当前终端类型</li>
</ul>
</li>
<li>HOME<ul>
<li>用户主目录</li>
</ul>
</li>
</ul>
</li>
<li>存储形式<ul>
<li><code>extern char **environ</code></li>
<li>字符指针数组</li>
<li><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-29-13-22-15.png"><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-10-45-58.png"></li>
</ul>
</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="pid-t-fork-void"><a href="#pid-t-fork-void" class="headerlink" title="pid_t fork(void);"></a><code>pid_t fork(void);</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>#include&lt;sys/types.h&gt;</code></li>
<li><code>#include&lt;unistd.h&gt;</code></li>
<li>创建子进程<ul>
<li>父子进程内容相同（用户区和内核区）相互独立</li>
<li><code>fork</code>在父进程返回一次<code>pid_t</code> ，在子进程返回一次<code>pid_t</code></li>
<li>成功：父进程返回子进程<code>pid_t</code>，子进程返回0</li>
<li>失败：父进程返回-1</li>
</ul>
</li>
<li>父子进程之间的关系：<ul>
<li>区别：<ul>
<li>fork函数的返回值</li>
<li>pcb进程控制块中的数据</li>
<li>进程创建时间</li>
<li>当前进程的<code>id，pid</code></li>
<li>当前进程的父进程的<code>id pid</code></li>
<li>信号集</li>
</ul>
</li>
<li>共同点<ul>
<li>data段，text段，堆，栈，环境变量，全局变量，宿主目录位置，进程工作目录位置，信号处理方式</li>
</ul>
</li>
<li>不同点<ul>
<li>进程<code>id</code>、返回值、各自的父进程、进程创建时间、闹钟、未决信号集。</li>
</ul>
</li>
<li>父子进程共享<ul>
<li><code>mmap</code>映射区(都有什么。。。)</li>
<li>文件描述符（打开的文件结构体）</li>
</ul>
</li>
</ul>
</li>
<li>特别的，<code>fork</code>之后父进程先执行还是子进程先执行不确定，取决于内核所使用的调度算法</li>
</ul>
<blockquote>
<p>子进程会复制父进程的几乎所有信息：子进程复制父进程用户空间所有数据；子进程复制父进程内核空间PCB中绝大多数数据；<br>子进程复制父进程的数据段，BSS段，代码段，堆空间，栈空间，文件描述符，但是对于文件描述符关联的内核文件表项（即struct file结构体）则是采用共享的方式</p>
</blockquote>
<ul>
<li>有点乱，等我学操作系统再研究吧。。</li>
</ul>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a><strong>写时拷贝</strong></h3><ul>
<li><strong>读时共享，写时复制</strong></li>
</ul>
<h3 id="pid-t-getpid-void"><a href="#pid-t-getpid-void" class="headerlink" title="pid_t getpid(void)"></a><code>pid_t getpid(void)</code></h3><ul>
<li>返回当前进程<code>id</code></li>
</ul>
<h3 id="pid-t-getppid-void"><a href="#pid-t-getppid-void" class="headerlink" title="pid_t getppid(void)"></a><code>pid_t getppid(void)</code></h3><ul>
<li>返回父进程<code>id</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">// 实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">// 写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">// 内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">// 只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">// 也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">// 注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">// fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">// */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="争夺cpu模型"><a href="#争夺cpu模型" class="headerlink" title="争夺cpu模型"></a>争夺cpu模型</h3><p><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-16-46.png"><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-17-05.png"><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-19-52.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i!=<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;parent process id = %d\tthe parent parent process id = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child process id = %d\tthe parent process id = %d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./fork_shc.out </span><br><span class="line">child process id = <span class="number">3221</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">child process id = <span class="number">3220</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">parent process id = <span class="number">3219</span>	the parent parent process id = <span class="number">2852</span></span><br><span class="line">child process id = <span class="number">3222</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">child process id = <span class="number">3223</span>	the parent process id = <span class="number">3219</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ child process id = <span class="number">3224</span>	the parent process id = <span class="number">2344</span></span><br></pre></td></tr></table></figure>


<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><ul>
<li><code>exec</code> 让子进程去执行其他程序</li>
<li><code>a./out</code>的父进程是<code>bash</code> 那么<code>bash</code>是如何做到开辟一个子进程去执行我们写的代码？就是用<code>exec</code>函数族</li>
<li><code>exec</code> 函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通<br>常我们直接在 <code>exec</code> 函数调用后直接调用 <code>perror()</code>和 <code>exit()</code>，无需 <code>if</code> 判断</li>
<li>调用<code>exec</code>并不创建新进程，所以前后的进程ID并未改变，<code>exec</code>只是用磁盘山东个一个新程序代替了当前进程的正文段，数据段，堆段，和栈段。</li>
<li>调用系统提供的，用<code>execlp</code></li>
<li>调用自己写的，用<code>execl</code><br><img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-28-11-59-37.png"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">l (list) 命令行参数列表</span></span><br><span class="line"><span class="comment">p (path) 搜素 file 时使用 path 变量</span></span><br><span class="line"><span class="comment">v (vector) 使用命令行参数数组</span></span><br><span class="line"><span class="comment">e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运</span></span><br><span class="line"><span class="comment">行的环境变量</span></span><br><span class="line"><span class="comment">事实上，只有 execve 是真正的系统调用，其它五个函数最终都调用 execve，所以 execve</span></span><br><span class="line"><span class="comment">在 man 手册第 2 节，其它函数在 man 手册第 3 节。这些函数之间的关系如下图所示。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<img src="/2021/11/25/Linux-%E8%BF%9B%E7%A8%8B/2021-11-29-13-22-03.png"></li>
</ul>
<h3 id="execl-const-char-path-const-char-arg"><a href="#execl-const-char-path-const-char-arg" class="headerlink" title="execl(const char *path,const char *arg, ...)"></a><code>execl(const char *path,const char *arg, ...)</code></h3><ul>
<li>第一个参数是：可执行文件的路径；</li>
<li>第二个参数是：可执行程序的程序名，</li>
<li>其余参数是命令函的参数，通常最后一个参数是一个空指针NULL(用来表示命令行数组的结尾).<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">-1</span>) <span class="comment">//  父进程 调用fork失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)  <span class="comment">//  父进程调用fork成功 返回子进程pid</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sleep(1);  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process , pid = %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// execlp(&quot;ls&quot;,&quot;ls&quot;,&quot;-a&quot;,&quot;-h&quot;,&quot;-l&quot;,NULL);</span></span><br><span class="line">        <span class="comment">// execlp(&quot;date&quot;,&quot;date&quot;,NULL);</span></span><br><span class="line">        <span class="comment">// execl(&quot;./a.out&quot;,&quot;./a.out&quot;,NULL);</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>,<span class="string">&quot;-h&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>没加<code>sleep(1)</code>有可能会发生如下</li>
<li>本进程的子进程没有抢过本进程，本进程<code>(printf i am parent)</code>结束后（即该段程序变成的进程结束后），父进程<code>bash</code>先抢夺到<code>cpu</code>，先执行出<code>henry@henry:~/code/learn/exec_learn$</code>，然后再到<code>child process</code>执行<code>ls</code><ul>
<li>父进程结束后，<code>bash</code>就会去回收这个父进程<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/exec_learn$ gcc fork_exec.c -o fork_exec.out</span><br><span class="line">henry@henry:~/code/learn/exec_learn$ ./fork_exec.out </span><br><span class="line">i am parent process , pid = 3389</span><br><span class="line">henry@henry:~/code/learn/exec_learn$ 总用量 24K</span><br><span class="line">drwxrwxr-x 2 henry henry 4.0K 10月 20 12:23 .</span><br><span class="line">drwxr-xr-x 7 henry henry 4.0K 10月 20 12:16 ..</span><br><span class="line">-rw-rw-r-- 1 henry henry  424 10月 20 12:23 fork_exec.c</span><br><span class="line">-rwxrwxr-x 1 henry henry 8.4K 10月 20 12:23 fork_exec.out</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>加上<code>sleep(1)</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">henry@henry:~/code/learn/exec_learn$ ./fork_exec.out </span><br><span class="line">总用量 24K</span><br><span class="line">drwxrwxr-x 2 henry henry 4.0K 10月 20 12:22 .</span><br><span class="line">drwxr-xr-x 7 henry henry 4.0K 10月 20 12:16 ..</span><br><span class="line">-rw-rw-r-- 1 henry henry  424 10月 20 12:23 fork_exec.c</span><br><span class="line">-rwxrwxr-x 1 henry henry 8.5K 10月 20 12:22 fork_exec.out</span><br><span class="line">i am parent process , pid = 3370</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><ul>
<li>父进程先终止，其子进程被送进<code>init</code>孤儿院</li>
<li>在一个进程终止时，内核逐渐检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程<code>ID</code>就更改为<code>1</code>（<code>init</code>的<code>pid</code>）。这种方法保证了每个进程有一个父进程</li>
</ul>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><ul>
<li><p>进程终止时，用户区的内容就已经被释放。</p>
</li>
<li><p>子进程比父进程先终止，那么父进程如何在做相应检查时得到子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程获取保存了一定量的信息，所以当终止进程的父进程调用wait或者waitpid是可以获取这些信息的。（信息包括进程ID，进程终止状态，以及进程使用CPU时间总量等）。<strong>内核</strong>可以释放终止进程所使用的所有存储区，关闭其所有打开文件。</p>
</li>
<li><p>一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它仍占用的资源）的进程成为僵尸进程。</p>
</li>
<li><p><strong>我认为</strong></p>
</li>
<li><p><strong>所以！死去进程之所以会有残留资源（信息），就是为了告诉父进程他是怎么死的。而我们对残留信息采用wait或者直接丢弃的做法，都代表我们已经不再使用该子进程，系统在这之后就会释放这些残留资源。</strong></p>
</li>
<li><p><strong>所以！wait的作用只是去获取子进程死亡的状态，释放资源的动作是由系统做的。</strong></p>
</li>
<li><p><code>ps</code>中僵尸进程打印为<code>z</code></p>
</li>
<li><p>僵尸进程解决方法：</p>
<ul>
<li><code>wait</code>而非<code>kill</code>，因为此进程已经死了。<ul>
<li><code>wait</code>获取死去进程的信息后，系统知道这些进程对于用户来说已经彻底没有用了，于是乎释放那些信息。</li>
</ul>
</li>
<li>杀死产生僵尸进程的父进程，这样这些僵尸进程就变成了孤儿进程，进而被init进程接管，进而被回收。</li>
<li>在子进程死亡发送<code>SIGCHLD</code>信号时，直接采用<strong>忽略</strong>的做法。<code>signal(SIGCHLD,SIG_IGN)</code>。忽略这个信号，这也是一种代表了我们对子进程死亡的处理态度。我们不关心他的死法。而系统也懂了我们不关心，故直接释放资源。不会造成僵尸进程的诞生。</li>
</ul>
</li>
</ul>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul>
<li>一个由<code>init</code>收养的进程终止时是否会变成一个僵尸进程？<ul>
<li>不会。<code>init</code>被编写成，无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数取得其终止状态，这样也就防止了系统中塞满僵尸进程的情况。</li>
</ul>
</li>
<li><code>init的子进程</code><ul>
<li><code>init</code>产生的</li>
<li><code>init</code>收养的。</li>
</ul>
</li>
</ul>
<h2 id="wait-waitpid"><a href="#wait-waitpid" class="headerlink" title="wait/waitpid"></a><code>wait/waitpid</code></h2><h3 id="pid-t-wait-int-statloc"><a href="#pid-t-wait-int-statloc" class="headerlink" title="pid_t wait(int *statloc);"></a><code>pid_t wait(int *statloc);</code></h3><hr>
<ul>
<li>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块<code>PCB</code>的信息（包括进程号、退出状态、运行时间等）。我们需要对这些信息进行处理，以告知系统我们已经彻底结束对这个进程的利用。</li>
</ul>
<h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a><strong>纠错</strong></h3><ul>
<li><p><code>wait</code>函数作用</p>
<ul>
<li>阻塞等待子进程退出。（这时候应该会让出<code>cpu</code>资源吧？？）</li>
<li>当一个子进程终止时，<code>wait</code>去获取整个终止子进程的终止信息，取得该子进程的终止状态则立即返回。</li>
<li>如果他没有任何子进程，则立即出错返回。</li>
</ul>
</li>
<li><p>当调用<code>wait</code>获取信息后，<strong>系统</strong>就会释放内核中的残留信息。（这些信息就是为了让<code>wait</code>去获取的，<code>wait</code>获取完之后，这些东西自然就可以释放掉）。</p>
</li>
<li><p><strong>所以释放残留资源这一步，不是wait函数做的，而是系统做的！！！</strong></p>
<ul>
<li><strong>那么多博客都tm以讹传讹。害死人。</strong></li>
</ul>
</li>
<li><p><strong>看啊</strong></p>
<ul>
<li><code>description</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">**In the <span class="keyword">case</span> of a terminated child, performing a wait allows the system to release</span><br><span class="line">   the resources associated with the child; <span class="keyword">if</span> a wait is <span class="keyword">not</span> performed, then the terminated child remains in  a  <span class="string">&quot;zombie&quot;</span>  state**</span><br><span class="line">   (see NOTES below).</span><br></pre></td></tr></table></figure></li>
<li><code>notes</code>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT flag is set for SIGCHLD (see</span><br><span class="line">   sigaction(2)), then children that terminate do not become zombies and a call to wait() or  waitpid()  will  block  until  all</span><br><span class="line">   children  have terminated, and then fail with errno set to ECHILD. </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>看manpage去</p>
</li>
</ul>
<hr>
<ul>
<li><code>pid_t wait(int *statloc);</code></li>
<li><code>int *statloc</code>：保存退出状态。保存的就是子进程结束时return的值。</li>
<li><code>return</code><ul>
<li>成功回收：返回回收的进程的<code>pid</code>号</li>
<li>出错：调用<code>wait</code>的当前进程并没有任何子进程。则返回<code>-1</code>。</li>
</ul>
</li>
<li><code>waitpid</code>相较于<code>wait</code>可以选择是否阻塞，以及回收特定的某一个子进程</li>
<li>一次 <code>wait</code> 或 <code>waitpid</code> 调用只能清理一个子进程</li>
<li><code>wait</code>等价于<code>waitpid(-1, &amp;wstatus, 0);</code></li>
</ul>
<ul>
<li>宏函数判断终止原因。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WIFEXITED（status）宏判断为真 表示程序正常退出</span><br><span class="line">WEXITSTATUS(status)上一个宏判断为真 则返回状态值  <span class="comment">//也就是在获取子进程最后return的值。</span></span><br><span class="line">WIFSIGNALED(status) 宏判断为真 表示程序异常退出</span><br><span class="line">WTERMSIG(status) 上一个判断为真，则返回状态值 <span class="comment">//也就是在获取子进程最后return的值。</span></span><br><span class="line">WIFSTOPPED(status)：子进程被停止，返回真</span><br><span class="line">WSTOPSIG(status)：返回停止子进程的信号值 <span class="comment">//也就是在获取子进程最后return的值。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">pid_t</span> target_pid;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">                                target_pid = pid; <span class="comment">//  注意用pid 不是getpid()</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">int</span> statloc;    <span class="comment">//  接收进程退出状态</span></span><br><span class="line">                <span class="keyword">pid_t</span> wpid = waitpid(target_pid,&amp;statloc,<span class="number">0</span>);    <span class="comment">//  阻塞回收 成功：返回进程id，错误：返回-1（一般是子进程不存在）</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;i am the parent process , wait for the child process id = %d\n&quot;</span>,wpid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;i am the child process id = %d\n&quot;</span>,getpid());</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./waitpid_shc.out </span><br><span class="line">i am the child process id = <span class="number">4306</span></span><br><span class="line">i am the child process id = <span class="number">4307</span></span><br><span class="line">i am the child process id = <span class="number">4309</span></span><br><span class="line">i am the child process id = <span class="number">4310</span></span><br><span class="line">i am the child process id = <span class="number">4308</span></span><br><span class="line">i am the parent process , wait <span class="keyword">for</span> the child process id = <span class="number">4308</span>  <span class="comment">//  回收i=2进程</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pid-t-waitpid-pid-t-pid-int-statloc-int-options"><a href="#pid-t-waitpid-pid-t-pid-int-statloc-int-options" class="headerlink" title="pid_t waitpid(pid_t pid,int *statloc,int options);"></a><code>pid_t waitpid(pid_t pid,int *statloc,int options);</code></h3><ul>
<li><p>传入参数</p>
<ul>
<li><code>pid_t pid</code><ul>
<li><code>&gt;0 </code>指定进程号</li>
<li><code>=-1</code> 回收任意子进程，相当于<code>wait</code>。<code>waitpid(-1,&amp;status,0) &lt;-&gt; wait(&amp;status);</code></li>
<li><code>=0</code> 回收和当前调用<code>waitpid</code>的进程的一个组的所有子进程（一般同一进程<code>fork</code>出的子进程默认同一组）</li>
<li><code>&lt;-1</code> 回收指定进程组的任意子进程</li>
</ul>
</li>
<li><code>int *statloc</code><ul>
<li>保存退出状态</li>
<li>我也不太懂怎么就能保存状态。应该是通过位图吧</li>
</ul>
</li>
<li><code>options</code><ul>
<li>0：阻塞</li>
<li><code>WNOHANG</code>：非阻塞，没有子进程结束，立即返回</li>
<li><code>WUNTRACED</code>：如果子进程由于被停止产生的 SIGCHLD，waitpid 则立即返回</li>
<li><code>WCONTINUED</code>：如果子进程由于被 <code>SIGCONT</code> 唤醒而产生的 <code>SIGCHLD</code>，<code>waitpid</code> 则立即返回</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li><p><code>return</code></p>
<ul>
<li>成功回收：返回回收的进程的<code>pid</code>号</li>
<li>出错：调用<code>waitpid</code>的当前进程并没有任何子进程。则返回<code>-1</code>。（有正在运行的子进程也叫有子进程）</li>
<li>如果使用了<code>WNOHANG</code>非阻塞参数，且没有子进程已经终止、可以回收，那么就返回<code>0</code>.</li>
</ul>
</li>
<li><p>回收指定进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">pid_t</span> target_pid;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">			sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">2</span>)</span><br><span class="line">				target_pid = pid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> statloc;	<span class="comment">//  接收进程退出状态</span></span><br><span class="line">		<span class="keyword">pid_t</span> wpid = waitpid(target_pid,&amp;statloc,<span class="number">0</span>);	<span class="comment">//  阻塞回收 成功：返回进程id，错误：返回-1（一般是子进程不存在）</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(wpid==<span class="number">-1</span>)</span><br><span class="line">			sys_err(<span class="string">&quot;waitpid&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;i am the parent process , wait for the child process id = %d\n&quot;</span>,wpid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am the child process id = %d\n&quot;</span>,getpid());</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i am the child process id = <span class="number">4538</span></span><br><span class="line">i am the child process id = <span class="number">4539</span></span><br><span class="line">i am the child process id = <span class="number">4541</span></span><br><span class="line">i am the child process id = <span class="number">4540</span></span><br><span class="line">i am the child process id = <span class="number">4542</span></span><br><span class="line">i am the parent process , wait <span class="keyword">for</span> the child process id = <span class="number">4540</span></span><br></pre></td></tr></table></figure></li>
<li><p>回收所有进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        perror(str);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">                <span class="keyword">if</span>(pid==<span class="number">-1</span>)</span><br><span class="line">                        sys_err(<span class="string">&quot;forl error&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">pid_t</span> wpid  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// while((wpid=waitpid(-1,NULL,0)!=-1))</span></span><br><span class="line">                <span class="comment">//         printf(&quot;i wait the child id = %d hhhh\n&quot;,wpid);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//  这样循环使用WNOHANG 的 waitpid的效果和上面直接使用 阻塞的 waitpid的效果一样（我认为）</span></span><br><span class="line">               <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,WNOHANG))!=<span class="number">-1</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                        <span class="comment">//  非阻塞 且没有结束的子进程时 返回0</span></span><br><span class="line">                        <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;i wait the child id = %d\n&quot;</span>,wpid);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                usleep(<span class="number">1</span>);      <span class="comment">//  父进程睡眠 让出cpu  </span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; parent die\n &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;i am the %d th child process id = %d\n&quot;</span>,i,getpid());</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// i am the 0 th child process id = 4407</span></span><br><span class="line"><span class="comment">// i am the 1 th child process id = 4408</span></span><br><span class="line"><span class="comment">// i am the 3 th child process id = 4410</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i am the 2 th child process id = 4409</span></span><br><span class="line"><span class="comment">// i am the 4 th child process id = 4411</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">// i wait the child id = 1 hhhh</span></span><br><span class="line"><span class="comment">//  parent die</span></span><br><span class="line"></span><br><span class="line">i am the <span class="number">1</span> th child process id = <span class="number">4381</span></span><br><span class="line">i am the <span class="number">0</span> th child process id = <span class="number">4380</span></span><br><span class="line">i am the <span class="number">3</span> th child process id = <span class="number">4383</span></span><br><span class="line">i wait the child id = <span class="number">4380</span></span><br><span class="line">i wait the child id = <span class="number">4381</span></span><br><span class="line">i am the <span class="number">2</span> th child process id = <span class="number">4382</span></span><br><span class="line">i am the <span class="number">4</span> th child process id = <span class="number">4384</span></span><br><span class="line">i wait the child id = <span class="number">4382</span></span><br><span class="line">i wait the child id = <span class="number">4383</span></span><br><span class="line">i wait the child id = <span class="number">4384</span></span><br><span class="line"> parent die</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关于wait函数只是负责获取终止状态，而不负责回收资源的代码"><a href="#关于wait函数只是负责获取终止状态，而不负责回收资源的代码" class="headerlink" title="关于wait函数只是负责获取终止状态，而不负责回收资源的代码"></a><strong>关于wait函数只是负责获取终止状态，而不负责回收资源的代码</strong></h2><ul>
<li>所以那在处理死去的进程时，如果不需要获取这个死去进程的信息，就不需要<code>wait</code>。直接<code>signal(SIGCHLD，SIG_IGN)</code>就可以让这个死去的子进程被释放残留资源从而不变成僵尸进程<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	signal(SIGCHLD,SIG_IGN);</span><br><span class="line">	<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; i am parent \n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am %d child\n&quot;</span>,i);</span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d die\n&quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps ajx也没有僵尸进程</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/<span class="keyword">try</span>$ ./test01_wait.out </span><br><span class="line">i am <span class="number">0</span> child</span><br><span class="line">i am <span class="number">1</span> child</span><br><span class="line"> i am parent </span><br><span class="line">i am <span class="number">2</span> child</span><br><span class="line">i am <span class="number">3</span> child</span><br><span class="line">i am <span class="number">4</span> child</span><br><span class="line"><span class="number">0</span> die</span><br><span class="line"><span class="number">1</span> die</span><br><span class="line"><span class="number">2</span> die</span><br><span class="line"><span class="number">3</span> die</span><br><span class="line"><span class="number">4</span> die</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="子进程返回值补充"><a href="#子进程返回值补充" class="headerlink" title="子进程返回值补充"></a>子进程返回值补充</h2><ul>
<li>子进程结束时返回<code>int</code>值，父进程可以选择用<code>wait(&amp;status)</code>去接收<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) &#123;sleep(<span class="number">10</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="comment">// kill(pid,SIGINT);</span></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFEXITED(status),WEXITSTATUS(status));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFSIGNALED(status),WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./<span class="keyword">try</span>.out </span><br><span class="line"><span class="number">256</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span></span><br><span class="line"><span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) &#123;sleep(<span class="number">10</span>); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    kill(pid,SIGINT);</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFEXITED(status),WEXITSTATUS(status));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFSIGNALED(status),WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./<span class="keyword">try</span>.out </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span>       <span class="number">0</span></span><br><span class="line"><span class="number">1</span>       <span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) &#123;<span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFEXITED(status),WEXITSTATUS(status));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t%d\n&quot;</span>,WIFSIGNALED(status),WTERMSIG(status));</span><br><span class="line">&#125;</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ ./<span class="keyword">try</span>.out </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span>       <span class="number">0</span></span><br><span class="line"><span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure>


<h2 id="manpage阅读"><a href="#manpage阅读" class="headerlink" title="manpage阅读"></a>manpage阅读</h2><ul>
<li><code>wait</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WAIT(2)                    Linux Programmer&#x27;s </span><br><span class="line">  SYNOPSIS</span><br><span class="line">        #include &lt;sys/types.h&gt;</span><br><span class="line">        #include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">        pid_t wait(int *wstatus);</span><br><span class="line">        pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">        int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);</span><br><span class="line"></span><br><span class="line">  DESCRIPTION</span><br><span class="line">        All  of these system calls are used to wait for state changes in a child of the calling process, and obtain information about</span><br><span class="line">        the child whose state has changed.  A state change is considered to be: the child terminated; the child was stopped by a sig‐</span><br><span class="line">        nal; or the child was resumed by a signal.  **In the case of a terminated child, performing a wait allows the system to release</span><br><span class="line">        the resources associated with the child; if a wait is not performed, then the terminated child remains in  a  &quot;zombie&quot;  state**</span><br><span class="line">        (see NOTES below).</span><br><span class="line"></span><br><span class="line">        If  a  child  has  already  changed  state,  then these calls return immediately.  Otherwise, they block until either a child</span><br><span class="line">        changes state or a signal handler interrupts the call (assuming that system calls are not automatically restarted  using  the</span><br><span class="line">        SA_RESTART  flag of sigaction(2)).  In the remainder of this page, a child whose state has changed and which has not yet been</span><br><span class="line">        waited upon by one of these system calls is termed waitable.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  NOTES</span><br><span class="line">        A  child  that terminates, but has not been waited for becomes a &quot;zombie&quot;.  The kernel maintains a minimal set of information</span><br><span class="line">        about the zombie process (PID, termination status, resource usage information) in order to allow the parent to later  perform</span><br><span class="line">        a wait to obtain information about the child.  As long as a zombie is not removed from the system via a wait, it will consume</span><br><span class="line">        a slot in the kernel process table, and if this table fills, it will not be possible to create further processes.  If a  par‐</span><br><span class="line">        ent process terminates, then its &quot;zombie&quot; children (if any) are adopted by init(1), (or by the nearest &quot;subreaper&quot; process as</span><br><span class="line">        defined through the use of the prctl(2) PR_SET_CHILD_SUBREAPER operation); init(1) automatically performs a  wait  to  remove</span><br><span class="line">        the zombies.</span><br><span class="line"></span><br><span class="line">        POSIX.1-2001  specifies that if the disposition of SIGCHLD is set to SIG_IGN or the SA_NOCLDWAIT flag is set for SIGCHLD (see</span><br><span class="line">        sigaction(2)), then children that terminate do not become zombies and a call to wait() or  waitpid()  will  block  until  all</span><br><span class="line">        children  have terminated, and then fail with errno set to ECHILD.  (The original POSIX standard left the behavior of setting</span><br><span class="line">        SIGCHLD to SIG_IGN unspecified.  Note that even though the default disposition of SIGCHLD is &quot;ignore&quot;, explicitly setting the</span><br><span class="line">        disposition to SIG_IGN results in different treatment of zombie process children.)</span><br><span class="line"></span><br><span class="line">        Linux  2.6  conforms  to the POSIX requirements.  However, Linux 2.4 (and earlier) does not: if a wait() or waitpid() call is</span><br><span class="line">        made while SIGCHLD is being ignored, the call behaves just as though SIGCHLD were not being ignored, that is, the call blocks</span><br><span class="line">        until the next child terminates and then returns the process ID and status of that child.</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-进程2-进程通信</title>
    <url>/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/</url>
    <content><![CDATA[<p>Linux进程通信</p>
<span id="more"></span>


<ul>
<li>参考 APUE，牛客讲义</li>
</ul>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>半双工<ul>
<li>半双工通信是指可以双向流动，但不能同时。</li>
</ul>
</li>
<li><strong>常见<code>IPC</code>方法</strong><ul>
<li>管道（无名）<code>pipe：</code>血缘</li>
<li>管道（有名）<code>fifo：</code>非血缘<ul>
<li>管道：内核借助消息队列实现，因此数据只能读一次</li>
</ul>
</li>
<li>信号</li>
<li><code>mmap</code>（存储映射<code>I/O</code>）：非血缘<ul>
<li>速度快，数据可以反复读取。</li>
</ul>
</li>
<li>本地套接字：稳定</li>
</ul>
</li>
</ul>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>伪文件（不占磁盘空间）</li>
<li>两个文件描述符<code>（r/w）</code></li>
<li>数据从写端流入，读端流出</li>
<li>管道缓冲区大小 4096<ul>
<li><code>ulimit -a</code></li>
<li><code>pipe size            (512 bytes, -p) 8</code></li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>环形队列</li>
<li>内核缓冲区</li>
</ul>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul>
<li>优点：简单</li>
<li>数据不能反复读</li>
<li>单向通信（半双工）</li>
<li>只能用于有公共祖先的进程间。（父子，兄弟）</li>
</ul>
<h3 id="读写行为"><a href="#读写行为" class="headerlink" title="读写行为"></a>读写行为</h3><ul>
<li>读管道<ul>
<li>管道中有数据，<code>read</code>返回实际读到字节数</li>
<li>管道中无数据<ul>
<li>有写端，则<code>read</code>阻塞等待写端写入</li>
<li>无写端，<code>read</code>返回0（读到文件尾）。</li>
</ul>
</li>
</ul>
</li>
<li>写管道<ul>
<li>管道无读端，异常。<code>SIGPIPE</code>信号</li>
<li>管道有读端<ul>
<li>未满，直接写，返回写入字节个数</li>
<li>已满，阻塞等待<code>read</code>把数据读走。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="int-pipe-int-pipefd-2"><a href="#int-pipe-int-pipefd-2" class="headerlink" title="int pipe(int pipefd[2]);"></a><code>int pipe(int pipefd[2]);</code></h3><ul>
<li><code>return</code><ul>
<li><code>r/w</code> 两个文件描述符。无需 <code>open</code>，但需手动 <code>close</code>。</li>
<li><code>fd[0] &lt;-&gt; read , fd[1] &lt;-&gt; write</code></li>
<li>向管道文件读写数据其实是在读写内核缓冲区</li>
<li>成功0，失败-1，设置erron</li>
</ul>
</li>
<li>使用<ul>
<li>父进程<code>pipe</code>，得管道，以及<code>fd[0],fd[1]</code></li>
<li>父进程<code>fork</code>，子进程复制父进程文件描述表，共享文件描述符关联的文件结构体，故子进程也有<code>fd[0],fd[1]</code>指向相应文件。（自己猜的，不知道对错）</li>
<li>父进程关闭读，进行写；子进程关闭写，进行读。管道环形队列实现，保证数据单线流动。</li>
</ul>
</li>
<li>问题<ul>
<li>读时共享，写时复制。所以不会父进程读端的关闭不会造成子进程读端的关闭。同理，子进程写端的关闭也不会造成父进程写端的关闭。故不会发生错误。</li>
<li><blockquote>
<p>子进程复制父进程的数据段，BSS段，代码段，堆空间，栈空间，文件描述符，但是对于文件描述符关联的内核文件表项（即struct file结构体）则是采用共享的方式</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/2021-11-29-13-41-57.png"><br><img src="/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/2021-11-29-13-21-24.png"></p>
<ul>
<li>基本用法（父子）（兄弟同理）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">pipe</span>(fd);</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">0</span>]);   <span class="comment">//  关闭 父读</span></span><br><span class="line">                <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">&quot;hello\n&quot;</span>,<span class="keyword">sizeof</span> <span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">1</span>]);   <span class="comment">//  关闭 父写</span></span><br><span class="line">                <span class="built_in">waitpid</span>(pid,<span class="literal">NULL</span>,<span class="number">0</span>);    <span class="comment">//  阻塞回收子进程      </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">1</span>]);   <span class="comment">//  关闭 子写</span></span><br><span class="line">                <span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">0</span>]);   <span class="comment">//  关闭 子读</span></span><br><span class="line">                <span class="built_in">write</span>(STDOUT_FILENO,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./pipe_1.out </span><br><span class="line">hello</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>父子进程实现<code>ls | wc -l</code>，xd同理（记得关闭不适用管道的进程的r/w端）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">char</span> *err)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程实现 ls ；子进程利用父进程ls的结果使用wc命令；子进程命令结果输送到终端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">pipe</span>(fd);</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">0</span>]);   <span class="comment">//   父进程关闭读段,但是子进程的读端没有关闭，使得数据单向流动</span></span><br><span class="line">                <span class="built_in">dup2</span>(fd[<span class="number">1</span>],STDOUT_FILENO);      <span class="comment">//  向终端的输出stdout 重定向 到管道的写端fd[1]</span></span><br><span class="line">                <span class="built_in">execlp</span>(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-ahl&quot;</span>,<span class="literal">NULL</span>);  <span class="comment">//  execlp(可执行文件名字,命令参数,NULL);       这里依靠execlp 执行程序结束后隐式的关闭副进程写</span></span><br><span class="line">端，下同理</span><br><span class="line">                <span class="comment">//  execlp后面的代码只有在execlp失败了才会走到 所以不用wait了</span></span><br><span class="line">                <span class="built_in">sys_err</span>(<span class="string">&quot;exclp error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">close</span>(fd[<span class="number">1</span>]);   <span class="comment">//   关闭子进程写端</span></span><br><span class="line">                <span class="built_in">dup2</span>(fd[<span class="number">0</span>],STDIN_FILENO);       <span class="comment">//  从终端读入stdin 重定向为 从管道读端读入fd[0]</span></span><br><span class="line">                <span class="built_in">execlp</span>(<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;wc&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);    <span class="comment">//   execlp</span></span><br><span class="line">                <span class="built_in">sys_err</span>(<span class="string">&quot;execlp error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   简记 dup2(a,b) 将文件描述符a拷贝给b        之后对b做的事情就相当于对a做的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ ./pipe_shc.out </span><br><span class="line"><span class="number">22</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="有名管道FIFO"><a href="#有名管道FIFO" class="headerlink" title="有名管道FIFO"></a>有名管道FIFO</h2><ul>
<li><p><code>FIFO</code> 常被称为命名管道，以区分管道<code>(pipe)</code>。管道<code>(pipe)</code>只能用于“有血缘关系”的进程间。但通过 <code>FIFO</code>，不相关的进程也能交换数据。</p>
</li>
<li><p><code>FIFO </code>是 <code>Linux</code> 基础文件类型中的一种。但，<code>FIFO</code> 文件在磁盘上没有数据块（所以没有大小），仅仅用来标识内核中一条通道。各进程可以打开这个文件进行 <code>read/write</code>，实际上是在读写内核通道，这样就实现了进程间通信。</p>
</li>
<li><p>真有意思，<code>fifo</code>作为文件系统中的一种文件，内容居然存在于内存。使用<code>fifo</code>的进程退出后，<code>fifo</code>文件将继续保存在文件系统中以便后续使用。</p>
</li>
<li><p>创建</p>
<ul>
<li>命令：<code>mkfifo</code></li>
<li>函数：<code>int mkfifo(const char *pathname, mode_t mode);</code></li>
</ul>
</li>
<li><p>打开</p>
<ul>
<li>读端：<code>int fd1 = open(&quot;./fifo2&quot;,O_RDONLY);</code></li>
<li>写端：<code>int fd1 = open(&quot;./fifo2&quot;,O_WRONLY);</code></li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>以<code>O_RDONLY</code>且没有<code>O_NONBLOCK</code>打开一个<code>fifo</code>时，会阻塞等待指导有一个进程对<code>fifo</code>执行写打开。</li>
<li>所以当一个进程需要对<code>fifo</code>写读时，一般使用<code>O_RDWR</code></li>
<li>迷惑：程序里用<code>mkfifo</code>创建一个管道时，对管道的默认权限好像不可以写。</li>
<li>似乎不是重点？日后用到再补充。<br><img src="/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/2021-11-29-15-49-03.png"></li>
</ul>
</li>
<li><p><code>fifo_shc1</code>写，<code>fifo_shc2</code>读</p>
<ul>
<li><p><code>fifo_shc1</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//  这个权限很迷，貌似不可以写</span></span><br><span class="line"><span class="comment">//      int fd1 = mkfifo(&quot;./fifo2&quot;,0664);</span></span><br><span class="line">        <span class="keyword">int</span> fd1 = open(<span class="string">&quot;./fifo2&quot;</span>,O_RDWR);</span><br><span class="line">        <span class="keyword">int</span> fd2 = open(<span class="string">&quot;./waitpid_shc.c&quot;</span>,O_RDONLY);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">int</span> len = read(fd2,buf,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,len);</span><br><span class="line">                write(fd1,<span class="string">&quot;hhhhhhhh&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;hhhhhhhh&quot;</span>));</span><br><span class="line">                <span class="comment">//  只有第一次读的时候有len!=0 一次数据就读完了。需要用lseek移动文件指针。</span></span><br><span class="line">                <span class="keyword">if</span>(len) </span><br><span class="line">                &#123;</span><br><span class="line">                        write(fd1,buf,len);</span><br><span class="line">                        write(STDOUT_FILENO,buf,len);</span><br><span class="line">                &#125;</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line">        close(fd2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>fifo_shc2</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SADSADADSADASDS\n&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> fd1 = open(<span class="string">&quot;/home/shc/code/revier/fifo2&quot;</span>,O_RDWR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;KKKK\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(fd1==<span class="number">-1</span>)&#123;</span><br><span class="line">                perror(<span class="string">&quot;open wrong&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;???\n&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;??\n&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> len = read(fd1,buf,<span class="keyword">sizeof</span> buf);</span><br><span class="line">                write(STDOUT_FILENO,buf,len);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,len);</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        close(fd1);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SADSADADSADASDS</span><br><span class="line">KKKK</span><br><span class="line">???</span><br><span class="line">??</span><br><span class="line">hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh56</span><br><span class="line">??</span><br><span class="line">hhhhhhhh8</span><br><span class="line">??</span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;sys/wait.h&gt;</span></span><br><span class="line">...若干文件内容 只读了一次就读完了</span><br><span class="line">hhhhhhhh783</span><br><span class="line">??</span><br><span class="line">hhhhhhhh8</span><br><span class="line">??</span><br><span class="line">hhhhhhhhhhhhhhhh16</span><br><span class="line">??</span><br><span class="line">hhhhhhhh8</span><br><span class="line">??</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="存储映射I-O-mmap"><a href="#存储映射I-O-mmap" class="headerlink" title="存储映射I/O mmap"></a><code>存储映射I/O mmap</code></h2><h3 id="void-mmap-void-addr-size-t-length-int-prot-int-flags-int-fd-off-t-offset"><a href="#void-mmap-void-addr-size-t-length-int-prot-int-flags-int-fd-off-t-offset" class="headerlink" title="void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);"></a><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></h3><ul>
<li><p>存储映射（<code>memory-mapped I/O</code>）能将一个磁盘文件映射到存储空间的一个缓冲区上，于是，当从缓冲区读取数据时，就相当于读文件中的相应字节。与此类似，将数据写入缓冲区时，相应字节就自动写入文件。这样，就可以在不用<code>read，write</code>的情况下，执行<code>I/O</code>。（<code>mmap</code>将文件映射到用户区，所以可以使用C库函数，在用户区进行读写，不必进入内核，因而省去了使用<code>read/write</code>）</p>
</li>
<li><p>所以用mmap好处：可以用对指针进行操作的库函数；且是我知道的所有这些进程间通信方式中最快的。</p>
</li>
<li><p>父子进程共享</p>
<ul>
<li> <code>mmap</code>映射区</li>
<li>文件描述符（打开的文件结构体）</li>
</ul>
</li>
<li><p>上图！<br><img src="/2021/11/28/Linux-%E8%BF%9B%E7%A8%8B2/2021-11-29-22-54-41.png"></p>
</li>
<li><p><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></p>
<ul>
<li><code>addr</code>：指定映射存储区的起始地址。通常NULL，系统自动分配</li>
<li><code>length</code>：映射的字节数，即指定存储映射区大小。&lt;=文件实际大小</li>
<li><code>prot</code>：映射存储区的读写属性<ul>
<li><code>PROT_READ</code>：映射区可读</li>
<li><code>PROT_WRITE</code>：映射区可写</li>
<li><code>PROT_EXEC</code>：映射区可执行</li>
<li><code>PROT_NON</code>E：映射区不可访问</li>
</ul>
</li>
<li><code>flags</code>：标注映射存储区的属性。<ul>
<li><code>MAP_SHARED</code>：对存储映射区的修改会反应到物理磁盘上</li>
<li><code>MAP_PRIVATE</code></li>
<li><code>MAP_ANONYMOUS / MAP_ANON</code>：匿名</li>
</ul>
</li>
<li><code>fd</code>：用于创建存储映射区的文件的文件描述符</li>
<li><code>offset</code>：要映射字节在文件中的起始偏移量。应是4K的整数倍，一般为0。</li>
</ul>
</li>
<li><p><code>return</code></p>
<ul>
<li>成功：映射区的首地址</li>
<li>失败：<code>return MAP_FAILED(void*(-1);   + errno</code></li>
</ul>
</li>
<li><p><strong>注意</strong>（黑马）</p>
<ul>
<li> 用于创建映射区的文件（<code>fd</code>）大小为 0，实际指定非0大小创建映射区<code>（length）</code>，出 “总线错误 <code>SIGBUS</code>”。</li>
<li> 用于创建映射区的文件<code>（fd）</code>大小为 0，实际制定0大小创建映射区<code>（length）</code>， 出 “无效参数 <code>Invalid</code>”。</li>
<li> 用于创建存储映射区的文件读写属性为，只读<code>（open时的mode）</code>。存储映射区属性<code>（prot）</code>为 读、写<code>（PROT_READ|PROT_WRITE）</code>。 出 “无效参数”</li>
<li> 创建映射区的过程中，隐含着一次对映射文件的读操作。因此<code>mmap</code>创建映射区，必定需要<code>read</code>权限。</li>
<li> 当访问权限<code>（flags）</code>指定为 “共享”<code>MAP_SHARED</code>是， <code>mmap</code>的<code>（prot）</code>读写权限，应该 <code>&lt;=</code>文件的open权限。只写不行。</li>
<li> 映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭。文件描述符<code>fd</code>，在<code>mmap</code>创建存储映射区完成即可关闭。后续访问文件，用地址（即mmap返回的）指针访问。</li>
<li><code> offset</code> 必须是 <code>4096</code>的整数倍。（<code>MMU</code> 映射的最小单位 <code>4k</code> ）</li>
<li> 对申请的映射区内存，不能越界访问</li>
<li> <code>munmap</code>用于释放的 址，必须是<code>mmap</code>申请返回的地址。</li>
<li> 映射区访问权限<code>flags</code>为 “私有”<code>MAP_PRIVATE</code>, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘</li>
<li> 映射区访问权限<code>flags</code>为 “私有”<code>MAP_PRIVATE</code>, 只需要<code>open</code>文件时，有读权限，用于创建映射区即可。</li>
<li><code> munmap</code> 传入的地址一定是 <code>mmap</code> 的返回地址。坚决杜绝指针<code>++</code>操作</li>
<li> <code>mmap</code> 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作。</li>
</ul>
</li>
<li><p><code>mmap</code>保险调用</p>
<ul>
<li><code>fd = open(&quot; &quot;,O_RDWR);</code></li>
<li><code>mmap(NULL,文件大小,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SYNOPSIS</span></span><br><span class="line"><span class="comment">      #include &lt;sys/mman.h&gt;</span></span><br><span class="line"><span class="comment">自理:</span></span><br><span class="line"><span class="comment">    通过mmap映射 可以不进行read write，只用地址指针就对磁盘文件进行读写I/O操作。</span></span><br><span class="line"><span class="comment">    mmap将文件映射到用户区，所以可以使用C库函数，在用户区进行读写，不必进入内核，因而省去了使用read/write</span></span><br><span class="line"><span class="comment">      void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span></span><br><span class="line"><span class="comment">      int munmap(void *addr, size_t length);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;perror(str); <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./test_mmap3.txt&quot;</span>,O_RDONLY|O_CREAT|O_TRUNC,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>) sys_err(<span class="string">&quot;open erorr&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ftruncate(fd,<span class="number">100</span>);  <span class="comment">//  需要写权限。</span></span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END); <span class="comment">//  返回从文件起始到 SEEK_END再向后便宜0字节的大小，即文件大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  建立存储映射区</span></span><br><span class="line">    <span class="keyword">char</span> *p = mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>); </span><br><span class="line">    <span class="keyword">if</span>(p==MAP_FAILED)   sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);  <span class="comment">//  建立完之后即可关闭文件描述符！</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;hello void *mmap(void* addr , size_t length,int prot,int flags,int fd,off_t offset);\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------%s-----------------\n&quot;</span>,p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  释放</span></span><br><span class="line">    <span class="keyword">int</span> ret = munmap(p,len);  </span><br><span class="line">    <span class="keyword">if</span>(ret==<span class="number">-1</span>) sys_err(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件扩容100字节</span></span><br><span class="line"><span class="comment">// lseek(fd,99,SEEK_END);   //  将文件指针从SEEK_END向后移动9个字节</span></span><br><span class="line"><span class="comment">// write(fd,&quot;\0&quot;,1);   //  再写一个 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li><p>父子进程使用 <code>mmap</code> 进程间通信：</p>
<ul>
<li>父进程 先 创建映射区。 <code>open (O_RDWR)</code> <code>mmap(MAP_SHARED)</code>;</li>
<li>指定 <code>MAP_SHARED</code> 权限</li>
<li><code>fork()</code> 创建子进程。</li>
<li>一个进程读， 另外一个进程写。</li>
</ul>
</li>
<li><p>无血缘关系进程间 <code>mmap</code> 通信（<strong>重点</strong>）                  </p>
<ul>
<li>两个进程 打开同一个文件，创建映射区。</li>
<li>指定<code>flags</code> 为 <code>MAP_SHARED。</code></li>
<li>一个进程写入，另外一个进程读出。</li>
<li>不同于<code>fifo</code>，<code>mmap</code>存储映射区中的数据可以重复读取。</li>
</ul>
</li>
<li><p>匿名映射<code>flags</code>：只能用于血缘关系进程间通信。</p>
<ul>
<li>即不需要创建临时文件</li>
<li><code>Linux</code>下<ul>
<li><code>int *p = (int *)mmap(NULL,大小, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</code><ul>
<li><code>length</code>：任意</li>
<li><code>flags：MAP_ANONYMOUS/MAP_ANON</code></li>
<li><code>fd</code>：-1</li>
</ul>
</li>
</ul>
</li>
<li><code>Unix</code>下<ul>
<li><code>fd = open(&quot;/dev/zero&quot;, O_RDWR);</code></li>
<li><code> p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>使用<code>mmap</code>进行父子关系进程通信代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> var = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    fd = open(<span class="string">&quot;temp&quot;</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ftruncate(fd, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//p = (int *)mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);</span></span><br><span class="line">    p = (<span class="keyword">int</span> *)mmap(<span class="literal">NULL</span>, <span class="number">4</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;		<span class="comment">//注意:不是p == NULL</span></span><br><span class="line">        perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);					<span class="comment">//映射区建立完毕,即可关闭文件</span></span><br><span class="line"></span><br><span class="line">    pid = fork();				<span class="comment">//创建子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">      *p = <span class="number">7000</span>;               <span class="comment">// 写共享内存</span></span><br><span class="line">        var = <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, *p = %d, var = %d\n&quot;</span>, *p, var);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, *p = %d, var = %d\n&quot;</span>, *p, var);     <span class="comment">// 读共享内存</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = munmap(p, <span class="number">4</span>);				<span class="comment">//释放映射区</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;munmap error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>mmap</code>进行非血缘关系进程通信代码。</p>
<ul>
<li>结构<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier$ tree .</span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   ├── student.h</span><br><span class="line">│   └── sys_err.h</span><br><span class="line">└── src</span><br><span class="line">    ├── mmap_shc.c</span><br><span class="line">    ├── mmap_shc.out</span><br><span class="line">    ├── mmap_shc_read.c</span><br><span class="line">    ├── mmap_shc_read.out</span><br><span class="line">    ├── mmap_shc_write.c</span><br><span class="line">    ├── mmap_shc_write.out</span><br><span class="line">    ├── sys_err.c</span><br><span class="line"><span class="comment">//命令</span></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/revier/src$ gcc mmap_shc_read.c sys_err.c -o mmap_shc_raed.out -Iinclude -Wall</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体结构及头文件</span></span><br><span class="line"><span class="comment">// sys_err.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(name);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sys_err.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(name);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>写<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR|O_TRUNC|O_CREAT,<span class="number">0664</span>);</span><br><span class="line">    ftruncate(fd,<span class="keyword">sizeof</span> (struct student));</span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    unlink(argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  建立存储映射区，p指向那那段地方</span></span><br><span class="line">    <span class="comment">//                         存储映射区首地址    映射区长度   对存储映射区权限   是否反应到真实磁盘上 fd 起始偏移量  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> =</span> (struct student*)mmap(<span class="literal">NULL</span>,len,PROT_WRITE|PROT_READ,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==MAP_FAILED) sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  建立完映射区后即可关闭文件</span></span><br><span class="line">    close(fd);  <span class="comment">//  之后就是通过p对内存做事情 不需要文件描述符了 因此关闭</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">student</span> =</span> &#123;<span class="number">1</span>,<span class="string">&quot;shc&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;student,<span class="keyword">sizeof</span> student);</span><br><span class="line">        ++student.id;</span><br><span class="line">        usleep(<span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    munmap(p,<span class="keyword">sizeof</span> student); <span class="comment">//  释放映射区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>读<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/student.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;../include/sys_err.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>],O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> len = lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    unlink(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//  建立</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span> =</span> (struct student *)mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==MAP_FAILED) sys_err(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s\n&quot;</span>,p-&gt;id,p-&gt;name);</span><br><span class="line">        usleep(<span class="number">2000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  释放</span></span><br><span class="line">    munmap(p,<span class="keyword">sizeof</span> student);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./mmap_shc_write.out temp</span><br><span class="line">shc@shc-virtual-machine:~/code/revier/src$ ./mmap_shc_read.out temp</span><br><span class="line">22 shc</span><br><span class="line">24 shc</span><br><span class="line">26 shc</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>匿名映射代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">懒得写了，下次一定</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令常识</title>
    <url>/2021/11/05/Linux%E5%91%BD%E4%BB%A4%E5%B8%B8%E8%AF%86/</url>
    <content><![CDATA[<ul>
<li><code>od -c 文件</code><ul>
<li><code>od</code> 观察文件实际内容</li>
<li><code>-c</code>以字符方式打印文件内容</li>
</ul>
</li>
<li><code>ln -s</code><ul>
<li>创建软链接，又称符号链接。建议采用绝对路径。</li>
<li><code>shc@shc-virtual-machine:~/code/revier$ ln -s test02.txt ./soft_test02</code></li>
</ul>
</li>
<li><code>ln</code> <ul>
<li>创建硬链接。</li>
<li><code>shc@shc-virtual-machine:~/code/revier$ ln test01.txt ./test01_hard</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ReStart</title>
    <url>/2021/11/04/ReStart/</url>
    <content><![CDATA[<p><img src="/2021/11/04/ReStart/2021-11-04-22-11-58.png"></p>
<h1 id="重新搭建的小窝"><a href="#重新搭建的小窝" class="headerlink" title="重新搭建的小窝"></a>重新搭建的小窝</h1><ul>
<li><code>Dell</code>的硬盘坏掉了，来来回回修了快一个月</li>
<li>什么环境都没得了，幸好笔记还都在</li>
<li>虽然怕麻烦，不过重建一个自己的新窝还是很开心的。</li>
<li>继续记录吧。</li>
</ul>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/11/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
<span id="more"></span>

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/14/static-library-And-shared-object/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2021/11/04/test/</url>
    <content><![CDATA[<p>这是摘要</p>
<span id="more"></span>
<p>以下是正文</p>
<h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><p>1</p>
<h2 id="子标题1"><a href="#子标题1" class="headerlink" title="子标题1"></a>子标题1</h2><p>1.1</p>
<h3 id="子子标题1"><a href="#子子标题1" class="headerlink" title="子子标题1"></a>子子标题1</h3><p>1.1.1</p>
<h1 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h1><p>2</p>
<h2 id="子标题2"><a href="#子标题2" class="headerlink" title="子标题2"></a>子标题2</h2><p>2.2</p>
<h3 id="子子标题2"><a href="#子子标题2" class="headerlink" title="子子标题2"></a>子子标题2</h3><p>2.2.2</p>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
  <entry>
    <title>test02</title>
    <url>/2021/11/04/test02/</url>
    <content><![CDATA[<p>如何插入图片</p>
<span id="more"></span>
<p><img src="/2021/11/04/test02/2021-11-04-21-26-16.png"></p>
<h1 id="如何插入图片"><a href="#如何插入图片" class="headerlink" title="如何插入图片"></a>如何插入图片</h1><ul>
<li>过程<ul>
<li><code>hexo new xxx</code><ul>
<li>会生成一个同名文件夹</li>
</ul>
</li>
<li><code>ctrl + alt + v</code>  <ul>
<li>图片会自动到同名文件夹下。</li>
</ul>
</li>
</ul>
</li>
<li>有用插件 <ul>
<li><code>hexo-asset-image</code></li>
<li><code>hexo-renderer-ejs</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Blog_test</category>
      </categories>
      <tags>
        <tag>Blog_test</tag>
      </tags>
  </entry>
</search>
