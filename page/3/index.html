<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="小窝">
<meta property="og:type" content="website">
<meta property="og:title" content="不落辰">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="不落辰">
<meta property="og:description" content="小窝">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Cstardust">
<meta property="article:tag" content="C++,Linux">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>不落辰</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不落辰" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不落辰</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知不可乎骤得,托遗响于悲风</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/git%E5%B8%B8%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/01/git%E5%B8%B8%E8%AF%86/" class="post-title-link" itemprop="url">git常识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-01 22:03:24" itemprop="dateCreated datePublished" datetime="2022-05-01T22:03:24+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:14:52" itemprop="dateModified" datetime="2022-05-28T22:14:52+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E8%83%BD-%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">技能 & 工具</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>分布式git 集中式SVN<ul>
<li>集中式SVN：版本控制只发生在远程仓库上。本地没有。所以要如果没有连接远程仓库，就不能获取之前版本的代码。也就是必须在一个局域网里开发。</li>
<li>git：版本控制在本地仓库和远程仓库均有。断网也能获取之前版本的代码。</li>
<li>github：远程代码版本托管系统<blockquote>
<p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-01-22-09-33.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="仓库拉取"><a href="#仓库拉取" class="headerlink" title="仓库拉取"></a>仓库拉取</h2><ul>
<li>git clone ssh远程仓库地址：<ul>
<li>拉取仓库代码到本地，在本地生成一个仓库</li>
<li>本地自动创建两个东西<ul>
<li>远程仓库的名称 origin</li>
<li>本地仓库默认生成主干分支 <code>main</code> 。与远程仓库的对应关系生成好了就<code>main -&gt; origin/main</code></li>
</ul>
</li>
</ul>
</li>
<li>工作区、暂存区、本地仓库代码分支、远程仓库代码分支<blockquote>
<p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-02-09-53-43.png"></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>git clone命令的作用是，可以把指定的远程仓库代码拉取到本地<br>git add 把git工作区的代码改动添加到暂存区<br>git commit -m “xxx” 把暂存区的代码提交到本地分支<br>写代码是在工作区，add是把代码从工作区交到暂存区<br>git push (origin main) 把本地分支的代码推送（提交）到远程分支上去<br>git pull 把远程代码拉取到本地<br>git status 查看当前操作的状态信息<br>git log 查看代码修改日志。（看谁改过代码）<br>工作区：当前存放项目代码的目录<br>暂存区：git add把工作区修改的内容添加到暂存区当中<br>本地仓库：git commit把本地暂存区的修改提交到本地代码仓库分支中（不同分支代表不同的代<br>码版本）<br>远程仓库：通过git push把本地仓库的某一个分支上的代码推送到远程仓库的某个分支上<br>HEAD指针：本地仓库每一个分支上的代码修改都会生成一个commit id信息，HEAD指针指向最<br>近一次的commit提交，通过这个commit id可以进行版本回退。HEAD指向最新的修改<br>git reflog：查看进行过的commit、reset操作<br>git diff HEAD –main.cpp 查看工作区main.cpp和本地仓库的main.cpp有什么区别</p>
</blockquote>
<blockquote>
<p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-02-10-44-21.png"></p>
</blockquote>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-02-11-30-41.png"></p>
<ul>
<li>各种回退<ul>
<li>工作区回退<ul>
<li><code>git checkout --filename</code></li>
<li>用本地仓库分支代码将工作区代码覆盖掉</li>
</ul>
</li>
<li>暂存区回退 <ul>
<li><code>git reset HEAD filename</code></li>
<li>取消对暂存区的修改</li>
</ul>
</li>
<li>本地仓库版本回退<ul>
<li><code>git reset --hard commitid</code></li>
<li>本地仓库回退到commitid版本</li>
</ul>
</li>
<li>远程仓库版本回退<ul>
<li>先本地回退，再<code>git push -f</code>。</li>
<li>回退到没发生错误的版本，强制提交。（如果别人还没提交代码的话）</li>
<li>本地的commit落后于远程的commit时，不能提交到远程仓库。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dell@DESKTOP-TVUERHD MINGW64 /e/Git/HelloWorld/HelloWorld (main)</span><br><span class="line">$ git push</span><br><span class="line">To github.com:Cstardust/HelloWorld.git</span><br><span class="line"> ! [rejected]        main -&gt; main (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">&#x27;github.com:Cstardust/HelloWorld.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure></li>
<li>如果自己提交错误代码，那么回退本地仓库，再用本地仓库覆盖远程仓库。前提：两次提交之间没有其他人commit。<ul>
<li>当确定自己提交错误之后没有别人提交，那么可以<code>git push -f</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>git checkout –  在git add之前，把工作区的代码用版本库中的代码覆盖掉，注意命令中的–不能<br>去掉，否则成切换分支的命令了<br>git reset HEAD 把git add之后，暂存区的内容全部撤销<br>git reset –hard  commitid 把提交到本地仓库中的代码改动进行回退<br>git reflog 查看HEAD指针的改动日志<br>git push -f 强制推送本地仓库代码到远程仓库<br>git diff HEAD –  查看工作区file文件和仓库中该文件最新版本的代码有什么区别</p>
</blockquote>
<ul>
<li>常识：指令信息含义<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dell@DESKTOP-TVUERHD MINGW64 /e/Git/HelloWorld/HelloWorld (main)</span><br><span class="line">$ git reflog</span><br><span class="line"><span class="comment">#  HEAD指针指向的版本是 当前的本地main分支 远程的main分支 远程的head指针也指向相同版本 </span></span><br><span class="line">717c054 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;0&#125;: reset: moving to 717c</span><br><span class="line">cb65a86 HEAD@&#123;1&#125;: reset: moving to cb65</span><br><span class="line">717c054 (HEAD -&gt; main, origin/main, origin/HEAD) HEAD@&#123;2&#125;: commit: windows一个错误的commit</span><br><span class="line">cb65a86 HEAD@&#123;3&#125;: reset: moving to HEAD</span><br><span class="line">cb65a86 HEAD@&#123;4&#125;: pull: Fast-forward</span><br><span class="line">0bcc164 HEAD@&#123;5&#125;: commit: 创建const.cpp文件，写了c++const代码</span><br><span class="line">34a386c HEAD@&#123;6&#125;: <span class="built_in">clone</span>: from github.com:Cstardust/HelloWorld.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id><a href="#" class="headerlink" title=".."></a>..</h2><h2 id="git工作实践"><a href="#git工作实践" class="headerlink" title="git工作实践"></a>git工作实践</h2><p><img src="/2022/05/01/git%E5%B8%B8%E8%AF%86/2022-05-03-21-33-55.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/01/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="post-title-link" itemprop="url">内存对齐</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-01 11:25:20" itemprop="dateCreated datePublished" datetime="2022-05-01T11:25:20+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:44:01" itemprop="dateModified" datetime="2022-05-28T22:44:01+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BE%85%E5%81%9A/" itemprop="url" rel="index"><span itemprop="name">待做</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/tutorial/10018/446a7a7f8eaf41749573a0d187efda47">https://www.nowcoder.com/tutorial/10018/446a7a7f8eaf41749573a0d187efda47</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">3.内存对齐的作用是什么？</span><br><span class="line">答案：提升性能：减少CPU读取内存的次数，提升程序执行的效率</span><br><span class="line">图片标题</span><br><span class="line"></span><br><span class="line">上图是CPU和几种存储之间的存取速度在这30多年的发展对比（图片来自CMU的深入理解计算机系统课程）。内存就是上述的DRAM存储，CPU的速度和内存 的速度之间差距接近1000倍，3个数量级的差距。可见如果能够减少对内存的读取次数可以极大的提升程序的执 行效率。移植原因：有的硬件体系不支持非对齐内存地址的电路系统.当遇到非对齐内存地址的存取时,它将抛出一个异常，可能导致程序崩溃。</span><br><span class="line"></span><br><span class="line">4.内存对齐的原则是什么？</span><br><span class="line">答：三原则:</span><br><span class="line">结构体变量的起始地址能够被其最宽的成员大小整除；</span><br><span class="line">结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充空白字节；</span><br><span class="line">结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充空白字节；</span><br><span class="line">分析：编译器在编译的时候是可以指定对齐大小的，实际使用的有效对齐其实是取指定大小和自身大小的最小值，一般默认的对齐大小是4。可以通过预编译命令#pragma pack(n)。除了上述3原则之外还有其他的对齐规则：计算机体系结构当中缓存是很重要的一环，CPU不是直接读取内存而是读取缓存：高速缓冲存储器。其作用是为了更好的利用局部性原理，减少CPU访问主存的次数。因为存取内存相对存取缓存是慢很多的，cache也可以看做是一种空间换时间的做法。实际读取内存的是缓存。所以内存对齐有的时候还需要考虑缓存更新的读取策略，一些规则如下：</span><br><span class="line">1.对较大结构体进行cache line对齐：Cache与内存交换的最小单位为cache line。一个cache line大小以64字节为例。当我们的结构体大小没有与64字节对齐时，一个结构体可能就要占用比原本需要更多的cache line,同时还会带来错误共享问题，大家可以自行google。</span><br><span class="line"></span><br><span class="line">2.对只读字段和读写字段分离对齐： 只读字段和读写字段分离对齐的目的是为了让只读字段和读写字段分别存储在缓存的不同cache line中，使得读写字段的淘汰尽量少的影响只读字段，因为只读字段不会被改变所以应该尽量少的被缓存换出。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.什么是指令乱序？</span><br><span class="line">答：从编译器的角度其实是对我们写的代码的一种优化，按照机器的角度讲一些指令代码执行顺序进行改变，优化程序实际执行的效率。</span><br><span class="line">分析：之所以出现编译器乱序优化是因为编译器能在很大范围内进行代码分析,从而做出更优的执行策略,可以充分利用处理器的乱序执行功能。</span><br><span class="line">指令乱序的问题：编译器优化产生的指令乱序可能会导致多线程程序产生意外的结果。</span><br><span class="line"></span><br><span class="line">6.如何解决指令乱序问题？</span><br><span class="line">答：内存屏障。</span><br><span class="line">分析：内存屏障，是一类同步指令，是对内存随机访问的操作中的一个同步点。此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。因为指令乱序执行的存在，就需要内存屏障保证程序执行的可靠。</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/" class="post-title-link" itemprop="url">sgi_stl二级空间配置器移植代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-30 17:23:21" itemprop="dateCreated datePublished" datetime="2022-04-30T17:23:21+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:53:26" itemprop="dateModified" datetime="2022-05-28T22:53:26+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sgi-stl-内存池"><a href="#sgi-stl-内存池" class="headerlink" title="sgi_stl 内存池"></a>sgi_stl 内存池</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><ul>
<li><code>template&lt;typename T&gt; class my_allocator&#123;&#125;</code><br><img src="/2022/04/30/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-20-40-33.png"><br><img src="/2022/04/30/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E7%A7%BB%E6%A4%8D%E4%BB%A3%E7%A0%81/2022-05-01-20-41-44.png"></li>
</ul>
<h2 id="OOP封装"><a href="#OOP封装" class="headerlink" title="OOP封装"></a>OOP封装</h2><ul>
<li>对外接口<ul>
<li>allocate、deallocate、reallocate、construct、destroy<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 移植SGI STL二级空间配置器源码</span></span><br><span class="line"><span class="comment">* 不同于nginx内存池，二级空间配置器中使用到的内存池需要注意多线程问题</span></span><br><span class="line"><span class="comment">* nginx内存池，可以一个线程创建一个内存池</span></span><br><span class="line"><span class="comment">* 而二级空间配置器，是用来给容器使用的，如vector对象。而一个vector对象很有可能在多个线程并发使用</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 移植成功！一个线程安全的二级空间配置器 my_allocator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//  一级空间配置器 将对象构造和内存开辟分开</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">first_level_my_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		T* p = <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T)*size);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, <span class="keyword">const</span> T&amp; _val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (p) <span class="built_in">T</span>(_val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* p, T&amp;&amp; rval)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (p) <span class="built_in">T</span>(std::<span class="built_in">move</span>(rval));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destory</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">	<span class="comment">//  预制的回调函数 _S_oom_malloc -&gt; __malloc_alloc_oom_handler</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//  尝试分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);	<span class="comment">//  尝试释放nbytes内存，返回给result</span></span><br><span class="line">		<span class="keyword">return</span> __result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">free</span>(__p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新分配new_sz大小内存 </span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">		<span class="keyword">return</span> __result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//  用户通过这个接口来预制自己的回调函数。用以释放内存来解决内存不足的问题</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*__set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">void</span></span> (*__old)() = __malloc_alloc_oom_handler;</span><br><span class="line">		__malloc_alloc_oom_handler = __f;</span><br><span class="line">		<span class="keyword">return</span>(__old);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  my_allocator中用到的__malloc_alloc_template中的两个函数和一个成员</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		__my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) &#123; <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); &#125;</span><br><span class="line">		(*__my_malloc_handler)();</span><br><span class="line">		__result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">		<span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">void</span></span> (*__my_malloc_handler)();</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		__my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == __my_malloc_handler) &#123; <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>(); &#125;</span><br><span class="line">		(*__my_malloc_handler)();</span><br><span class="line">		__result = <span class="built_in">realloc</span>(__p, __n);</span><br><span class="line">		<span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*__malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">using</span> malloc_alloc = __malloc_alloc_template&lt;<span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  二级空间配置器 对外接口为allocate、deallocate、reallocate、construct、destroy</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> value_type = T;</span><br><span class="line">	<span class="keyword">using</span> _Newfirst = T;</span><br><span class="line">	<span class="keyword">using</span> _From_primary = my_allocator;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">(<span class="keyword">const</span> my_allocator&amp;)</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Other</span>&gt;</span></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">my_allocator</span><span class="params">(<span class="keyword">const</span> my_allocator&lt;_Other&gt;&amp;)</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  开辟内存</span></span><br><span class="line">	<span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新分配内存。并将原先的内存归还给操作系统。并且不要再使用p的原指向地址</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  构建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* __p, <span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (__p) <span class="built_in">T</span>(val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* __p, T&amp;&amp; val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> (__p) <span class="built_in">T</span>(std::<span class="built_in">move</span>(val));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* __p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		__p-&gt;~<span class="built_in">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">	<span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _ALIGN = <span class="number">8</span> &#125;;								<span class="comment">//  自由链表从8bytes开始，以8bytes为对齐方式，一直扩充到128Bytes</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _MAX_BYTES = <span class="number">128</span> &#125;;							<span class="comment">//  最大块大小   &gt;128就不会放到内存池里了，也即不会用二级空间配置器。会用一级空间配置器</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> &#123;</span> _NFREELISTS = <span class="number">16</span> &#125;;  						<span class="comment">//  自由链表成员个数  _MAX_BYTES/_ALIGN</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  将byte上调至8的倍数</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  计算出bytes大小的chunk应该挂载到自由链表free-list的哪个成员下</span></span><br><span class="line">	<span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">		<span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  开辟内存池，挂载到freelist成员下，返回请求的内存块。</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">	<span class="comment">//  从还没形成链表的原始内存中取内存分配给自由链表成员，去形成链表。如果原始空闲内存不够了，则再开辟</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  每个chunk块的信息。_M_free_list_link指向下一个chunk块</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">		<span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  基于free-list的内存池，需要考虑线程安全</span></span><br><span class="line">	<span class="keyword">static</span> _Obj* <span class="keyword">volatile</span> _S_free_list[_NFREELISTS];	<span class="comment">//  防止被线程缓存</span></span><br><span class="line">	<span class="keyword">static</span> std::mutex mtx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  static：类内声明、类外定义。</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;         <span class="comment">//   空闲free内存的起始start位置 </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;           <span class="comment">//   空闲free内存的结束end位置 ) </span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;         <span class="comment">//   总共malloc过的内存大小（因为malloc是从堆heap上请求的，所以叫heapsize）</span></span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  static 类内声明，类外定义/初始化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::mutex my_allocator&lt;T&gt;::mtx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> my_allocator&lt;T&gt;::_S_heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> my_allocator&lt;T&gt;::_Obj* <span class="keyword">volatile</span></span><br><span class="line">my_allocator&lt;T&gt; ::_S_free_list[my_allocator&lt;T&gt;::_NFREELISTS] </span><br><span class="line">= &#123; <span class="literal">nullptr</span>,<span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* my_allocator&lt;T&gt;::<span class="built_in">allocate</span>(<span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">	__n = __n * <span class="built_in"><span class="keyword">sizeof</span></span>(T);		<span class="comment">//  因为vector容器传来的是元素个数</span></span><br><span class="line">	<span class="comment">//  std::cout &lt;&lt; &quot;user allocate &quot; &lt;&lt; __n &lt;&lt; std::endl;</span></span><br><span class="line">	<span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES) &#123;</span><br><span class="line">		__ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		_Obj* <span class="keyword">volatile</span>* __my_free_list</span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);</span><br><span class="line">		<span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">		<span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">		<span class="comment">// unwinding.</span></span><br><span class="line">		<span class="comment">//  _S_free_list 是所有线程共享的。加锁实现线程安全</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">		_Obj* __result = *__my_free_list;</span><br><span class="line">		<span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">			__ret = _S_refill(_S_round_up(__n));</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			*__my_free_list = __result-&gt;_M_free_list_link;</span><br><span class="line">			__ret = __result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T*&gt;(__ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* my_allocator&lt;T&gt;::_S_refill(<span class="keyword">size_t</span> __n)  <span class="comment">//  n是一个chunk块的大小</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//  分配指定大小的内存池    __nobjs：chunk内存块数量 ；这里的 __n：每个chunk内存块大小。</span></span><br><span class="line">	<span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">	_Obj* <span class="keyword">volatile</span>* __my_free_list;</span><br><span class="line">	_Obj* __result;</span><br><span class="line">	_Obj* __current_obj;</span><br><span class="line">	_Obj* __next_obj;</span><br><span class="line">	<span class="keyword">int</span> __i;</span><br><span class="line">	<span class="comment">//  __nobjs：申请到的chunk块数量。当只申请到一个时，直接返回该内存块给上一级使用。无需建立各个chunk的连接关系，无需挂载到相应的freelist成员下。（因为只有一个）</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line"></span><br><span class="line">	__my_free_list = _S_free_list + _S_freelist_index(__n);     <span class="comment">//  根据内存块大小求出内存池应该在由freelist第几个成员管理（指向）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//  静态链表：把每个chunk块通过Obj*里的指针连接起来</span></span><br><span class="line">	<span class="comment">//  每个内存块，有一部分的内存时union联合体Obj，里面有一个Obj*指针，负责连接每个空闲内存块。</span></span><br><span class="line">	<span class="comment">/* Build free list in chunk */</span></span><br><span class="line">	__result = (_Obj*)__chunk;</span><br><span class="line">	*__my_free_list = __next_obj = (_Obj*)(__chunk + __n);    <span class="comment">//  __n：一个内存块的大小（因为第一个内存块要分配出去）</span></span><br><span class="line">	<span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">		__current_obj = __next_obj;</span><br><span class="line">		__next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);          <span class="comment">//   维护内存块间的连接  char* 因此+__n是偏移n个bytes +n是为了一次跑一个chunk块</span></span><br><span class="line">		<span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;                               <span class="comment">//   空闲内存块数为0?</span></span><br><span class="line">			__current_obj-&gt;_M_free_list_link = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			__current_obj-&gt;_M_free_list_link = __next_obj;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(__result);   <span class="comment">//  返回第一个内存块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">char</span>* my_allocator&lt;T&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size,<span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">char</span>* __result;</span><br><span class="line">	<span class="keyword">size_t</span> __total_bytes = __size * __nobjs;            <span class="comment">//  本次总共需要请求的内存大小</span></span><br><span class="line">	<span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//  __default_alloc_template&lt;__threads, __inst&gt; 从开始到现在，请求的剩余空闲的的内存大小。不包括回收的。只是开辟的。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;                <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">		__result = _S_start_free;                       <span class="comment">//  __result 作为返回内存首地址</span></span><br><span class="line">		_S_start_free += __total_bytes;                 <span class="comment">//  移动_S_start_free</span></span><br><span class="line">		<span class="keyword">return</span>(__result);                               <span class="comment">//  [result , _S_start_free)  作为请求结果返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;                <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">		__nobjs = (<span class="keyword">int</span>)(__bytes_left / __size);</span><br><span class="line">		__total_bytes = __size * __nobjs;</span><br><span class="line">		__result = _S_start_free;</span><br><span class="line">		_S_start_free += __total_bytes;</span><br><span class="line">		<span class="keyword">return</span>(__result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;                                            <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">		<span class="keyword">size_t</span> __bytes_to_get =                         <span class="comment">//  当剩余的空闲内存不够时，需要向操统malloc内存。这是计算出需要malloc内存的大小（至少malloc出来要求内存的(__total_bytes)两倍）</span></span><br><span class="line">			<span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">		<span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">		<span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">		<span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                         <span class="comment">//  </span></span><br><span class="line">			_Obj* <span class="keyword">volatile</span>* __my_free_list =</span><br><span class="line">				_S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">			((_Obj*)_S_start_free)-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">			*__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">		&#125;</span><br><span class="line">		_S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//  向操统malloc内存</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">nullptr</span> == _S_start_free) &#123;                       <span class="comment">//  malloc失败</span></span><br><span class="line">			<span class="keyword">size_t</span> __i;</span><br><span class="line">			_Obj* <span class="keyword">volatile</span>* __my_free_list;</span><br><span class="line">			_Obj* __p;</span><br><span class="line">			<span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">			<span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">			<span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="comment">//  从别的freelist成员管理的原始备用内存池中借用至少size大小的chunk块</span></span><br><span class="line">			<span class="keyword">for</span> (__i = __size;__i &lt;= (<span class="keyword">size_t</span>)_MAX_BYTES;__i += (<span class="keyword">size_t</span>)_ALIGN) </span><br><span class="line">			&#123;</span><br><span class="line">				__my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">				__p = *__my_free_list;</span><br><span class="line">				<span class="keyword">if</span> (<span class="literal">nullptr</span> != __p) &#123;</span><br><span class="line">					*__my_free_list = __p-&gt;_M_free_list_link;</span><br><span class="line">					_S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">					_S_end_free = _S_start_free + __i;</span><br><span class="line">					<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">					<span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">					<span class="comment">// right free list.</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//  都没有时，只能allcoate</span></span><br><span class="line">			_S_end_free = <span class="literal">nullptr</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">			_S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">			<span class="comment">// This should either throw an</span></span><br><span class="line">			<span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">			<span class="comment">// succeeded.</span></span><br><span class="line">		&#125;</span><br><span class="line">		_S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">		_S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">		<span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* __p may not be 0 */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> my_allocator&lt;T&gt;::<span class="built_in">deallocate</span>(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)		<span class="comment">//  因为vector容器传来的是字节大小</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>)_MAX_BYTES)	<span class="comment">//  n&gt;128 同一级空间配置器</span></span><br><span class="line">	&#123;</span><br><span class="line">		malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		_Obj* <span class="keyword">volatile</span>* __my_free_list</span><br><span class="line">			= _S_free_list + _S_freelist_index(__n);  <span class="comment">//  找到相应freelist成员</span></span><br><span class="line">		_Obj* __q = (_Obj*)__p;       <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// acquire lock</span></span><br><span class="line">		<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">		__q-&gt;_M_free_list_link = *__my_free_list;</span><br><span class="line">		*__my_free_list = __q;</span><br><span class="line">		<span class="comment">// lock is released here</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* my_allocator&lt;T&gt;::<span class="built_in">reallocate</span>(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span>* __result;</span><br><span class="line">	<span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  old new都&gt;128byets，那么用的就应当是和一级空间配置器一样的方法malloc</span></span><br><span class="line">	<span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>)_MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>)_MAX_BYTES) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  如果即将分配的chunk块大小一致，那么不必，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="keyword">return</span>(__p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  重新开辟new_size大小内存，并拷贝数据到新开辟的内存里</span></span><br><span class="line">	__result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">	__copy_sz = __new_sz &gt; __old_sz ? __old_sz : __new_sz;</span><br><span class="line">	<span class="built_in">memcpy</span>(__result, __p, __copy_sz); <span class="comment">//  拷贝数据</span></span><br><span class="line">	<span class="built_in">deallocate</span>(__p, __old_sz);  <span class="comment">//  释放</span></span><br><span class="line">	<span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;myallocator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::vector&lt;<span class="keyword">int</span>,my_allocator&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">		std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/sgi_stl$ g++ *.cpp -o sgi_stl_allocator.out -Wall</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/sgi_stl$ ./sgi_stl_allocator.out </span><br><span class="line"><span class="number">0</span></span><br><span class="line">...</span><br><span class="line"><span class="number">98</span></span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%A7%BB%E6%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%A7%BB%E6%A4%8D/" class="post-title-link" itemprop="url">nginx内存池移植代码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-30 08:45:11" itemprop="dateCreated datePublished" datetime="2022-04-30T08:45:11+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:10:18" itemprop="dateModified" datetime="2022-05-28T22:10:18+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OOP移植内存池"><a href="#OOP移植内存池" class="headerlink" title="OOP移植内存池"></a>OOP移植内存池</h1><h2 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h2><p><img src="/2022/04/30/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%A7%BB%E6%A4%8D/2022-05-01-09-17-05.png"></p>
<h2 id="ngx-mem-pool-h"><a href="#ngx-mem-pool-h" class="headerlink" title="ngx_mem_pool.h"></a>ngx_mem_pool.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> nginx_memory_pool</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nginx_memory_pool</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> u_char = <span class="keyword">unsigned</span> <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">ngx_uint_t</span> = <span class="keyword">unsigned</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  小内存池（Block）头信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char* last;                           <span class="comment">//  可用内存起始</span></span><br><span class="line">    u_char* end;                            <span class="comment">//  内存末尾</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* next;                       <span class="comment">//  小内存Block链表</span></span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;           <span class="comment">//  分配内存是否成功</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  大内存池（Block）头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* next;     <span class="comment">//   大内存Block的头信息链表</span></span><br><span class="line">    <span class="keyword">void</span>* alloc;                <span class="comment">//   指向申请的大内存Block</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*ngx_pool_cleanup_pt)</span><span class="params">(<span class="keyword">void</span>* data)</span></span>;     <span class="comment">//  回调函数；负责清理外部资源</span></span><br><span class="line"><span class="comment">//  外部资源的头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_t</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;      <span class="comment">//  处理外部资源的回调函数</span></span><br><span class="line">    <span class="keyword">void</span>* data;                         <span class="comment">//  传给handler的参数</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* next;           <span class="comment">//  外部资源头信息链表。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  管理整个内存池的头信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;                <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;              <span class="comment">//  大块内存和小块内存的分界线。p-&gt;max：一个小块Block块内最多能分配多大的内存。其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095              </span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* current;                    <span class="comment">//  指向第一块提供小块内存分配的小块内存Block地址</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;                <span class="comment">//  大内存Block头信息的链表入口</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* cleanup;            <span class="comment">//  外部资源的头信息链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  32位 4   64位 8</span></span><br><span class="line"><span class="comment">//  小块内存考虑字节对齐时的单位</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_ALIGNMENT = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>);    <span class="comment">/* platform word */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  默认一个页面大小：4KB</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ngx_pagesize = <span class="number">4096</span>;  <span class="comment">//  1024B = 1KB</span></span><br><span class="line"><span class="comment">//  ngx小块内存block里可分配的最大空间。（也即不能超过一个页）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MAX_ALLOC_FROM_POOL = ngx_pagesize - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  默认创建的内存池大小为16K</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_DEFAULT_POOL_SIZE = <span class="number">16</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//  对齐为16的整数倍</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_POOL_ALIGNMENT = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将d上调至a的倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align(d,a) ( ((d)+(a-1)) &amp; ~(a-1) )</span></span><br><span class="line"><span class="comment">//  把指针p调整到a的临近倍数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_align_ptr(p, a)                                                   \</span></span><br><span class="line"><span class="meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memset(buf, c, n)     (void) memset(buf, c, n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  ngx小块内存池最小的size调整成 NGX_POOL_ALIGNMENT 的倍数</span></span><br><span class="line"><span class="comment">//  保证至少能有一个ngx_pool_t头信息的大小 如 sizeof(ngx_pool_t)【15】 + 2*8 = 31    调整至32</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NGX_MIN_POOL_SIZE = <span class="built_in">ngx_align</span>((<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>) + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>)), NGX_POOL_ALIGNMENT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* OOP 移植nginx内存池</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ngx_mem_pool</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  构造函数，创建内存池。</span></span><br><span class="line">    <span class="built_in">ngx_mem_pool</span>(<span class="keyword">size_t</span> size = NGX_DEFAULT_POOL_SIZE);</span><br><span class="line">    <span class="comment">//  析构函数，释放内存池</span></span><br><span class="line">    ~<span class="built_in">ngx_mem_pool</span>();</span><br><span class="line">    <span class="comment">//  考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  不考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_pnalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  调用ngx_palloc，并初始化为0.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_pcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  释放大块内存block。ngx不提供释放小块内存的接口。原因见博客</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_pfree</span><span class="params">(<span class="keyword">void</span>* p)</span></span>;</span><br><span class="line">    <span class="comment">//  内存重置函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_reset_pool</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">//  添加回调清理操作函数</span></span><br><span class="line">    <span class="function"><span class="keyword">ngx_pool_cleanup_t</span>* <span class="title">ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//  指向nginx内存池的入口指针，一个内存池只有一个pool。即第一个创建的内存block里的ngx_pool_t。pool_的指向不会改变，始终是第一个，因为只有第一个有。会发生改变的是它指向的current，next之类的东西。</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* pool_;                      </span><br><span class="line">    <span class="comment">//  尝试从内存池中拿出size大小内存。内存池不够则从操作系统开辟。align=1意味着需要内存对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span>;</span><br><span class="line">    <span class="comment">//  从操作系统开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用ngx_memalign。在unix平台下ngx_memalign就是ngx_alloc</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">//  从操作系统开辟大块内存，挂载到某个已有的大块头信息下。（或再从内存池申请一块用作大内存block头信息）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;           </span><br><span class="line">    <span class="comment">//  销毁内存池</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ngx_destroy_pool</span><span class="params">()</span></span>;           </span><br><span class="line">    <span class="comment">//  创建size大小的内存池  （每个小内存block的大小均为size）</span></span><br><span class="line">    <span class="function"><span class="keyword">ngx_pool_t</span>* <span class="title">ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//    void* ngx_alloc(size_t size);  //  从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h2 id="ngx-mem-pool-cpp"><a href="#ngx-mem-pool-cpp" class="headerlink" title="ngx_mem_pool.cpp"></a>ngx_mem_pool.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;ngx_mem_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//  创建size大小的内存池  （每个小内存block的大小均为size）</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span>* <span class="title">ngx_mem_pool::ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pool_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_t</span>*&gt;(<span class="built_in">malloc</span>(size));</span><br><span class="line">    <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;d.last = (u_char*)pool_ + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    pool_-&gt;d.end = (u_char*)pool_ + size;</span><br><span class="line">    pool_-&gt;d.next = <span class="literal">nullptr</span>;</span><br><span class="line">    pool_-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    pool_-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;current = pool_;</span><br><span class="line">    pool_-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">    pool_-&gt;cleanup = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pool_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  考虑字节对齐，从内存池申请size大小的内存。下层有可能从操统开辟新内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool_-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  尝试从内存池中拿出size大小内存。内存池不够则从操作系统开辟。align=1意味着需要内存对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc_small</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char* m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p;</span><br><span class="line">    p = pool_-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align) &#123;</span><br><span class="line">            m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT));  <span class="comment">//  ??</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>)(p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操作系统malloc开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用ngx_memalign。在unix平台下ngx_memalign就是ngx_alloc。（就是对malloc的浅封装）</span></span><br><span class="line"><span class="keyword">void</span>* ngx_mem_pool :: <span class="built_in">ngx_palloc_block</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char* m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p, * new_m;</span><br><span class="line"></span><br><span class="line">    psize = (<span class="keyword">size_t</span>)(pool_-&gt;d.end - (u_char*)pool_);</span><br><span class="line"></span><br><span class="line">    m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">malloc</span>(psize));   <span class="comment">//  ngx_alloc底层就是malloc</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new_m = (<span class="keyword">ngx_pool_t</span>*)m;</span><br><span class="line"></span><br><span class="line">    new_m-&gt;d.end = m + psize;</span><br><span class="line">    new_m-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    new_m-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="keyword">static_cast</span>&lt;u_char*&gt;(<span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT));</span><br><span class="line">    new_m-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool_-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool_-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = new_m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操作系统malloc开辟大块内存，挂载到某个已有的大块头信息下。（或再从内存池申请一块用作大内存block头信息）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_palloc_large</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (large = pool_-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_large_t</span>*&gt;(<span class="built_in">ngx_palloc_small</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool_-&gt;large;</span><br><span class="line">    pool_-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</span></span><br><span class="line"><span class="comment">// void* ngx_mem_pool::ngx_alloc(size_t size)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     void* p = malloc(size);</span></span><br><span class="line"><span class="comment">//     return p;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  释放大块内存block。ngx不提供释放小块内存的接口。原因见博客</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_pfree</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* l;</span><br><span class="line">    <span class="keyword">for</span> (l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  考虑字节对齐，从内存池申请size大小的内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ngx_mem_pool::ngx_pnalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool_-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(size, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  调用ngx_palloc，并初始化为0.</span></span><br><span class="line"><span class="keyword">void</span>* ngx_mem_pool :: <span class="built_in">ngx_pcalloc</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  从内存池申请内存</span></span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">ngx_palloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;    <span class="comment">//  清0操作</span></span><br><span class="line">        <span class="built_in">ngx_memzero</span>(p, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  内存重置函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_reset_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  自己加的：释放外部资源</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">ngx_pool_cleanup_t</span>* c = pool_-&gt;cleanup; c; c = c-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler&amp;&amp;c-&gt;data) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">            c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line">            c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">ngx_pool_large_t</span>* l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重置小块内存</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p = pool_;</span><br><span class="line">    p-&gt;d.last = (u_char*)p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = p-&gt;d.next; p; p = p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;d.last = (u_char*)p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for (p = pool_; p; p = p-&gt;d.next) &#123;</span></span><br><span class="line">    <span class="comment">//    p-&gt;d.last = (u_char*)p + sizeof(ngx_pool_t);</span></span><br><span class="line">    <span class="comment">//    p-&gt;d.failed = 0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//  重置pool_成员</span></span><br><span class="line">    pool_-&gt;current = pool_;</span><br><span class="line">    pool_-&gt;large = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  销毁内存池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_mem_pool::ngx_destroy_pool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* p, * n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放外部资源</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool_-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool_-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放小块内村</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool_, n = pool_-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  申请外部资源信息头、添加回调清理操作函数</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_cleanup_t</span>* <span class="title">ngx_mem_pool::ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* c;</span><br><span class="line"></span><br><span class="line">    c = <span class="keyword">static_cast</span>&lt;<span class="keyword">ngx_pool_cleanup_t</span>*&gt;(<span class="built_in">ngx_palloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">nullptr</span>;</span><br><span class="line">    c-&gt;next = pool_-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    pool_-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ngx_mem_pool::<span class="built_in">ngx_mem_pool</span>(<span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    pool_ = <span class="built_in">ngx_create_pool</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (pool_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_mem_pool::~<span class="built_in">ngx_mem_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~ngx_mem_pool&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">ngx_destroy_pool</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="test-mem-pool-cpp"><a href="#test-mem-pool-cpp" class="headerlink" title="test_mem_pool.cpp"></a>test_mem_pool.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;ngx_mem_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//  多个指针</span></span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    FILE* pfile;</span><br><span class="line">    <span class="keyword">char</span>* ptr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">yData</span> <span class="title">yData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* ptr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler\n&quot;</span>);</span><br><span class="line">    stData* q = (stData*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(q-&gt;pfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler_02</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* q = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler_02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. ngx_create_pool 造内存池</span></span><br><span class="line">        <span class="comment">//  第一块内存Block。里面有完整的ngx_pool_t</span></span><br><span class="line">        <span class="comment">// ngx_pool_t::max = min(512 - sizeof(ngx_pool_t) , 4095)     </span></span><br><span class="line">        <span class="function">ngx_mem_pool <span class="title">mem_pool</span><span class="params">(<span class="number">512</span>)</span></span>;</span><br><span class="line">    <span class="comment">//  2. 小块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请小块内存</span></span><br><span class="line">        stData* p1 = <span class="keyword">static_cast</span>&lt;stData*&gt;(mem_pool.<span class="built_in">ngx_palloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(yData))); <span class="comment">// 从小块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc %d bytes fail\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(yData));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  小块内存保存的指针管理的外部资源</span></span><br><span class="line">        p1-&gt;ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        p1-&gt;pfile = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        p1-&gt;ptr2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr2, <span class="string">&quot;goodbye world&quot;</span>);</span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span>* c1 = mem_pool.<span class="built_in">ngx_pool_cleanup_add</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(yData));     <span class="comment">//  开辟内存，用于handler传参</span></span><br><span class="line">        c1-&gt;handler = self_handler;</span><br><span class="line">        <span class="built_in">memcpy</span>(c1-&gt;data, p1, <span class="built_in"><span class="keyword">sizeof</span></span>(yData));                                      <span class="comment">//  用户只负责拷贝！！将外部资源拷贝一下到c1-&gt;data。将p1指针指向的内容逐字节拷贝到c-&gt;data指向的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 大块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请大块内存</span></span><br><span class="line">        yData* p2 = <span class="keyword">static_cast</span>&lt;yData*&gt;(mem_pool.<span class="built_in">ngx_palloc</span>(<span class="number">512</span>)); <span class="comment">// 从大块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 512 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  外部资源</span></span><br><span class="line">        p2-&gt;ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">12</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(p2-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span>* c2 = mem_pool.<span class="built_in">ngx_pool_cleanup_add</span>(<span class="number">0</span>);                   <span class="comment">//  不开辟内存，直接让c-&gt;data指向要释放的内存</span></span><br><span class="line">        c2-&gt;handler = self_handler_02;</span><br><span class="line">        c2-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  重置内存池</span></span><br><span class="line">        <span class="comment">//  mem_pool.ngx_reset_pool();</span></span><br><span class="line">        <span class="comment">//  std::cout &lt;&lt; &quot;reset over&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  释放内存池</span></span><br><span class="line">        <span class="comment">//   ~mem_pool() 调用mem_pool.ngx_destroy_pool(); // 1.调用所有的预置的清理函数 2.释放大块内存 3.释放小块内存池所有内存</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul>
<li>环境 ubuntu / VS均可<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/my_nginx$ ./test_mem_pool.out </span><br><span class="line">~ngx_mem_pool</span><br><span class="line">self_handler_02</span><br><span class="line">free ptr mem!</span><br><span class="line">self_handler</span><br><span class="line">free ptr mem!</span><br><span class="line">free ptr mem!</span><br><span class="line">close file!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><ul>
<li>VS Debug下出现<code>heap corruption detected</code><ul>
<li>测试代码问题：添加外部资源时的大小不对。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/" class="post-title-link" itemprop="url">nginx内存池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-22 22:30:19" itemprop="dateCreated datePublished" datetime="2022-04-22T22:30:19+08:00">2022-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:03:59" itemprop="dateModified" datetime="2022-05-28T22:03:59+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="nginx内存池"><a href="#nginx内存池" class="headerlink" title="nginx内存池"></a>nginx内存池</h1><ul>
<li>内存池中分为大内存block和小内存block</li>
<li>大内存block的头信息在小内存块中。大内存块头信息通过链表连接起来。</li>
</ul>
<p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-29-10-55-50.png"></p>
<h2 id="内存池结构"><a href="#内存池结构" class="headerlink" title="内存池结构"></a>内存池结构</h2><blockquote>
<p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-10-40-03.png"></p>
</blockquote>
<h3 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h3><ul>
<li>内存池<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  内存池</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_data_t</span>       d;                <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">size_t</span>                max;              <span class="comment">//  p-&gt;max：一个Block块内最多能分配多大的小内存。其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095              </span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>* current;                    <span class="comment">//  指向当前内存块</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>* large;                <span class="comment">//  大内存Block头信息的链表入口</span></span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>* cleanup;            <span class="comment">//  外部资源的头信息链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="小内存Block-头信息"><a href="#小内存Block-头信息" class="headerlink" title="小内存Block 头信息"></a>小内存Block 头信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  小内存池头信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    u_char               *last;             <span class="comment">//  可用内存起始</span></span><br><span class="line">    u_char               *end;              <span class="comment">//  内存末尾</span></span><br><span class="line">    <span class="keyword">ngx_pool_t</span>           *next;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>            failed;           <span class="comment">//  分配内存是否成功</span></span><br><span class="line">&#125; <span class="keyword">ngx_pool_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_s</span>            <span class="title">ngx_pool_t</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="大内存Block-头信息"><a href="#大内存Block-头信息" class="headerlink" title="大内存Block 头信息"></a>大内存Block 头信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  大内存池头信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span>  <span class="title">ngx_pool_large_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_large_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>     *next;</span><br><span class="line">    <span class="keyword">void</span>                 *alloc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="外部资源-头信息"><a href="#外部资源-头信息" class="headerlink" title="外部资源  头信息"></a>外部资源  头信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;</span><br><span class="line">    <span class="keyword">void</span>                 *data;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>     <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>   <span class="title">ngx_pool_cleanup_t</span></span></span><br></pre></td></tr></table></figure>


<h3 id="一些宏"><a href="#一些宏" class="headerlink" title="一些宏"></a>一些宏</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MAX_ALLOC_FROM_POOL  (ngx_pagesize - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_DEFAULT_POOL_SIZE    (16 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_POOL_ALIGNMENT       16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NGX_MIN_POOL_SIZE                                                     \</span></span><br><span class="line"><span class="meta">    ngx_align((sizeof(ngx_pool_t) + 2 * sizeof(ngx_pool_large_t)),            \</span></span><br><span class="line"><span class="meta">              NGX_POOL_ALIGNMENT)</span></span><br></pre></td></tr></table></figure>


<h2 id="创建内存池-ngx-create-pool"><a href="#创建内存池-ngx-create-pool" class="headerlink" title="创建内存池 ngx_create_pool"></a>创建内存池 ngx_create_pool</h2><h3 id="ngx-create-pool"><a href="#ngx-create-pool" class="headerlink" title="ngx_create_pool"></a>ngx_create_pool</h3><ul>
<li>创造的是一个内存Block，从操作系统malloc而来。是打头的那个。有完整的ngx_pool_t，记录了整个内存池的信息。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  size：内存池大小（实际可以使用的比size小）</span></span><br><span class="line"><span class="comment">//  log：日志</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pool_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_create_pool</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  开辟内存池。依据平台调用相应函数</span></span><br><span class="line">    <span class="comment">//  ngx_pool_t + 自由内存</span></span><br><span class="line">    p = <span class="built_in">ngx_memalign</span>(NGX_POOL_ALIGNMENT, size, log);    </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.last = (u_char *) p + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);      <span class="comment">//  内存池起始</span></span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;                     <span class="comment">//  内存池末尾</span></span><br><span class="line">    p-&gt;d.next = <span class="literal">NULL</span>;                                   <span class="comment">//  下一个小内存block</span></span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;                                    <span class="comment">//  当前内存块分配内存失败次数</span></span><br><span class="line"></span><br><span class="line">    size = size - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);                   <span class="comment">//  内存Block实际能使用的大小。整个内存池大小size - 内存池头信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  p-&gt;max：一个Block块内最多能分配多大的小内存。</span></span><br><span class="line">        <span class="comment">//  其大小受制于程序本身ngx_memalign开辟的大小，也受制于小内存定义的上限4095</span></span><br><span class="line">    <span class="comment">//  p-&gt;max = min(size,4095)</span></span><br><span class="line">    <span class="comment">//  max不超过一个页面的大小</span></span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;cleanup = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;log = log;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ngx-memalign"><a href="#ngx-memalign" class="headerlink" title="ngx_memalign"></a>ngx_memalign</h3></li>
<li>向操作系统malloc内存</li>
<li><code>ngx_memalign(size_t alignment, size_t size, ngx_log_t *log)</code>：<ul>
<li>开辟内存池（size和log参数起作用），并根据平台选择是否内存对齐（alignment参数起作用）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Linux has memalign() or posix_memalign()</span></span><br><span class="line"><span class="comment"> * Solaris has memalign()</span></span><br><span class="line"><span class="comment"> * FreeBSD 7.0 has posix_memalign(), besides, early version&#x27;s malloc()</span></span><br><span class="line"><span class="comment"> * aligns allocations bigger than page size at the page boundary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  根据平台选择是否内存对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN || NGX_HAVE_MEMALIGN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span>;  <span class="comment">//  进行内存对齐</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memalign(alignment, size, log)  ngx_alloc(size, log)    <span class="comment">//  ngx_alloc(size,log) 不进行内存对齐</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//  ngx_alloc：就是malloc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------</span><br><span class="line"><span class="comment">// void *ngx_memalign(size_t alignment, size_t size, ngx_log_t *log);  //  内存对齐的malloc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_POSIX_MEMALIGN)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    <span class="keyword">int</span>    err;</span><br><span class="line">    err = <span class="built_in">posix_memalign</span>(&amp;p, alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, err,</span><br><span class="line">                      <span class="string">&quot;posix_memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">        p = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug3</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;posix_memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (NGX_HAVE_MEMALIGN)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line">    p = <span class="built_in">memalign</span>(alignment, size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;memalign(%uz, %uz) failed&quot;</span>, alignment, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug3</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;memalign: %p:%uz @%uz&quot;</span>, p, size, alignment);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="内存Block分配-ngx-palloc"><a href="#内存Block分配-ngx-palloc" class="headerlink" title="内存Block分配 ngx_palloc"></a>内存Block分配 ngx_palloc</h2><ul>
<li>小块内存分配、大块内存分配</li>
<li>ngx_palloc 考虑了内存对齐<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(NGX_DEBUG_PALLOC)</span></span><br><span class="line"><span class="comment">//  分配小块内存（优先从内存池分配，如果没有，再新开辟ngx_memalign）</span></span><br><span class="line"><span class="comment">//  size：上级要请求的</span></span><br><span class="line"><span class="comment">//  pool-&gt;max block块内空闲内存的上限</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ngx_palloc_small</span>(pool, size, <span class="number">1</span>); <span class="comment">//  指针 ，大小 ，1:对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//  分配大块内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_large</span>(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ngx-palloc-small-小块内存分配"><a href="#ngx-palloc-small-小块内存分配" class="headerlink" title="ngx_palloc_small 小块内存分配"></a>ngx_palloc_small 小块内存分配</h3><ul>
<li><p>从操作系统开辟新的小块内存池。ngx_palloc_small调用ngx_palloc_block。ngx_palloc_block底层调用memalign。</p>
</li>
<li><p><strong>效率极高</strong>：如何分配内存：通过移动last指针分配内存。将移出的size内存返回给上级</p>
</li>
<li><p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-55-14.png"></p>
</li>
<li><p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-55-41.png"></p>
</li>
<li><p>ngx_palloc_small</p>
<ul>
<li>先尝试用已有的内存池中拿出size大小的内存块，当内存池里没有可分配的满足size大小的内存块时，再ngx_palloc_block开辟新block块。从block里拿出size大小的内存返回给上级。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ngx_inline <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_small</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size, <span class="keyword">ngx_uint_t</span> align)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p;</span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line">        <span class="keyword">if</span> (align) &#123;    <span class="comment">//  如果要求对齐</span></span><br><span class="line">            m = <span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT);    <span class="comment">//  内存对齐：把指针调整到平台相关的4/8倍数。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  内存池的空闲内存大于要申请的内存</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">size_t</span>) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            <span class="comment">//  m指针偏移size字节，即内存池给应用程序分配内存</span></span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  如果本block块剩余的不够size，那么顺着p-&gt;d.next向下走到第二个内存块block。</span></span><br><span class="line">        p = p-&gt;d.next;      </span><br><span class="line">    &#125; <span class="keyword">while</span> (p);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  从pool-&gt;current开始 遍历完了 所有的block，也没找到够用的空闲内存</span></span><br><span class="line">    <span class="comment">//  那么就只能新开辟block</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ngx_palloc_block</span>(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>ngx_palloc_block<ul>
<li>原有内存池内存不够，分配新的内存块加入内存池<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_block</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    <span class="keyword">size_t</span>       psize;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>  *p, *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    psize = (<span class="keyword">size_t</span>) (pool-&gt;d.end - (u_char *) pool);   <span class="comment">//  Block大小</span></span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">ngx_memalign</span>(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> = (<span class="keyword">ngx_pool_t</span> *) m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span>-&gt;d.end = m + psize;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">    m = <span class="built_in">ngx_align_ptr</span>(m, NGX_ALIGNMENT);</span><br><span class="line">    <span class="keyword">new</span>-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  由于进入到这个函数必然意味着之前的block都分配内存失败</span></span><br><span class="line">    <span class="comment">//  所以要把前几个block的fail次数都++;</span></span><br><span class="line">    <span class="comment">//  当一个block了=块分配内存失败次数</span></span><br><span class="line">    <span class="comment">//  当一个block块失败次数&gt;4之后，就认为这块Block的剩余内存已经很少，之后请求小内存时就不从这块Block开始请求</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d.failed++ &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;d.next = <span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>ngx_free 释放大块内存<br>小块内存不释放</p>
<h3 id="ngx-palloc-large-大内存块分配"><a href="#ngx-palloc-large-大内存块分配" class="headerlink" title="ngx_palloc_large 大内存块分配"></a>ngx_palloc_large 大内存块分配</h3><ul>
<li><p>从操统malloc大块内存。ngx_palloc_large调用ngx_alloc。ngx_alloc调用malloc</p>
</li>
<li><p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-16-54-56.png"></p>
</li>
<li><p>malloc大块内存用于存储数据；从小内存池申请一块内存用作大内存池头信息；维护大内存池链表；将本次malloc的大块内存全部返回给上级使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_palloc_large</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>              *p;</span><br><span class="line">    <span class="keyword">ngx_uint_t</span>         n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *large;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  malloc大块内存；不进行字节对齐</span></span><br><span class="line">    p = <span class="built_in">ngx_alloc</span>(size, pool-&gt;log);     </span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  以pool-&gt;large为起始 遍历大内存池头信息节点</span></span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//  如果遍历到的这块大内存池节点的头信息的alloc==nullptr</span></span><br><span class="line">        <span class="comment">//  意味着并这个ngx_pool_large_t没有管理一块大内存。</span></span><br><span class="line">        <span class="comment">//  所以直接由他管理</span></span><br><span class="line">        <span class="keyword">if</span> (large-&gt;alloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  为了效率</span></span><br><span class="line">        <span class="keyword">if</span> (n++ &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  向小内存池申请一段内存用作大内存池头信息</span></span><br><span class="line">    large = <span class="built_in">ngx_palloc_small</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_large_t</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (large == <span class="literal">NULL</span>) &#123;    <span class="comment">//  没申请来就放弃本次操作</span></span><br><span class="line">        <span class="built_in">ngx_free</span>(p);    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  将大内存池头插法插入large起始的链表中</span></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ngx_alloc() 分配大块内存，不进行内存对齐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">ngx_log_t</span> *log)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>  *p;</span><br><span class="line"></span><br><span class="line">    p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno,</span><br><span class="line">                      <span class="string">&quot;malloc(%uz) failed&quot;</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, log, <span class="number">0</span>, <span class="string">&quot;malloc: %p:%uz&quot;</span>, p, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ngx_free()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_free          free</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="大小内存Block的重置-ngx-reset-pool"><a href="#大小内存Block的重置-ngx-reset-pool" class="headerlink" title="大小内存Block的重置 ngx_reset_pool"></a>大小内存Block的重置 ngx_reset_pool</h2><ul>
<li><code>nginx</code>大块内存block通过<code>malloc</code>分配  <ul>
<li>大块内存：通过<code>free</code>释放</li>
</ul>
</li>
<li><code>nginx</code>小内存通过在内存池（的一个小内存块）中移动last指针来实现内存分配<ul>
<li>小块内存：无<code>free</code>释放，只是通过移动last指针来重置</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_reset_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>        *p;   <span class="comment">//  小内存Block的头信息</span></span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;   <span class="comment">//  大内存Block的头信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  大块内存 free掉</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  小块内存 不释放。只是移动指针。</span></span><br><span class="line">        <span class="comment">//  因为从实现方式上来看，就释放不了。我们通过移动last指针来分配内存。可能我们要释放2号内存，但是我们只有last和end的两个指针，且last指向5号内存。</span></span><br><span class="line">        <span class="comment">//  从nginx的功能来看，也无需释放。</span></span><br><span class="line">    <span class="comment">// for (p = pool; p; p = p-&gt;d.next) &#123;</span></span><br><span class="line">    <span class="comment">//     p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);</span></span><br><span class="line">    <span class="comment">//     p-&gt;d.failed = 0;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    p = pool;</span><br><span class="line">    p-&gt;d.last = (u_char*)p+<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_t</span>);</span><br><span class="line">    p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=p-&gt;d.next;p;p=p-&gt;d.next)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;d.last = (u_char*)p+<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_data_t</span>);</span><br><span class="line">        p-&gt;d.failed = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重置首块内存Block中用于管理所有内存Block的</span></span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = <span class="literal">NULL</span>;</span><br><span class="line">    pool-&gt;large = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="释放指定大内存块-ngx-pfree"><a href="#释放指定大内存块-ngx-pfree" class="headerlink" title="释放指定大内存块 ngx_pfree"></a>释放指定大内存块 ngx_pfree</h2><ul>
<li>释放指定大内存块<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_int_t</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_pfree</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool, <span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>  *l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="为什么reset-pool中nginx内存池的小内存块不free释放？？"><a href="#为什么reset-pool中nginx内存池的小内存块不free释放？？" class="headerlink" title="为什么reset_pool中nginx内存池的小内存块不free释放？？"></a><strong>为什么reset_pool中nginx内存池的小内存块不free释放？？</strong></h2><ul>
<li>因为没有free小块内存的接口。</li>
<li>所以只能移动last指针<h3 id="1-为什么没free接口"><a href="#1-为什么没free接口" class="headerlink" title="1. 为什么没free接口"></a>1. 为什么没free接口</h3></li>
<li>首先nginx内存池的没办法回收针对某一特定小内存块进行free回收。 <ul>
<li>因为从实现方式上来看，就释放不了。我们通过移动last指针来分配内存。可能我们要释放2号内存，但是我们只有last和end的两个指针，且last指向3号下的free内存。那么如果移动last到2那里然后free，那么就会把3也free掉</li>
<li><blockquote>
<p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-23-18-47-48.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><strong>因此</strong>nginx<strong>没有提供</strong>free回收小块内存的接口函数</li>
<li>所以重置时我们只能通过移动last指针来表示哪些内存是空闲内存</li>
</ul>
<h3 id="2-为什么移动last可以"><a href="#2-为什么移动last可以" class="headerlink" title="2. 为什么移动last可以"></a>2. 为什么移动last可以</h3><ul>
<li>那么在释放内存时为什么移动last就可以。这样能表明装有没用数据的内存是空闲的，不害怕有用的内存被覆盖吗？</li>
<li>当<code>reset_pool</code>时，不会有有用的内存块。因为我们是短连接。</li>
<li><code>nginx</code>本质：<code>http</code>服务器。<strong>短连接、间歇性。</strong><ul>
<li>client向nginx server发送请求后，nginx处理完请求，并发送完response响应后；即一次服务处理完后，就主动和客户端断开tcp连接，该次连接的资源就都可以释放了。（server就像和client端没见过面一样。之前的东西都不必再保留，一干二净。）</li>
<li><strong>所以，当nginx server 处理完一次请求后，就可以调用<code>ngx_reset_pool</code>，free大块内存；将小块内存的last指针回退，等待下次覆盖。</strong></li>
</ul>
</li>
<li>而<strong>长连接</strong>不论client是否发来请求，server和client是不能断开的。也即处理完请求后，连接也不能断开，资源也不允许释放，直到系统资源耗尽。长连接的这种server应该用SGI STL的二级空间配置器中的内存池。？？？？？？<ul>
<li>长连接举例：<code>http1.1 keep-alive = 60s</code>，即http服务器返回响应后，需等待<code>60s</code>。如果这段时间之内客户端又发来请求，那么重置等待时间。如果没发来请求，那么就断开连接。</li>
</ul>
</li>
<li>以上关于nginx用于短连接的场景我可以理解。不过他为什么不能用于长连接？我只写过短连接的webserver，还没写过长连接的。等写了长连接的server应该就能理解了吧。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3fc3646fad80">长连接短连接</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/734ef8e5a712">nginx服务器入门</a></li>
</ul>
<h2 id="nginx内存池和sgi-stl二级空间配置器"><a href="#nginx内存池和sgi-stl二级空间配置器" class="headerlink" title="nginx内存池和sgi stl二级空间配置器"></a>nginx内存池和sgi stl二级空间配置器</h2><ul>
<li>nginx对于小块内存的分配效率绝对比sgi stl二级空间配置器高，因为nginx只需要移动指针。</li>
<li>nginx无法释放小块内存。sgi stl 小块和大块都释放。<ul>
<li>故nginx适用于短连接Web服务器（http服务器）。sgi stl适用于长连接服务器。</li>
<li>？why？</li>
</ul>
</li>
</ul>
<h2 id="内存池外部资源释放"><a href="#内存池外部资源释放" class="headerlink" title="内存池外部资源释放"></a>内存池外部资源释放</h2><h3 id="外部资源信息头"><a href="#外部资源信息头" class="headerlink" title="外部资源信息头"></a>外部资源信息头</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span> &#123;</span></span><br><span class="line">    ngx_pool_cleanup_pt   handler;</span><br><span class="line">    <span class="keyword">void</span>                 *data;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>   *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>     <span class="class"><span class="keyword">struct</span> <span class="title">ngx_pool_cleanup_s</span>   <span class="title">ngx_pool_cleanup_t</span></span></span><br></pre></td></tr></table></figure>

<h3 id="内存池外部资源释放-1"><a href="#内存池外部资源释放-1" class="headerlink" title="内存池外部资源释放"></a>内存池外部资源释放</h3><p><img src="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/2022-04-29-10-59-23.png"></p>
<h4 id="对于cleanup-add的使用有两种方式"><a href="#对于cleanup-add的使用有两种方式" class="headerlink" title="对于cleanup_add的使用有两种方式"></a>对于cleanup_add的使用有两种方式</h4><ul>
<li><ol>
<li>一种是给c-&gt;data开辟一块内存，然后把外部资源拷贝进去。之后destroy中c-&gt;handler(void*p)</li>
</ol>
<ul>
<li><code>ngx_pool_cleanup_t * c = ngx_pool_cleanup_add(pool,sizeof(x))</code></li>
<li>感觉适用于一个这块内存里很多指针管理很多外部资源，可以省去挨个设置外部资源信息头以及回调函数。</li>
</ul>
</li>
<li><ol start="2">
<li>一种是不给c-&gt;data开辟内存，直接让c-&gt;data指向要释放的内存。</li>
</ol>
<ul>
<li><code>ngx_pool_cleanup_t * c = ngx_pool_cleanup_add(pool,0)</code></li>
</ul>
</li>
<li>我觉得在一块申请的内存中由很多指针管理外部资源时，【第一种优于第二种】。<ul>
<li>相较于【第二种不拷贝方法】单独为 每个指针管理的外部资源都设置一个外部资源信息头，以及一个释放的回调函数；不如【第一种方法】只设置一个回调函数和一个信息头。将这些外部资源拷贝到一块内存中，然后将这块内存传入即可。这样就可以用一个信息头，一个回调函数，即可释放多个资源。</li>
</ul>
</li>
</ul>
<h4 id="源码论证"><a href="#源码论证" class="headerlink" title="源码论证"></a>源码论证</h4><ul>
<li>第【1】种<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  结构体</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">ngx_fd_t</span>              fd;</span><br><span class="line">        u_char               *name;</span><br><span class="line">        <span class="keyword">ngx_log_t</span>            *log;</span><br><span class="line">    &#125; <span class="keyword">ngx_pool_cleanup_file_t</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  为c-&gt;data开辟内存</span></span><br><span class="line">    cln = <span class="built_in">ngx_pool_cleanup_add</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_file_t</span>));</span><br><span class="line">    ....</span><br><span class="line">    cln-&gt;handler = clean ? ngx_pool_delete_file : ngx_pool_cleanup_file;</span><br><span class="line">    <span class="comment">//  将管理的资源地址拷贝到c-&gt;data指向的内存</span></span><br><span class="line">    clnf = cln-&gt;data;</span><br><span class="line">    clnf-&gt;fd = file-&gt;fd;</span><br><span class="line">    clnf-&gt;name = file-&gt;name.data;</span><br><span class="line">    clnf-&gt;log = pool-&gt;log;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  预制的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_pool_delete_file</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_file_t</span>  *c = data;</span><br><span class="line">    <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, c-&gt;log, <span class="number">0</span>, <span class="string">&quot;file cleanup: fd:%d %s&quot;</span>,</span><br><span class="line">                   c-&gt;fd, c-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ngx_delete_file</span>(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ngx_close_file</span>(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第【2】种<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  不申请内存</span></span><br><span class="line">cln = <span class="built_in">ngx_pool_cleanup_add</span>(r-&gt;pool, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (cln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  直接将地址给cln-&gt;data</span></span><br><span class="line">cln-&gt;handler = ngx_http_file_cache_cleanup;</span><br><span class="line">cln-&gt;data = c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  预制回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_http_file_cache_cleanup</span><span class="params">(<span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_http_cache_t</span>  *c = data;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;updated) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">ngx_log_debug0</span>(NGX_LOG_DEBUG_HTTP, c-&gt;file.log, <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;http file cache cleanup&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;updating &amp;&amp; !c-&gt;background) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ngx_http_file_cache_free</span>(c, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>cleanup_add功能概述：通过预置回调函数，实现c++中对象析构的功能。也即释放内存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ngx_pool_cleanup_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">ngx_pool_cleanup_add</span><span class="params">(<span class="keyword">ngx_pool_t</span> *p, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    <span class="comment">//  从小内存block中 分配一块内存用作ngx_pool_cleanup_t</span></span><br><span class="line">    c = <span class="built_in">ngx_palloc</span>(p, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">ngx_pool_cleanup_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  看用户是怎么调用的</span></span><br><span class="line">        <span class="comment">//  size&gt;0 从内存池中申请一块内存。用作之后用户将外部资源拷贝到这里</span></span><br><span class="line">        <span class="comment">//  size=0 不申请内存。用户直接将c-&gt;data = 外部资源地址</span></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">        c-&gt;data = <span class="built_in">ngx_palloc</span>(p, size);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;handler = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, p-&gt;log, <span class="number">0</span>, <span class="string">&quot;add cleanup: %p&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内存池销毁"><a href="#内存池销毁" class="headerlink" title="内存池销毁"></a>内存池销毁</h3><ul>
<li>先遍历链表执行外部资源的释放操作；再遍历链表执行释放大块内存的操作；再遍历链表重置小块内存Block   </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_destroy_pool</span><span class="params">(<span class="keyword">ngx_pool_t</span> *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ngx_pool_t</span>          *p, *n;</span><br><span class="line">    <span class="keyword">ngx_pool_large_t</span>    *l;</span><br><span class="line">    <span class="keyword">ngx_pool_cleanup_t</span>  *c;</span><br><span class="line">    <span class="comment">//  遍历外部资源信息头链表， 调用预设置的回调函数handler，释放外部资源。</span></span><br><span class="line">    <span class="keyword">for</span> (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;handler) &#123;</span><br><span class="line">            <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                           <span class="string">&quot;run cleanup: %p&quot;</span>, c);</span><br><span class="line">            c-&gt;<span class="built_in">handler</span>(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_DEBUG)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * we could allocate the pool-&gt;log from this pool</span></span><br><span class="line"><span class="comment">     * so we cannot use this log while free()ing the pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_debug1</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>, <span class="string">&quot;free: %p&quot;</span>, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">ngx_log_debug2</span>(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, <span class="number">0</span>,</span><br><span class="line">                       <span class="string">&quot;free: %p, unused: %uz&quot;</span>, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历大块内存信息头，释放大块内存</span></span><br><span class="line">    <span class="keyword">for</span> (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l-&gt;alloc) &#123;</span><br><span class="line">            <span class="built_in">ngx_free</span>(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历小块内存信息头，释放小块内村</span></span><br><span class="line">    <span class="keyword">for</span> (p = pool, n = pool-&gt;d.next; <span class="comment">/* void */</span>; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        <span class="built_in">ngx_free</span>(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><ul>
<li>环境：ubuntu 18.04 ； nginx-1.12.2 ；工具：Source Insigh4.0</li>
<li>指令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line">gcc -o ngx_testpool ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br></pre></td></tr></table></figure></li>
<li><code>void *memcpy(void *des, const void *src, size_t n)</code><ul>
<li>将src指向的内存中的内容逐字节的拷贝到des指向的内存<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span>* p = &amp;a;</span><br><span class="line">	<span class="keyword">int</span>* q = &amp;b;	<span class="comment">//  q不能=null！因为是要把p指向的内存的内容拷贝到q的内存里。q如果是null则error</span></span><br><span class="line">	<span class="built_in">memcpy</span>(q, p, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line">	cout &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00000021</span>ACF5F904</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">00000021</span>ACF5F8E4</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>ngx_testpool.c<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_log_error_core</span><span class="params">(<span class="keyword">ngx_uint_t</span> level, <span class="keyword">ngx_log_t</span> *log, <span class="keyword">ngx_err_t</span> err,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">stData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//  多个指针</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    FILE *pfile;</span><br><span class="line">    <span class="keyword">char</span> *ptr2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">yData</span> <span class="title">yData</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">yData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler\n&quot;</span>);</span><br><span class="line">    stData *q = (stData*) p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q-&gt;ptr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fclose</span>(q-&gt;pfile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_handler_02</span><span class="params">(<span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *q = (<span class="keyword">char</span>*)p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;self_handler_02\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;free ptr mem!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. ngx_create_pool 造内存池</span></span><br><span class="line">        <span class="comment">//  第一块内存Block。里面有完整的ngx_pool_t</span></span><br><span class="line">        <span class="comment">// ngx_pool_t::max = min(512 - sizeof(ngx_pool_t) , 4095)     </span></span><br><span class="line">        <span class="keyword">ngx_pool_t</span> *pool = <span class="built_in">ngx_create_pool</span>(<span class="number">512</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(pool == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_create_pool fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 小块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请小块内存</span></span><br><span class="line">        stData *p1 = <span class="built_in">ngx_palloc</span>(pool, <span class="built_in"><span class="keyword">sizeof</span></span>(yData)); <span class="comment">// 从小块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 128 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  小块内存保存的指针管理的外部资源</span></span><br><span class="line">        p1-&gt;ptr = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        p1-&gt;pfile = <span class="built_in">fopen</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        p1-&gt;ptr2 = <span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p1-&gt;ptr2, <span class="string">&quot;hhhh&quot;</span>);</span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span> *c1 = <span class="built_in">ngx_pool_cleanup_add</span>(pool,<span class="built_in"><span class="keyword">sizeof</span></span>(yData));     <span class="comment">//  开辟内存，用于handler传参</span></span><br><span class="line">        c1-&gt;handler = self_handler;</span><br><span class="line">        <span class="built_in">memcpy</span>(c1-&gt;data,p1,<span class="built_in"><span class="keyword">sizeof</span></span>(yData));                                      <span class="comment">//  用户只负责拷贝！！将外部资源拷贝一下到c1-&gt;data。将p1指针指向的内容逐字节拷贝到c-&gt;data指向的内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 大块内存以及外部资源</span></span><br><span class="line">        <span class="comment">//  向内存池申请大块内存</span></span><br><span class="line">        yData *p2 = <span class="built_in">ngx_palloc</span>(pool, <span class="number">512</span>); <span class="comment">// 从大块内存池分配的</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ngx_palloc 512 bytes fail...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  外部资源</span></span><br><span class="line">        p2-&gt;ptr = <span class="built_in">malloc</span>(<span class="number">12</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p2-&gt;ptr, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  预置回调函数用于释放外部资源</span></span><br><span class="line">        <span class="keyword">ngx_pool_cleanup_t</span> *c2 = <span class="built_in">ngx_pool_cleanup_add</span>(pool,<span class="number">0</span>);                   <span class="comment">//  不开辟内存，直接让c-&gt;data指向要释放的内存</span></span><br><span class="line">        c2-&gt;handler = self_handler_02;</span><br><span class="line">        c2-&gt;data = p2-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  释放内存池</span></span><br><span class="line">    <span class="built_in">ngx_destroy_pool</span>(pool); <span class="comment">// 1.调用所有的预置的清理函数 2.释放大块内存 3.释放小块内存池所有内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ gcc -c -g -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules -o ngx_testpool.o  ngx_testpool.c</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ gcc -o ngx_testpool.out ngx_testpool.o objs/src/core/ngx_palloc.o objs/src/os/unix/ngx_alloc.o</span><br><span class="line">shc@shc-<span class="keyword">virtual</span>-machine:~/code/nginx/nginx<span class="number">-1.12</span><span class="number">.2</span>$ ./ngx_testpool.out </span><br><span class="line">self_handler_02</span><br><span class="line">free ptr mem!</span><br><span class="line">self_handler</span><br><span class="line">free ptr mem!</span><br><span class="line">free ptr mem!</span><br><span class="line">close file!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存对齐好处"><a href="#内存对齐好处" class="headerlink" title="内存对齐好处"></a>内存对齐好处</h2><ul>
<li>较少cpu的IO次数</li>
<li>内存对齐博客待完善</li>
</ul>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><ul>
<li>gcc -g 生成的可执行文件可以调试</li>
<li>gdb …out   </li>
<li>start 开始一行一行运行</li>
<li>n 下一行</li>
<li>s（step）进入函数</li>
<li>finish 跳出函数</li>
<li>quit 退出</li>
<li>l 当前附近代码</li>
</ul>
<h2 id="nginx内存池不足（我认为）"><a href="#nginx内存池不足（我认为）" class="headerlink" title="nginx内存池不足（我认为）"></a>nginx内存池不足（我认为）</h2><ul>
<li>链表管理<ul>
<li>链表的查找遍历时间复杂度是 O(n)。ngx_pfree 效率不高</li>
</ul>
</li>
<li>小内存块链表，current 问题：<ul>
<li>当遇到密集地分配比较大的小内存场景时，导致已分配结点，分配失败，failed 次数增加。current 指向新的结点，由于是单向链表，前面的结点其实还有足够的空闲空间分配给其它小内存的，导致空闲空间利用率不高。</li>
</ul>
</li>
<li>ngx_reset_pool中没有释放外部资源。需要等到destroy时才可以释放。</li>
<li>ngx_reset_pool中，在重置小块内村的last指针时，有一部分没有重置，造成内存碎片。</li>
</ul>
<h2 id="我"><a href="#我" class="headerlink" title="我"></a>我</h2><ul>
<li>移植之后解决了ngx_reset_pool中没有释放外部资源的问题</li>
<li>解决了reset中last指针的问题。</li>
</ul>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q1449660223/article/details/106094683">堆、栈</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/" class="post-title-link" itemprop="url">sgi_stl二级空间配置器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-16 09:52:38" itemprop="dateCreated datePublished" datetime="2022-04-16T09:52:38+08:00">2022-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:20:29" itemprop="dateModified" datetime="2022-05-28T22:20:29+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>29k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。"><a href="#一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。" class="headerlink" title="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。"></a>一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。</h2><h2 id="二级空间配置器就是-一级空间配置器-基于freelist实现的内存池的结合"><a href="#二级空间配置器就是-一级空间配置器-基于freelist实现的内存池的结合" class="headerlink" title="二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合"></a>二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合</h2><h1 id="SGI-STL-二级空间配置器-原理"><a href="#SGI-STL-二级空间配置器-原理" class="headerlink" title="SGI STL 二级空间配置器 原理"></a>SGI STL 二级空间配置器 原理</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><ul>
<li> <code>template&lt;typename T&gt; class my_allocator&#123;&#125;</code></li>
<li>整体<ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-17-24.png"></li>
</ul>
</li>
<li>_S_chunk_alloc<ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-18-11.png"></li>
</ul>
</li>
</ul>
<h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><ul>
<li>SGI STL包含了一级空间配置器和二级空间配置器，<ul>
<li>其中一级空间配置器allocator采用malloc和free来管理内存，和C++标准库中提供的allocator是一样的，</li>
<li>但其二级空间配置器allocator采用了基于freelist（自由链表）原理的内存池机制实现内存管理。</li>
</ul>
</li>
<li>SGI STL二级空间配置器：线程安全</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) allocator<span class="meta-string">&lt; T &gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) alloc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  一级空间配置器</span></span><br><span class="line">allocator&lt; T &gt;：</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> // 一级空间配置器内存管理类 -- 通过<span class="title">malloc</span>和<span class="title">free</span>管理内</span></span><br><span class="line"><span class="class">存</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//  二级空间配置器</span></span><br><span class="line"><span class="class"><span class="title">alloc</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span> <span class="comment">// 二级空间配置器内存管理类 -- 通过自定义内存池实现内存管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> :</span> <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>

<h2 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h2><ul>
<li><p>内存池粒度信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;       <span class="comment">//  内存对齐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">//  最大块大小   &gt;128就不会放到内存池里了，也即不会用二级空间配置器。会用一级空间配置器  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">//  静态链表的成员个数 _MAX_BYTES/_ALIGN</span></span><br></pre></td></tr></table></figure></li>
<li><p>每一个内存chunk块的头信息</p>
<ul>
<li>chunk：数据块，区块。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自由链表数组。数组的每个成员是静态的_Obj*指针。_STL_VOLATILE是为了保证多线程安全（通过防止线程缓存？多线程中一般堆上和数据段都会加volatile）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;__threads, __inst&gt;::_Obj* __STL_VOLATILE</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::</span><br><span class="line">_S_free_list[_NFREELISTS] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Chunk allocation state</code>. 记录内存<code>chunk</code>块的分配情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  static：类内声明、类外定义。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;         <span class="comment">//   空闲free内存的起始start位置 [</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;           <span class="comment">//   空闲free内存的结束end位置 )       (包括回收的吗？)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;         <span class="comment">//   总共malloc过的内存大小（因为malloc是从堆heap上请求的，所以叫heapsize）</span></span><br><span class="line"><span class="comment">//  类外定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>我认为SGI STL二级空间配置器中的<strong>内存池</strong>，分为<strong>三部分</strong></p>
<ul>
<li>一部分给用户使用</li>
<li>一部分是用户还没使用的，已经形成chunk链表内存池</li>
<li>一部分是还没加入chunk链表内存池的原始空闲内存</li>
</ul>
</li>
</ul>
<h2 id="重要辅助函数"><a href="#重要辅助函数" class="headerlink" title="重要辅助函数"></a>重要辅助函数</h2><ul>
<li>将bytes上调至最邻近的_ALIGN = 8的倍数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分析<ul>
<li>计组复习：<ul>
<li>机器数的解释规则都是补码。也就是计算机里的数都是以补码形式存储的。</li>
<li>补码<ul>
<li>正数：补码=原码=真值</li>
<li>负数：补码=~原码+1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">枚举变量的取值为花括号内的任意一个值（有且只能有其中一个值），而这个值是<span class="keyword">int</span>型的。</span><br><span class="line">在X86系统中，所以<span class="built_in"><span class="keyword">sizeof</span></span>(_ALIGN) = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) = <span class="number">4</span>，也就是枚举变量的值为<span class="number">4</span></span><br><span class="line">_ALIGN</span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00001000</span></span><br><span class="line">_ALIGN - <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000111</span></span><br><span class="line">~(ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN</span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00001000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span></span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000111</span></span><br><span class="line"></span><br><span class="line">~((<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span> + bytes</span><br><span class="line"><span class="number">000.</span>..| <span class="number">00000111</span>    +<span class="number">0</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001000</span>    +<span class="number">1</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001001</span>    +<span class="number">2</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001111</span>    +<span class="number">8</span></span><br><span class="line"><span class="comment">// -&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00010000</span>    +<span class="number">9</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00010111</span>    +<span class="number">16</span></span><br><span class="line"><span class="comment">// -&gt; 16</span></span><br><span class="line"></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00011000</span>    +<span class="number">17</span></span><br><span class="line"><span class="comment">// -&gt; 24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp; </span><br><span class="line">~((<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">111.</span>..| <span class="number">11111000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>返回位于第几个内存块<ul>
<li>bytes &gt;= 1  内存块号 &gt;= 0<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  bytes &gt;= 1  内存块号 &gt;= 0</span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">      <span class="comment">//  (bytes + 7)/(ALIGN = 8) - 1。（+7(ALIGN-1)：为了保证12345678位于同一组？</span></span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>][<span class="number">9</span>,<span class="number">16</span>][<span class="number">17</span>,<span class="number">24</span>]</span><br><span class="line">  <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>例子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> _ALIGN = <span class="number">8</span> &#125;;     <span class="comment">//  4</span></span><br><span class="line"><span class="comment">//  将bytes上调至最邻近的8的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回位于第几个内存块</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);   <span class="comment">//  (bytes + 7)/8  -1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;                    <span class="comment">//  4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;              <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;     <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>) &lt;&lt; endl;                 <span class="comment">//  8    </span></span><br><span class="line">    <span class="comment">//  size_t ：unsigned long long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(_ALIGN) &lt;&lt; endl;                 <span class="comment">//  4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(_ALIGN).<span class="built_in">name</span>() &lt;&lt; endl;          <span class="comment">//  enum &lt;unnamed-enum-_ALIGN&gt;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>((<span class="keyword">size_t</span>)_ALIGN) &lt;&lt; endl;         <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>((<span class="keyword">size_t</span>)_ALIGN).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">//  unsigned __int64</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; _ALIGN &lt;&lt; endl;                         <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _ALIGN<span class="number">-1</span> &lt;&lt; endl;                       <span class="comment">//  7</span></span><br><span class="line">    cout &lt;&lt; ~(_ALIGN - <span class="number">1</span>) &lt;&lt; endl;                  <span class="comment">//  -8</span></span><br><span class="line">    cout &lt;&lt; ((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &lt;&lt; endl;           <span class="comment">//  7</span></span><br><span class="line">    cout &lt;&lt; (~(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &lt;&lt; endl;          <span class="comment">//  18446744073709551606</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">0</span>) &lt;&lt; endl;                 <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">1</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">7</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">8</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">9</span>) &lt;&lt; endl;                 <span class="comment">//  16</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">16</span>) &lt;&lt; endl;                <span class="comment">//  16</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">17</span>) &lt;&lt; endl;                <span class="comment">//  24</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//  cout &lt;&lt; _S_freelist_index(0) &lt;&lt; endl;   bytes至少&gt;=1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">1</span>) &lt;&lt; endl;           <span class="comment">//  0   </span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">7</span>) &lt;&lt; endl;           <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">8</span>) &lt;&lt; endl;           <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">15</span>) &lt;&lt; endl;          <span class="comment">//  1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">16</span>) &lt;&lt; endl;          <span class="comment">//  1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">17</span>) &lt;&lt; endl;          <span class="comment">//  2</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">24</span>) &lt;&lt; endl;          <span class="comment">//  2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h2><ul>
<li>概述：根据n大小，采取相应方式获取内存，并返回。<ul>
<li>n&gt;128<ul>
<li>malloc_alloc::allocate(__n)。同一级空间配置器。开辟后返回</li>
</ul>
</li>
<li>n&lt;128<ul>
<li>根据n大小，借助free从freelist相应元素管理的内存池中取出相应大小内存块。当内存池不存在时，开辟内存池。</li>
<li>对于传入的请求内存大小n，n决定了请求那个freelist成员指向的内存池的内存块。<ul>
<li><code>_Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n)</code></li>
</ul>
</li>
<li>如果相应的<code>freelist</code>成员=nullptr的话，<ul>
<li>调用<code>_S_refill</code>：<code>__ret = _S_refill(_S_round_up(__n));</code><ul>
<li>开辟内存块数=nobjs(20)的内存池，内存池中的每个内存块的大小都是传入的<code>__n</code><ul>
<li><code>char* __chunk = _S_chunk_alloc(__n, __nobjs);</code></li>
</ul>
</li>
<li>_S_refill根据传入的n大小，计算出开辟的内存池应该由哪个freelist成员管理。<ul>
<li><code>__my_free_list = _S_free_list + _S_freelist_index(__n);</code></li>
</ul>
</li>
<li>将内存池挂到freelist相应成员下，</li>
<li>并维护每个空闲内存块之间指向关系。（每个空闲内存块连接在一起组成内存池）</li>
<li>返回第一个内存块。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>freelist[]（自由链表）是一个静态的链表</li>
<li>数组的每个元素指向一个内存池。</li>
<li>同一内存池的chunk内存块的大小一致。</li>
<li>不同内存池的chunk内存块大小不一致。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span>     <span class="comment">//  请求的一块大小为n的空间</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果&gt;128bytes，那么调用malloc_alloc::allocate（同一级空间配置器的allocator的allocate一样)</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);          <span class="comment">//  应当在哪个</span></span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;                            <span class="comment">//  上锁</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;      <span class="comment">//  __RESTRICT线程安全</span></span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//  _S_round_up(n)（向上取8的倍数）。根据n的大小，计算出应该开辟多大内存。</span></span><br><span class="line">      <span class="comment">//  _S_refill：在相应freelist成员下开辟内存池，且内存池的每个内存块大小都为__n向上取8的倍数。并返回内存池的第一个内存块。</span></span><br><span class="line">      <span class="comment">//   如何确定将内存池接在哪个freelist成员下？通过_S_freelist_index(n)计算出。</span></span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));            <span class="comment">//  开辟内存池</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-07-18.png"></p>
<h2 id="S-refill"><a href="#S-refill" class="headerlink" title="_S_refill"></a>_S_refill</h2><ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-08-25.png"></li>
<li>__n：内存池里每个内存块的大小。并且可以借助n计算出该内存池应该接在那个freelist成员下。</li>
<li>概述：当freelist的某个元素obj*=nullptr时，会调用_S_refill，(<code>_S_refill</code>向下调用<code>_S_chunk_alloc</code>)开辟内存池，并返回内存池的第一个内存块。并且<code>_S_refill</code>内维护从原始内存中申请来的内存池中每个内存块chunk节点之间的指向关系。<ul>
<li><code>_S_chunk_alloc</code>：分配指定大小的内存池</li>
<li>静态链表：把每个chunk块通过Obj*里的指针连接起来</li>
</ul>
</li>
<li>allocate函数中调用_S_refill。n是传入的参数，代表allocate请求一个多大的内存块。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns an object of size __n, and optionally adds to size __n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that __n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)  <span class="comment">//  n是一个chunk块的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  分配指定大小的内存池    __nobjs：chunk内存块数量 ；这里的 __n：每个chunk内存块大小。</span></span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  __nobjs：申请到的chunk块数量。当只申请到一个时，直接返回该内存块给上一级使用。无需建立各个chunk的连接关系，无需挂载到相应的freelist成员下。（因为只有一个）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);  </span><br><span class="line">    </span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);     <span class="comment">//  根据内存块大小求出内存池应该在由freelist第几个成员管理（指向）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  静态链表：把每个chunk块通过Obj*里的指针连接起来</span></span><br><span class="line">    <span class="comment">//  每个内存块，有一部分的内存时union联合体Obj，里面有一个Obj*指针，负责连接每个空闲内存块。</span></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      __result = (_Obj*)__chunk;</span><br><span class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);    <span class="comment">//  __n：一个内存块的大小（因为第一个内存块要分配出去）</span></span><br><span class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">        __current_obj = __next_obj;                             </span><br><span class="line">        __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);          <span class="comment">//   维护内存块间的连接  char* 因此+__n是偏移n个bytes +n是为了一次跑一个chunk块</span></span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;                               <span class="comment">//   空闲内存块数为0?</span></span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);   <span class="comment">//  返回第一个内存块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="S-chunk-alloc"><a href="#S-chunk-alloc" class="headerlink" title="_S_chunk_alloc"></a>_S_chunk_alloc</h2><ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-20-41-44.png"></li>
<li><code>allocate(size_t n) -&gt; _S_refill(size_t n) -&gt; _S_chunk_alloc(size_t __size__,int &amp;nobjs)</code></li>
<li>将所有备用内存池都应用到，哪怕只剩下<code>8bytes</code>（最小的块就是<code>8bytes</code>，将这些用不到的小内存块挂载到相应的<code>freelist</code>成员下。）。</li>
<li><code>chunk_alloc</code>里可能<code>malloc</code>，也可能不<code>malloc</code>。<ul>
<li><code>malloc</code>：备用内存(当前<code>start-end</code>)不够</li>
<li>不<code>malloc</code>：备用内存(当前<code>start-end</code>)本身就够<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></li>
</ul>
</li>
<li>从 【备用空闲内存池申请】 或者 【操作系统中开辟】 内存池。这个内存池中，每个<code>chunk</code>大小为<code>size</code> bytes，数量为<code>_nobjs</code>。将所申请的这一整个池子的首地址返回给上一级–_S_refill。在_S_refill中，负责将该池子中的每个chunk块建立起链表关系，并挂载到相应free-list成员下。并且_S_refill负责把一个size大小的chunk返回给上一级allocate。（用户调用请求函数）。</li>
<li>而在_S_chunk_alloc中，对于内存池子是从备用内存池请求，还是再从操统中开辟，又分以下情况讨论<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">    <span class="keyword">if</span>(_bytes_left &gt;= total_bytes)&#123; </span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> result;  <span class="comment">//  total大小内存块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(__bytes_left &gt;= __size)&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> result;  <span class="comment">//  尽量return大点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 后半+的这个是为了malloc越来越大</span></span><br><span class="line">      <span class="comment">// 计算要malloc多少内存s</span></span><br><span class="line">      bytes_to_get = <span class="number">2</span>*__total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// malloc内存</span></span><br><span class="line">      _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">            <span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">            <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                          </span><br><span class="line">              <span class="comment">//  头插法</span></span><br><span class="line">              <span class="comment">//  start_free头插接入_S_free_list + _S_freelist_index(__bytes_left)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      _S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">      _S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">      <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;            <span class="comment">//  本次总共需要请求的内存大小</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//  __default_alloc_template&lt;__threads, __inst&gt; 从开始到现在，请求的剩余空闲的的内存大小。不包括回收的。只是开辟的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;                <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">        __result = _S_start_free;                       <span class="comment">//  __result 作为返回内存首地址</span></span><br><span class="line">        _S_start_free += __total_bytes;                 <span class="comment">//  移动_S_start_free</span></span><br><span class="line">        <span class="keyword">return</span>(__result);                               <span class="comment">//  [result , _S_start_free)  作为请求结果返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;                <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get =                         <span class="comment">//  当剩余的空闲内存不够时，需要向操统malloc内存。这是计算出需要malloc内存的大小（至少malloc出来要求内存的(__total_bytes)两倍）</span></span><br><span class="line">	  <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                         <span class="comment">//  </span></span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//  向操统malloc内存</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;                       <span class="comment">//  malloc失败</span></span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">	    _Obj* __p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="comment">//  从别的freelist成员管理的原始备用内存池中借用至少size大小的chunk块</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size;</span><br><span class="line">                 __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES;</span><br><span class="line">                 __i += (<span class="keyword">size_t</span>) _ALIGN) &#123;</span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  都没有时，尝试下allcoate来补救</span></span><br><span class="line">	    _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        _S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><ul>
<li><p>什么时候调用chunk_alloc?当某个freelist成员的内存池为空时。（没分配过内存池或者内存池耗尽）</p>
</li>
<li><p><strong>调用上下文</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">allocate中：<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">_Obj* __RESTRICT __result </span>= *__my_free_list;</span><br><span class="line"><span class="comment">//  当某个freelist成员的内存池为空时。（没分配过内存池或者内存池耗尽） 调用__S_chunk_alloc</span></span><br><span class="line"><span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">  __ret = _S_refill(_S_round_up(__n));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//  消耗内存池</span></span><br><span class="line">  *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">  __ret = __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __ret;</span><br><span class="line"></span><br><span class="line">S_refill中</span><br><span class="line"><span class="number">1.</span> <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line"><span class="number">2.</span> 连接得到的chunk块</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>整体<blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-21-13-13.png"></p>
</blockquote>
</li>
<li>我将图中形成链表的自由（空闲）内存节点们称为内存池。</li>
<li>将没有建立链表连接的称为原始内存（或者叫备用内存池）。</li>
</ul>
<hr>
<ul>
<li>大体：<code>start-free==0</code>时，就是一点 <strong>备用的 空闲的</strong> 内存也没有了<ul>
<li>备用内存：<ul>
<li>优先是只进行了malloc的空闲原始内存，也就是没有被形成freelist某成员内存池的</li>
<li>如果没有，其次是已经参与形成内存链表池的空闲chunk块。</li>
</ul>
</li>
</ul>
</li>
<li>当没有备用内存(<code>bytes_left==0</code>)时，正常从操统中malloc内存<ul>
<li>一小块返回给用户使用，</li>
<li>一部分返回给上一级加工成内存池（把chunk块之间连起来）</li>
<li>一部分在 <code>[_start_free</code> 和 <code>_end_free)</code>之间，用作备用内存（备用内存池/原始内存）。</li>
</ul>
</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-09-38.png"></li>
</ul>
<hr>
<ul>
<li>当有备用内存时<ul>
<li>start和free之间malloc的原始内存，还没参与形成内存池</li>
<li> [start，free) &gt; size (nobjs&gt;1)，则将这块内存挂给相应freelist成员</li>
<li>图中为空闲内存有160bytes，而上层申请16*20bytes内存<br><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-10-52.png"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>条件同上<ul>
<li>start和free之间malloc的原始内存，还没参与形成内存池</li>
<li>nobjs = [start，free) / size = 1，则将这内存块返回。（因为只有一个，所以不必挂载形成内存池） </li>
<li>图中空闲内存为160bytes，而上层申请16*128bytes内存。<ul>
<li>返回1个128bytes内存块</li>
</ul>
</li>
<li>用户又接着申请32bytes</li>
<li>用户接着申请128bytes</li>
</ul>
</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-08-16.png"></li>
<li><blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-08-39-50.png"></p>
</blockquote>
</li>
<li>第三张红圈的例子：解释如下。<ul>
<li>只返回一个<code>128bytes</code>块时，<code>freelist</code>的<code>128bytes</code>成员仍是空，因为返回的这一个直接就用作请求结果了，并没空闲内存块。</li>
<li>当上层(allocate)再次请求128Bytes时，_S_refill调用<code>chunk = _S_chunk_alloc(size_t __size = 128, int&amp; __nobjs = 20)</code>。由于剩下<code>__bytes_left = 32bytes &lt; size = 128bytes</code>。故进入<code>else</code>。</li>
<li>剩余的<code>32bytes</code>被<code>freelist</code>的<code>32bytes</code>成员管理（因为这个<code>32bytes</code>对于128bytes的chunk块来说无用）。再开辟<code>bytes_to_get</code>的内存。移动<code>free_start</code>。接下来的操作同一开始malloc内存。（再循环调用<code>chunk_alloc...</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>malloc失败<ul>
<li>从别的freelist成员已经形成链表的内存池中，拿出一块chunk，给本次请求用<blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-10-58-25.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h2><ul>
<li>功能概述：归还p指向的、大小为n的内存块，还给内存池链表。（n用于计算归还的该块内存应该在哪个freelist成员管理的内存之中）<ul>
<li>将p头插入法插入内存池链表中。</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-32-12.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)  <span class="comment">//  n&gt;128 同一级空间配置器</span></span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);  <span class="comment">//  找到相应freelist成员</span></span><br><span class="line">      _Obj* __q = (_Obj*)__p;       <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="malloc-alloc-template"><a href="#malloc-alloc-template" class="headerlink" title="__malloc_alloc_template"></a>__malloc_alloc_template</h2><ul>
<li><p>辅助__malloc_alloc_template的类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  申请nbytes。如果空间不足，则释放nbytes</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  释放p</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>malloc_alloc:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="malloc-alloc-allocate"><a href="#malloc-alloc-allocate" class="headerlink" title="malloc_alloc::allocate"></a>malloc_alloc::allocate</h3><ul>
<li>功能概述<ul>
<li>分配nbytes成功 返回result</li>
<li>分配失败，那么就调用预制好的_S_oom_malloc，释放nbytes空间，给result<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>调用上下文<ul>
<li>在没有空间（不能malloc）的情况下，又必须进行malloc。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_S_chunk_alloc()&#123;</span><br><span class="line">  malloc = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 没有空间 却又只能allcoate</span></span><br><span class="line">  _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">  _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="malloc-alloc-S-oom-malloc"><a href="#malloc-alloc-S-oom-malloc" class="headerlink" title="malloc_alloc::_S_oom_malloc"></a>malloc_alloc::_S_oom_malloc</h3><ul>
<li>功能概述：循环调用用户预制的回调函数，以期解决内存不够的问题，好拿出nbyte内存。</li>
<li>oom：out of memory 内存耗尽</li>
<li>用户先前设置好回调函数<code>__malloc_alloc_oom_handler</code><ul>
<li>设置：那么这个回调函数必须实现 释放其他内存，使得可以给当前请求分配内存的功能。否则会陷入死循环，直到可以malloc内存。<code>return</code>malloc的内存。</li>
<li>没设置：直接抛异常 throw bad_alloc<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __my_malloc_handler)();   <span class="comment">//  用于接收回调函数</span></span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;   <span class="comment">//  设置回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<span class="comment">//  如果用户之前没设置回调函数，那么直接抛异常</span></span><br><span class="line">        (*__my_malloc_handler)();                           <span class="comment">//  调用回调函数</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);                       <span class="comment">//  </span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="reallocate"><a href="#reallocate" class="headerlink" title="reallocate"></a>reallocate</h2><ul>
<li>功能概述<ul>
<li>为指针p重新分配指向的空间，大小为new_sz。并返回这块新内存的地址。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">reallocate</span>(<span class="keyword">void</span>* __p,size_t__old_sz,<span class="keyword">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  old new都&gt;128byets，那么用的就应当是和一级空间配置器一样的方法malloc</span></span><br><span class="line">    <span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));   <span class="comment">//  重新分配内存。释放p地址内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果即将分配的chunk块大小一致，那么不必，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="keyword">return</span>(__p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重新从内存池中申请new_size大小内存，并拷贝数据到新申请来的内存里</span></span><br><span class="line">    __result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">    __copy_sz = __new_sz &gt; __old_sz? __old_sz : __new_sz;</span><br><span class="line">    <span class="built_in">memcpy</span>(__result, __p, __copy_sz); <span class="comment">//  拷贝数据</span></span><br><span class="line">    <span class="built_in">deallocate</span>(__p, __old_sz);  <span class="comment">//  将p指向的内存还给内存池链表</span></span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="经典内存池优点"><a href="#经典内存池优点" class="headerlink" title="经典内存池优点"></a>经典内存池优点</h2><ul>
<li><p>C/C++下内存管理是让几乎每一个程序员头疼的问题，分配足够的内存、追踪内存的分配、在不需要的时候释放内存——这个任务相当复杂。而直接使用系统调用malloc/free、new/delete进行内存分配和释放，有以下弊端：<br>利用默认的内存管理函数new/delete或malloc/free在堆上分配和释放内存会有一些额外的开销。</p>
</li>
<li><p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。</p>
</li>
<li><p>默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。 </p>
</li>
<li><p>可见，如果应用程序频繁地在堆上分配和释放内存，则会导致性能的损失。并且会使系统中出现大量的内存碎片，降低程序性能，降低内存的利用率。</p>
</li>
<li><p>默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池则可以获得更好的性能。</p>
</li>
<li><p>内存池（memory pool)是代替直接调用malloc/free、new/delete进行内存管理的常用方法，当我们申请内存空间时，首先到我们的内存池中查找合适的内存块，而不是直接向操作系统申请，优势在于：</p>
<ul>
<li>比malloc/free进行内存申请/释放的方式快;</li>
<li>不会产生或很少产生堆碎片;</li>
<li>可避免内存泄漏;</li>
</ul>
</li>
<li><p>普通内存池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象。</span><br><span class="line"></span><br><span class="line">（2）每个对象连同一个指向下一个对象的指针一起构成一个内存节点（Memory Node）。各个空闲的内存节点通过指针来形成一个链表，链表的每一个内存节点都是一块可供分配的内存空间。</span><br><span class="line"></span><br><span class="line">（3）某个内存节点一旦分配出去，就将从链表中去除。</span><br><span class="line"></span><br><span class="line">（4）一旦释放了某个内存节点的空间，又将该节点重新加入自由内存节点链表。</span><br><span class="line"></span><br><span class="line">（5）如果一个内存块的所有内存节点分配完毕，若程序继续申请新的对象空间，则会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。</span><br><span class="line"></span><br><span class="line">经典内存池的实现过程大致如上面所述，其形象化的过程如下图所示： </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SGI-STL-二级空间配置器优点"><a href="#SGI-STL-二级空间配置器优点" class="headerlink" title="SGI STL 二级空间配置器优点"></a>SGI STL 二级空间配置器优点</h2><ul>
<li>对于每一个字节数的chunk块分配，都是返回给用户一个使用的内存块，并给freelist一个内存池，，并留有另一部分作为备用内存池。这个备用可以给当前的字节数freelist成员使用，也可以给其他字节数的freelist成员使用。</li>
<li>对于备用内存池划分chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的内存块再次分配出去，备用内存池使用的一滴不剩。</li>
<li>当指定bytes字节数内存分配失败以后，有一个异常处理的过程，bytes -&gt; 128字节所有的chunk块进行查看，如果哪个freelist成员下的内存链表池中有chunk块，借一个出去。<ul>
<li>如果操作失败，会调用<code>_S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get)</code>来malloc内存；<ul>
<li><code>allocate</code>里面通过调用<code>oom_malloc</code>，来调用预先设置好的回调函数<code>__malloc_alloc_oom_handler</code>。用于处理<code>malloc</code>失败的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缺点-我认为"><a href="#缺点-我认为" class="headerlink" title="缺点 我认为"></a>缺点 我认为</h2><ul>
<li>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：<ul>
<li>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它 会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造 成很多内部碎片；</li>
<li>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过 程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全 是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有： <ul>
<li>1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失 败；</li>
<li>2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请 不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">灼夭. 10:11:37</span><br><span class="line">xdm 请问大家个问题。二级空间配置器真的解决了内存碎片的问题吗。我觉得虽然解决了外部碎片的问题，但好像又会导致产生很多内部碎片呀？还是说虽然会产生内部碎片，但是无所谓？对程序性能、内存利用率也没啥太大影响？</span><br><span class="line"></span><br><span class="line">灼夭. 10:11:51</span><br><span class="line">Alex💡 10:23:52</span><br><span class="line">灼夭.  </span><br><span class="line">xdm 请问大家个问题。二级空间配置器真的解决了内存碎片的问题吗。我觉得虽然解决了外部碎片的问题，但好像又会导致产生很多内部碎片呀？还是说虽然会产生内部碎片，但是无所谓？对程序性能、内存利用率也没啥太大影响？</span><br><span class="line">@灼夭. 我之前看侯捷讲的说法是，二级配置器可以很好的解决频繁调用malloc带来的时间消耗以及额外内存消耗，但是与此同时，内存池分配的小块内存都是8的倍数，也会存在一定的内部碎片，但相对于malloc而言，其性能还是好的。</span><br><span class="line"></span><br><span class="line">灼夭. 10:27:53</span><br><span class="line">Alex💡  </span><br><span class="line">@灼夭. 我之前看侯捷讲的说法是，二级配置器可以很好的解决频繁调用malloc带来的时间消耗以及额外内存消耗，但是与此同时，内存池分配的小块内存都是8的倍数，也会存在一定的内部碎片，但相对于malloc而言，其性能还是好的。</span><br><span class="line">@Alex💡 哦哦哦 多谢xd</span><br><span class="line"></span><br><span class="line">Alex💡 10:28:17</span><br><span class="line">没事儿。</span><br></pre></td></tr></table></figure>


<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fdk_lcl/article/details/89482835">https://blog.csdn.net/fdk_lcl/article/details/89482835</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">round - 必应词典</span><br><span class="line">美[raʊnd]英[raʊnd]</span><br><span class="line">n.旋转；巡视；一连串；绕圈</span><br><span class="line">adv.环绕；附近；各处；向四面</span><br><span class="line">prep.环绕；在…周围；始终</span><br><span class="line">v.绕过；拐过；使成圆形；把…四舍五入</span><br><span class="line">adj.圆的；球形的；肥胖的；弧形的</span><br><span class="line">网络回合；轮；圆形的</span><br><span class="line"></span><br><span class="line">round up 向上取整</span><br></pre></td></tr></table></figure>








<ul>
<li>计组<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>计算机里的数都是补码形式，因为CPU只会做加法，数的补码形式就可以用加法实现减法运算，进而以加法完成所有的运算。至于数以什么码的形式输入和输出，编程人员是可以控制的。</span><br><span class="line"><span class="number">2.</span>计算机里数码的位数是<span class="number">2</span>的正整数次方，比如<span class="number">4</span>位、<span class="number">8</span>位、<span class="number">16</span>位，因为CPU及周边电路一旦制成，一次处理数据位数、总线位数、各种寄存器位数就都固定下来，都是<span class="number">2</span>的正整数次方位，这样选择的理由很多，可参照有关资料了解。</span><br><span class="line"><span class="number">3.</span>一个<span class="number">8</span>位的补码数，它表示数的范围是<span class="number">-128</span>~+<span class="number">127</span>，原码表示数的范围是<span class="number">-127</span>~+<span class="number">127</span>，反码表示数的范围是<span class="number">-127</span>~+<span class="number">127</span>，就是因为最高位是符号位，实际数位只有<span class="number">7</span> 位。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存碎片是问题吗？"><a href="#内存碎片是问题吗？" class="headerlink" title="内存碎片是问题吗？"></a>内存碎片是问题吗？</h2><ul>
<li>截</li>
</ul>
<hr>
<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Default node allocator.</span></span><br><span class="line"><span class="comment">// With a reasonable compiler, this should be roughly as fast as the</span></span><br><span class="line"><span class="comment">// original STL class-specific allocators, but with less fragmentation.</span></span><br><span class="line"><span class="comment">// Default_alloc_template parameters are experimental and MAY</span></span><br><span class="line"><span class="comment">// DISAPPEAR in the future.  Clients should just use alloc for now.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Important implementation properties:</span></span><br><span class="line"><span class="comment">// 1. If the client request an object of size &gt; _MAX_BYTES, the resulting</span></span><br><span class="line"><span class="comment">//    object will be obtained directly from malloc.</span></span><br><span class="line"><span class="comment">// 2. In all other cases, we allocate an object of size exactly</span></span><br><span class="line"><span class="comment">//    _S_round_up(requested_size).  Thus the client has enough size</span></span><br><span class="line"><span class="comment">//    information that we can return the object to the proper free list</span></span><br><span class="line"><span class="comment">//    without permanently losing part of the object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The first template parameter specifies whether more than one thread</span></span><br><span class="line"><span class="comment">// may use this allocator.  It is safe to allocate an object from</span></span><br><span class="line"><span class="comment">// one instance of a default_alloc and deallocate it with another</span></span><br><span class="line"><span class="comment">// one.  This effectively transfers its ownership to the second one.</span></span><br><span class="line"><span class="comment">// This may have undesirable effects on reference locality.</span></span><br><span class="line"><span class="comment">// The second parameter is unreferenced and serves only to allow the</span></span><br><span class="line"><span class="comment">// creation of multiple default_alloc instances.</span></span><br><span class="line"><span class="comment">// Node that containers built on different allocator instances have</span></span><br><span class="line"><span class="comment">// different types, limiting the utility of this approach.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size __n, and optionally adds to size __n free list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_THREADS</span></span><br><span class="line">    <span class="keyword">static</span> _STL_mutex_lock _S_node_allocator_lock;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It would be nice to use _STL_auto_lock here.  But we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need the NULL check.  And we do need a test whether</span></span><br><span class="line">    <span class="comment">// threads have actually been started.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125;</span><br><span class="line">            ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size __n, and optionally adds to size __n free list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_THREADS</span></span><br><span class="line">    <span class="keyword">static</span> _STL_mutex_lock _S_node_allocator_lock;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It would be nice to use _STL_auto_lock here.  But we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need the NULL check.  And we do need a test whether</span></span><br><span class="line">    <span class="comment">// threads have actually been started.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125;</span><br><span class="line">            ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  申请nbytes。如果空间不足，则释放nbytes</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  释放p</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/10/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/10/HTTP/" class="post-title-link" itemprop="url">HTTP(预习)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-10 09:44:02" itemprop="dateCreated datePublished" datetime="2022-04-10T09:44:02+08:00">2022-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:43:11" itemprop="dateModified" datetime="2022-05-28T22:43:11+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>密码系统：算法+密钥组成。明文和密钥是原材料，算法是加工的方式，产出的就是密文。</li>
<li>密钥是要保密的。密码算法不用保密。因为密码算法终究hui’bei’po’jie，不能依赖保密算法提高安全性。</li>
<li><strong>对称加密</strong>：发送和接收方共用同一套密钥。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/436455172">对称密钥</a></li>
<li><strong>非对称加密</strong>：发送方和接受方各自设定一套私钥和公钥。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/436455172">非对称密钥</a><ul>
<li>使用对方的提供的公钥来进行加密，加密发送给对方后，对方有私钥负责解密。公钥是之前就互相提供给对方的，<br><img src="/2022/04/10/HTTP/2022-04-10-09-55-20.png"></li>
</ul>
</li>
<li><strong>混合加密</strong>：对称加密和非对称加密结合<ul>
<li>通信建立前：采用<strong>非对称加密方式</strong>交换<em>会话密钥</em>，后续就不再使用非对称加密</li>
<li>通信过程：通信过程中全部使用<strong>对称加密</strong>的<em>会话密钥</em>的方式</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/r1-12king/p/15880436.html#:~:text=%E5%AE%83%E6%9C%89%E4%B8%A4%E4%B8%AA%E5%AF%86%E9%92%A5%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%8F%AB%E2%80%9C%E5%85%AC%E9%92%A5%E2%80%9D%EF%BC%88public,key%EF%BC%89%EF%BC%8C%E4%B8%80%E4%B8%AA%E5%8F%AB%E2%80%9C%E7%A7%81%E9%92%A5%E2%80%9D%EF%BC%88private%20key%EF%BC%89%E3%80%82">暴力加密</a></li>
</ul>
</li>
</ul>
<h2 id="HTTPS通信"><a href="#HTTPS通信" class="headerlink" title="HTTPS通信"></a>HTTPS通信</h2><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https">记录</a></p>
<ul>
<li>http由于明文传输，所以存在以下问题<ul>
<li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li>篡改风险，比如强制植入垃圾广告，视觉污染，用户眼容易瞎</li>
<li>冒充风险，比如冒充淘宝网站，用户钱容易没</li>
</ul>
</li>
<li>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：<br><img src="/2022/04/10/HTTP/2022-04-10-12-00-59.png"><ul>
<li>信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li>校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li>身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
</li>
<li>可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的。</li>
<li>HTTPS 是如何解决上面的三个风险的？<ul>
<li><strong>混合加密</strong>的方式实现信息的机密性，解决了窃听的风险。</li>
<li><strong>摘要算法</strong>的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li>
<li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li>
</ul>
</li>
<li>HTTPS 是如何建立连接的？其间交互了什么？<ul>
<li>客户端向服务器索要并验证服务器的公钥。</li>
<li>双方协商生产「会话秘钥」。</li>
<li>双方采用「会话秘钥」进行加密通信。</li>
<li>前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。</li>
</ul>
</li>
<li>SSL/TLS 的「握手阶段」涉及四次通信，可见下图：</li>
</ul>
<p><img src="/2022/04/10/HTTP/2022-04-10-11-30-05.png"><br>cipher 密码<br>spec 规格</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> ClientHello</span><br><span class="line"></span><br><span class="line">首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</span><br><span class="line"></span><br><span class="line">在这一步，客户端主要向服务器发送以下信息：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）客户端支持的 SSL/TLS 协议版本，如 TLS <span class="number">1.2</span> 版本。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）客户端支持的密码套件列表，如 RSA 加密算法。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> SeverHello</span><br><span class="line"></span><br><span class="line">服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）确认的密码套件列表，如 RSA 加密算法。</span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）服务器的数字证书。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>客户端回应</span><br><span class="line"></span><br><span class="line">客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</span><br><span class="line"></span><br><span class="line">如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</span><br><span class="line"></span><br><span class="line">上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 服务器的最后回应</span><br><span class="line"></span><br><span class="line">服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：</span><br><span class="line"></span><br><span class="line">（<span class="number">1</span>）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</span><br><span class="line"></span><br><span class="line">至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</span><br></pre></td></tr></table></figure>


<p><strong><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3fc3646fad80">长连接短连接</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">容器复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-07 10:27:02" itemprop="dateCreated datePublished" datetime="2022-04-07T10:27:02+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:19:08" itemprop="dateModified" datetime="2022-05-28T22:19:08+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88792786?spm=1001.2014.3001.5502">https://blog.csdn.net/QIANGWEIYUAN/article/details/88792786?spm=1001.2014.3001.5502</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ STL standard template libaray 标准模板库</span></span><br><span class="line"><span class="comment">一、标准容器 C++11 array  forward_list</span></span><br><span class="line"><span class="comment">1.顺序容器 </span></span><br><span class="line"><span class="comment">vector</span></span><br><span class="line"><span class="comment">deque</span></span><br><span class="line"><span class="comment">list</span></span><br><span class="line"><span class="comment">2.容器适配器</span></span><br><span class="line"><span class="comment">stack</span></span><br><span class="line"><span class="comment">queue</span></span><br><span class="line"><span class="comment">priority_queue</span></span><br><span class="line"><span class="comment">3.关联容器 </span></span><br><span class="line"><span class="comment">无序关联容器 =&gt; 链式哈希表  增删查O(1) </span></span><br><span class="line"><span class="comment">set:集合 key   map:映射表 [key,value]</span></span><br><span class="line"><span class="comment">unordered_set 单重集合</span></span><br><span class="line"><span class="comment">unordered_multiset 多重集合</span></span><br><span class="line"><span class="comment">unordered_map 单重映射表</span></span><br><span class="line"><span class="comment">unordered_multimap 多重映射表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有序关联容器 =&gt; 红黑树 增删查O(log2n) 2是底数(树的层数，树的高度)</span></span><br><span class="line"><span class="comment">set</span></span><br><span class="line"><span class="comment">multiset</span></span><br><span class="line"><span class="comment">map</span></span><br><span class="line"><span class="comment">multimap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、近容器</span></span><br><span class="line"><span class="comment">数组，string，bitset(位容器)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">三、迭代器</span></span><br><span class="line"><span class="comment">iterator和const_iterator</span></span><br><span class="line"><span class="comment">reverse_iterator和const_reverse_iterator</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">四、函数对象（类似C的函数指针）</span></span><br><span class="line"><span class="comment">greater,less</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">五、泛型算法</span></span><br><span class="line"><span class="comment">sort,find,find_if,binary_search,for_each</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>size：元素个数</li>
<li>empty：是否无元素</li>
<li>reserve：预留空间，但不放元素。</li>
<li>resize：重新设置空间，并且每个位置都放上元素（int()）。所以之后再push_back，还是会扩容。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector：向量容器 </span></span><br><span class="line"><span class="comment">底层数据结构：动态开辟的数组，每次以原来空间大小的2倍进行扩容的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">vector&lt;int&gt; vec;</span></span><br><span class="line"><span class="comment">增加:</span></span><br><span class="line"><span class="comment">vec.push_back(20); 末尾添加元素 O(1)   导致容器扩容</span></span><br><span class="line"><span class="comment">vec.insert(it, 20); it迭代器指向的位置添加一个元素20  O(n)   导致容器扩容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">删除:</span></span><br><span class="line"><span class="comment">vec.pop_back(); 末尾删除元素 O(1) </span></span><br><span class="line"><span class="comment">vec.erase(it); 删除it迭代器指向的元素 O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">查询:</span></span><br><span class="line"><span class="comment">operator[] 下标的随机访问vec[5]  O(1)</span></span><br><span class="line"><span class="comment">iterator迭代器进行遍历</span></span><br><span class="line"><span class="comment">find，for_each</span></span><br><span class="line"><span class="comment">foreach =&gt; 通过iterator来实现的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：对容器进行连续插入或者删除操作(insert/erase)，一定要更新迭代器，否则第一次insert或者erase完成，</span></span><br><span class="line"><span class="comment">迭代器就失效了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">常用方法介绍:</span></span><br><span class="line"><span class="comment">size()</span></span><br><span class="line"><span class="comment">empty()</span></span><br><span class="line"><span class="comment">reserve(20)：vector预留空间的   只给容器底层开辟指定大小的内存空间，并不会添加新的元素</span></span><br><span class="line"><span class="comment">resize(20)：容器扩容用的  不仅给容器底层开辟指定大小的内存空间，还会添加新的元素</span></span><br><span class="line"><span class="comment">swap ： 两个容器进行元素交换</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">// vector&lt;string&gt; vec; 0 1 2 4 8 16 32 64</span></span><br><span class="line">	<span class="comment">//vec.reserve(20); // 叫做给vector容器预留空间</span></span><br><span class="line">	vec.<span class="built_in">resize</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// int()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>()%<span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// vector的operator[]运算符重载函数</span></span><br><span class="line">	<span class="keyword">int</span> size = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把vec容器中所有的偶数全部删除</span></span><br><span class="line">	<span class="keyword">auto</span> it2 = vec.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span> (it2 != vec.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it2 % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			it2 = vec.<span class="built_in">erase</span>(it2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++it2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过迭代器遍历vector容器</span></span><br><span class="line">	<span class="keyword">auto</span> it1 = vec.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给vector容器中所有的奇数前面都添加一个小于奇数1的偶数   44 45    56 57</span></span><br><span class="line">	<span class="keyword">for</span> (it1 = vec.<span class="built_in">begin</span>(); it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it1 % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			it1 = vec.<span class="built_in">insert</span>(it1, *it1<span class="number">-1</span>);</span><br><span class="line">			++it1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (it1 = vec.<span class="built_in">begin</span>(); it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="deque、list"><a href="#deque、list" class="headerlink" title="deque、list"></a>deque、list</h2><ul>
<li>deque<br><img src="/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/2022-04-08-22-24-44.png"></li>
<li>list<br><img src="/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/2022-04-08-22-25-24.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">deque：双端队列容器</span></span><br><span class="line"><span class="comment">底层数据结构：动态开辟的二维数组，一维数组从2开始，以2倍的方式进行扩容，每次扩容后，原来第二维的数组，从</span></span><br><span class="line"><span class="comment">新的第一维数组的下标oldsize/2开始存放，上下都预留相同的空行，方便支持deque的首尾元素添加</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque&lt;int&gt; deq;</span></span><br><span class="line"><span class="comment">增加：</span></span><br><span class="line"><span class="comment">deq.push_back(20); 从末尾添加元素 O(1)  </span></span><br><span class="line"><span class="comment">deq.push_front(20); 从首部添加元素 O(1)   // vec.insert(vec.begin(), 20) O(n)</span></span><br><span class="line"><span class="comment">deq.insert(it, 20); it指向的位置添加元素 O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">删除：</span></span><br><span class="line"><span class="comment">deq.pop_back(); 从末尾删除元素 O(1)  </span></span><br><span class="line"><span class="comment">deq.pop_front(); 从首部删除元素 O(1)  </span></span><br><span class="line"><span class="comment">deq.erase(it);  从it指向的位置删除元素 O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">查询搜索：</span></span><br><span class="line"><span class="comment">iterator(连续的insert和erase一定要考虑迭代器失效的问题)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">list：链表容器</span></span><br><span class="line"><span class="comment">底层数据结构：双向的循环链表   pre data next</span></span><br><span class="line"><span class="comment">list&lt;int&gt; mylist;</span></span><br><span class="line"><span class="comment">增加：</span></span><br><span class="line"><span class="comment">mylist.push_back(20); 从末尾添加元素 O(1)</span></span><br><span class="line"><span class="comment">mylist.push_front(20); 从首部添加元素 O(1)   // vec.insert(vec.begin(), 20) O(n)</span></span><br><span class="line"><span class="comment">mylist.insert(it, 20); it指向的位置添加元素 O(1) // 链表中进行insert的时候，先要进行一个query查询操作</span></span><br><span class="line"><span class="comment">    对于链表来说，查询操作效率就比较慢了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">删除：</span></span><br><span class="line"><span class="comment">mylist.pop_back(); 从末尾删除元素 O(1)</span></span><br><span class="line"><span class="comment">mylist.pop_front(); 从首部删除元素 O(1)</span></span><br><span class="line"><span class="comment">mylist.erase(it);  从it指向的位置删除元素 O(1)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">查询搜索：</span></span><br><span class="line"><span class="comment">iterator(连续的insert和erase一定要考虑迭代器失效的问题)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">deque和list，比vector容器多出来的增加删除函数接口：</span></span><br><span class="line"><span class="comment">push_front和pop_front</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>vector底层：连续的数组</li>
<li>deque底层：两个维度 每一个第二维度的数组是连续的。是单独new出来的。</li>
</ul>
<h2 id="vector、deque、list对比"><a href="#vector、deque、list对比" class="headerlink" title="vector、deque、list对比"></a>vector、deque、list对比</h2><ul>
<li>deque &amp; vector 的erase/insert操作。(都是O(n))<br><img src="/2022/04/07/c++_%E5%AE%B9%E5%99%A8%E5%A4%8D%E4%B9%A0/2022-04-08-22-24-31.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector特点：动态数组，内存是连续的，2倍的方式进行扩容， vector&lt;int&gt; vec; 0-1-2-4-8... reserve(20)/resize</span></span><br><span class="line"><span class="comment">deque特点：动态开辟的二维数组空间，第二维是固定长度的数组空间，扩容的时候（第一维的数组进行2倍扩容）</span></span><br><span class="line"><span class="comment">		面经问题：deque底层内存是否是连续的？   并不是  每一个第二维是连续的，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">容器的纵向考察：容器掌握的深度</span></span><br><span class="line"><span class="comment">容器的横向考察：各个相似容器之间的对比</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">vector和deque之间的区别？</span></span><br><span class="line"><span class="comment">1.底层数据结构：</span></span><br><span class="line"><span class="comment">2.前中后插入删除元素的时间复杂度： 末尾 O(1) ； 前 deque O(1) vector O(n) ；中间都是O(n)</span></span><br><span class="line"><span class="comment">3.对于内存的使用效率： vector 需要的内存空间必须是连续的    deque 可以分块进行数据存储，不需要内存空间必须是一片连续的</span></span><br><span class="line"><span class="comment">4.在中间进行insert或者erase，vector和deque它们的效率谁能好一点(vector)？谁能差一点(deque)？  但是都是O(n)</span></span><br><span class="line"><span class="comment">	因为deque的每个第二维的内存单独连续。需要移动元素时还要去找一维的地址。</span></span><br><span class="line"><span class="comment">	vector的所有内存都是连续的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for(int i=0; i&lt;10000; ++i)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; arr[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">vector和list之间的区别？   数组:增加删除O(n) 查询O(n) 随机访问O(1)   链表:(考虑搜索的时间)增加删除O(1)  查询O(n)</span></span><br><span class="line"><span class="comment">1.底层数据结构：数组   双向循环链表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><ul>
<li>没有实现自己的迭代器，也就因此不能通过迭代器遍历容器。（如stack）<h3 id="stack、queue、pritority-queue"><a href="#stack、queue、pritority-queue" class="headerlink" title="stack、queue、pritority_queue"></a>stack、queue、pritority_queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span> <span class="comment">// stack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span> <span class="comment">// queue和priority_queue</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">标准容器 - 容器适配器 =&gt; 设计模式，就叫做适配器模式</span></span><br><span class="line"><span class="comment">怎么理解这个适配器？</span></span><br><span class="line"><span class="comment">1.适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的</span></span><br><span class="line"><span class="comment">2.没有实现自己的迭代器，也就没有办法通过迭代器遍历。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template&lt;typename T, typename Container=deque&lt;T&gt;&gt;</span></span><br><span class="line"><span class="comment">class Stack</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">	void push(const T &amp;val) &#123; con.push_back(val); &#125;</span></span><br><span class="line"><span class="comment">	void pop() &#123; con.pop_back(); &#125;</span></span><br><span class="line"><span class="comment">	T top()const &#123; return con.back(); &#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">	Container con;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">stack: push入栈  pop出栈  top查看栈顶元素  empty判断栈空  size返回元素个数 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">queue: push入队  pop出队  front查看队头元素 back查看队尾元素  empty判断队空   size返回元素个数</span></span><br><span class="line"><span class="comment">queue =&gt; deque  为什么不依赖vector呢？？？</span></span><br><span class="line"><span class="comment">stack =&gt; deque  为什么不依赖vector呢？？？</span></span><br><span class="line"><span class="comment">1.vector的初始内存使用效率太低了！没有deque好  queue&lt;int&gt; stack&lt;int&gt;  vector 0-1-2-4-8 deque 4096/sizeof(int) = 1024</span></span><br><span class="line"><span class="comment">2.对于queue来说，需要支持尾部插入，头部删除，O(1)  如果queue依赖vector，其出队效率很低</span></span><br><span class="line"><span class="comment">3.vector需要大片的连续内存，而deque只需要分段的内存，当存储大量数据时，显然deque对于内存的利用率更好一些</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">priority_queue: push入队  pop出队  top查看队顶元素  empty判断队空  size返回元素个数  默认：大根堆</span></span><br><span class="line"><span class="comment">priority_queue =&gt; vector 为什么依赖vector？？？</span></span><br><span class="line"><span class="comment">底层默认把数据组成一个大根堆结构  在一个内存连续的数组上构建一个大根堆或者小根堆的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; pque;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		pque.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; pque.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (!pque.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; pque.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		pque.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		que.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; que.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; que.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s1.<span class="built_in">push</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; s1.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		s1.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h2><p>不允许重复：一个元素（或者key-value中的key）只存一次，第二次就不存了。<br>允许重复：一个元素可以存多次。（可以看集合的大小就能看出来）</p>
<ul>
<li><p>有序关联容器</p>
<ul>
<li>set：不允许key重复。元素有序。红黑树。#include<set></set></li>
<li>multiset：允许key重复。元素有序。红黑树。#include<set><ul>
<li>元素有序：加入的元素要实现operator&lt;</li>
</ul>
</set></li>
</ul>
</li>
<li><p>无序关联容器</p>
<ul>
<li>unordered_set：不允许key重复。元素无序。链式哈希表。 #include<unordered_set></unordered_set></li>
<li>unordered_multiset：不允许key重复。元素有。链式哈希表#include<unordered_set></unordered_set></li>
</ul>
</li>
<li><p>unordered：无序</p>
</li>
<li><p>multi：重复</p>
</li>
<li><p>使用无序关联容器：#include<unordered_set> #include<unordered_map></unordered_map></unordered_set></p>
</li>
<li><p>使用有序关联容器：#include<set> #include<map></map></set></p>
</li>
<li><p>set换成map即可。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关联容器：</span></span><br><span class="line"><span class="comment">1.各个容器底层的数据结构 O(1)  O(log2n)</span></span><br><span class="line"><span class="comment">2.常用增删查方法</span></span><br><span class="line"><span class="comment">增加：insert(val)</span></span><br><span class="line"><span class="comment">遍历：iterator自己搜索，调用find成员方法</span></span><br><span class="line"><span class="comment">删除：erase(key)  erase(it)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 处理海量数据查重复；去重复的时候</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> ARR_LEN = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> arr[ARR_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ARR_LEN; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = <span class="built_in">rand</span>() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上面的10万个整数中，把数字进行去重打印  set  map</span></span><br><span class="line">	unordered_set&lt;<span class="keyword">int</span>&gt; set;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : arr) <span class="comment">// O(n)</span></span><br><span class="line">	&#123;</span><br><span class="line">		set.<span class="built_in">insert</span>(v); <span class="comment">// O(1)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : set)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">// 上面的10万个整数中，统计哪些数字重复了，并且统计数字重复的次数</span></span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map1;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k : arr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		auto it = map1.find(k);</span></span><br><span class="line"><span class="comment">		if (it == map1.end())</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			map1.insert(&#123;k, 1&#125;);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			it-&gt;second++;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		map1[k]++; <span class="comment">// map1[k]  [k, 1]</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	for (const pair&lt;int, int&gt; &amp;p : map1)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		if (p.second &gt; 1)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; &quot;key:&quot; &lt;&lt; p.first &lt;&lt; &quot; count:&quot; &lt;&lt; p.second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != map1.<span class="built_in">end</span>(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (it-&gt;second &gt; <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt;</span><br><span class="line">				<span class="string">&quot; count:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	[key, value]</span></span><br><span class="line"><span class="comment">	struct pair</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	 first; =&gt; key</span></span><br><span class="line"><span class="comment">	 second; =&gt; value</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	map的operator[]</span></span><br><span class="line"><span class="comment">	1.查询</span></span><br><span class="line"><span class="comment">	2.如果key不存在，它会插入一对数据[key, string()]</span></span><br><span class="line"><span class="comment">	V&amp; operator[](const K &amp;key)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		insert(&#123;key, V()&#125;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	unordered_map&lt;int, string&gt; map1;</span></span><br><span class="line"><span class="comment">	map1.insert(make_pair(1000, &quot;张三&quot;));</span></span><br><span class="line"><span class="comment">	map1.insert(&#123;1010, &quot;李四&quot;&#125;); // map表增加元素</span></span><br><span class="line"><span class="comment">	map1.insert(&#123;1020, &quot;王五&quot; &#125;);</span></span><br><span class="line"><span class="comment">	map1.insert(&#123;1030, &quot;王凯&quot; &#125;);</span></span><br><span class="line"><span class="comment">	map1.erase(1020); // &#123;1020, &quot;王五&quot; &#125;删除了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	auto it1 = map1.find(1030);</span></span><br><span class="line"><span class="comment">	if (it1 != map1.end())</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		// it1 -&gt; pair对象</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; &quot;key:&quot; &lt;&lt; it1-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it1-&gt;second &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	//map1[2000]; // key:2000 value:&quot;&quot;</span></span><br><span class="line"><span class="comment">	//map1[2000] = &quot;刘硕&quot;; // map1.insert(&#123;2000, &quot;刘硕&quot;&#125;);</span></span><br><span class="line"><span class="comment">	//map1[1000] = &quot;张三2&quot;; // </span></span><br><span class="line"><span class="comment">	//cout &lt;&lt; map1.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	// map operator[](key) =&gt; value  查询</span></span><br><span class="line"><span class="comment">	//cout &lt;&lt; map1[1000] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">	unordered_set&lt;<span class="keyword">int</span>&gt; set1; <span class="comment">// 不会存储key值重复的元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		set1.<span class="built_in">insert</span>(<span class="built_in">rand</span>()%<span class="number">20</span>+<span class="number">1</span>); <span class="comment">// vector/deque/list  insert(it, val)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cout &lt;&lt; set1.size() &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; set1.count(15) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> it1 = set1.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it1 != set1.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	set1.<span class="built_in">erase</span>(<span class="number">20</span>); <span class="comment">// 按key值删除元素</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (it1 = set1.<span class="built_in">begin</span>(); it1 != set1.<span class="built_in">end</span>(); )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*it1 == <span class="number">30</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			it1 = set1.<span class="built_in">erase</span>(it1); <span class="comment">// 调用erase，it1迭代器就失效了</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++it1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	it1 = set1.<span class="built_in">find</span>(<span class="number">20</span>);</span><br><span class="line">	<span class="keyword">if</span> (it1 != set1.<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		set1.<span class="built_in">erase</span>(it1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : set1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="有序关联容器"><a href="#有序关联容器" class="headerlink" title="有序关联容器"></a>有序关联容器</h2><ul>
<li>有序关联容器<ul>
<li>set、multiset。红黑树#include<set>。</set></li>
<li>map、mutimap。红黑树#include<map>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span> <span class="comment">// stack</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span> <span class="comment">// queue和priority_queue</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用无序关联容器包含的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用有序关联容器包含的头文件  红黑树</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span> <span class="comment">// set multiset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span> <span class="comment">// map multimap</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="keyword">int</span> id=<span class="number">0</span>, string name=<span class="string">&quot;&quot;</span>)</span><br><span class="line">		:_id(id), _name(name) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _id;</span><br><span class="line">	string _name;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;stu);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; stu._id &lt;&lt; <span class="string">&quot; name:&quot;</span> &lt;&lt; stu._name &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	map&lt;<span class="keyword">int</span>, Student&gt; stuMap;</span><br><span class="line">	stuMap.<span class="built_in">insert</span>(&#123; <span class="number">1000</span>, <span class="built_in">Student</span>(<span class="number">1000</span>, <span class="string">&quot;张雯&quot;</span>) &#125;);</span><br><span class="line">	stuMap.<span class="built_in">insert</span>(&#123; <span class="number">1020</span>, <span class="built_in">Student</span>(<span class="number">1020</span>, <span class="string">&quot;李广&quot;</span>) &#125;);</span><br><span class="line">	stuMap.<span class="built_in">insert</span>(&#123; <span class="number">1030</span>, <span class="built_in">Student</span>(<span class="number">1030</span>, <span class="string">&quot;高洋&quot;</span>) &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stuMap.erase(it) stuMap.erase(1020)  stuMap[2000] [2000, V()]</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; stuMap[1020] &lt;&lt; endl;   stuMap.find(key)</span></span><br><span class="line">	<span class="keyword">auto</span> it = stuMap.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != stuMap.<span class="built_in">end</span>(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Student</span>(<span class="keyword">int</span> id, string name)</span><br><span class="line">		:_id(id), _name(name) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Student &amp;stu)<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _id &lt; stu._id;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _id;</span><br><span class="line">	string _name;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;stu);</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> Student &amp;stu)</span><br><span class="line">&#123;</span><br><span class="line">	out &lt;&lt; <span class="string">&quot;id:&quot;</span> &lt;&lt; stu._id &lt;&lt; <span class="string">&quot; name:&quot;</span> &lt;&lt; stu._name &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set&lt;Student&gt; set1;</span><br><span class="line"></span><br><span class="line">	set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1020</span>, <span class="string">&quot;李广&quot;</span>));</span><br><span class="line">	set1.<span class="built_in">insert</span>(<span class="built_in">Student</span>(<span class="number">1000</span>, <span class="string">&quot;张雯&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = set1.<span class="built_in">begin</span>();</span><br><span class="line">		it != set1.<span class="built_in">end</span>(); ++it)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	set&lt;int&gt; set1;</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; 20; ++i)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		set1.insert(rand()%20+1);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	for (int v : set1)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></map></li>
</ul>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">容器的迭代器</span></span><br><span class="line"><span class="comment">const_iterator:常量的正向迭代器  只能读，而不能写了</span></span><br><span class="line"><span class="comment">iterator:普通的正向迭代器</span></span><br><span class="line"><span class="comment">reverse_iterator:普通的反向迭代器</span></span><br><span class="line"><span class="comment">const_reverse_iterator:常量的反向迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// vector&lt;int&gt;::iterator</span></span><br><span class="line">	<span class="comment">// auto it1 = vec.begin(); </span></span><br><span class="line">	<span class="comment">// const_iterator   &lt;=   iterator</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	class const_iterator</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">	public:</span></span><br><span class="line"><span class="comment">		const T&amp; operator*()&#123;return *_ptr;&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	class iterator : public const_iterator</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		T&amp; operator*()&#123;return *_ptr;&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::const_iterator it1 = vec.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it1 != vec.<span class="built_in">end</span>(); ++it1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *it1 &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// rbegin()：返回的是最后一个元素的反向迭代器表示</span></span><br><span class="line">	<span class="comment">// rend：返回的是首元素前驱位置的迭代器的表示</span></span><br><span class="line">	<span class="comment">// vector&lt;int&gt;::reverse_iterator</span></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator rit = vec.<span class="built_in">rbegin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; rit != vec.<span class="built_in">rend</span>(); ++rit)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; *rit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*for (int v : vec)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li>一个类，重载了<code>operator()</code>小括号运算符。如<code>class xx&#123;bool operator()(int a,int b);&#125;</code>。把这个类的对象称为函数对象或者仿函数。</li>
<li>函数对象好处（代替函数指针）：<ul>
<li>通过函数对象调用<code>operator()</code>，可以省略函数的调用开销，比通过函数指针调用函数（不能够<code>inline</code>内联调用）效率高</li>
<li>因为函数对象是用类生成的，所以可以添加相关的成员变量，用来记录函数对象使用时更多的信息</li>
</ul>
</li>
<li><code>sort(vec.begin(),vec.end(),greater&lt;int&gt;())</code><ul>
<li>传入函数对象：<code>greater&lt;int&gt;()</code>。</li>
</ul>
</li>
<li><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;</code><ul>
<li>传入函数对象的类类型<code>:less&lt;int&gt;</code>，将来会在<code>priority_queue</code>的类中造函数对象<code>less&lt;int&gt; comp</code>;<h3 id="仿函数和函数指针对比"><a href="#仿函数和函数指针对比" class="headerlink" title="仿函数和函数指针对比"></a>仿函数和函数指针对比</h3></li>
</ul>
</li>
<li>函数对象示例<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Compare：函数对象的类类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Compare&gt;  </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare cmp)</span>    <span class="comment">//  cmp是个函数对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(a,b);    <span class="comment">//  通过函数对象 调用的是operator()(a,b);</span></span><br><span class="line">    <span class="comment">//  内联inline！</span></span><br><span class="line">    <span class="comment">//  因为cmp是函数对象。也就是()是类内的函数。那么这个函数就是内联的.</span></span><br><span class="line">    <span class="comment">//  因为通过对象调用，那么</span></span><br><span class="line">    <span class="comment">//  编译器看到指定模板参数类型调用compare时，会实例化compare模板函数，而在这时Compare类型已经指定。也就是说对象cmp确定是什么类型的了。</span></span><br><span class="line">    <span class="comment">//  那么我们就可以知道调用哪个函数了。那么编译器就可以将他内联了，</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  mygreater类的对象称为 仿函数 / 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mygreater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span></span>&#123;  <span class="comment">//  二元函数对象</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  myless类的对象称为 仿函数 / 函数对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myless</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;myless&lt;<span class="keyword">int</span>&gt;()(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;   <span class="comment">//  myless&lt;int&gt;()：仿函数 / 函数对象</span></span><br><span class="line">	cout&lt;&lt; <span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,myless&lt;<span class="keyword">int</span>&gt;()) &lt;&lt;endl;  <span class="comment">//  传入函数对象</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// cout&lt;&lt;compare&lt;int,myless&lt;int&gt;&gt;(1,2,myless&lt;int&gt;())&lt;&lt;endl; </span></span><br><span class="line">    <span class="comment">//  &lt;myless&lt;int&gt;&gt; 显示传入函数对象的类型 </span></span><br><span class="line">    <span class="comment">//  (myless&lt;int&gt;()) 传入函数对象 </span></span><br><span class="line">	<span class="comment">//  myless&lt;int&gt;：模板名 + 类型参数列表 = 类名。这是myless&lt;int&gt;()这个对象的类类型。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>函数指针示例<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Compare 函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b, Compare cmp)</span>	<span class="comment">//  cmp是一个函数指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cmp</span>(a,b);    <span class="comment">//  通过函数指针调用</span></span><br><span class="line">    <span class="comment">//  通过函数指针调用缺点：！！！</span></span><br><span class="line">    <span class="comment">//  无法inline、开销大！因为有函数调用的开销！</span></span><br><span class="line">    <span class="comment">//  为什么无法内联？</span></span><br><span class="line">    <span class="comment">//  内联是在编译时期做的。而这里我们通过函数指针调用，是在运行时调用，在运行时传入地址，通过地址调用。</span></span><br><span class="line">    <span class="comment">//  而在编译时，编译器当然不知道调用的是那个函数。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  这俩不是仿函数，是函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">greater</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myless</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;myless&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;   	   <span class="comment">//  myless&lt;int&gt;:函数指针。</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,myless&lt;<span class="keyword">int</span>&gt;)&lt;&lt;endl;  <span class="comment">//  myless&lt;int&gt;的类型是一个函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="STL示例"><a href="#STL示例" class="headerlink" title="STL示例"></a>STL示例</h3><ul>
<li>STL模板参数指定函数对象类型<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;,</span></span><br><span class="line"><span class="comment">	   typename _Compare  = less&lt;typename _Sequence::value_type&gt; &gt;</span></span><br><span class="line"><span class="comment">    class priority_queue</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    protected:</span></span><br><span class="line"><span class="comment">      //  See queue::c for notes on these names.</span></span><br><span class="line"><span class="comment">      _Sequence  c;</span></span><br><span class="line"><span class="comment">      _Compare   comp;	用类型_Compare定义了一个函数对象</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int&gt; q;  //  使用默认底层容器类型vector&lt;int&gt; 使用默认仿函数类型_Compare = less&lt;..&gt;</span></span><br><span class="line"><span class="comment">//    priority_queue&lt;int,vector&lt;int&gt;&gt; q;  //  使用默认 _Compare模板参数类型</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)    q.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">继承与多态复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-04 23:36:38" itemprop="dateCreated datePublished" datetime="2022-04-04T23:36:38+08:00">2022-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:19:10" itemprop="dateModified" datetime="2022-05-28T22:19:10+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.继承的本质和原理<br>2.派生类的构造过程<br>3.重载、覆盖、隐藏<br>4.静态绑定和动态绑定<br>5.多态 vfptr和vftable<br>6.抽象类的设计原理<br>7.多重继承以及问题<br>8.虚基类 vbptr和vbtable<br>9.RTTI<br>10.C++四种类型强转<br>11.继承多态常见笔试面试题分享</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.继承的本质和原理</span></span><br><span class="line"><span class="comment">继承的本质：a.代码的复用  b.</span></span><br><span class="line"><span class="comment">类和类之间的关系：</span></span><br><span class="line"><span class="comment">组合：a part of... ...一部分的关系</span></span><br><span class="line"><span class="comment">继承：a kind of... ...一种的关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承方式     基类的访问限定     派生类的访问限定      (main)外部的访问限定</span></span><br><span class="line"><span class="comment">public </span></span><br><span class="line"><span class="comment">			  public			public                 Y</span></span><br><span class="line"><span class="comment">			  protected			protected			   N</span></span><br><span class="line"><span class="comment">			  private			不可见的				   N         </span></span><br><span class="line"><span class="comment">protected(基类的成员的访问限定，在派生类里面是不可能超过继承方式的)</span></span><br><span class="line"><span class="comment">			  public			protected			   N</span></span><br><span class="line"><span class="comment">			  protected			protected			   N</span></span><br><span class="line"><span class="comment">			  private			不可见的				   N</span></span><br><span class="line"><span class="comment">private</span></span><br><span class="line"><span class="comment">			  public			private				   N</span></span><br><span class="line"><span class="comment">			  protected			private				   N</span></span><br><span class="line"><span class="comment">			  private			不可见的				   N</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">1.外部只能访问对象public的成员，protected和private的成员无法直接访问</span></span><br><span class="line"><span class="comment">2.在继承结构中，派生类从基类可以继承过来private的成员，但是派生类却无法直接访问</span></span><br><span class="line"><span class="comment">3.protected和private的区别？在基类中定义的成员，想被派生类访问，但是不想被外部访问，</span></span><br><span class="line"><span class="comment">那么在基类中，把相关成员定义成protected保护的；如果派生类和外部都不打算访问，那么</span></span><br><span class="line"><span class="comment">在基类中，就把相关成员定义成private私有的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">默认的继承方式是什么？</span></span><br><span class="line"><span class="comment">要看派生类是用class定义的，还是struct定义的？</span></span><br><span class="line"><span class="comment">class定义派生类，默认继承方式就是private私有的</span></span><br><span class="line"><span class="comment">struct定义派生类，默认继承方式就是public私有的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mc; <span class="comment">// 自己或者友元能访问私有的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承 A 基类/父类   B 派生类/子类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; ma &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> md;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> me;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mf;</span><br><span class="line">	<span class="comment">// int ma;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 在C里面，请问ma的访问限定是什么？ 不可见的，但是能继承来</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; b.mb &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>重载关系<ul>
<li>一组函数要重载，必须处在同一个作用域当中；而且函数名字相同，参数列表不同</li>
</ul>
</li>
<li>隐藏(作用域的隐藏)的关系<ul>
<li>在继承结构当中，派生类的同名成员，把基类的同名成员给隐藏调用了（无论参数列表、返回值是否相同，只要名字相同，都会隐藏）</li>
</ul>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><ul>
<li><p><strong>覆盖</strong>：基类和派生类的方法，返回值、函数名以及参数列表都相同，而且基类的方法是虚函数，那么派生类的方法就自动处理成虚函数，它们之间成为覆盖关系。</p>
</li>
<li><p><strong>一个类添加了虚函数，对这个类有什么影响？</strong></p>
<ul>
<li>总结一：一个类里面定义了虚函数，那么编译阶段，编译器给这个类类型产生一个唯一的vftable虚函数表，虚函数表中主要存储的内容就是RTTI指针和虚函数的地址。当程序运行时，每一张虚函数表都会加载到内存的.<strong>rodata区</strong>。</li>
<li>总结二：一个类里面定义了函数数，那么这个类定义的对象，其运行时，内存中开始部分，多存储一个vfptr虚函数指针，指向相应类型的虚函数表vftable。一个类型定义的n个对象，它们的额vfptr指向的都是同一张虚函数表</li>
<li>总结三：一个类里面虚函数的个数，不影响对象内存大小（vfptr），影响的是虚函数表的大小</li>
<li>总结四：如果派生类中的方法，和基类继承来的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是virtual虚函数，那么派生类的这个方法，自动处理成虚函数。重写《=》覆盖</li>
</ul>
</li>
<li><p><code>vfptr：virtual function pointer</code></p>
</li>
<li><p><code>vftable：virtual function table</code> </p>
</li>
<li><p><code>RTTI：Run-Time Type Information</code></p>
</li>
<li><p>虚函数表：</p>
<ul>
<li><code>virtual function table.</code></li>
<li>运行时加载到<code>.rodata段</code></li>
</ul>
</li>
<li><p><strong>静态绑定</strong>： <code>call  Base::show(0163BD)</code>    call具体函数地址</p>
</li>
<li><p><strong>动态绑定</strong>：<code>call 寄存器</code>。寄存器存放什么地址运行时才知道。因此叫动态绑定</p>
</li>
<li><p><code>call</code>到<code>.text</code>段</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr[pb]	 把pb指向的虚函数地址交给eax寄存器</span><br><span class="line">mov ecx, dword ptr[eax]</span><br><span class="line">call ecx（虚函数的地址） 跳转到ecx指向的虚函数地址</span><br><span class="line">动态（运行时期）的绑定（函数的调用）</span><br></pre></td></tr></table></figure></li>
<li><p>虚函数个数不会影响类的大小。无论多少虚函数(&gt;=1)，类只多一个虚函数表指针<code>virtual function table</code></p>
</li>
<li><p><code>Base size Base = int(4) + vfptr(4) = 8</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class _s__RTTIBaseClassDescriptor       <span class="title">size</span><span class="params">(<span class="number">28</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | pTypeDescriptor</span></span><br><span class="line"><span class="function"> <span class="number">4</span>      | numContainedBases</span></span><br><span class="line"><span class="function"> <span class="number">8</span>      | _PMD where</span></span><br><span class="line"><span class="function"><span class="number">20</span>      | attributes</span></span><br><span class="line"><span class="function"><span class="number">24</span>      | pClassDescriptor</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class _s__RTTIBaseClassArray    size(<span class="number">1</span>):</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | arrayOfBaseClassDescriptors</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">class Base      size(<span class="number">8</span>):</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | &#123;</span>vfptr&#125;</span><br><span class="line"> <span class="number">4</span>      | ma</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">Base::$vftable@:</span><br><span class="line">        | &amp;Base_meta</span><br><span class="line">        |  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>      | &amp;Base::show</span><br><span class="line"> <span class="number">1</span>      | &amp;Base::show</span><br></pre></td></tr></table></figure></li>
<li><p><code>Derive = int(4) + int(4) + vfptr(4)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">class Derive    <span class="title">size</span><span class="params">(<span class="number">12</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | +--- (base class Base)</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | | &#123;</span>vfptr&#125;</span><br><span class="line"> <span class="number">4</span>      | | ma</span><br><span class="line">        | +---</span><br><span class="line"> <span class="number">8</span>      | mb</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">Derive::$vftable@:</span><br><span class="line">        | &amp;Derive_meta</span><br><span class="line">        |  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>      | &amp;Derive::show</span><br><span class="line"> <span class="number">1</span>      | &amp;Base::show</span><br></pre></td></tr></table></figure></li>
<li><p>动态绑定指令</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="keyword">int</span> data = <span class="number">10</span>) :<span class="built_in">ma</span>(data) &#123;&#125;</span><br><span class="line">	<span class="comment">// 虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::show(int)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="comment">// 虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::show()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derive</span>(<span class="keyword">int</span> data = <span class="number">20</span>) :<span class="built_in">Base</span>(data), <span class="built_in">mb</span>(data) &#123;&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::show()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Derive <span class="title">d</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line">	Base* pb = &amp;d;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	pb-&gt;Base Base::show 如果发现show是普通函数，就进行静态绑定：call Base::show</span></span><br><span class="line"><span class="comment">	pb-&gt;Base Base::show 如果发现show是虚函数，就进行动态绑定了</span></span><br><span class="line"><span class="comment">	mov eax, dword ptr[pb]	 把pb指向的虚函数地址交给eax寄存器</span></span><br><span class="line"><span class="comment">	mov ecx, dword ptr[eax]</span></span><br><span class="line"><span class="comment">	call ecx（虚函数的地址） 跳转到ecx指向的虚函数地址</span></span><br><span class="line"><span class="comment">	动态（运行时期）的绑定（函数的调用）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	pb-&gt;<span class="built_in">show</span>(); <span class="comment">//静态（编译时期）的绑定（函数的调用）call  Base::show (01612DAh)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Base::show(int) 是一个虚函数，此时就得动态绑定了</span></span><br><span class="line"><span class="comment">	mov eax, dword ptr[pb]</span></span><br><span class="line"><span class="comment">	mov ecx, dword ptr[eax+8]</span></span><br><span class="line"><span class="comment">	call ecx（虚函数的地址） 动态（运行时期）的绑定（函数的调用）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	pb-&gt;<span class="built_in">show</span>(<span class="number">10</span>); <span class="comment">//静态绑定 call  Base::show (01612B2h)</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Base) &lt;&lt; endl; <span class="comment">// 4+4 = 8</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Derive) &lt;&lt; endl; <span class="comment">// 8+4 = 12</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	pb的类型：Base -&gt; 有没有虚函数</span></span><br><span class="line"><span class="comment">	如果Base没有虚函数，*pb识别的就是编译时期的类型  *pb &lt;=&gt; Base类型</span></span><br><span class="line"><span class="comment">	如果Base有虚函数，*pb识别的就是运行时期的类型 RTTI类型</span></span><br><span class="line"><span class="comment">	pb-&gt;d(vfptr)-&gt;Derive vftable  class Derive</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(pb).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// class Base*</span></span><br><span class="line">	cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(*pb).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// class Base  class Derive </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="问题一：哪些函数不能实现成虚函数？"><a href="#问题一：哪些函数不能实现成虚函数？" class="headerlink" title="问题一：哪些函数不能实现成虚函数？"></a>问题一：哪些函数不能实现成虚函数？</h3><ul>
<li><p><strong>虚函数依赖</strong>：</p>
<ul>
<li>1.虚函数能产生地址，存储在vftable当中</li>
<li>2.对象必须存在。<ul>
<li>因为寻找虚函数地址时要通过对象中的：<code>vfptr -&gt; vftable -&gt; 虚函数地址</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>构造函数</strong></p>
<ul>
<li>1.virtual+构造函数 NO！ </li>
<li>2.构造函数中（调用的任何函数，都是静态绑定的）调用虚函数，也不会发生静态绑定</li>
<li>因为对象还没构造完，而虚函数需要有赖于虚函数表指针。</li>
<li>派生类对象构造过程  1.先调用的是基类的构造函数 2.才调用派生类的构造函数。如果基类调用虚函数的话，那么可能是想匹配子类重写的函数。但是子类还没构造，也就没有vptr。</li>
</ul>
</li>
<li><p><strong>static静态成员方法</strong> NO！ virtual + static</p>
<ul>
<li>因为虚函数要依赖于对象。而static成员不属于对象</li>
</ul>
</li>
</ul>
<h3 id="问题二：基类的析构函数必须实现成虚函数"><a href="#问题二：基类的析构函数必须实现成虚函数" class="headerlink" title="问题二：基类的析构函数必须实现成虚函数"></a>问题二：基类的析构函数必须实现成虚函数</h3><ul>
<li>虚析构函数、析构函数调用的时候，对象必须是存在的。</li>
<li>基类的指针（引用）指向堆上new出来的派生类对象的时候， delete pb(基类的指针)，它调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。</li>
</ul>
<h3 id="虚函数不一定是动态绑定"><a href="#虚函数不一定是动态绑定" class="headerlink" title="虚函数不一定是动态绑定"></a>虚函数不一定是动态绑定</h3><ul>
<li>是不是虚函数的调用一定就是动态绑定？ 肯定不是的！</li>
<li>在类的构造函数当中，调用虚函数，也是静态绑定（构造函数中调用其它函数（虚），不会发生动态绑定的）</li>
<li>如果不是通过指针或者引用变量来调用虚函数，那就是静态绑定</li>
</ul>
<h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><ul>
<li>抽象类：有虚函数类</li>
<li>基类：被继承的类</li>
<li>基类一般定义成抽象类</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="如何解释多态？"><a href="#如何解释多态？" class="headerlink" title="如何解释多态？"></a>如何解释多态？</h3><ul>
<li>静态（编译时期）的多态： 函数重载、模板（函数模板和类模板）<ul>
<li>函数重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>&#123;&#125; </span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10</span>, <span class="number">20</span>); call compare_int_int 在编译阶段就确定好调用的函数版本</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10.5</span>, <span class="number">20.5</span>); call compare_douoble_double 在编译阶段就确定好调用的函数版本</span><br></pre></td></tr></table></figure></li>
<li>模板<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>&#123;&#125;</span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>, <span class="number">20</span>);  =&gt; <span class="keyword">int</span> 实例化一个 compare&lt;<span class="keyword">int</span>&gt;</span><br><span class="line"><span class="built_in">compare</span>(<span class="number">10.5</span>, <span class="number">20.5</span>); =&gt; <span class="keyword">double</span> 实例化一个 compare&lt;<span class="keyword">double</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>动态（运行时期）的多态：Base Derive</li>
<li>在继承结构中，基类指针（引用）指向派生类对象，通过该指针（引用）调用同名覆盖方法（虚函数），基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名覆盖方法，称为多态</li>
<li><code>pbase-&gt;bark();</code>多态底层是通过动态绑定来实现的。<ul>
<li>pbase-》访问谁的vfptr=》继续访问谁的vftable=》当然调用的是对应的派生类对象的方法了</li>
</ul>
</li>
</ul>
<h3 id="继承的好处是什么？"><a href="#继承的好处是什么？" class="headerlink" title="继承的好处是什么？"></a>继承的好处是什么？</h3><ul>
<li>可以做代码的复用</li>
<li>在基类中给所有派生类提供统一的虚函数接口，让派生类进行重写，然后就可以使用多态了</li>
</ul>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><h3 id="交换类对象的虚函数指针"><a href="#交换类对象的虚函数指针" class="headerlink" title="交换类对象的虚函数指针"></a>交换类对象的虚函数指针</h3><ul>
<li>交换虚函数指针指向，因此通过虚指针vfptr找到的虚函数表vftable所对应的虚函数地址交换了，调用的函数也就不同。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animal</span>(string name) :_name(name) &#123;&#125;</span><br><span class="line">	<span class="comment">// 纯虚函数</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是动物实体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Cat</span>(string name) :<span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; bark: miao miao!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Dog</span>(string name) :<span class="built_in">Animal</span>(name) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; bark: wang wang!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Animal* p1 = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;加菲猫&quot;</span>); <span class="comment">// vfptr -&gt; Dog vftable</span></span><br><span class="line">	Animal* p2 = <span class="keyword">new</span> <span class="built_in">Dog</span>(<span class="string">&quot;二哈&quot;</span>); <span class="comment">// vfptr -&gt; Cat vftable</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>* p11 = (<span class="keyword">int</span>*)p1;</span><br><span class="line">	<span class="keyword">int</span>* p22 = (<span class="keyword">int</span>*)p2;</span><br><span class="line">	<span class="keyword">int</span> tmp = p11[<span class="number">0</span>]; <span class="comment">// p11[0]访问的就是Cat的前4个字节</span></span><br><span class="line">	p11[<span class="number">0</span>] = p22[<span class="number">0</span>]; <span class="comment">// p22[0]访问的就是Dog的前4个字节</span></span><br><span class="line">	p22[<span class="number">0</span>] = tmp;</span><br><span class="line"></span><br><span class="line">	p1-&gt;<span class="built_in">bark</span>(); <span class="comment">// p1 -&gt; Cat vfptr -&gt; Dog vftable bark</span></span><br><span class="line">	p2-&gt;<span class="built_in">bark</span>(); <span class="comment">// p2 -&gt; Dog vfptr -&gt; Cat vftable bark</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span> p1;</span><br><span class="line">	<span class="keyword">delete</span> p2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">加菲猫 bark: wang wang!</span><br><span class="line">二哈 bark: miao miao!</span><br></pre></td></tr></table></figure>
<h3 id="基类函数默认实参"><a href="#基类函数默认实参" class="headerlink" title="基类函数默认实参"></a>基类函数默认实参</h3></li>
<li>派生类虚函数的默认实参最好和基函数相同。因为虚函数的默认实参调用不到。<ul>
<li>函数需要的参数压栈，这是在编译期做的，从汇编可以看到，当参数压栈之后，才会去找要动态绑定那个函数。因此，参数只看静态类型，是哪个静态类型就用哪个静态类型的函数的默认实参，也就是会把相应静态类型的默认实参压栈。</li>
</ul>
</li>
<li>参数压栈 + call虚函数过程<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push <span class="number">0</span>Ah =&gt; 函数调用，参数压栈是在编译时期就确定好的</span><br><span class="line">mov eax, dword ptr[p]		<span class="comment">//  通过虚函数表vfptr找到vftable</span></span><br><span class="line">mov ecx, dword ptr[eax]</span><br><span class="line">call ecx				<span class="comment">//  调用函数表中相应位置的函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Base::show i:&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> i = <span class="number">20</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive::show i:&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base* p = <span class="keyword">new</span> <span class="built_in">Derive</span>(); <span class="comment">// 虚析构函数</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	push 0Ah =&gt; 函数调用，参数压栈是在编译时期就确定好的</span></span><br><span class="line"><span class="comment">	mov eax, dword ptr[p]</span></span><br><span class="line"><span class="comment">	mov ecx, dword ptr[eax]</span></span><br><span class="line"><span class="comment">	call ecx</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	p-&gt;<span class="built_in">show</span>(); <span class="comment">// 动态绑定 p-&gt; Derive vfptr -&gt; Derive vftable</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call Derive::show i:<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="访问限定符-编译时"><a href="#访问限定符-编译时" class="headerlink" title="访问限定符(编译时)"></a>访问限定符(编译时)</h3><ul>
<li>访问限定符public private 是在编译阶段起作用的，是语法层面的。不是在运行时期起作用。运行时期所有内存都能随意访问。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Base::show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive::show&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derive* p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	成员方法能不能调用，就是说方法的访问权限是不是public的，是在编译阶段就需要确定</span></span><br><span class="line"><span class="comment">	好的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	编译阶段 Base::show</span></span><br><span class="line"><span class="comment">	call Base::show   call ecx</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//“Base::show”: 无法访问 private 成员(在“Base”类中声明)</span></span><br><span class="line">	p-&gt;<span class="built_in">show</span>(); <span class="comment">// 最终能调用到Derive::show，是在运行时期才确定的</span></span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="vfptr什么时候赋值"><a href="#vfptr什么时候赋值" class="headerlink" title="vfptr什么时候赋值"></a>vfptr什么时候赋值</h3><ul>
<li><p>注意虚函数表什么时候都赋值给虚函数指针    </p>
<ul>
<li>在本构造函数压完栈，并且调用完了基类构造函数后。</li>
</ul>
</li>
<li><p>因此父类中的clear不会影响子类的vptr，只会把父类的vptr置为null。子类的vptr还没进行赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  压栈</span></span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line">sub esp, <span class="number">4</span>Ch</span><br><span class="line"><span class="comment">//  调用父类构造</span></span><br><span class="line"><span class="function">call &amp;<span class="title">Base::Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//  父类构造结束后，进入本函数体。</span></span></span><br><span class="line"><span class="function"><span class="comment">//  首先给虚函数表指针vfptr赋值</span></span></span><br><span class="line"><span class="function">vfptr &lt;- &amp;Base::vftable</span></span><br></pre></td></tr></table></figure></li>
<li><p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		push ebp</span></span><br><span class="line"><span class="comment">		mov ebp, esp</span></span><br><span class="line"><span class="comment">		sub esp, 4Ch</span></span><br><span class="line"><span class="comment">		rep stos esp&lt;-&gt;ebp 0xCCCCCCCC(windows VS GCC/G++)</span></span><br><span class="line"><span class="comment">		vfptr &lt;- &amp;Base::vftable</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Base()&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(<span class="keyword">this</span>, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Base::show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Derive</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		push ebp</span></span><br><span class="line"><span class="comment">		mov ebp, esp</span></span><br><span class="line"><span class="comment">		sub esp, 4Ch</span></span><br><span class="line"><span class="comment">		call Base</span></span><br><span class="line"><span class="comment">		rep stos esp&lt;-&gt;ebp 0xCCCCCCCC(windows VS GCC/G++)</span></span><br><span class="line"><span class="comment">		vfptr &lt;- &amp;Derive::vftable</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive::show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	mov eax, dword ptr[pb1]</span></span><br><span class="line"><span class="comment">	mov ecx, dword ptr[eax] eax:0x00000000 不是Base::vftable</span></span><br><span class="line"><span class="comment">	call ecx</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//  error</span></span><br><span class="line">	<span class="comment">//Base *pb1 = new Base();</span></span><br><span class="line">	<span class="comment">//pb1-&gt;show(); // 动态绑定</span></span><br><span class="line">	<span class="comment">//delete pb1;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	vfptr里面存储的是vftable的地址</span></span><br><span class="line"><span class="comment">	vfptr &lt;- vftable</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//  ok</span></span><br><span class="line">	Base* pb2 = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">	<span class="comment">// 动态绑定 call Derive::show()</span></span><br><span class="line">	pb2-&gt;<span class="built_in">show</span>();</span><br><span class="line">	<span class="keyword">delete</span> pb2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>汇编</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="built_in">Derive</span>()</span><br><span class="line"><span class="comment">//  压栈、开辟栈帧</span></span><br><span class="line"><span class="number">00007F</span>F66C201E85  push        rbp  </span><br><span class="line"><span class="number">00007F</span>F66C201E86  push        rdi  </span><br><span class="line"><span class="number">00007F</span>F66C201E87  sub         rsp,<span class="number">108</span>h  </span><br><span class="line"><span class="number">00007F</span>F66C201E8E  lea         rbp,[rsp+<span class="number">20</span>h]  </span><br><span class="line">...</span><br><span class="line"><span class="comment">//  调用父类函数</span></span><br><span class="line"><span class="number">00007F</span><span class="function">F66C201EA6  call        <span class="title">Base::Base</span> <span class="params">(<span class="number">07F</span>F66C20112Ch)</span>  </span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"><span class="comment">//  虚函数表的地址赋给虚函数指针 </span></span></span><br><span class="line"><span class="function">00007FF66C201EB2  lea         rcx,[Derive::`vftable&#x27; <span class="params">(<span class="number">07F</span>F66C20BC60h)</span>]  </span></span><br><span class="line"><span class="function">00007FF66C201EB9  mov         qword ptr [rax],rcx  </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//  退栈</span></span><br><span class="line"><span class="number">00007F</span>F66C201EC3  mov         rax,qword ptr [<span class="keyword">this</span>]  </span><br><span class="line"><span class="number">00007F</span>F66C201ECA  lea         rsp,[rbp+<span class="number">0E8</span>h]  </span><br><span class="line"><span class="number">00007F</span>F66C201ED1  pop         rdi  </span><br><span class="line"><span class="number">00007F</span>F66C201ED2  pop         rbp  </span><br><span class="line"><span class="number">00007F</span>F66C201ED3  ret  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h2><ul>
<li>抽象类：有抽象函数的类。抽象类不是虚基类！</li>
<li>virtual<ul>
<li>修饰成员方法：是虚函数</li>
<li>修饰继承方式：是虚继承</li>
</ul>
</li>
<li>虚基类：被虚继承的类</li>
<li>普通继承：内存布局中，基类数据放在派生类前面</li>
<li>虚继承：内存布局中，基类数据移到派生来末尾。在派生类前面加一个vbptr</li>
<li>vfptr -&gt; vftable<ul>
<li>vftable 记录虚函数地址</li>
</ul>
</li>
<li>vbptr -&gt; vbtable<ul>
<li>vbtable记录的是虚基类数据在派生类内存中的偏移量</li>
</ul>
</li>
<li>基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;call A::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="comment">//  ~A(); operator delete(A); </span></span><br><span class="line">	<span class="comment">//  重载基类的，因为是基类的指针指向对象。因此是delete 基类指针。</span></span><br><span class="line">	<span class="comment">//  operator delete被编译器自动看为静态的</span></span><br><span class="line">	<span class="comment">//  A类内重载了operator delete。delete A时就会调用A得operator delete</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pc)</span>	</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator delete A &quot;</span> &lt;&lt; pc &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">free</span>(pc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> <span class="keyword">virtual</span>  A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;call B::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="comment">// new B(); 则会调用B类中的operator new 而非基类A中的。所以重载B类的operator new</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;operator new &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="A-int-vfptr-8"><a href="#A-int-vfptr-8" class="headerlink" title="A int + vfptr = 8"></a>A int + vfptr = 8</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="function">class A <span class="title">size</span><span class="params">(<span class="number">8</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | &#123;</span>vfptr&#125;</span><br><span class="line"> <span class="number">4</span>      | ma</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">A::$vftable@:</span><br><span class="line">        | &amp;A_meta</span><br><span class="line">        |  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>      | &amp;A::func</span><br></pre></td></tr></table></figure>

<h3 id="B-int-int-4-4-16"><a href="#B-int-int-4-4-16" class="headerlink" title="B int + int + 4 + 4 = 16"></a>B int + int + 4 + 4 = 16</h3><p><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-20-41-42.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class B <span class="title">size</span><span class="params">(<span class="number">16</span>)</span>:</span></span><br><span class="line"><span class="function">        +---</span></span><br><span class="line"><span class="function"> <span class="number">0</span>      | &#123;</span>vbptr&#125;	<span class="keyword">virtual</span> base pointer</span><br><span class="line"> <span class="number">4</span>      | mb</span><br><span class="line">        +---</span><br><span class="line">        +--- (<span class="keyword">virtual</span> base A)</span><br><span class="line"> <span class="number">8</span>      | &#123;vfptr&#125;</span><br><span class="line"><span class="number">12</span>      | ma</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line"><span class="comment">//  vbtable</span></span><br><span class="line">B::$vbtable@:</span><br><span class="line"> <span class="number">0</span>      | <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>      | <span class="number">8</span> (<span class="built_in">Bd</span>(B+<span class="number">0</span>)A)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  vftable</span></span><br><span class="line">B::$vftable@:</span><br><span class="line">        | <span class="number">-8</span></span><br><span class="line"> <span class="number">0</span>      | &amp;B::func</span><br><span class="line"></span><br><span class="line">B::func <span class="keyword">this</span> adjustor: <span class="number">8</span></span><br><span class="line">vbi:       <span class="class"><span class="keyword">class</span>  <span class="title">offset</span> <span class="title">o</span>.<span class="title">vbptr</span>  <span class="title">o</span>.<span class="title">vbte</span> <span class="title">fVtorDisp</span></span></span><br><span class="line"><span class="class">               <span class="title">A</span>       8       0       4 0</span></span><br></pre></td></tr></table></figure>


<h3 id="delete虚基类指针"><a href="#delete虚基类指针" class="headerlink" title="delete虚基类指针"></a>delete虚基类指针</h3><ul>
<li>windows VS 报错</li>
<li>linux g++ ok</li>
<li>基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址</li>
</ul>
<ul>
<li>堆上的<br><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-20-35-23.png"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A* p = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	p-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> <span class="number">00000231E897</span>FEB0</span><br><span class="line">main p:<span class="number">00000231E897</span>FEC0</span><br><span class="line">call B::func</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span> A <span class="number">00000231E897</span>FEC0</span><br><span class="line">堆异常中断</span><br></pre></td></tr></table></figure>
<ul>
<li>栈上的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 基类指针指向派生类对象，永远指向的是派生类基类部分数据的起始地址</span></span><br><span class="line">	B b;</span><br><span class="line">	A* p = &amp;b;<span class="comment">//new B(); // B::vftable</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;main p:&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	p-&gt;<span class="built_in">func</span>();</span><br><span class="line">	<span class="comment">//delete p;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main p:<span class="number">0000009F</span>C932FBD8</span><br><span class="line">call B::func</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">sizeof</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">sizeof</span> B = <span class="number">1</span>;</span><br><span class="line">为什么不为<span class="number">0</span>？为了让实例化出来的类对象得地址唯一</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">sizeof</span> A = <span class="number">4</span>;	<span class="comment">//  vfptr</span></span><br><span class="line"><span class="keyword">sizeof</span> B = <span class="number">4</span>;	<span class="comment">//  vfptr</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">int</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">sizeof</span> B = <span class="number">4</span>(<span class="keyword">int</span>) + <span class="number">4</span>(vbptr) = <span class="number">8</span>;	<span class="comment">//  vbptr</span></span><br><span class="line"><span class="comment">//  没有虚函数当然就没有虚函数表，自然也就没虚函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">int</span> ; <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;</span><br><span class="line"><span class="keyword">sizeof</span> B = <span class="number">4</span>(<span class="keyword">int</span>) + <span class="number">4</span>(vfptr) + <span class="number">4</span>(vbptr) = <span class="number">12</span>;	<span class="comment">//  vbptr vfptr</span></span><br><span class="line"><span class="comment">//  没有虚函数当然就没有虚函数表，自然也就没虚函数指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-22-13-41.png"></p>
<ul>
<li>菱形继承<br><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-22-16-57.png"></li>
<li>解决方法：用<strong>virtual继承</strong>。将虚基类A的内容移动到了派生类的末尾。<ul>
<li>则D类需要负责处理虚基类A的构造<br><img src="/2022/04/04/c++_%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%A4%8D%E4%B9%A0/2022-04-06-22-17-41.png"></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++的多重继承 - 菱形继承的问题  派生类有多份间接基类的数据 设计的问题</span></span><br><span class="line"><span class="comment">好处，可以做更多代码的复用   D -&gt; B,C    B *p = new D()   C *p = new D()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="keyword">int</span> data) :<span class="built_in">ma</span>(data) &#123; cout &lt;&lt; <span class="string">&quot;A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;~A()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//=======================================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">B</span>(<span class="keyword">int</span> data) :<span class="built_in">A</span>(data), <span class="built_in">mb</span>(data) &#123; cout &lt;&lt; <span class="string">&quot;B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;~B()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">C</span>(<span class="keyword">int</span> data) :<span class="built_in">A</span>(data), <span class="built_in">mc</span>(data) &#123; cout &lt;&lt; <span class="string">&quot;C()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">C</span>() &#123; cout &lt;&lt; <span class="string">&quot;~C()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> mc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//=========================================</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//“A::A”: 没有合适的默认构造函数可用</span></span><br><span class="line">	<span class="built_in">D</span>(<span class="keyword">int</span> data) :<span class="built_in">A</span>(data), <span class="built_in">B</span>(data), <span class="built_in">C</span>(data), <span class="built_in">md</span>(data) &#123; cout &lt;&lt; <span class="string">&quot;D()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	~<span class="built_in">D</span>() &#123; cout &lt;&lt; <span class="string">&quot;~D()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="keyword">int</span> md;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">D <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line"><span class="built_in">B</span>()</span><br><span class="line"><span class="built_in">C</span>()</span><br><span class="line"><span class="built_in">D</span>()</span><br><span class="line">~<span class="built_in">D</span>()</span><br><span class="line">~<span class="built_in">C</span>()</span><br><span class="line">~<span class="built_in">B</span>()</span><br><span class="line">~<span class="built_in">A</span>()</span><br></pre></td></tr></table></figure>


<h2 id="四种类型转换"><a href="#四种类型转换" class="headerlink" title="四种类型转换"></a>四种类型转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++语言级别提供的四种类型转换方式</span></span><br><span class="line"><span class="comment">int a = (int)b;</span></span><br><span class="line"><span class="comment">const_cast : 去掉（指针或者引用）常量属性的一个类型转换</span></span><br><span class="line"><span class="comment">static_cast :  提供编译器认为安全的类型转换（没有任何联系的类型之间的转换就被否定了）</span></span><br><span class="line"><span class="comment">reinterpret_cast : 类似于C风格的强制类型转换</span></span><br><span class="line"><span class="comment">dynamic_cast : 主要用在继承结构中，可以支持RTTI类型识别的上下转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;call Derive1::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive2</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;call Derive2::func&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">	<span class="comment">// Derive2实现新功能的API接口函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">derive02func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">	</span>&#123; </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;call Derive2::derive02func&quot;</span> &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typeid(*p).name() == &quot;Derive&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showFunc</span><span class="params">(Base *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// dynamic_cast会检查p指针是否指向的是一个Derive2类型的对象？</span></span><br><span class="line">	<span class="comment">// p-&gt;vfptr-&gt;vftable RTTI信息 如果是，dynamic_cast转换类型成功，</span></span><br><span class="line">	<span class="comment">// 返回Derive2对象的地址，给pd2；否则返回nullptr</span></span><br><span class="line">	<span class="comment">// static_cast编译时期的类型转换  dynamic_cast运行时期的类型转换 支持RTTI信息识别</span></span><br><span class="line">	Derive2 *pd2 = <span class="keyword">dynamic_cast</span>&lt;Derive2*&gt;(p);</span><br><span class="line">	<span class="keyword">if</span> (pd2 != <span class="literal">nullptr</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pd2-&gt;<span class="built_in">derive02func</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p-&gt;<span class="built_in">func</span>(); <span class="comment">// 动态绑定  *p的类型 Derive2  derive02func</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Derive1 d1;</span><br><span class="line">	Derive2 d2;</span><br><span class="line">	<span class="built_in">showFunc</span>(&amp;d1);</span><br><span class="line">	<span class="built_in">showFunc</span>(&amp;d2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//static_cast 基类类型 《=》 派生类类型  能不能用static_cast?当然可以！会永远转型成功</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// re interpret 重新阐述</span></span><br><span class="line">	<span class="comment">//int *p = nullptr;</span></span><br><span class="line">	<span class="comment">//double* b = reinterpret_cast&lt;double*&gt;(p);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//const int a = 10;</span></span><br><span class="line">	<span class="comment">//int *p1 = (int*)&amp;a;</span></span><br><span class="line">	<span class="comment">//int *p2 = const_cast&lt;int*&gt;(&amp;a);</span></span><br><span class="line">	<span class="comment">// const_cast&lt;这里面必须是指针或者引用类型 int* int&amp;&gt;</span></span><br><span class="line">	<span class="comment">//int b = const_cast&lt;int&gt;(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/04/c++_new-delete/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/04/c++_new-delete/" class="post-title-link" itemprop="url">new_delete</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-04 08:58:07" itemprop="dateCreated datePublished" datetime="2022-04-04T08:58:07+08:00">2022-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:19:04" itemprop="dateModified" datetime="2022-05-28T22:19:04+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="new、malloc区别。free、delete区别"><a href="#new、malloc区别。free、delete区别" class="headerlink" title="new、malloc区别。free、delete区别"></a>new、malloc区别。free、delete区别</h2><ul>
<li>malloc free 称为C的库函数</li>
<li>new delete 称作运算符<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="built_in">malloc</span>();</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">==================================</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(...);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="malloc和new的区别？"><a href="#malloc和new的区别？" class="headerlink" title="malloc和new的区别？"></a>malloc和new的区别？</h3><ul>
<li><code>new</code>调用<code>operator new</code>，<code>operator new</code>调用<code>malloc</code></li>
<li>malloc按<strong>字节</strong>开辟内存的；new开辟内存时需要<strong>指定类型</strong> new int[10]；所以malloc开辟内存返回的都是void*  </li>
<li>malloc只负责开辟空间，new不仅仅有malloc的功能，可以进行数据的初始化<code>new int(20);   new int[20]();</code> </li>
<li>malloc开辟内存失败返回nullptr指针；new抛出的是bad_alloc类型的异常<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span>) cout &lt;&lt; <span class="string">&quot;wrong&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span>* pp = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> bad_alloc&amp; e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  int *pp = new int[20];  在堆上开辟后不会初始化</span></span><br><span class="line"><span class="keyword">int</span> *pp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>]();    <span class="comment">// 在堆上开辟后会初始化</span></span><br><span class="line"><span class="keyword">delete</span> []pp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h3><ul>
<li>先分配<code>memory</code>，再调用<code>ctor</code>（构造函数）</li>
<li><code>Complex* pc = new Complex(1,2);</code></li>
<li>编译器转化为<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="keyword">sizeof</span> Complex); <span class="comment">//分配内存 operator new 内部调用malloc(n)</span></span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);       <span class="comment">//强转</span></span><br><span class="line">pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);              <span class="comment">//构造 Complex::(pc,1,2); pc即为this</span></span><br></pre></td></tr></table></figure>
<h4 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h4></li>
<li>operator new仅仅负责开辟内存，在内存上写什么、任何与对象内容有关系的事情都与operator new无关<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">//  按Byte</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="有几种new"><a href="#有几种new" class="headerlink" title="有几种new"></a>有几种new</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="built_in"><span class="keyword">new</span></span> (nothrow) <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p3 = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//  定位new 在指定内存上构造对象</span></span><br><span class="line"><span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="built_in"><span class="keyword">new</span></span> (&amp;data) <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);</span><br><span class="line">cout&lt;&lt;data&lt;&lt;endl; <span class="comment">//  5</span></span><br></pre></td></tr></table></figure>


<h3 id="free和delete的区别？"><a href="#free和delete的区别？" class="headerlink" title="free和delete的区别？"></a>free和delete的区别？</h3><ul>
<li>delete调用operator delete，operator delete 调用free</li>
<li>delete (int*)p: 调用析构函数；再free(p)</li>
</ul>
<p>new和delete能混用吗？C++为什么区分单个元素和数组的内存分配和释放呢？<br>new delete<br>new[] delete[]<br>对于普通的编译器内置类型 new/delete[]   new[]/delete</p>
<p>自定义的类类型，有析构函数，为了调用正确的析构函数，那么开辟对象数组的时候，<br>会多开辟4个字节，记录对象的个数</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a><strong>delete</strong></h3><ul>
<li>先调用<code>dtor</code>，再释放内存<code>memory</code></li>
<li><code>Complex *pc = new Complex(1,2);</code><br><code>delete pc</code></li>
<li>编译器转化为<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex::~<span class="built_in">Complex</span>(pc);  <span class="comment">//dtor 调用析构函数是为了释放（基类、派生类）成员指针管理的内存，而不会释放本对象本身占据的内存。</span></span><br><span class="line"><span class="comment">//  如果本对象是栈上的，那么离开作用域后会自动调用析构函数 ，然后释放内存（也就是说析构函数何释放本对象内存是两回事）。很可惜，new出来的对象在堆上，得手动调用operator delete释放。（所以要保证pc指向得位置是对的（虚基类里就不对））</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;    <span class="comment">//释放memory 内部调用 free(pc)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="operator-delete"><a href="#operator-delete" class="headerlink" title="operator delete"></a>operator delete</h4><ul>
<li>operator delete仅仅负责释放内存，在内存上析构什么对象、任何与对象内容有关系的事情都与operator new无关。之前就已经做完了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="new-delete-new-delete"><a href="#new-delete-new-delete" class="headerlink" title="new[] delete[] ; new delete"></a>new[] delete[] ; new delete</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * new：</span></span><br><span class="line"><span class="comment"> * void *mem = operator new(size);</span></span><br><span class="line"><span class="comment"> * p = static_case&lt;&gt;(mem);</span></span><br><span class="line"><span class="comment"> * p-&gt;crot();;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * delete:</span></span><br><span class="line"><span class="comment"> * p-&gt;dtor;</span></span><br><span class="line"><span class="comment"> * operator delete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator new : &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete : &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator new[] &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;operator delete[] &quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>new[] delete[]正常使用</li>
<li>new[]<ul>
<li>除了开辟对象内存之外，还会在栈顶方向(p-8)开辟一块内存用于记录对象个数。</li>
<li>用于释放数组时，得知需要调用几个对象的析构函数</li>
<li>delete时会从那块内存(p-8)开始释放</li>
</ul>
</li>
<li>delete[]<ul>
<li>会从对象栈顶方向4/8bytes开始。也会把那块内存的数据当作要析构的对象个数<br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-28-22.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Test* p2 = <span class="keyword">new</span> Test[<span class="number">5</span>]; </span><br><span class="line"><span class="comment">//  除了开辟对象内存之外，还会在栈顶方向(p-8)开辟一块内存用于记录对象个数。</span></span><br><span class="line"><span class="comment">//  delete时也会连带释放那块内存(p-8)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2:&quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] p2; <span class="comment">// Test[0]对象析构， 直接free(p2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>[] <span class="number">0000021E55300</span>DF0</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">p2:<span class="number">0000021E55300</span>DF8</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[] <span class="number">0000021E55300</span>DF0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>new delete<br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-33-46.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Test* p1 = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 : &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> : <span class="number">000001</span>A1BF04D6B0</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">p1 : <span class="number">000001</span>A1BF04D6B0</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span> : <span class="number">000001</span>A1BF04D6B0</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>new delete[]混用后果<br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-21-28.png"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="keyword">int</span> data = <span class="number">10</span>) &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test* p1 = <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">delete</span>[]p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span> : <span class="number">000001</span>D8BC681C50</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">p1 : <span class="number">000001</span>D8BC681C50</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">~<span class="built_in">Test</span>() ...死循环</span><br></pre></td></tr></table></figure>
<ul>
<li>new[] delete<ul>
<li>只会调用一个对象的析构函数，并且用于记录对象个数的内存没有被释放<br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-35-26.png"><br><img src="/2022/04/04/c++_new-delete/2022-04-04-10-38-47.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Test* p2 = <span class="keyword">new</span> Test[<span class="number">5</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2:&quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> p2; <span class="comment">// Test[0]对象析构， 直接free(p2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>[] <span class="number">00000299</span>D1C59BA0</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line"><span class="built_in">Test</span>()</span><br><span class="line">p2:<span class="number">00000299</span>D1C59BA8</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span> : <span class="number">00000299</span>D1C59BA8</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><ul>
<li>简单来说：将对象所占的内存提前开辟出来，放到一个池子里面（链表维护），当需要构造对象的时候，就从池子里面取出内存来在那上面构造。<br><img src="/2022/04/04/c++_new-delete/2022-04-04-15-51-16.png"></li>
</ul>
<h4 id="链式队列-内置对象池"><a href="#链式队列-内置对象池" class="headerlink" title="链式队列 + 内置对象池"></a>链式队列 + 内置对象池</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  对象池 链式队列</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _front = _rear = <span class="keyword">new</span> <span class="built_in">QueueItem</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Queue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        QueueItem *cur = _front , *ne=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ne = cur-&gt;_next;</span><br><span class="line">            <span class="keyword">delete</span> cur; <span class="comment">//  delete 时 会调用QueueItem类内重载的operator delete。while会将这些节点全部加入内存池。不过没释放。</span></span><br><span class="line">            cur = ne;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _rear-&gt;_next = <span class="keyword">new</span> <span class="built_in">QueueItem</span>(val);   <span class="comment">//  产生节点</span></span><br><span class="line">        _rear = _rear-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">empty</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        QueueItem *first = _front-&gt;_next;</span><br><span class="line">        _front-&gt;_next = first-&gt;_next;</span><br><span class="line">        <span class="keyword">delete</span> first;</span><br><span class="line">        <span class="keyword">if</span>(_front-&gt;_next==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _rear = _front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">front</span><span class="params">()</span>   </span>&#123;<span class="keyword">return</span> _front-&gt;_next-&gt;_data;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _front==_rear;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * new :    operator new ; 强转 ; 构造函数 ; 返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//  给QueueItem提供内存管理 operator new ; operator delete</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueItem</span>    //  内置节点类型</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">QueueItem</span>(T data = <span class="built_in">T</span>() , QueueItem *next=<span class="literal">nullptr</span>)</span><br><span class="line">            :_data(data),_next(next)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  编译器会自动处理为static</span></span><br><span class="line">        <span class="comment">//  对象池为空时，再造一个对象池。（这个对象池的节点和前一个对象池的节点不是割裂的。之后会通过pop()(_next)连上的</span></span><br><span class="line">        <span class="comment">//  对象池不为空时，从对象池里取对象。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span>     <span class="comment">//   size没有用，只是为了构成重载</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_itemPool==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;!&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="comment">//  分配足够大内存 用作空闲池</span></span><br><span class="line">                _itemPool = (QueueItem*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(QueueItem)*POOL_ITEM_SIZE);</span><br><span class="line">                QueueItem *p = _itemPool;</span><br><span class="line">                <span class="comment">//  虽然还没构造这个QueueItem对象，不过QueueItem类型指针指向那里，就认为那里的内存存储的数据是QueueItem对象。p也就认为相应位置存在着一个相应成员</span></span><br><span class="line">                <span class="comment">//  operator new之后才调用ctor构造函数。构造函数的作用也就是给相应位置的内存存入相应数据。并没有开辟内存的作用</span></span><br><span class="line">                <span class="comment">//  p指向的内存已经被申请来，不用担心会被程序的其他指令要求占用</span></span><br><span class="line">                <span class="keyword">for</span>(;p&lt;_itemPool + POOL_ITEM_SIZE - <span class="number">1</span>;++p)</span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;_next = p+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p-&gt;_next = <span class="literal">nullptr</span>; <span class="comment">//  最后一个空闲节点的下一位置 为空 代表空闲池耗尽。走到nullptr就意味着我们要造新池子。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  现在要从这堆空闲内存取出一个 取出链表头部的</span></span><br><span class="line">            QueueItem *p = _itemPool;</span><br><span class="line">            _itemPool = _itemPool-&gt;_next;</span><br><span class="line">            <span class="keyword">return</span> p;   <span class="comment">//  接下来要通过p在p指向的内存上调用构造函数 （此时p的_next会被改变，不再指向下一个空闲节点，无所谓。本来就该这样。此时p应该在链式队列的链表上。而非对象池的链表上）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  管理已经无用的内存块 将其放入空闲内存链表中</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;ptr&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">//  头插法 加入对象池。而非释放这块内存。</span></span><br><span class="line">            QueueItem *p = <span class="keyword">static_cast</span>&lt;QueueItem*&gt;(ptr);</span><br><span class="line">            p-&gt;_next = _itemPool-&gt;_next;</span><br><span class="line">            _itemPool-&gt;_next = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T _data;</span><br><span class="line">        QueueItem *_next;</span><br><span class="line">        <span class="keyword">static</span> QueueItem *_itemPool;  <span class="comment">//  指向内存池的首个节点（即第一块空闲内存）</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> POOL_ITEM_SIZE = <span class="number">10000</span>;    <span class="comment">//  新标准 static常量可以类内初始化。</span></span><br><span class="line">    &#125;;</span><br><span class="line">    QueueItem *_front;  <span class="comment">//  头节点（无意义）</span></span><br><span class="line">    QueueItem *_rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;    <span class="comment">//  模板名 + 参数名 才是类型 所以是Queue&lt;T&gt;::</span></span><br><span class="line"><span class="keyword">typename</span> Queue&lt;T&gt;:: QueueItem*</span><br><span class="line">Queue&lt;T&gt;::QueueItem::_itemPool = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">rand</span>()%<span class="number">20</span>);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;q.<span class="built_in">empty</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  !</span></span><br><span class="line"><span class="comment">//  1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新标准：静态常量可以在类里面初始化，不用在外面初始化。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cstardust</p>
  <div class="site-description" itemprop="description">小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cstardust</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">554k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">8:24</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
