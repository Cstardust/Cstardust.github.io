<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不落辰</title>
  
  <subtitle>知不可乎骤得,托遗响于悲风</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-27T15:17:41.269Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Cstardust</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++_shared_ptr问题</title>
    <link href="http://example.com/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/"/>
    <id>http://example.com/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/</id>
    <published>2023-02-25T05:34:35.000Z</published>
    <updated>2023-02-27T15:17:41.269Z</updated>
    
    <content type="html"><![CDATA[<ul><li>shared_ptr的引用计数的++–是线程安全的吗？是的</li><li>shared_ptr的是线程安全吗 ? 不是的.<ul><li>shared_ptr由两部分组成 : raw ptr and control block</li></ul></li><li>资源释放时机 : use_count == 0 </li><li>shared_ptr&lt; void&gt;托管所有资源</li></ul><span id="more"></span><h2 id="计数的线程安全-Yes"><a href="#计数的线程安全-Yes" class="headerlink" title="计数的线程安全 Yes"></a>计数的线程安全 Yes</h2><ul><li>多个thread 使用shared_ptr时 , control block中引用计数的改变 是线程安全的.<ul><li>因为shared_ptr内部(control block的对于引用计数的改变采用<strong>原子指令</strong>.</li><li><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-15-30-54.png"></li><li>__exchange_and_add_dispatch : Adds the second argument’s value to the first argument. Returns the old value.<ul><li>下面用的应该就是汇编里的某些原子指令，如xchg. 见操作系统-并发02-blog</li></ul></li></ul></li></ul><h2 id="shared-ptr的线程安全-No"><a href="#shared-ptr的线程安全-No" class="headerlink" title="shared_ptr的线程安全 No"></a>shared_ptr的线程安全 No</h2><p>一言以蔽之：由于分为两步，且内部无mutex保护 ，故 不是线程安全的.</p><ul><li><p>首先 : <strong>shared_ptr</strong>由两部分组成</p><ul><li><strong>raw pointer</strong> (指向托管资源的裸指针) , 资源在<strong>堆</strong>上</li><li><strong>ref pointer</strong> 指向 在<strong>堆</strong>上的<strong>control block</strong> (引用计数等)<blockquote><p><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-15-36-39.png"></p></blockquote><ul><li>use_count : 指向该资源的shared_ptr数量</li><li>weak_count : 指向该资源的weak_ptr数量</li><li>ptr : 指向 资源 . Why ? -&gt; 用于delete. 后文介绍.</li><li>deleter , allocator : user传入,可选.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> :</span> <span class="keyword">public</span> __shared_ptr&lt;_Tp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">:</span> <span class="keyword">public</span> __shared_ptr_access&lt;_Tp, _Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    element_type*   _M_ptr;         <span class="comment">// Contained pointer.</span></span><br><span class="line">    __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">        _M_refcount指向的Control Block根据是否自定义Deleter分为两种.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>那么 易知 对于一个 shared_ptr的拷贝，由两步骤组成</p><ul><li><ol><li>复制 raw ptr</li></ol></li><li><ol start="2"><li>复制 ref ptr</li></ol></li><li>例如<ul><li>shared_ptr<Foo> x(new Foo);<ul><li><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-15-47-50.png"></li></ul></Foo></li><li>再执行 shared_ptr<Foo> y = x;<ul><li>结果如下<ul><li><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-15-49-59.png"></li></ul></li><li>步骤如下<ul><li><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-15-50-40.png"></li></ul></li></ul></Foo></li></ul></li></ul></li><li><p>由于分为两个步骤，且内部实现没有mutex保护，也即非原子，那么多个线程对指向统一资源的shared_ptr对象 , 同时进行读写操作，会出现data race. 不是线程安全的</p></li><li><p>例子如下 : 多thread无保护的读写shared_ptr g</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">g</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>; <span class="comment">// 线程之间共享的 shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; x; <span class="comment">// 线程 A 的局部变量</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;Foo&gt; <span class="title">n</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>; <span class="comment">// 线程 B 的局部变量</span></span><br></pre></td></tr></table></figure><p>  <img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-15-57-22.png"><br>  <img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-15-57-43.png"></p></li></ul><h2 id="释放-资源-amp-control-block"><a href="#释放-资源-amp-control-block" class="headerlink" title="释放 : 资源 &amp; control block"></a>释放 : 资源 &amp; control block</h2><ul><li><p>同理 , shared_ptr的析构分为两部分</p><ul><li><p>一个是释放(raw ptr)托管资源 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called when _M_use_count drops to zero, to release the resources</span></span><br><span class="line"><span class="comment">// managed by *this.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span></span><br><span class="line">_M_dispose() <span class="keyword">noexcept</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>一个是释放control block</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called when _M_weak_count drops to zero.</span></span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span></span><br><span class="line">_M_destroy() <span class="keyword">noexcept</span></span><br><span class="line">&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br></pre></td></tr></table></figure></li><li><p>这两部分<strong>都是由control block负责</strong>做的.</p></li><li><p>可以看到control block就是code中的class _Sp_counted_base(ContrlBlock的Base)</p><blockquote><p><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-16-10-10.png"></p></blockquote></li></ul></li><li><p><strong>关于释放时机</strong></p><ul><li><strong>释放资源 : use_count == 0</strong></li><li><strong>释放control block : use_count == 0 &amp;&amp; weak_count == 0</strong></li><li><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-16-11-51.png"></li></ul></li><li><p><strong>关于释放资源的方式</strong></p><ul><li>易知释放control block的操作，仅仅就是delete this即可</li><li>但对于资源来讲，user可以自定义function deleter. code中体现见下.<ul><li>user没有自定义deleter, 默认的deleter为delete this. 对应于class _Sp_counted_ptr. 继承自 Counted_base<ul><li><blockquote><p><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-16-19-17.png"><br><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-14-35-02.png"></p></blockquote></li></ul></li><li>user自定义deleter. 对应于class _Sp_counted_deleter. 继承自 Counted_base<ul><li><blockquote><p><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-16-21-33.png"><br><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-16-23-14.png"><br><img src="/2023/02/25/c++-shared_ptr%E7%96%91%E9%97%AE/2023-02-25-14-31-28.png"></p></blockquote></li></ul></li></ul></li></ul></li></ul><h2 id="shared-ptr-lt-void-gt"><a href="#shared-ptr-lt-void-gt" class="headerlink" title="shared_ptr&lt; void&gt;"></a>shared_ptr&lt; void&gt;</h2><ul><li><p>很有趣的一点，可以用<strong>shared_ptr&lt; void&gt;来托管任意类型的资源</strong></p><ul><li>这也是为什么 <strong>control block中 还需要有 指向资源的指针</strong></li></ul></li><li><p><strong>为什么能托管呢?</strong></p><ul><li>control block 中持有的是资源的真实类型(Y)的指针.(Y由shared_ptr自己推导)</li><li>raw pointer 是用户的传入的模板类型(T)的指针,当然也指向资源</li><li>Y和T可以不同，但Y要无error的转化成T</li><li>当释放资源时，是control block使用其资源真实类型的指针进行delete，和我们传入的模板参数T无关.</li><li>故此，即便即便传入的T与真实的Y不同，资源也能正确的释放.</li></ul></li><li><p>control block中 指向的资源的真实类型是由shared_ptr推导出来的,如何推导的呢? </p><ul><li>模板参数会根据我们传入的实参进行推导</li><li>具体见下</li></ul></li><li><p><strong>shared_ptr<void> p = new Test()</void></strong>;</p><ul><li><strong>_Tp : void</strong><ul><li><strong>p.get() return _Tp</strong>*</li></ul></li><li><strong>_Yp : Test</strong><ul><li><strong>deleter of 资源 call _Yp</strong>* <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  class shared_ptr</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span> :</span> <span class="keyword">public</span> __shared_ptr&lt;_Tp&gt;</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">//  _Tp 是我们人为传入的模板</span></span><br><span class="line">            <span class="comment">//  _Yp 是根据我们传入的__p进行类型推导</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Yp, <span class="keyword">typename</span> = _Constructible&lt;_Yp*&gt;&gt;</span><br><span class="line">        <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(_Yp* __p) : __shared_ptr&lt;_Tp&gt;(__p) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  class __shared_ptr</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, _Lock_policy _Lp&gt;</span><br><span class="line">    class __shared_ptr</span><br><span class="line">    : <span class="keyword">public</span> __shared_ptr_access&lt;_Tp, _Lp&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//  这个_Tp 是user传入的&lt;T&gt;的模板参数的T</span></span><br><span class="line">        <span class="keyword">using</span> element_type = <span class="keyword">typename</span> remove_extent&lt;_Tp&gt;::type;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//  _Yp* 根据shared_ptr传递过来的__p,推导出_Yp</span></span><br><span class="line">    <span class="comment">//  此时_Yp仍然是user传入的指针的真实的类型</span></span><br><span class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Yp, <span class="keyword">typename</span> = _SafeConv&lt;_Yp&gt;&gt;</span><br><span class="line">        <span class="keyword">explicit</span> __shared_ptr(_Yp* __p)</span><br><span class="line">        : _M_ptr(__p), _M_refcount(__p, <span class="keyword">typename</span> is_array&lt;_Tp&gt;::<span class="built_in">type</span>())</span><br><span class="line">        &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        element_type*   _M_ptr;           <span class="comment">// Contained pointer.</span></span><br><span class="line">        __shared_count&lt;_Lp&gt;  _M_refcount;    <span class="comment">// Reference counter.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;_Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_count</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//  _Ptr 根据shared_ptr传递过来的__p,推导出_Ptr</span></span><br><span class="line">    <span class="comment">//  这个_Ptr的类型就是user传入的指针的真实类型</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr&gt;             </span><br><span class="line">    <span class="keyword">explicit</span> __shared_count(_Ptr __p) : _M_pi(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    __try</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  将指针真实类型作为模板传入</span></span><br><span class="line">            _M_pi = <span class="keyword">new</span> _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);</span><br><span class="line">        &#125;</span><br><span class="line">    __catch(...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> __p;</span><br><span class="line">            __throw_exception_again;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  _Ptr : user传入的指针的原本类型</span></span><br><span class="line"><span class="comment">//  Control Block</span></span><br><span class="line"><span class="comment">//  到此，Control Block拿到了user传入的指针，并知道了其本身的类型.</span></span><br><span class="line"><span class="comment">//  然后 默认的deleter : _M_dispose 就是使用这个指向资源的且真实类型的指针 进行 delete</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ptr, _Lock_policy _Lp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Sp_counted_ptr</span> <span class="keyword">final</span> :</span> <span class="keyword">public</span> _Sp_counted_base&lt;_Lp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">explicit</span> _Sp_counted_ptr(_Ptr __p) <span class="keyword">noexcept</span></span><br><span class="line">        : _M_ptr(__p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">void</span> _M_dispose() <span class="keyword">noexcept</span>     <span class="comment">//  _M_ptr 指向的是smart pointer class 管理的资源</span></span><br><span class="line">        &#123; <span class="keyword">delete</span> _M_ptr; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> <span class="keyword">void</span> _M_destroy() <span class="keyword">noexcept</span>     <span class="comment">//  this 是指向的是smart pointer class的control block </span></span><br><span class="line">        &#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      _Ptr             _M_ptr;      <span class="comment">//  保留了user传入的指针的原本类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">同理，对于自定义deleter的ControlBlock,其同样使用的是具有真实类型的指针进行析构</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>muduo中也使用了shared_ptr&lt; void&gt;。 不过纯纯是炫技.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;shared_ptr的引用计数的++–是线程安全的吗？是的&lt;/li&gt;
&lt;li&gt;shared_ptr的是线程安全吗 ? 不是的.&lt;ul&gt;
&lt;li&gt;shared_ptr由两部分组成 : raw ptr and control block&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源释放时机 : use_count == 0 &lt;/li&gt;
&lt;li&gt;shared_ptr&amp;lt; void&amp;gt;托管所有资源&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统_semaphore实现</title>
    <link href="http://example.com/2023/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-semaphore%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/02/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-semaphore%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-02-22T14:22:37.000Z</published>
    <updated>2023-02-27T15:21:10.453Z</updated>
    
    <content type="html"><![CDATA[<p>如jyy所说，cond和mutex配合在一起就是万能方案.<br>我也就不咋喜欢用信号量semaphore.<br>但这是个考点啊。遂用cond和mutex实现一下.</p><span id="more"></span><ul><li>思路 : 所谓 semaphore 就是初始计数可以不为1的mutex_lock ; 那么 我们可以将初始计数作为cond的条件,使用万能方法,和cond配合使用即可</li><li>code</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如jyy所说，cond和mutex配合在一起就是万能方案.&lt;br&gt;我也就不咋喜欢用信号量semaphore.&lt;br&gt;但这是个考点啊。遂用cond和mutex实现一下.&lt;/p&gt;</summary>
    
    
    
    <category term="OS" scheme="http://example.com/categories/OS/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>c++_Any</title>
    <link href="http://example.com/2023/02/22/c++_Any/"/>
    <id>http://example.com/2023/02/22/c++_Any/</id>
    <published>2023-02-22T13:10:11.000Z</published>
    <updated>2023-02-27T15:17:44.912Z</updated>
    
    <content type="html"><![CDATA[<p>简易实现一个c++17的<a href="https://en.cppreference.com/w/cpp/utility/any">std::any</a></p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>背景 : user提交task给线程池中的thread去执行 , user可能会希望获取到task的执行结果. 但编写thread时并不知道应该返回给user什么类型.<ul><li>故先想到 直接用模板 template T. 如 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTask</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">各种各样的UserTask 继承自 BaseTask</span><br></pre></td></tr></table></figure></li><li>又由于virtual function不能使用template T.</li><li>故需要一种新的类型Any.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseTask</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Any <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">各种各样的UserTask 继承自 BaseTask</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="can’t-create-a-virtual-template-function"><a href="#can’t-create-a-virtual-template-function" class="headerlink" title="can’t create a virtual template function"></a>can’t create a virtual template function</h2><ul><li><p><a href="https://yeahexp.com/template-virtual-function/">参考</a></p></li><li><p>Member function templates cannot be declared virtual. This constraint is imposed because the usual implementation of the virtual function call mechanism uses a fixed-size table with one entry per virtual function. However, the number of instantiations of a member function template is not fixed until the entire program has been translated. Hence , supporting virtual member function templates would require support for a whole new kind of mechanism in C ++ compilers and linkers. In contrast, the ordinary members of class templates can be virtual because their number is fixed when a class is instantiated</p><ul><li>模板函数不能被声明成virtual的. 这个约束被提出是因为虚函数实现的机制 使用了一个装有虚函数指针的固定大小的虚函数表。 但是，模板函数的实例化个数在编译时是无法知道的。因此，如果要实现虚函数模板需要一种新的c++编译器和链接器的支持. </li></ul></li><li><p>自己话解释</p><ul><li>易知每个含有虚函数的类中都有一个虚函数表，该虚函数表存储着该类的所有的虚函数的地址。</li><li>易知对于函数模板，编译器会在其调用处为其实例化出代码.</li><li>此时若有一个类的virtual funcA 用到了 template T</li><li>编译器编译该文件时并不知道其他文件对该virtual funcA的调用情况,也就不知道在别的文件中还有没有实例化出代码实例 ,所以无法确定模板虚函数的实例化个数,因为或许在别的文件中还有需要指向的该虚函数实例化后的地址,分离式编译,我们顶天知道这个文件内的。</li></ul></li><li><p>故virtual function中，不能用到 template T</p></li></ul><h2 id="Any的简易实现"><a href="#Any的简易实现" class="headerlink" title="Any的简易实现"></a>Any的简易实现</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Any&#123;</span><br><span class="line">    <span class="number">1.</span> 需要有一个类来真正的存储任意类型的data , 故使用模板类Derived</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T data_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span> 易知对于不同的T,Derived&lt;T&gt;是不同的类型. 故Any需要一个类型来同意接受所有的Derived&lt;T&gt;. 故令Derived继承自父类Base. 用Base*引用各种Derived&lt;T&gt;</span><br><span class="line">    故有如下 </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Base</span>;</span> <span class="keyword">and</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">member</span> :</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Base&gt; base_;</span><br><span class="line">    </span><br><span class="line">    <span class="number">2.1</span> 然后在构造的时候用base_接收传入的data</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//  会根据data自动推导出T</span></span><br><span class="line">    Any(T data) : base_(<span class="built_in">std</span>::make_unique&lt;Derive&lt;T&gt;&gt;())&#123;&#125;</span><br><span class="line">    <span class="comment">//  该constructor使得Any接收任意类型data,并存入Derived对象 由base管理</span></span><br><span class="line"></span><br><span class="line">    <span class="number">3.</span> 需要有一种方法 cast 将Any中Derived&lt;T&gt;存储的data提取出来返回给user. 也即将Base指针指向的Derived对象的data提取出来. 故涉及到 base pointer到derive的pointer的强转</span><br><span class="line">    其中user需要自己确保传入的T确实是Derived中存储的数据类型</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">T <span class="title">cast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Derive&lt;T&gt; *pd = <span class="keyword">dynamic_cast</span>&lt;Derive&lt;T&gt;*&gt;(base_.get());</span><br><span class="line">        <span class="keyword">return</span> pd-&gt;data(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Any : 可以代表并接收任意类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Any</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Any</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Any</span>(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>; <span class="comment">//  因为unique_ptr</span></span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Any &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Any</span>(Any &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Any &amp;<span class="keyword">operator</span>=(Any &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  使得Any接收任意类型data,并存入Derived对象 由base管理.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">Any</span>(T data) : <span class="built_in">base_</span>(std::make_unique&lt;Derive&lt;T&gt;&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  user通过cast将Any对象里存储的data提取出来.</span></span><br><span class="line">        <span class="comment">//  user需要自己确定 其传入的T和Derive&lt;T&gt;是一致的</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function">T <span class="title">cast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//  从base_找到所指向的Derive. 从其中取出data_</span></span><br><span class="line">        <span class="comment">//  base pointer --&gt; derive pointer only when base指针确实指向derive</span></span><br><span class="line">        Derive&lt;T&gt; *pd = <span class="keyword">dynamic_cast</span>&lt;Derive&lt;T&gt;*&gt;(base_.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span>(pd == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;type is unmatch&quot;</span>!;</span><br><span class="line">        <span class="keyword">return</span> pd-&gt;<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Derive : 用于存储任意类型的data</span></span><br><span class="line">    <span class="comment">//  对于不同类型的data , 也即不同类型的T , Derive的类型是不同的.(因为Derive+T合在一起是一个完整的类型)</span></span><br><span class="line">    <span class="comment">//  因此Any里面需要有一个类型可以统一的接收这些Dervie&lt;T&gt;</span></span><br><span class="line">    <span class="comment">//  那么很显然 , 这个类型就应当是 Derive&lt;T&gt; 的父类指针. 于是我们令他继承一个父类Base</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derive</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Derive</span>(T data) : <span class="built_in">data_</span>(data)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T data_;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;Base&gt; base_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简易实现一个c++17的&lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/any&quot;&gt;std::any&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-CS144-Socket及Lab总结</title>
    <link href="http://example.com/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/"/>
    <id>http://example.com/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/</id>
    <published>2023-02-19T08:02:16.000Z</published>
    <updated>2023-02-27T15:23:39.708Z</updated>
    
    <content type="html"><![CDATA[<ul><li>CS144lab1-7 自顶向下 实现了HTTP(GET) , TCP , IP(util) ,ARP(NetworkInterface) , Ethernet(util)(NetworkInterface use) , 最后在用户态组成了一个可靠数据传输的socket<ul><li>FullStackSocket概述<ul><li>2 thread (main thread , tcp thread)</li><li>3 fd(user socket , 内置的_thread_data(与协议栈交互) , tap fd)</li><li>eventloop注册事件</li></ul></li></ul></li></ul><span id="more"></span><ul><li>看完FullStackSocket之后 重新体会到socket是站在用户层和传输层之间的这句话了</li><li>FullStackSocket通过一个socketpair 将user看到的Socket和实际与协议栈交互的Socket(_thread_data)分开. main thread 使用 _socket , tcp_thread使用_thread_data</li><li>user只需要站在user层拿着_socket就好 等待数据到来 , 交付数据即可。背后协议栈的处理以及网卡数据的读写以及_thread_data交付数据都不需要管,都由tcp_thread的eventloop负责监听和处理了。user甚至可以认为 他就是直接通过这个_socket去和外界交互的.</li></ul><h1 id="FullStackSocket"><a href="#FullStackSocket" class="headerlink" title="FullStackSocket"></a>FullStackSocket</h1><ul><li>镇楼<br><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-33-37.png"><br>outbound buffer和inbound buffer就是俩bytestream</li></ul><h2 id="3Fd"><a href="#3Fd" class="headerlink" title="3Fd"></a>3Fd</h2><ul><li>FullStackSocket中总共有<strong>3</strong>个Fd<ul><li><strong>_socket fd</strong> : user see . (main thread)<ul><li>user认为就是这个fd和internet交互，实际上是在和_thread_data进行交互 , 最终和internet交互的是网卡TAP fd</li></ul></li><li><strong>_thread_data fd</strong> : 和_socket交互 (TCP thread)</li><li><strong>TAP fd</strong> : 和外界交互,接收发送frame (TCP thread)</li></ul></li></ul><h3 id="pipe-socketpair"><a href="#pipe-socketpair" class="headerlink" title="pipe(socketpair)"></a>pipe(socketpair)</h3><ul><li><p><strong>_socket和_thread_data是socketpair. 通过pipe通信</strong></p><ul><li>tcp_thread对_thread_data进行操作 </li><li>main thread 对_socket进行操作. </li><li>避免了对同一socket复杂的线程通信操作.</li><li>感觉这就是所谓的”通过通信共享内存，而不是通过共享内存通信.”; </li><li>通过pipe , tcp_thread和main_thread“共享”(通信）了user要发送和下层读取到的data</li></ul></li><li><p><strong>main thread对_socket的操作</strong></p><ul><li>main thread对_socket进行write , 将data送入pipe之后即可返回</li><li>main thread对_socket进行read(block) , 从pipe中读到数据后即可返回</li></ul></li><li><p><strong>tcp thread对_thread_data的操作</strong></p><ul><li>TCP thread负责监听_thread_data读事件，并读出_thread_data数据并送入TCP/IP协议栈处理</li><li>TCP thread负责监听_thread_data写事件，并将data从_thread_data写入,送给pipe的另一端_socket</li></ul></li></ul><h3 id="TAP-Fd"><a href="#TAP-Fd" class="headerlink" title="TAP Fd"></a>TAP Fd</h3><ul><li>除此之外，<strong>tcp thread还需要对TAP Fd进行操作</strong><ul><li>监听TAP Fd写事件,并处理</li><li>监听TAP Fd读事件,并处理</li></ul></li><li>TAP device接收上层构造好的链路层帧(link-layer frames)并直接发送出去</li></ul><h2 id="2-thread"><a href="#2-thread" class="headerlink" title="2 thread"></a>2 thread</h2><ul><li>FullStackSocket中总共有2个thread<ul><li><strong>main thread</strong> (user)<ul><li>main thread对_socket进行write , 将data送入pipe之后即可返回</li><li>main thread对_socket进行read(block) , 从pipe中读到数据后即可返回</li></ul></li><li><strong>TCP thread</strong><ul><li><strong>一言以蔽之</strong>：<ul><li>负责 和上层main thread的_socket交互.</li><li>TCP/IP协议栈处理数据  </li><li>以及读写网卡  </li></ul></li><li>有个很重要的组件 : <strong>eventloop</strong>. 下文介绍.</li></ul></li></ul></li></ul><h3 id="eventloop-tcp-thread"><a href="#eventloop-tcp-thread" class="headerlink" title="eventloop (tcp thread)"></a>eventloop (tcp thread)</h3><p><strong>eventloop</strong></p><ul><li><p>好像到处都有eventloop哈，libsponge有，muduo有，redis有。是个reactor就有。</p></li><li><p>大概来说如下</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">    poll();</span><br><span class="line">    handleEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不过只能说类似,因为我们没有listenfd.只有connfd<blockquote><p><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-07-47.png"></p></blockquote></li></ul></li><li><p>eventloop监听事件如下</p><ul><li><strong>EventA</strong> : adapter的读事件. 即TAP Fd 接收到frame<ul><li>Handler : network interface 读取frame并交付给上层协议栈</li><li>注册条件 : 只有local tcp存活时 才监听并处理该事件</li></ul></li><li><strong>EventB</strong> : _thread_data的读事件. 即_thread_data接收到了_socket写入pipe的数据<ul><li>Handler : tcp sender 读取_thread_data的数据并发送</li><li>注册条件 : 在local tcp存活 &amp;&amp; 写不关闭 &amp;&amp; local tcp outbound_buffer仍有空闲空间时 可监听并处理此事件</li></ul></li><li><strong>EventC</strong> : _thread_data的写事件.<ul><li>Handler : _thread_data从inbound buffer中读出数据，写入pipe</li><li>注册条件 : tcp inbound buffer有数据可读出写入_thread_data</li></ul></li><li><strong>EventD</strong> : TAP Fd可写. <ul><li>Handler : datagram adapter读取TCPsender发送的segment。层层封装成frame 写给TAP Fd</li><li>注册条件 : tcp outbound buffer有数据可读出送入协议栈</li></ul></li></ul></li></ul><h4 id="关于写事件的注册"><a href="#关于写事件的注册" class="headerlink" title="关于写事件的注册"></a>关于写事件的注册</h4><ul><li><p>背景: 如何正确的在epoll/poll LT模式下正确的执行写操作.</p><ul><li>易知poll为水平触发 , 在LT模式下如果注册了某fd的写事件到epoll上，那么只要fd背后的pipe亦或者kernel buffer没被填满，就会触发该事件,基本上一定会陷入死循环（busy wait)(loop刚刚回到poll就再次触发事件)。</li></ul></li><li><p>如何正确执行写操作 -&gt; 如何正确的在poll上注册写事件,使得写事件可以在有数据写的时候发生,没有的时候就不发生？而不会频繁的触发写事件陷入busy wait ?</p><ul><li>解决方案很简单如下：<ul><li><strong>设置一个 注册写事件的先决条件</strong>(code中的interest).</li><li>如先决条件为有数据可写,那么如下 </li><li>也即 只有在<strong>有数据时才注册写事件</strong>到poll</li><li>并且 在<strong>不满足该条件时，就立刻将该写事件从poll上拿下来</strong>.</li></ul></li><li>如<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Event C interest</span><br><span class="line">    <span class="comment">//  interest : 如果tcp的outbound buffer有数据要可发 才注册 ; 不符合该条件时立刻移除</span></span><br><span class="line">    [&amp;] &#123; <span class="keyword">return</span> <span class="keyword">not</span> _tcp-&gt;segments_out().empty(); &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Event D interest</span><br><span class="line">    [&amp;] &#123;</span><br><span class="line">    <span class="comment">//  tcp的inbound buffer不空(有数据可交付给上层app) || tcp的inbound buffer读到eof亦或者出错error (那就可以返回给上层eof或是error) </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">not</span> _tcp-&gt;inbound_stream().buffer_empty()) <span class="keyword">or</span></span><br><span class="line">            ((_tcp-&gt;inbound_stream().eof() <span class="keyword">or</span> _tcp-&gt;inbound_stream().error()) <span class="keyword">and</span> <span class="keyword">not</span> _inbound_shutdown);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="之前的一些问题"><a href="#之前的一些问题" class="headerlink" title="之前的一些问题"></a>之前的一些问题</h2><ul><li><p>使用</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  des addr :  ip and port</span></span><br><span class="line"><span class="function">Address <span class="title">addr</span><span class="params">(host,<span class="string">&quot;http&quot;</span>)</span></span>;    <span class="comment">//  getaddrinfo : host -&gt; ip ; http -&gt; port </span></span><br><span class="line"><span class="comment">//  connect</span></span><br><span class="line">FullStackSocket tcp_socket;</span><br><span class="line">tcp_socket.connect(addr);   </span><br><span class="line"><span class="comment">//  send req</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\n&quot;</span> + <span class="string">&quot;Host: &quot;</span> + host + <span class="string">&quot;\r\n&quot;</span> + <span class="string">&quot;Connection: close\r\n&quot;</span> + <span class="string">&quot;\r\n&quot;</span>)</span></span>;</span><br><span class="line">tcp_socket.write(request);</span><br><span class="line"><span class="keyword">while</span>(!tcp_socket.eof())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;tcp_socket.read();</span><br><span class="line">&#125;</span><br><span class="line">tcp_socket.wait_until_closed();</span><br></pre></td></tr></table></figure></li><li><p>wait_until_closed()</p><ul><li>此时peer已经停止写(receiver 接收fin)</li><li>于是我们 _socket 关闭读写, 致使 _thread_data关闭读 , 通过之前注册的回调 , 致使tcpconnection关闭写 , 于是local tcp sender发送fin给peer. 完成四次挥手. clean shutdown<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AdaptT&gt;</span><br><span class="line"><span class="keyword">void</span> TCPSpongeSocket&lt;AdaptT&gt;::wait_until_closed() &#123;</span><br><span class="line">    <span class="comment">//  关闭user看到的_socketfd的读写   </span></span><br><span class="line">    shutdown(SHUT_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (_tcp_thread.joinable()) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;DEBUG: Waiting for clean shutdown... &quot;</span>;    <span class="comment">//  </span></span><br><span class="line">        _tcp_thread.join();     <span class="comment">//  等待tcp thread结束</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;done.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><ul><li>port是传输层的，可是我们没在lab4的tcpconnection中填充，他在什么时候填充的 ?<ul><li>tcpConnection 填充了 seq num , ack num , window , data , ack , rst , syn , fin. urg和psh没用到</li><li>tcpsegment自己计算了dataoffset , checksum</li><li><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-11-03-04.png"></li><li>在wrap_tcp_in_ip中填充的<br><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-38-22.png"></li></ul></li></ul><ul><li><p>本地IP和本地Port在什么时候告知Socket？: connect时随机生成port ; peer的IP和Port呢？: user传入. 见connect.<br>  <img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-43-58.png"></p></li><li><p>port在什么时候起到作用 ? 怎么用于区分segment是不是给我们的socket的？<br>  <img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-20-10-47-59.png"></p></li></ul><ul><li>tcp协议的端口只是逻辑上的端口，并没有实际物理意义，没有对应设备 只是个逻辑上的 用于区分socket罢了. 其范围0到65535是受报文中给port的空间限制的 .<ul><li>在网络技术中，端口(Port)大致有两种意思：一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用于连接其他网络设备的接口，如RJ-45端口、SC端口等等；二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</li></ul></li></ul><h3 id="关于IP分片"><a href="#关于IP分片" class="headerlink" title="关于IP分片"></a>关于IP分片</h3><p><img src="/2023/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-Socket/2023-02-27-13-18-56.png"></p><ul><li>可以看到 util以及libsonge中并没有IP分片的代码. 为什么 ?<ul><li>因为我们只实现了TCP/IP协议栈. 并没有实现UDP/IP . </li><li>UDP才会在IP分片，TCP不会在IP分片. 原因如下</li></ul></li><li><strong>TCP</strong>会进行<strong>分段</strong>,临界为称为(Max Segment Size). <strong>MSS</strong><ul><li>放入TCP Segment的最大应用层报文段大小.</li><li>MSS的大小一般都是参考了MTU. 如MTU = 1500bytes , 则 MSS = 1500 - IP Header - TCP Header = 1460 Bytes</li></ul></li><li><strong>IP</strong>层<strong>分片</strong>的临界是(Max Transimssion Unit)<strong>MTU</strong>. <ul><li>MTU是由数据链路层决定的. 如Ethernet II的MTU就是1500 bytes</li><li>MTU = IP Header + TCP Header + MSS</li></ul></li><li>易知一个IP datagram里面封装一个 TCP Segment. 又由于 MSS &lt; MTU , 故<strong>TCP分段避免了IP分片</strong>.</li><li>TCP MSS目的 : 为了让IP层少分包或是不分包 ,因为<strong>IP分片丢失会导致TCP重传所有分片组成的那个Segment.</strong></li><li>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。<ul><li>当某一个 IP 分片丢失后，接收方的 IP 层就无法组装成一个完整的 TCP 报文（头部 + 数据），也就无法将数据报文送到 TCP 层，所以接收方不会响应 ACK 给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」(该TCPSegment大于MTU)。</li><li>因此，IP 层进行分片，如果丢失某个分片，则重传效率很低</li></ul></li></ul><h3 id="listening-fd"><a href="#listening-fd" class="headerlink" title="listening fd"></a>listening fd</h3><ul><li>与kernel实现不同. Kernel里面，对于server，会有一个listening socket（与peer进行三次握手建立连接)。然后为到来的建立连接请求创建connection socket. 去和client的connfd进行通信.</li><li>libsponge的实现没有listening socket,仅仅就是一个connection socket。这个connection去和client的connfd进行三次握手、通信以及四次挥手.</li></ul><h2 id="PS-eventloop相关code"><a href="#PS-eventloop相关code" class="headerlink" title="PS :  eventloop相关code"></a>PS :  eventloop相关code</h2><ul><li>tcp_spong_socket.cc</li></ul><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><ul><li>通过CS144 lab0-7 <ul><li>掌握了如何实现基本的TCP协议(TCPSender TCPReceiver) , 更加理解了TCP协议是如何应对 对于两军问题导致的双方难以达成clean shutdown的情况 , 并对TCP/IP协议栈(TCP IP ARP Ethernet)以及路由(Router)有了更深刻的理解.</li><li>学会了c++14的一些新特性,如optional , string_view </li><li>学习FullStackSocket的设计 : 事件交给worker thread的eventloop来做 , user 在另一个thread等待 , 二者通过pipe传输.</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;CS144lab1-7 自顶向下 实现了HTTP(GET) , TCP , IP(util) ,ARP(NetworkInterface) , Ethernet(util)(NetworkInterface use) , 最后在用户态组成了一个可靠数据传输的socket&lt;ul&gt;
&lt;li&gt;FullStackSocket概述&lt;ul&gt;
&lt;li&gt;2 thread (main thread , tcp thread)&lt;/li&gt;
&lt;li&gt;3 fd(user socket , 内置的_thread_data(与协议栈交互) , tap fd)&lt;/li&gt;
&lt;li&gt;eventloop注册事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>c++_string_view</title>
    <link href="http://example.com/2023/02/15/c++_string_view/"/>
    <id>http://example.com/2023/02/15/c++_string_view/</id>
    <published>2023-02-15T10:37:44.000Z</published>
    <updated>2023-02-27T15:17:34.357Z</updated>
    
    <content type="html"><![CDATA[<p>string_view : {data_pointer , data_len}<br>不拥有数据、只读<br>解决在只需读str时 还会拷贝str造成的开销 ; 提高效率.<br>可用string_view代替const string &amp;作为形参</p><p><a href="https://segmentfault.com/a/1190000018387368">基本参考一篇挺好的string_view科普.</a></p><span id="more"></span><p>总结如下</p><h1 id="string-view"><a href="#string-view" class="headerlink" title="string_view"></a>string_view</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li>为什么要有string_view ? 提高性能. 为什么提高性能 ? 有const string &amp;还不够吗 ? <ul><li>const string &amp;问题如下.</li><li>对于形参为const string&amp;的，此时的情况必然是传递的数据为只读.<ul><li><ol><li>使用&amp;当然是为了避免拷贝, 可是<strong>对于要传递给const &amp; , 只有当实参类型相同 , 即为string时, 才不会发生拷贝</strong>.</li></ol></li><li><strong>如果实参 字符串字面值(“sss”)、字符数组(char [])、字符串指针(char *) 的传递给 const string&amp; —&gt; 仍要数据拷贝</strong><ul><li>实参与string类型不同 , 则需要拷贝生成个string临时对象,然后const string &amp;指向这个临时对象. 见(C++ Primer)</li></ul></li><li><ol start="2"><li>同时string的substr效率为O(n),耗费性能. </li></ol><ul><li>O(n) : 因为substr会生成新的子串</li><li>我们本意很可能并不是要改变原字符串,实际上返回源字符串本身的一部分即可</li></ul></li></ul></li></ul></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>string_view</strong><ul><li><strong>组成 : {data_pointer , data_len}.</strong></li><li><strong>string_view本身并不持有数据，只是有个指向数据的指针罢了. 所以注意string_view可能指向一个已经失效的str</strong></li><li><strong>只读data，不可修改data</strong></li><li><strong>构造</strong>：除默认构造和拷贝构造外,还有<ul><li>constexpr string_view(const CharT* s, size_type count); </li><li>constexpr string_view(const CharT* s);</li><li>string_view foo(string(“abc”))<ul><li>a. string(“abc”)转换为string_view对象</li><li>b. string_view对象拷贝构造</li></ul></li></ul></li><li><strong>自定义字面量</strong> : sv做后缀 , 将串中的\0视作字符而非null<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::literals;</span><br><span class="line"><span class="built_in">std</span>::string_view s1 = <span class="string">&quot;abc\0\0def&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::string_view s2 = <span class="string">&quot;abc\0\0def&quot;</span>sv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1: &quot;</span> &lt;&lt; s1.size() &lt;&lt; <span class="string">&quot; \&quot;&quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s2: &quot;</span> &lt;&lt; s2.size() &lt;&lt; <span class="string">&quot; \&quot;&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">s1: <span class="number">3</span> <span class="string">&quot;abc&quot;</span></span><br><span class="line">s2: <span class="number">8</span> <span class="string">&quot;abc^@^@def&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>好处</strong><ul><li><ol><li>我们可以使用<strong>string_view</strong> 代替 const string &amp; 作为<strong>形参</strong>. 效率更高. 无论实参是 “sss” , char[] , 还是 char * , 还是string , 都只需要构造一个string_view , 然后拷贝构造string_view即可. 代价基本仅仅是1 data_pointer + 1 data_len. 远小于拷贝整个string的代价.</li></ol></li><li><ol start="2"><li>string_view的<strong>substr</strong>函数的时间复杂度是<strong>O(1)</strong>.(移动data_pointer构造string_view即可)</li></ol></li></ul></li><li><strong>注意</strong><ul><li>string_view范围内的字符可能不包含\0</li><li>从[const] char*构造string_view对象时间复杂度O(n).(为了遍历获取data_len)</li><li>string_view指向的内容的生命周期可能比其本身短</li></ul></li><li><strong>指导</strong> : 约束少，使用自由，难以保证data的生命周期长于string_view. 故我们应将string_view作为<strong>函数形参</strong>，因为如果该参数仅仅在函数体内使用而不传递出去，这样使用是安全的。<ul><li>当然string_view作为函数形参 , 整个函数中 绝对不会出现data失效的问题.</li><li>不过可以看到 cs144中依然返回了string_view(Buffer.h) ，因为Buffer内部通过shared_ptr保证了data的生命周期 ? </li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;string_view : {data_pointer , data_len}&lt;br&gt;不拥有数据、只读&lt;br&gt;解决在只需读str时 还会拷贝str造成的开销 ; 提高效率.&lt;br&gt;可用string_view代替const string &amp;amp;作为形参&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000018387368&quot;&gt;基本参考一篇挺好的string_view科普.&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>(未完成)计算机网络-CS144-lab4-优化</title>
    <link href="http://example.com/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/</id>
    <published>2023-02-15T05:28:43.000Z</published>
    <updated>2023-02-27T15:23:42.906Z</updated>
    
    <content type="html"><![CDATA[<p>心血来潮，给lab4来个性能优化. 失败<br>未完成</p><span id="more"></span><h2 id="分析-amp-优化（未完成）"><a href="#分析-amp-优化（未完成）" class="headerlink" title="分析 &amp; 优化（未完成）"></a>分析 &amp; 优化（未完成）</h2><ul><li>You may need to profile your code or reason about where it is slow, and you may have to improve your implementation of some of the critical modules (e.g., ByteStream or StreamReassembler) to get to this point.</li></ul><h3 id="尝试优化-ByteStream-失败"><a href="#尝试优化-ByteStream-失败" class="headerlink" title="尝试优化 ByteStream (失败)"></a>尝试优化 ByteStream (失败)</h3><ul><li>根据同学支招 , 尝试将ByteStream中的deque&lt; char&gt;替换为BufferList，不过效果不太明显甚至导致性能更差.<ul><li>分析之后我认为原因如下几点<ul><li>a. bytestream由StreamReassembler调用 , 我实现的策略是StreamReassembler逐个字节的扫描并write进bytestream. 那么如果在stream.write()为一个字节造了个Buffer , 还要再填入BufferList , 得不偿失.</li><li>b. 并且由于StreamReassembler策略(逐byte写入)会导致频繁的调用output_bytestream.write(),导致BufferList里面的buffer数量急剧增多，在求取BufferList.size()时会极耗费时间.<blockquote><p><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-22-02-53.png"></p></blockquote></li><li>c. 更何况，即便使用了Buffer(shared_ptr管理data) ,每个字节<strong>进入bytestream必然要1次拷贝</strong>(因为传入的是const &amp;) , 从bytestream<strong>离开也必然需要1次拷贝</strong>. 这点来讲这实际上和我的 deque&lt; char &gt; 并无差别.</li><li>gropf验证一下 , 可以看到BufferList造成的开销更大(归咎于StreamReassembler策略)<ul><li><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-22-19-00.png"></li></ul></li></ul></li></ul></li><li>总结: <strong>我的性能热点不在这里。即不在于str进出bytestream的拷贝次数过多. md浪费时间了</strong></li></ul><h3 id="性能热点确定-StreamReassembler"><a href="#性能热点确定-StreamReassembler" class="headerlink" title="性能热点确定 : StreamReassembler"></a>性能热点确定 : StreamReassembler</h3><ul><li>使用gropf得到<img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-17-31.png"></li><li>从图中可以看到，<strong>性能消耗的大头在于unordered_map和move_receiving_window , 也即性能热点都在StreamReassembler</strong>. 有点麻烦啊靠。 </li><li>unordered_map应该没啥优化空间了，复杂度平摊下来O(1) ; 那么就是优化move_receiving_window. 我的代码没有时刻记录能移动到的位置，只能最后遍历一次. 所以应该尝试在重组字节的时候就记录下最大的顺序字节的位置. 日后有时间再尝试吧. 这一下午就当打游戏了…… 悲</li><li>突然想起来当时写StreamReassembler时，写到这部分时考虑过是否性能会较低,不过当时偷懒先只追求正确性了，可恶.</li><li>有时间再继续优化吧. 不赶趟了不赶趟了 快点复习数据库考试吧.</li></ul><h2 id="分析-amp-gprof-和-gprof2dot-py-使用"><a href="#分析-amp-gprof-和-gprof2dot-py-使用" class="headerlink" title="分析 &amp; gprof 和 gprof2dot.py 使用"></a>分析 &amp; gprof 和 gprof2dot.py 使用</h2><ul><li><p>gprof使用</p><ul><li><ol><li>编译选项 -g更改为 -pg</li></ol></li><li><ol start="2"><li>./apps/tcp_benchmark 运行一下生成gmon.out</li></ol></li><li><ol start="3"><li>分析生成的gmon.out : <code>gprof ./apps/tcp_benchmark</code></li></ol><ul><li>函数消耗时间分析. 依据self seconds进行排序<br>  <img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-17-31.png"><br>  <img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-26-53.png"></li><li>call graph段. 描述函数调用关系<br><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-23-16.png"></li></ul></li></ul></li><li><p>图形化 : gprof2dot.py使用</p><ul><li><ol><li>还是先生成gmon.out</li></ol></li><li><ol start="2"><li>分析生成的gmon.out , 并将输出传递给gprof2dot.py , 处理完之后传给dot. 生成png</li></ol><ul><li> <code>sudo gprof ./apps/tcp_benchmark | gprof2dot.py | dot -Tpng -o report.png</code></li><li><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-17-55.png"></li><li><img src="/2023/02/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E4%BC%98%E5%8C%96/2023-02-18-14-18-17.png"></li></ul></li></ul></li><li><p>gprof 缺陷：只能分析应用程序在运行过程中所消耗掉的用户时间，无法得到程序内核空间的运行时间。</p></li><li><p>这类工具还有valgrind, google perftools , perf , systemtap , oprofile , dtrace 有时间再研究.</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;心血来潮，给lab4来个性能优化. 失败&lt;br&gt;未完成&lt;/p&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-CS144-lab7</title>
    <link href="http://example.com/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/"/>
    <id>http://example.com/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/</id>
    <published>2023-02-10T04:03:55.000Z</published>
    <updated>2023-02-27T15:23:40.624Z</updated>
    
    <content type="html"><![CDATA[<p>使用我们lab0-5实现的协议栈(Host) 以及 lab6实现的router , 来和远端server实现通信</p><span id="more"></span><ul><li>使用我们lab0-5实现的协议栈(Host) 以及 lab6实现的router , 来实现通信.<ul><li>原理 : 自己画了一遍也确实是这样<br><img src="/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/2023-02-12-09-37-28.png"></li><li>exchange data<br><img src="/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/2023-02-12-08-40-29.png"></li><li>sending and recving file over network<br><img src="/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/2023-02-12-09-54-55.png"></li></ul></li></ul><p>简单理解relay server : 中继服务器 由于距离过远 , Host不直接将信号发送给彼此，而是通过中继节点，经过信号放大或再生处理进行转发。</p><ul><li>over!<br><img src="/2023/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab7/2023-02-12-10-06-40.png"></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用我们lab0-5实现的协议栈(Host) 以及 lab6实现的router , 来和远端server实现通信&lt;/p&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-CS144-lab6</title>
    <link href="http://example.com/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/"/>
    <id>http://example.com/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/</id>
    <published>2023-02-08T23:59:51.000Z</published>
    <updated>2023-02-27T15:23:41.171Z</updated>
    
    <content type="html"><![CDATA[<p>build a Router based on Network Interface</p><ul><li>在Network Interface的基础上实现一个Router<ul><li>功能 : 根据 forwarding table (&lt;ip_prefix - interface(port)&gt;). 将来自ip的分组从正确的网卡接口转发出去.</li><li>匹配规则 : 最长前缀匹配</li><li>注意entry中需要记录next_hop_ip</li></ul></li><li>我们的Router只实现了数据平面（转发），并没有实现控制平面（路由选择）<ul><li>控制平面的路由选择算法有 LS , DV , RIP , OSPF. 详情见《自顶向下》</li></ul></li></ul><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li><p>本周在NetworkInterface之上实现一个IP Router. IP Router的任务是根据routing table转发. 对于收到的dgram,router有一系列规则</p><ul><li>转发到正确的interface</li><li>获知下一跳的IP地址(为了使得Router将其传递给NetWork Interface , NetWork Interface根据ip获取下一跳的mac地址)</li></ul></li><li><p>概述图<img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-08-11-25.png"></p></li></ul><p>我们的任务是 实现一个router. 去解决上述两个事情. </p><ul><li>我们只实现了router的数据平面 , 并没有实现router的控制平面.</li><li>也即我们只实现了根据router的forwarding table,并没有实现生成forwarding_table的routing algorithm路由选择算法<ul><li>You will not need to implement the algorithms that make the routing table, e.g. RIP, OSPF,BGP, or an SDN controller—just the algorithm that follows the routing table.</li></ul></li><li>IP router不必关系任何有关TCP,ARP,Ethernet协议字段的任何东西. 只关心IP协议字段即可.</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>Router class 应该负责<ul><li>维护forwarding table</li><li>Router负责处理收到的网络层的datagram. 对于每个datagram<ul><li>正确的发到下一跳</li><li>转发到正确的NetworkInterface</li></ul></li></ul></li></ul><ul><li>重要成员 forwarding_table的entry  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RouterEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> route_prefix;                <span class="comment">//  ip</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> prefix_length;                 <span class="comment">//  ip_perfix_len</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;Address&gt; next_hop;       <span class="comment">//  下一跳的ip地址 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> interface_num;             <span class="comment">//  从哪个网卡转发出去 编号 </span></span><br><span class="line">    RouterEntry(<span class="keyword">const</span> <span class="keyword">uint32_t</span> ip , <span class="keyword">const</span> <span class="keyword">uint8_t</span> prefix , <span class="keyword">const</span> <span class="built_in">std</span>::optional&lt;Address&gt; ne , <span class="keyword">const</span> <span class="keyword">size_t</span> interface_idx):</span><br><span class="line">        route_prefix(ip),prefix_length(prefix),next_hop(ne),interface_num(interface_idx)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;RouterEntry&gt; _forwarding_table&#123;&#125;;</span><br><span class="line"></span><br><span class="line">一来开始以为 既然我们的router只需要维护forwarding table并转发到正确的Interface. 因此forwarding table的entry并不需要记录next_hop_ip。只需要记录 &lt;ip_perfix , interface&gt;. 但由于之后forwarding_table要调用interface接口进行发送.为了使得interface可以获取到mac地址,需要传递给下一跳的ip地址, 故forwarding table的entry中还需要记录next_hop_ip</span><br></pre></td></tr></table></figure></li></ul><ul><li><strong>void add_route(const uint32_t route_prefix, const uint8_t prefix_length, const optional&lt; Address &gt; next_hop, const size_t interface_num);</strong><ul><li>保存一条 {ip_perfix,network_interface}到forwarding_table中</li></ul></li></ul><ul><li><strong>void route_one_datagram(InternetDatagram &amp;dgram);</strong><ul><li><strong>“match-action” rule</strong> : <ul><li>依据我们在《自顶向下》中所学，router应当对收到的dgram执行 匹配加动作 规则。而传统路由器的动作就是根据目的地转发. 也即本lab中实现的 匹配加转发</li><li><strong>匹配</strong> : 将dgram中的ip和forwarding_table中的ip进行 <strong>最长前缀匹配</strong></li><li><strong>动作 : 转发</strong><ul><li>如果router和dst ip<strong>在同一网络</strong>中(If the router is directly attached to the network in question) , 那么forwarding_table中的entry记录的next_hop_ip为empty, router传递给network_interface的next_hop_ip为dgram_dst_ip</li><li>如果router和dst ip<strong>不在同一网络</strong>中(But if the router is connected to the network in question through some other router) , 那么entry中会记录路径上的下一跳ip地址(应该是个router ip)</li></ul></li></ul></li><li>步骤如下 , 根据forwarding_table找到最长前缀匹配的entry<ul><li>没找到 , drop the dgram</li><li>找到 , dgram TTL –.<ul><li>如果TTL已经 &lt;= 0 则 drop the dgram</li><li>否则 , 将dgram转发给正确的interface , 由interface将其封装成frame发送出去.</li></ul></li></ul></li></ul></li></ul><ul><li><p><strong>void Router::route()</strong></p><ul><li>(Linker) 从network interface取出dgrams , (Internet) 调用route_one_datagram(dgram) , (Linker) 进而转发到正确的network interface 发送出去</li><li><strong>Linker -&gt; Internet -&gt; Linker</strong></li></ul></li><li><p>网络协议巧妙设计 : 分层. router只关注网络层.</p><ul><li>Router不必关注frame中封装的TCP 还是ARP ,也不必关注link layer frame类型. </li><li>Router只需要关注 网络层的Internet datagram , 然后通过NetworkInterface 来和 链路层link layer进行交互</li><li>When it comes to questions like, “How are link-layer addresses resolved?” or “Does the link layer even have its own addressing scheme distinct from IP?” or “What’s the format of the link-layer frames?” or “What’s the meaning of the datagram’s payload?”, the router just doesn’t care.</li></ul></li><li><p>代码略 简单</p></li><li><p>ques : 如果router drop dgram : 没有找到对应entry , 或者ttl = 0 . 是否需要发送icmp 报文给源主机 ?</p><ul><li>在真实生活中 , router需要发哦是那个icmp给源主机 . 但lab中这不是必需的.即便在真实生活中 , 不是所有router都需要发送icmp报文给源地址的. </li></ul></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>测试原理. test code中的NetWork 模拟的就是下图交互情况. NetWork中的_router就是图中中间的路由器<br>  <img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-11-26.png"></li></ul><ul><li><p>apleasure to cherry</p><blockquote><p><img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-12-23.png"></p></blockquote></li><li><p>app to internet</p><blockquote><p><img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-14-12.png"></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; green &lt;&lt; <span class="string">&quot;\n\nSuccess! Testing applesauce sending to the Internet.&quot;</span> &lt;&lt; normal &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> dgram_sent = network.host(<span class="string">&quot;applesauce&quot;</span>).send_to(&#123;<span class="string">&quot;1.2.3.4&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;default_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><blockquote><p><img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-19-56.png"></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; green &lt;&lt; <span class="string">&quot;\n\nSuccess! Testing sending to the HS network and Internet.&quot;</span> &lt;&lt; normal &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> dgram_sent = network.host(<span class="string">&quot;applesauce&quot;</span>).send_to(&#123;<span class="string">&quot;143.195.131.17&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;hs_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line"></span><br><span class="line">    dgram_sent = network.host(<span class="string">&quot;cherrypie&quot;</span>).send_to(&#123;<span class="string">&quot;143.195.193.52&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;hs_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line"></span><br><span class="line">    dgram_sent = network.host(<span class="string">&quot;cherrypie&quot;</span>).send_to(&#123;<span class="string">&quot;143.195.223.255&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;hs_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line"></span><br><span class="line">    dgram_sent = network.host(<span class="string">&quot;cherrypie&quot;</span>).send_to(&#123;<span class="string">&quot;143.195.224.0&quot;</span>&#125;);</span><br><span class="line">    dgram_sent.header().ttl--;</span><br><span class="line">    network.host(<span class="string">&quot;default_router&quot;</span>).expect(dgram_sent);</span><br><span class="line">    network.simulate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>同一LAN</p><blockquote><p><img src="/2023/02/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab6/2023-02-10-10-15-20.png"></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dgram_sent = network.host(<span class="string">&quot;dm42&quot;</span>).send_to(network.host(<span class="string">&quot;dm43&quot;</span>).address());</span><br><span class="line">dgram_sent.header().ttl--;</span><br><span class="line">network.host(<span class="string">&quot;dm43&quot;</span>).expect(dgram_sent);</span><br><span class="line">network.simulate();</span><br></pre></td></tr></table></figure></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;build a Router based on Network Interface&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Network Interface的基础上实现一个Router&lt;ul&gt;
&lt;li&gt;功能 : 根据 forwarding table (&amp;lt;ip_prefix - interface(port)&amp;gt;). 将来自ip的分组从正确的网卡接口转发出去.&lt;/li&gt;
&lt;li&gt;匹配规则 : 最长前缀匹配&lt;/li&gt;
&lt;li&gt;注意entry中需要记录next_hop_ip&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们的Router只实现了数据平面（转发），并没有实现控制平面（路由选择）&lt;ul&gt;
&lt;li&gt;控制平面的路由选择算法有 LS , DV , RIP , OSPF. 详情见《自顶向下》&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-a_day_in_life_of_web_request</title>
    <link href="http://example.com/2023/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-a-day-in-life-of-web-request/"/>
    <id>http://example.com/2023/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-a-day-in-life-of-web-request/</id>
    <published>2023-02-07T06:48:58.000Z</published>
    <updated>2023-02-07T06:48:58.781Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络-链路层和局域网</title>
    <link href="http://example.com/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <id>http://example.com/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</id>
    <published>2023-02-05T09:15:42.000Z</published>
    <updated>2023-02-27T15:24:19.191Z</updated>
    
    <content type="html"><![CDATA[<p>链路层和物理层<br>链路层的MAC协议有<br>信道划分协议、随即加入协议、轮询协议<br>LAN局域网<br>链路层地址,又称 LAN地址(LAN address) , 物理地址(phyiscal address) , MAC地址(MAC address)<br>地址解析协议ARP<br>交换机：链路层设备（检查链路层头部）,根据MAC地址进行转发<br>路由器：网络层设备（检查网络层的头部）, 根据IP地址进行转发</p><span id="more"></span><h1 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为什么在链路层和传输层都实现了可靠性 ？<br>因为一个点到点 一个端到端 ? </p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p>传输层功能：解决进程到进程的区分，加强网络服务从不可靠变成可靠</p></li><li><p>网络层功能：解决端到端传输 ; 也即解决一个网络如何到达另一个网络的路由问题</p></li><li><p>链路层功能：解决点到点传输 ; 也即解决在一个网络内部如何由一个节点（主机或者路由器）到达另外一个相邻节点</p></li><li><p>目标</p><ul><li>理解数据链路层服务的原理:<ul><li>检错和纠错</li><li>共享广播信道：多点接入（多路访问）</li><li>链路层寻址</li><li>LAN:以太网、WLAN、VLANs</li><li>可靠数据传输，流控制: 解决!</li></ul></li><li>实例和各种链路层技术的实现</li></ul></li><li><p><strong>WAN : World Area NetWork</strong></p><ul><li><strong>广域网</strong>、外网、公网</li><li>网络形式采用<strong>点到点链路</strong> <ul><li>带宽大、距离远（延迟大） &gt;带宽延迟积大 </li><li>如果采用多点连接方式 <ul><li>竞争方式：一旦冲突代价大</li><li>令牌等协调方式：在其中协调节点的发送代价大</li></ul></li></ul></li><li><strong>点到点链路的链路层服务实现非常简单，封装和解封装</strong></li></ul></li><li><p><strong>LAN : Local Area NetWork</strong></p><ul><li><strong>局域网</strong></li><li>一般采用<strong>多点连接</strong>方式 <ul><li>连接节点非常方便 </li><li>接到共享型介质上（或网络交换机），就可以连接所有其他节点</li></ul></li><li>多点连接方式网络的链路层功能实现相当复杂 <ul><li>多点接入：协调各节点对共享性介质的访问和使用 </li><li>竞争方式：冲突之后的协调</li><li>令牌方式：令牌产生，占有和释放等</li></ul></li></ul></li></ul><ul><li><p><strong>术语</strong></p><ul><li>节点 node : 任何运行链路层协议的设备称为节点，包括主机、路由器、交换机、wifi接入点</li><li>链路 link :  沿着通信路径,连接个相邻节点通信信道的是链路<ul><li>有线链路 </li><li>无线链路 </li><li>局域网，共享性链路</li></ul></li><li>帧 frame : 第二层协议数据单元帧frame，封装数据报</li></ul></li><li><p>数据链路层负责从一个节点通过链路将（帧中的）数据报发送到相邻的物理节点（一个子网内部的2节点）</p></li></ul><p>链路层功能：解决点到点。在相邻两点之间，传输以帧为单位的数据</p><h3 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h3><ul><li><p><strong>成帧(frame)</strong> </p><ul><li>链路层协议将网络层数据报用链路层帧封装起来，然后放入链路传送</li></ul></li><li><p><strong>链路接入</strong> </p><ul><li>媒体访问控制(Medium Access Control , MAC)协议规定了frame在链路上传输的规则</li><li>对于点到点链路(链路的一端仅有一个发送方,另一端仅有一个接收方)<ul><li>MAC协议比较简单</li><li>即无论何时链路空闲，发送方都能够发送帧</li></ul></li><li>对于多个节点共享单个广播链路(即多路访问问题)<ul><li>MAC协议负责协调多个节点的帧传输</li></ul></li></ul></li><li><p><strong>可靠交付</strong></p><ul><li>当链路层协议提供可靠交付服务时,它保证无差错地经链路层移动每个网络层数据报 <ul><li>在（一个网络内）相邻两个节点完成可靠数据传递</li></ul></li><li>与TCP提供可靠交付服务类似，链路层也是通过确认和重传实现可靠交付</li><li>链路层可靠交付服务通常用于易于产生高差错率的链胳,如无线链路<ul><li>其目的是本地(也就是在差错发生的链路上)纠正一个差错，而不是通过运输层或应用层协议迫使迸行端到端的数据重传 </li></ul></li><li>然而，对于低比特差错的链路，括光纤、同轴电缆和许多双绞铜钱链路，链路层可靠交付可能会被认为是一种不必要的开销 由于这个原因，许多有线的链路层协议不提供可靠交付服务.</li></ul></li><li><p>差错检测和纠正</p><ul><li>差错检测 : 逼运输层、网络层的因特网校验和更复杂一些.</li><li>差错纠正 : 接收端检查和纠正bit错误，不通过重传来纠正错误</li></ul></li></ul><p>以太网 链路层 不保证可靠传输协议（因为以太网本身比较可靠，所以不需要通过协议实现可靠）<br>waln(无线局域网) 链路层 保证可靠传输协议(发出去之后需要确认)（因为无线网络本身出错率就比较高，存在电磁波衰减、干扰问题；所以需要人为地通过协议保证可靠）</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>链路层在哪里实现 ?</p><ul><li><p>首先，<strong>网络适配器(network adapter)<strong>，又称</strong>网络接口卡(Network Interface Card, NIC)<strong>，就是所谓的</strong>网卡</strong></p></li><li><p><strong>链路层功能主体在网卡上实现,也有功能在软件实现</strong>,软硬件结合<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-08-40-04.png"></p><ul><li>每个主机/路由器/交换机上插若干网卡,每个网卡上实现了链路层和相应物理层功能、</li><li>网卡写死了自己的MAC地址</li></ul></li><li><p><strong>网卡/适配器通信</strong><br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-08-42-58.png"></p><ul><li>发送方: <ul><li>在帧中封装数据报 </li><li>加上差错控制编码，实现RDT和流量控制功能等</li></ul></li><li>接收方 <ul><li>检查有无出错，执行rdt和流量控制功能等</li><li>解封装数据报，将至交给上层</li></ul></li><li>适配器是半自治的,实现了链路和物理层功能</li><li>一个适配器可以同时发/接</li></ul></li></ul><h2 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h2><ul><li>链路层会提供 <strong>比特级差错检测和纠正(bit-level error detection and correction)</strong> 服务</li><li>理论基础 : <ul><li>发送方 : 为保护比特受损，使用<strong>差错检测和纠正位(Error-Detection and Correction , EDC)<strong>来</strong>增强数据D</strong><ul><li>数据D不仅包括网络层数据报，还包括链路层首部</li></ul></li><li>接收方 : 收到D’和EDC’,确定D’和原D是否相同</li><li>检测并非100%有效，可能出现<strong>未检出比特差错(undetected bit error)</strong><ul><li>导致接收方向上提交一个受损的数据报</li><li>因此，我们要选择一个差错检测方案，使得这种事件发生的概率很小<ul><li>奇偶校验<ul><li>用来描述差错检测和纠正背后隐含的基本思想</li></ul></li><li>检验和方法<ul><li>更多地应用于运输层</li></ul></li><li>循环冗余检测<ul><li>更多地应用在适配器中的链路层<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-08-59-01.png"></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="奇偶检验"><a href="#奇偶检验" class="headerlink" title="奇偶检验"></a>奇偶检验</h3><ul><li>单bit奇偶校验 : 检测单(奇数)个bit级错误<ul><li>采用一个奇偶检验位.</li><li><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-09-08-59.png"></li></ul></li><li>2维奇偶校验 : 检测和纠正单个bit错误,检测两个bit差错的任意组合<ul><li>i+j+1个奇偶检验位</li><li><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-09-09-30.png"></li></ul></li></ul><h3 id="校验和方法"><a href="#校验和方法" class="headerlink" title="校验和方法"></a>校验和方法</h3><p>略</p><h3 id="循环冗余检测-CRC"><a href="#循环冗余检测-CRC" class="headerlink" title="循环冗余检测 CRC"></a>循环冗余检测 CRC</h3><p>略</p><ul><li>CRC : Cyclic Redundancy Check </li></ul><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><ul><li><p>两种类型的链路（一个子网内部链路连接形式）：</p><ul><li><strong>点对点链路(point-to-point link)</strong><ul><li>由链路一段的单个发送方和链路另一端的单个接收方组成 <ul><li>如以太网交换机和主机之间的点对点链路</li></ul></li><li>为点对点链路设计的链路层协议 , 如点对点协议 PPP ; HDLC</li></ul></li><li><strong>广播链路(broadcast link)</strong> (共享线路或媒体)<ul><li>多个发送和接收节点都连接在同一个，单一的，共享的，广播信道上</li><li>“广播”是因为当任何一个节点传输一个帧时，信道广播该帧，每个其他节点都收到一个副木。 </li><li>以太网和无线局域网是广播链路层技术的例子。</li></ul></li></ul></li><li><p><strong>多路访问问题 ( mu1tiple access problem )</strong></p><ul><li><strong>如何协调多个发送和接收节点对一个共享广播信道的访问 ?</strong> </li><li>在本节，我们暂缓讨论特定的链路层协议，而先研究这个对链路层很重要的问题. </li><li><strong>广播信道通常用于局域网中</strong>，局域网是一个地理上集中在一座建筑物中(或者在一个公司，或者在大学校园)的网络。因此我们还将在本节后面考察一下多路访问信道是如何在局域网中使用的</li></ul></li></ul><p>以太网：(Ethernet)，以太网可以看成是一种实现局域网通信的技术标准，是目前最广泛的局域网技术。以太网的运行速率有10Mbps,100Mbps,1Gbps,10Gbps的，它的传输介质有的是双绞线，有的是光纤。 简单的说，以太网就是在局域网内，把附近的设备连接起来，可以进行通讯。</p><h3 id="多路访问协议-媒体访问控制协议-MAC"><a href="#多路访问协议-媒体访问控制协议-MAC" class="headerlink" title="多路访问协议 / 媒体访问控制协议(MAC)"></a>多路访问协议 / 媒体访问控制协议(MAC)</h3><ul><li><strong>碰撞 (collision)</strong><ul><li>多个节点在同一个时刻发送，接收方则会收到2个或多个信号叠加</li><li>通常，当碰撞发生时，没有一个接收节点能够有效地获得任何传输的帧;在某种意义下，碰撞帧的信号纠缠在一起 因此，涉及此次碰撞的所有帧都丢失了，在碰撞时间间隔中的广播信道被浪费了 </li></ul></li></ul><ul><li><p><strong>多路访问协议 (multiple access protocol)</strong> </p><ul><li>即节点通过这些协议来规范它们在共享的广播信道上的传输行为</li><li>在实践中，数以百计或者甚至数以千计个节点能够通过一个广播信道直接通信</li><li>即 <strong>介质/媒体访问控制协议：MAC</strong><ul><li>分布式算法-决定节点如何使用共享信道，即：决定节点什么时候可以发送？</li><li>关于共享控制的通信必须用借助信道本身传输,没有带外信道.</li></ul></li></ul></li><li><p>理想多路访问协议</p><ul><li>给定：Rbps的广播信道</li><li>必要条件：<ul><li><ol><li>当一个节点要发送时，可以R速率发送. </li></ol></li><li><ol start="2"><li>当M个节点要发送，每个可以以R/M的平均速率发送</li></ol></li><li><ol start="3"><li>完全分布的:不会因某主节点故障而使得整个系统崩溃</li></ol><ul><li>没有特殊节点协调发送</li><li>没有时钟和时隙的同步</li></ul></li><li><ol start="4"><li>简单</li></ol></li></ul></li></ul></li></ul><h3 id="MAC协议分类"><a href="#MAC协议分类" class="headerlink" title="MAC协议分类"></a>MAC协议分类</h3><p>P294</p><ul><li>MAC协议可分为如下三大来<ul><li><strong>信道划分协议(channel partitioning protocol)</strong><ul><li>把信道划分成小片（时间、频率、编码）</li><li>分配片给每个节点专用</li></ul></li><li><strong>随机访问协议(random access protocol)</strong><ul><li>信道不划分，允许冲突</li><li>冲突后恢复</li></ul></li><li><strong>依次轮流协议(taking-turns protocol)</strong><ul><li>节点依次轮流</li><li>但是有很多数据传输的节点可以获得较长的信道使用权</li></ul></li></ul></li></ul><h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><h5 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h5><ul><li>TDMA:time division multiple access<ul><li>信道的时间分时间帧(time frame),每个时间帧划分为n个时隙(slot)</li><li>节点轮流使用信道,每个节点使用每周期中固定的时隙(长度=帧传输时间)传输帧</li><li>如果站点无帧传输，时隙空闲-》浪费</li><li>如：6站LAN，1、3、4有数据报，时隙2、5、6空闲<blockquote><p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-09-50-54.png"></p></blockquote></li></ul></li></ul><h5 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h5><ul><li>FDMA: frequency division multiple access<ul><li>信道的有效频率范围被分成一个个小的频段</li><li>每个站点被分配一个固定的频段</li><li>分配给站点的频段如果没有被使用，则空闲</li><li>例如：6站LAN，1、3、4有数据报，频段2、5、 6空闲<blockquote><p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-09-51-04.png"></p></blockquote></li></ul></li></ul><h5 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h5><ul><li>码分多路访问 CDMA (code division multiple access) : <ul><li>所有站点在整个频段上同时进行传输, 采用编码原理加以区分 </li><li>完全无冲突 </li><li>假定:信号同步很好,线性叠加</li><li>比方<ul><li>TDM:不同的人在不同的时刻讲话</li><li>FDM:不同的组在不同的小房间里通信</li><li>CDMA:不同的人使用不同的语言讲话</li></ul></li></ul></li></ul><h4 id="随机接入协议"><a href="#随机接入协议" class="headerlink" title="随机接入协议"></a>随机接入协议</h4><ul><li><p>当节点有帧要发送时</p><ul><li>以信道带宽的全部 R bps发送</li><li>没有节点间的预先协调</li><li>两个或更多节点同时传输，会发生➜冲突“collision” </li></ul></li><li><p>随机接入协议规定: </p><ul><li>如何检测冲突</li><li>如何从冲突中恢复（如：通过稍后的重传）</li></ul></li><li><p>有如下随机接入MAC协议:</p><ul><li>时隙ALOHA</li><li>ALOHA</li><li>CSMA, CSMA/CD, CSMA/CA</li></ul></li></ul><h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5><p>略</p><h5 id="纯ALOHA-非时隙"><a href="#纯ALOHA-非时隙" class="headerlink" title="纯ALOHA(非时隙)"></a>纯ALOHA(非时隙)</h5><p>略</p><h5 id="CSMA-载波侦听多路访问"><a href="#CSMA-载波侦听多路访问" class="headerlink" title="CSMA(载波侦听多路访问)"></a>CSMA(载波侦听多路访问)</h5><p>略</p><h5 id="CSMA-CD-冲突检测"><a href="#CSMA-CD-冲突检测" class="headerlink" title="CSMA/CD(冲突检测)"></a>CSMA/CD(冲突检测)</h5><p>略</p><h6 id="以太网的MAC协议-CSMA-CD"><a href="#以太网的MAC协议-CSMA-CD" class="headerlink" title="以太网的MAC协议 : CSMA/CD"></a>以太网的MAC协议 : CSMA/CD</h6><h5 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h5><p>略</p><h6 id="无线局域网中的MAC协议：CSMA-CA"><a href="#无线局域网中的MAC协议：CSMA-CA" class="headerlink" title="无线局域网中的MAC协议：CSMA/CA"></a>无线局域网中的MAC协议：CSMA/CA</h6><p>略</p><h4 id="轮流协议-Taking-Turns"><a href="#轮流协议-Taking-Turns" class="headerlink" title="轮流协议 Taking Turns"></a>轮流协议 Taking Turns</h4><ul><li>信道划分MAC协议:<ul><li>共享信道在高负载时是有效和公平的</li><li>在低负载时效率低下 <ul><li>只能等到自己的时隙开始发送或者利用1/N的信道频率发送 </li><li>当只有一个节点有帧传时，也只能够得到1/N个带宽分配</li></ul></li></ul></li><li>随机访问MAC协议<ul><li>在低负载时效率高：单个节点可以完全利用信道全部带宽</li><li>高负载时：冲突开销较大，效率极低，时间很多浪费在冲突中</li></ul></li><li>轮流协议 : 有2者的优点</li></ul><h5 id="轮询协议-polling-protocol"><a href="#轮询协议-polling-protocol" class="headerlink" title="轮询协议 polling protocol"></a>轮询协议 polling protocol</h5><ul><li>主节点邀请从节点依次传送</li></ul><ul><li>缺点: <ul><li>轮询开销：轮询本身消耗信道带宽 </li><li>等待时间：每个节点需等到主节点轮询后开始传输，即使只有一个节点，也需要等到轮询一周后才能够发送 </li><li>单点故障：主节点失效时造成整个系统无法工作<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-10-17-39.png"></li></ul></li></ul><h5 id="令牌传递协议-token-passing-protocol"><a href="#令牌传递协议-token-passing-protocol" class="headerlink" title="令牌传递协议 token-passing protocol"></a>令牌传递协议 token-passing protocol</h5><ul><li>令牌控制<ul><li>控制令牌( token)循环从一个节点到下一个节点传递</li><li>令牌报文：特殊的帧</li><li>缺点: <ul><li>令牌开销：本身消耗带宽 </li><li>延迟：只有等到抓住令牌，才可传输 </li><li>单点故障 (token)：令牌丢失系统级故障，整个系统无法传输<br>  <img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-10-17-32.png"></li></ul></li></ul></li></ul><h3 id="MAC协议总结"><a href="#MAC协议总结" class="headerlink" title="MAC协议总结"></a>MAC协议总结</h3><ul><li>多点接入问题：对于一个共享型介质，各个节点如何协调对它的访问和使用?<ul><li>MAC协议负责协调，MAC协议可划分为<ul><li>信道划分协议：按时间、频率或者编码<ul><li>TDMA、FDMA、CDMA</li></ul></li><li>随机访问协议 (动态)<ul><li>ALOHA, S-ALOHA, CSMA, CSMA/CD</li><li>载波侦听: 在有些介质上很容易 (wire：有线介质), 但在有些介质上比较困难 (wireless：无线)</li><li>CSMA/CD ：802.3 Ethernet网中使用</li><li>CSMA/CA ：802.11 WLAN中使用</li></ul></li><li>依次轮流协议 <ul><li>集中：由一个中心节点轮询；分布：通过令牌控制</li></ul></li></ul></li></ul></li></ul><h2 id="LAN-局域网"><a href="#LAN-局域网" class="headerlink" title="LAN 局域网"></a>LAN 局域网</h2><p>Local Area NetWork</p><h3 id="链路层寻址和ARP"><a href="#链路层寻址和ARP" class="headerlink" title="链路层寻址和ARP"></a>链路层寻址和ARP</h3><h4 id="链路层地址-MAC地址"><a href="#链路层地址-MAC地址" class="headerlink" title="链路层地址 (MAC地址)"></a>链路层地址 (MAC地址)</h4><ul><li><p>32bitIP地址: 网络层地址</p><ul><li>前n-1跳：用于使数据报到达目的IP子网</li><li>最后一跳：到达子网中的目标节点</li></ul></li><li><p>主机和路由器不但具有网络层地址，而且具有链路层地址（实际上是网卡具有）</p></li><li><p><strong>链路层地址</strong>,又称 <strong>LAN地址(LAN address) , 物理地址(phyiscal address) , MAC地址(MAC address)</strong></p><ul><li>用于使帧从一个网卡传递到与其物理连接的另一个网卡(在同一个物理网络中)</li><li>6bytes , 48bit </li><li>MAC地址被设计为永久的</li><li>理论上全球任何2个网卡的MAC地址都不相同 e.g.: 1A-2F-BB-76-09-AD</li></ul></li><li><p>网络层地址和MAC地址分离</p><ul><li>IP地址和MAC地址的作用不同<ul><li>IP地址是分层的<ul><li>一个子网所有站点网络号一致，为了路由聚集，减少路由表消耗内存</li><li>IP地址完成网络到网络的交付</li></ul></li><li>mac地址是一个平面的<ul><li>网卡在生产时不知道被用于哪个网络，因此给网卡一个唯一的标示，用于区分一个网络内部不同的网卡即可</li><li>可以完成一个物理网络内部的节点到节点的数据交付</li></ul></li></ul></li><li>局域网是为网络层协议设计的，而不仅仅是ip协议.如果适配器吧指派IP地址而非独立的MAC地址，则适配器不能方便的支持其他网络层协议</li><li>如果适配器使用网络层地址而不使用MAC地址<ul><li>则网络层地址存入适配器，那么每次适配器移动都需要重新配置</li><li>则网络层地址不存入适配器，而是适配器将收到的每个帧（向cpu发起中断，内核跳转到相应中断处理程序）沿协议栈向上传递到网络层.由网络层判断收到的帧的网络层地址是否匹配。这就造成，主机会被局域网上收到的每个帧中断.</li></ul></li></ul></li></ul><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><ul><li><p><strong>ARP : Address Resolution Protocol</strong></p><ul><li><strong>负责网络层地址(IP地址)和链路层地址(MAC地址)的转换</strong><br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-11-51-58.png"> </li></ul></li><li><p>在LAN上的每个IP节点都有一个ARP表</p></li><li><p>ARP表：包括一些LAN节点IP/MAC地址的映射</p><ul><li>&lt; IP address; MAC address; TTL&gt; </li><li>TTL时间是指MAC地址映射失效的时间 ,典型是20min<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-11-57-06.png"></li></ul></li><li><p>A要发送帧给B(B的IP地址已知),A需要根据ipB解析出macB.</p><ul><li>如果arp table中有该ipB的entry，那么易得mac地址</li><li>如果arp table中没有该ipB的entry(如222.222.222.222)，那么如何 ?<ul><li><strong>A广播包含B的IP地址的ARP查询包</strong><ul><li>ARP查询分组</li><li>目的地址使用MAC广播地址，子网LAN上的所有节点都会收到该查询包<ul><li>Dest MAC address = FF-FF-FF-FF-FF-FF </li></ul></li><li>子网中的其他适配器接收到该用于arp查询的帧，将该帧中的ARP分组向上传递给arp模块，arp模块检验该arp分组要查询的ip地址是否是本机的ip地址. 无论是否匹配 , 都缓存下收到的该查询分组&lt; sender_ip - sender_mac_addr &gt; 若匹配,</li></ul></li><li>B给A发送回一个响应ARP分组，告知其B的MAC地址<ul><li>该分组的目的地址为A的MAC地址</li></ul></li></ul></li></ul></li><li><p>ARP是即插即用的 </p><ul><li>节点自己创建ARP的表项 </li><li>无需网络管理员干预</li></ul></li><li><p>ARP报文结构<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-17-21-02.png"></p></li></ul><ul><li>ARP协议是网络层协议还是链路层协议 ? <ul><li>ARP分组既包含链路层地址，又包含网络层地址.</li><li>将ARP看成是跨越链路层和网络层边界的协议<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">===================</span><br><span class="line">    传输层 </span><br><span class="line">    TCP/UDP</span><br><span class="line">===================</span><br><span class="line">    网络层</span><br><span class="line">    ICMP</span><br><span class="line">    IP</span><br><span class="line">======# ARP #=======</span><br><span class="line">    链路层</span><br><span class="line">    Ethernet 以太网帧</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="发送数据报到子网外-路由到其他LAN"><a href="#发送数据报到子网外-路由到其他LAN" class="headerlink" title="发送数据报到子网外 / 路由到其他LAN"></a>发送数据报到子网外 / 路由到其他LAN</h4><p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-12-34-23.png"></p><ul><li><p>Walkthrough :发送数据报：由A通过R到B，假设A知道B的IP地址</p></li><li><p>在路由器R上有两个ARP表，分别对应两个LAN</p></li><li><p>在源主机的路由表中，发现到目标主机的下一跳时111.111.111.110</p></li><li><p>在源主机的ARP表中，发现其MAC地址是E6-E9-00-17-BB-4B, etc</p></li><li><p>A创建数据报，源IP地址：A；目标IP地址：B </p></li><li><p>A创建一个链路层的帧，目标MAC地址是R，该帧包含A到B的IP数据报<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-12-44-59.png"></p></li><li><p>帧从A发送到R</p></li><li><p>帧被R接收到，从中提取出IP分组，交给上层IP协议实体<br>  <img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-12-53-41.png"></p></li><li><p>R转发数据报，数据报源IP地址为A，目标IP地址为B</p></li><li><p>R创建一个链路层的帧，目标MAC地址为B，帧中包含 A到B的IP 数据报.</p><ul><li>R查询路由表得知下一跳的IP，然后查询ARP表，进而得知下一跳的MAC地址，进而将MAC地址写入链路层帧中<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-13-02-32.png"></li></ul></li></ul><h3 id="Ethernet-以太网"><a href="#Ethernet-以太网" class="headerlink" title="Ethernet 以太网"></a>Ethernet 以太网</h3><ul><li>基于集线器(hub)/交换机(switch)的星形拓扑结构<ul><li>每个节点以及相连的交换机端口使用（独立的）以太网协议(不会和其他节点的发送产生碰撞)</li><li>集线器只是重新生成接收的bit，将其能量强度放大并向其他接口传输出去</li><li><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-13-41-15.png"></li></ul></li></ul><h4 id="以太帧结构"><a href="#以太帧结构" class="headerlink" title="以太帧结构"></a>以太帧结构</h4><ul><li>发送方适配器在以太网帧中封装IP数据报，或其他网络层协议数据单元 </li></ul><p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-13-53-41.png"></p><ul><li><p>地址：6字节源MAC地址，目标MAC地址</p><ul><li>如：帧目标地址=本站MAC地址，或是广播地址，接收，递交帧中的数据到网络层</li><li>否则，适配器忽略该帧</li></ul></li><li><p>dest address : 6 bytes</p><ul><li>目标适配器的MAC address</li><li>若收到以太网帧，<ul><li>其目的地址是本机MAC地址或者MAC广播地址，则将该帧的数据字段传递给网络层;</li><li>否则丢弃</li></ul></li></ul></li><li><p>src address : 6 bytes</p><ul><li>源mac地址</li></ul></li><li><p>类型：指出高层协议(IP , Novell IPX , AppleTalk , ARP等)</p></li><li><p>payload : 承载 IP 数据报。</p><ul><li>payload最大 即 以太网的最大传输单元(MTU) 1500 字节 <ul><li>如果IP数据报 &gt;  1500 byte 则必须分片</li></ul></li><li>payload最小 为 46bytes <ul><li>如果IP数据报 &lt; 46 byte 则必须填充到46bytes</li></ul></li></ul></li><li><p>CRC：在接收方校验</p><ul><li>如果没有通过校验，丢弃错误帧</li></ul></li></ul><h4 id="以太网-无连接、不可靠的服务"><a href="#以太网-无连接、不可靠的服务" class="headerlink" title="以太网 : 无连接、不可靠的服务"></a>以太网 : 无连接、不可靠的服务</h4><ul><li>无连接：帧传输前，发送方和接收方之间没有握手</li><li>不可靠：接收方适配器不发送ACKs或NAKs给发送方<ul><li>递交给网络层的数据报流可能有gap</li><li>传输层使用TCP(rdt)，应用不会看到gap(tcp协议会导致重传)(这里以太网确实会重传数据，只不过是因为tcp协议而非以太网协议)</li><li>udp，应用层就会看到gap</li></ul></li><li>以太网的MAC协议：采用二进制退避的CSMA/CD<br>介质访问控制形式</li></ul><h4 id="以太网的MAC协议-CSMA-CD-1"><a href="#以太网的MAC协议-CSMA-CD-1" class="headerlink" title="以太网的MAC协议 : CSMA/CD"></a>以太网的MAC协议 : CSMA/CD</h4><p>略</p><h3 id="IEEE-802-11-Wireless-LAN-略"><a href="#IEEE-802-11-Wireless-LAN-略" class="headerlink" title="IEEE 802.11 Wireless LAN 略"></a>IEEE 802.11 Wireless LAN 略</h3><p>以太网是一种广泛应用的局域网 是有线的</p><p>WLAN也是一种局域网 是无线的</p><h4 id="802-11-LAN-体系结构"><a href="#802-11-LAN-体系结构" class="headerlink" title="802.11 LAN 体系结构"></a>802.11 LAN 体系结构</h4><p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-05-13.png"></p><h4 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h4><p>WLAN帧 <img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-02-48.png"></p><p>略</p><h3 id="链路层交换机"><a href="#链路层交换机" class="headerlink" title="链路层交换机"></a>链路层交换机</h3><p>我对链路层交换机的印象 : 对Host来说完全透明. 从TCP/IP协议栈到最底层的网卡Network Interface都不需要管链路层交换机. 不需要在帧里指定的填写字段说明发送给某个链路层交换机. 链路层交换机更像是一个被动的捕获网络中的帧, 作用仅仅是 将其信号放大 , 并正确的转发出去. </p><p>链路层交换机</p><ul><li><p><strong>执行转发和过滤</strong></p><ul><li>交换机基于 MAC 地址而不是基于 IP 地址转发分组</li><li>通过<strong>交换机表(switch table)a</strong>完成<ul><li>该表记录了从交换机某接口出发可以到达的MAC地址</li><li>交换机表中的一个表项包含:<ul><li>一个MAC 地址 </li><li>MAC 地址的交换机接口</li><li>表项放置在表中的时间<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-24-09.png"></li></ul></li></ul></li></ul></li><li><p><strong>透明</strong>：主机对交换机的存在可以不关心 </p><ul><li>通过交换机相联的各节点好像这些站点是直接相联的一样 </li></ul></li><li><p><strong>即插即用，自学习</strong>：</p><ul><li>交换机无需配置</li><li>如何自学习配置switch table ? <ul><li><ol><li>交换机表初始为空</li></ol></li><li><ol start="2"><li>对于在每个接口接收到的每个人帧，该交换机在其表中存储:</li></ol><ul><li>在该帧源地址字段中的 MAC 地址;</li><li>该 帧到达的接口;</li><li>当前时间 </li><li>交换机如此记录了发送节点所在的局域网网段 如果在局域网上的每个主机最终都发送了一个帧，则每个主机最终将在这张表中留有记录.</li></ul></li><li><ol start="3"><li>如果在一段时间(aging time)后，交换机没有接收到以该地址作为源地址的帧，就在表中删除这个地址.</li></ol></li></ul></li></ul></li><li><p>可以多路同时传输</p><ul><li>主机有一个专用和直接到交换机的连接</li><li>交换机缓存到来的帧</li><li>对每个帧进入的链路使用以太网协议，没有碰撞；全双工<ul><li>每条链路都是一个独立的碰撞域</li><li>MAC协议在其中的作用弱化了</li></ul></li><li>交换：A-to-A’ 和 B-to-B’ 可以同时传输，没有碰撞</li><li><blockquote><p><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-35-52.png"></p></blockquote></li></ul></li></ul><h4 id="链路层交换机-vs-路由器"><a href="#链路层交换机-vs-路由器" class="headerlink" title="链路层交换机 vs 路由器"></a>链路层交换机 vs 路由器</h4><p>P316</p><ul><li>都是存储转发设备，但层次不同<ul><li>交换机：链路层设备（检查链路层头部）,根据MAC地址进行转发</li><li>路由器：网络层设备（检查网络层的头部）, 根据IP地址进行转发<br>以下还有点不懂</li></ul></li><li>都有转发表：<ul><li>交换机：维护交换表，按照MAC地址转发<ul><li>执行过滤、自学习和生成树算法</li><li>即插即用；二层设备，速率高 </li><li>执行生成树算法，限制广播帧的转发</li><li>ARP表项随着站点数而增多</li></ul></li><li>路由器：维护路由表，执行路由算法<ul><li>路由算法能够避免环路，无需执行生成树算法，可以以各种拓扑构建网络</li><li>对广播分组做限制</li><li>不是即插即用的，配置网络地址（子网前缀）</li><li>三层设备，速率低<br><img src="/2023/02/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/2023-02-07-14-45-48.png"></li></ul></li></ul></li></ul><h3 id="VLANs"><a href="#VLANs" class="headerlink" title="VLANs"></a>VLANs</h3><p>略</p><h2 id="链路虚拟化：MPLS"><a href="#链路虚拟化：MPLS" class="headerlink" title="链路虚拟化：MPLS"></a>链路虚拟化：MPLS</h2><p>略</p><h2 id="数据中心网络"><a href="#数据中心网络" class="headerlink" title="数据中心网络"></a>数据中心网络</h2><p>略</p><h2 id="a-day-in-life-of-web-request"><a href="#a-day-in-life-of-web-request" class="headerlink" title="a day in life of web request"></a>a day in life of web request</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;链路层和物理层&lt;br&gt;链路层的MAC协议有&lt;br&gt;信道划分协议、随即加入协议、轮询协议&lt;br&gt;LAN局域网&lt;br&gt;链路层地址,又称 LAN地址(LAN address) , 物理地址(phyiscal address) , MAC地址(MAC address)&lt;br&gt;地址解析协议ARP&lt;br&gt;交换机：链路层设备（检查链路层头部）,根据MAC地址进行转发&lt;br&gt;路由器：网络层设备（检查网络层的头部）, 根据IP地址进行转发&lt;/p&gt;</summary>
    
    
    
    <category term="计网" scheme="http://example.com/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-网络层2</title>
    <link href="http://example.com/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/"/>
    <id>http://example.com/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</id>
    <published>2023-01-28T08:02:17.000Z</published>
    <updated>2023-02-27T15:24:20.550Z</updated>
    
    <content type="html"><![CDATA[<p>记得不多，好多都略.<br>网络层-控制平面<br>路由选择算法（LS，DV，RIP，OSPF，BGP）<br>SDN控制平面简介<br>ICMP简介</p><span id="more"></span><p>第5章：网络层控制平面</p><ul><li>本章目标：理解网络层控制平面的工作原理 <ul><li>传统路由选择算法 </li><li>SDN 控制器 </li><li>ICMP:Internet Control Message Protocol </li><li>网络管理（略）</li><li>以及它们在互联网上的实例和实现: <ul><li>OSPF, BGP, OpenFlow, ODL 和ONOS控制器, ICMP, SNMP</li></ul></li></ul></li></ul><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><ul><li>网络层功能 <ul><li>数据平面<ul><li>转发: 将分组从路由器的一个输入端口移到合适的输出端口</li></ul></li><li>控制平面<ul><li>路由：确定分组从源到目标的路径</li></ul></li></ul></li><li>2种构建网络控制平面功能的方法: <ul><li>每个路由器控制功能实现（传统） <ul><li>在每一个路由器中的单独路由器算法元件，在控制平面进行交互</li><li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-08-51-01.png"></li></ul></li><li>逻辑上集中的控制功能实现(software defined networking)<ul><li>一个不同的（通常是远程的）控制器与本地控制代理（CAs）交互</li><li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-08-51-22.png"></li></ul></li></ul></li></ul><h2 id="routing-algorithm-路由选择算法"><a href="#routing-algorithm-路由选择算法" class="headerlink" title="routing algorithm 路由选择算法"></a>routing algorithm 路由选择算法</h2><ul><li>路由选择算法(routing algorithm):网络层软件的一部分,完成路由功能</li></ul><h3 id="路由-route"><a href="#路由-route" class="headerlink" title="路由 route"></a>路由 route</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p>路由概念</p><ul><li>按照某种指标(传输延迟,所经过的站点数目等)找到一条从源节点到目标节点的较好路径 <ul><li>较好路径: 按照某种指标较小的路径 </li><li>指标:站数, 延迟,费用,队列长度等, 或者是一些单纯指标的加权平均 </li><li>采用什么样的指标,表示网络使用者希望网络在什么方面表现突出,什么指标网络使用者比较重视</li></ul></li></ul></li><li><p>以<strong>网络</strong>为单位进行路由（路由信息通告+路由计算） </p><ul><li>也即路由信息以子网为单位进行计算</li><li>前提条件是：一个网络所有节点地址前缀相同，且物理上聚集 </li><li>路由就是：找到一个子网到另一个子网最好的路径，也就是找到一个路由器到另一个路由器最好的路径，也就是找到了一个子网中的所有主机到另一个子网的所有主机的路径</li></ul></li><li><p>网络到网络的路由= 路由器-路由器之间路由</p><ul><li>网络对应的路由器到其他网络对应的路由器的路由</li><li>在一个网络中：路由器-主机之间的通信，由链路层负责解决</li><li>到了这个路由器就是到了这个网络</li><li>这里的网络应当就是一个子网。（子网里面没有其他路由器了，子网只有一个路由器和若干主机）</li></ul></li></ul><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><ul><li><p>网络图<br>  <img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-08-57-55.png"></p></li><li><p>路由的输入：拓扑、边的代价、源节点    </p></li><li><p>输出的输出：源节点的汇集树</p><ul><li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-08-58-45.png"></li></ul></li><li><p>sink tree 汇集树</p><ul><li>此节点到所有其它节点的最优路径形成的树</li><li>路由选择算法就是为所有路由器找到并使用汇集树<blockquote><p><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-00-47.png"></p></blockquote></li></ul></li></ul><h4 id="路由原则"><a href="#路由原则" class="headerlink" title="路由原则"></a>路由原则</h4><ul><li>正确性(correctness):算法必须是正确的和完整的,使分组一站一站接力，正确发向目标站；完整：目标所有的站地址，在路由表中都能找到相应的表项；没有处理不了的目标站地址；</li><li>简单性(simplicity):算法在计算机上应简单：最优但复杂的算法，时间上延迟很大，不实用，不应为了获取路由信息增加很多的通信量；</li><li>健壮性(robustness):算法应能适应通信量和网络拓扑的变化：通信量变化，网络拓扑的变化算法能很快适应；不向很拥挤的链路发数据，不向断了的链路发送数据</li><li>稳定性(stability)：产生的路由不应该摇摆</li><li>公平性(fairness)：对每一个站点都公平</li><li>最优性(optimality)：某一个指标的最优，时间上，费用上，等指标，或综合指标；实际上，获取最优的结果代价较高，可以是次优的</li></ul><h4 id="routing-algorithm"><a href="#routing-algorithm" class="headerlink" title="routing algorithm"></a>routing algorithm</h4><ul><li>按照集中式和分布式来区分<ul><li>centralized outing algorithm 集中式路由选择算法<ul><li>该算法以所有结点的连通性以及所有链路开销作为输入</li><li>这种具有全局状态信息的算法被称为 <strong>链路状态 (Link State , LS)算法</strong></li></ul></li><li>decentralized rouing algorithm 分散式路由选择算法<ul><li>每个节点仅有预期直接相连链路的开销 即可开启工作</li><li>迭代地与邻居交换路由信息、计算路由信息</li><li>没有节点拥有关于所有网络链路开销的完整信息</li><li>例子 : <strong>距离向量算法(Distance-Vector , DS)</strong></li></ul></li></ul></li></ul><ul><li>按照静态或者动态的区分<ul><li>静态: 路由随时间变化缓慢<ul><li>非自适应算法(non-adaptive algorithm)：不能适应网络拓扑和通信量的变化,路由表是事先计算好的</li></ul></li><li>动态: 路由变化很快<ul><li>周期性更新 </li><li>根据链路代价的变化而变化</li><li>自适应路由选择(adaptive algorithm)：能适应网络拓扑和通信量的变化</li></ul></li></ul></li></ul><h5 id="LS"><a href="#LS" class="headerlink" title="LS"></a>LS</h5><p>略<br>Dijkstra算法 – 链路状态算法<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-01-28-21-54-15.png"><br>链路状态分组 ：任何一个节点 其链路状态分组为 她到周边有哪些邻居，以及到这些邻居的代价。也就是邻接矩阵的出向边？<br>然后将链路状态分组泛红 我将我的链路状态告诉我的邻居 邻居们将我的链路状态告诉邻居的邻居</p><h5 id="DV"><a href="#DV" class="headerlink" title="DV"></a>DV</h5><p>略</p><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><h2 id="因特网中自治系统内部-AS-的路由选择"><a href="#因特网中自治系统内部-AS-的路由选择" class="headerlink" title="因特网中自治系统内部(AS)的路由选择"></a>因特网中自治系统内部(AS)的路由选择</h2><h3 id="RIP-Routing-Information-Protoco"><a href="#RIP-Routing-Information-Protoco" class="headerlink" title="RIP , Routing Information Protoco"></a>RIP , Routing Information Protoco</h3><p>略</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>略</p><h2 id="ISP之间的路由选择-BGP"><a href="#ISP之间的路由选择-BGP" class="headerlink" title="ISP之间的路由选择 : BGP"></a>ISP之间的路由选择 : BGP</h2><p>略</p><h2 id="SDN控制平面"><a href="#SDN控制平面" class="headerlink" title="SDN控制平面"></a>SDN控制平面</h2><ul><li><p>SDN控制平面的工作室 计算、管理和安装所有网络交换机中的流表项</p></li><li><p>互联网络网络层：</p><ul><li>传统方式：历史上都是通过分布式、每个路由器的实现<ul><li>单个路由器包含了：交换设备硬件、私有路由器OS（如：思科IOS）和其上运行的互联网标准协议(IP, RIP, IS-IS, OSPF, BGP)的私有实现</li><li>需要不同的中间盒来实现不同网络层功能：防火墙，负载均衡设备和NAT…</li><li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-24-59.png"></li></ul></li><li>SDN : 一种集中式<ul><li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-25-41.png"></li></ul></li></ul></li><li><p>为什么需要一个逻辑上集中的控制平面?</p><ul><li>网络管理更加容易<ul><li>避免路由器的错误配置，对于通信流的弹性更好</li></ul></li><li>基于流表的转发（回顾一下OpenFlow API)，允许“可编程”的路由器<ul><li>集中式“编程”更加容易：集中计算流表然后分发</li><li>传统方式分布式“编程”困难：在每个单独的路由器上分别运行分布式的算法，得到转发表（部署和升级代价低） <ul><li>而且要求各分布式计算出的转发表都得基本正确</li></ul></li><li>控制平面的开放实现（非私有）<ul><li>新的竞争生态</li></ul></li></ul></li></ul></li></ul><h3 id="SDN特点"><a href="#SDN特点" class="headerlink" title="SDN特点"></a>SDN特点</h3><p>自顶向下P265</p><ul><li>基于流的转发<ul><li>SDN控制的交换机的分组转发工作，能供基于运输层、网络层和链路层的任意数量首部字段进行.(路由器传统转发仅仅依据网络层的目的IP地址进行)</li></ul></li><li>数据平面和控制平面分离<ul><li>数据平面由分组交换机组成,根据流表执行匹配加动作的规则</li><li>控制平面由SDN控制器和SDN网络控制应用程序</li><li><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-45-57.png"></li></ul></li><li>网络控制功能：位于数据平面交换机外部</li><li>可编程的网络<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-30-08.png"></li></ul><h3 id="SDN架构"><a href="#SDN架构" class="headerlink" title="SDN架构"></a>SDN架构</h3><p>P266</p><p><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-45-40.png"></p><h4 id="数据平面的分组交换机"><a href="#数据平面的分组交换机" class="headerlink" title="数据平面的分组交换机"></a>数据平面的分组交换机</h4><ul><li>快速，简单，商业化交换设备,采用硬件实现通用转发功能</li><li>分组交换机的流表被控制器计算和安装</li><li>SDN控制器通过南向API（例如OpenFlow）访问基于流的交换机 </li></ul><h4 id="SDN控制器"><a href="#SDN控制器" class="headerlink" title="SDN控制器"></a>SDN控制器</h4><ul><li>维护网络状态信息</li><li>通过上面的北向API和网络控制应用交互</li><li>通过下面的南向API和网络交换机交互</li><li>逻辑上集中，但是在实现上通常由于性能、可扩展性、容错性以及鲁棒性采用分布式方法实现</li><li>SDN控制器组成<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-09-48-07.png"></li></ul><h4 id="SDN网络控制应用程序"><a href="#SDN网络控制应用程序" class="headerlink" title="SDN网络控制应用程序"></a>SDN网络控制应用程序</h4><ul><li>控制的大脑： 采用下层提供的服务（SDN控制器提供的API)，实现如下网络功能<ul><li>路由器 交换机</li><li>接入控制 防火墙</li><li>负载均衡</li><li>其他功能</li></ul></li><li>非绑定：SDN网络控制应用程序可以被第三方提供，与控制器厂商以通常上不同，与数据平面分组交换机厂商也可以不同</li></ul><h3 id="OpenFlow"><a href="#OpenFlow" class="headerlink" title="OpenFlow"></a>OpenFlow</h3><p>P268</p><ul><li>OpenFlow协议 <ul><li>是控制器和SDN交换机交互的协议</li><li>运行在SDN控制器和SDN控制的交换机或其他实现OpenFlowAPI的设备上</li><li>基于TCP</li></ul></li><li>控制器到交换机的重要报文如下<ul><li>特性：控制器查询交换机特性，交换机应答</li><li>配置：交换机查询/设置交换机的配置参数</li><li>修改状态：增加删除修改OpenFlow表中的流表</li><li>发送分组 packet-out：控制器可以将分组通过特定的端口发出<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-10-07-07.png"></li></ul></li><li>一些关键的交换机到控制器的报文<ul><li>分组进入: 将分组（和它的控制）传给控制器，见来自控制器的packet-out报文</li><li>流移除: 在交换机上删除流表项</li><li>端口状态: 通告控制器端口的变化<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-10-07-20.png"></li></ul></li></ul><h3 id="SDN控制平面-数据平面交互例子"><a href="#SDN控制平面-数据平面交互例子" class="headerlink" title="SDN控制平面-数据平面交互例子"></a>SDN控制平面-数据平面交互例子</h3><p>P269</p><ul><li><ol><li>交换机s1,经历了与s2的链路失效，采用OpenFlow”端口状态报文”通告控制器链路状态的更新</li></ol></li><li><ol start="2"><li>SDN 控制器接收OpenFlow报文，更新链路状态信息</li></ol></li><li><ol start="3"><li>Dijkstra路由算法应用被调用（前面注册过这个状态变化消息）</li></ol></li><li><ol start="4"><li>Dijkstra路由算法访问控制器中的网络拓扑信息，链路状态信息计算新路由</li></ol></li><li><ol start="5"><li>链路状态路由app和SDN控制器中流表计算元件交互，计算出新的所需流表</li></ol></li><li><ol start="6"><li>控制器采用OpenFlow在交换机上安装新的需要更新的流表<br><img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-10-07-59.png"></li></ol></li></ul><h2 id="ICMP-Internet-Control-Message-Protocol"><a href="#ICMP-Internet-Control-Message-Protocol" class="headerlink" title="ICMP : Internet Control Message Protocol"></a>ICMP : Internet Control Message Protocol</h2><ul><li>ICMP协议 , 用于主机、路由器、网关用于传达网络层控制信息 <ul><li>最典型用途 : <ul><li>错误报告 :</li><li>如运行http会话时，可能会遇到”目的网络不可达”之类的错误报文.</li><li>这种报文源于ICMP.</li><li>在某个位置，IP路由器不能找到一条通往和http请求种所指定的主机的路径，该路由器就会像你的主机生成并发送一个ICMP报文以指示该错误.</li></ul></li></ul></li><li>ICMP处在网络层，但是在IP协议的上面 <ul><li>ICMP消息由IP数据报承载</li></ul></li><li>ICMP 报文: 类型 + 编码 + (第一个导致该ICMP报文生成的)IP数据报的头8Byte<br>  <img src="/2023/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/2023-02-05-11-03-38.png"></li></ul><h3 id="TraceRoute"><a href="#TraceRoute" class="headerlink" title="TraceRoute"></a>TraceRoute</h3><ul><li><p>Traceroute ： 通过udp(源主机) 和 ICMP(路由器) 实现</p><ul><li>源主机发送udp segment，接收 icmp 报文段.</li></ul></li><li><p>源主机运行Traceroute , 发送一系列具有不可达UDP端口号的UDP报文段给目标主机 , 并为每个数据报开启定时器. </p><ul><li>第一个：TTL =1 , 第二个： TTL=2, etc.</li><li>当nth数据报到达nth路由器<ul><li>路由器观察到该数据过期，根据IP协议，路由器抛弃数据报 ,然后发送一个给源的ICMP报文 (type 11, code 0) . 报文包括了路由器的名字和IP地址 . </li></ul></li><li>当ICMP报文返回给源主机，源主机通过定时器计算RTT（往返时延），并从icmp报文种获得第n台路由器的名字和ip</li></ul></li><li><p>源主机何时停止发送udp报文段</p><ul><li>最终有一个数据报沿着这条路到达目的主机</li><li>因为该数据报包含了一个具有不可达端口号 UDP 报文段，该目的主机会向源发送一个端口不可达的 ICMP 报文(type 3 code 3) </li><li>当源主机收到这个特别的 ICMP 报文时，就不再发送另外的探测分组</li></ul></li></ul><h2 id="网络管理和SNMP"><a href="#网络管理和SNMP" class="headerlink" title="网络管理和SNMP"></a>网络管理和SNMP</h2><p>略</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;记得不多，好多都略.&lt;br&gt;网络层-控制平面&lt;br&gt;路由选择算法（LS，DV，RIP，OSPF，BGP）&lt;br&gt;SDN控制平面简介&lt;br&gt;ICMP简介&lt;/p&gt;</summary>
    
    
    
    <category term="计网" scheme="http://example.com/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式-论文学习-mapreduce</title>
    <link href="http://example.com/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/"/>
    <id>http://example.com/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/</id>
    <published>2023-01-20T08:09:04.000Z</published>
    <updated>2023-02-27T09:42:23.802Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p><span id="more"></span><p><a href="https://zhuanlan.zhihu.com/p/391197032">go plugin</a></p><p><a href="http://c.biancheng.net/view/4281.html">go断言</a><br>在Go语言中类型断言的语法格式如下：<br>value, ok := x.(T)</p><p>其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。</p><p>该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：<br>如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。<br>如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。<br>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。</p><p><a href="https://cloud.tencent.com/developer/article/1825053">go sort</a></p><p><a href="https://www.cnblogs.com/xiaobaiskill/p/10648179.html">go package使用</a></p><p><a href="https://juejin.cn/post/6975144762818953246#heading-0">go httpserver</a></p><p>一开始 : 只有一个进程,不涉及分布式<br>main/mrsequential.go<br>借助wc.go<br>执行map和reduce<br>来统计*.txt<br>结果输出到more-out-0</p><p>lab1 : </p><p>mapreduce框架要完成的是何时以何种方式使用用户编写的map和reduce函数达到分布式解决问题的目的</p><p>user的map和reduce : mrapps/wc.go</p><p>mapreduce框架的<br>    master 进程 : main/mrmaster.go<br>        master具体代码 : mr/master.go<br>    worker 进程 : main/mrworker.go<br>        worker具体代码 : mr/worker.go</p><p>gob error encoding body: gob: type mr.TaskReply has no exported fields<br>定义rpc调用所需的数据结构时，其首字母没有大写，导致外部程序无法访问</p><p>使用go时，以大写字母开头的字段和变量将被”导出”，并且对其他包可见。 以小写字母开头的字段是”未导出”的，并且仅在其自己的包中可见。<br>encoding / gob包依赖于反射来编码值，并且只能看到导出的struct字段。<br>为了使事情变得可编码，请在您的stateNode结构中将要保存的每个字段名称的首字母大写</p><p><a href="https://blog.csdn.net/wang545054788/article/details/112991515">https://blog.csdn.net/wang545054788/article/details/112991515</a></p><p>关于包级的变量名和函数名，小写相当于private 大写则是public ?</p><p>每个worker都可以执行map和reduce工作，一种比较靠谱和简单的实现方式是让worker向master请求工作，由master决定分配什么工作给该worker</p><p>注意的是，以后每次修改mr下的代码后都要重新编译wc.go -&gt; wc.so</p><p>worker 和 master 其所使用的tsak都是同步的吗？是同一个吗？当然不是同一个吗。都不是一个进程 甚至不是一个机器。那么是同步的吗？</p><p>map 和 reduce 的代码 即函数代码 是在worker端的<br>但是执行任务的元数据 以及何时执行什么任务 是在master端的</p><p>目前的实现 最终是服务端正常退出 客户端是异常退出了<br>退出时机：服务端分发完全部reduce任务 并客户端都已经确定完成。客户端最后一次调用RPCReqest 请求不到任务的。服务端对此是server thread的一个协程（那也就是那个thread在一直loop)在一直loop<br>main thread 通过isDone看到符合退出条件 故直接exit<br>那么server thread也随之exit</p><p>客户端此时仍在rpc的call等待，server端异常退出 ，由tcp协议可知，server会发送fin flag，client端的应用层会看到eof。rpc的call返回。<br>得到一个全是默认值的TaskReply。<br>会匹配到DoMapTask 会利用其中信息open文件 由于文件不存在 故异常退出<br>明天看看能不能优化成正常退出</p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-09-45.png"></p><p>需要内存过多，一台机器上的内存解决不了。于是 解决方案：mapreduce</p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-10-58.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-15-33.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-18-54.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-19-05.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-19-27.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-19-59.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-25-52.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-27-04.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-27-49.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-32-52.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-32-59.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-34-06.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-38-53.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-39-02.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-44-09.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-44-59.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-45-53.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-45-59.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-46-11.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-46-23.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-20-16-47-18.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-18-26.png"></p><p>如果你可以在不构建分布式系统的情况下 通过在一台已知的计算机上解决该问题<br>那么就应该采用这种方式</p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-18.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-29.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-38.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-45.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-19-59.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-20-05.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-20-24.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-21-13.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-21-19.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-22-18.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-11-23-53.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-49-43.png"></p><p>mapreduce 是一种计算系统<br>存储，通信，计算</p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-51-03.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-51-24.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-51-32.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-51-37.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-32.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-40.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-46.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-50.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-53-58.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-01.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-03.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-06.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-08.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-12.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-16.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-33.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-36.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-40.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-54-43.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-55-10.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-55-26.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-55-32.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-56-16.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-20-56-25.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-11-17.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-11-50.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-12-05.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-13-08.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-13-14.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-16-41.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-16-48.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-16-53.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-16-57.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-17-04.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-17-10.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-17-20.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-23-22.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-24-14.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-24-17.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-24-38.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-27-31.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-40-53.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-41-39.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-21-42-11.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-03-32.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-04-05.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-05-08.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-05-17.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-07-53.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-08-01.png"><br><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-08-07.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-08-19.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-21-22-12-16.png"></p><p>—————mapreduce———</p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-22-09-14-14.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-22-09-20-10.png"></p><p><img src="/2023/01/20/%E5%88%86%E5%B8%83%E5%BC%8F-%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0-mapreduce/2023-01-22-09-29-07.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TODO&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络-网络层</title>
    <link href="http://example.com/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://example.com/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2023-01-19T04:03:30.000Z</published>
    <updated>2023-02-27T15:24:20.048Z</updated>
    
    <content type="html"><![CDATA[<p>网络层-数据平面<br>路由器、IP协议(格式、IP分片、DHCP、NAT)<br>数据平面转发分为两类：基于目的地转发和通用转发. 通用转发涉及SDN<br>二者都是 匹配加动作 原则</p><p>参考 《自顶向下》《中科大》</p><span id="more"></span><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><ul><li>网络层的连接和传输层的连接不一样<ul><li>传输层tcp的连接只是体现在端系统,所以称为面向连接</li><li>网络层的连接 不仅在端系统,在中间的路由器上,也维护了通信的状态所以称为有连接</li><li>也即 运输层只存在于网络边缘（端点）（主机）, 网络层存在于网络边缘（每一台主机）和网络中心（路由器）上</li></ul></li></ul><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-09-28-07.png"></p><p>注 : </p><ul><li><ol><li>很多人互换的使用 转发 和 交换 这两个术语</li></ol></li><li><ol start="2"><li>约定 <strong>分组交换机</strong> 指 通用分组交换设备. 功能：根据分组首部字段的值，将分组从从输入链路接口转移到输出链路接口. </li></ol><ul><li>其中有两种分组交换机<ul><li><strong>链路层交换机</strong>(linker-layer switch)<ul><li>链路层的分组交换机(链路层/第二层设备)</li><li>基于链路层帧中的字段值进行转发</li></ul></li><li><strong>路由器</strong>(router) <ul><li>网络层的分组交换机 (网络层/第三层设备)</li><li>基于网络层数举报的首部字段值进行转发</li></ul></li></ul></li></ul></li></ul><p>分组交换器 其实应该叫分组路由器<br>交换器是对数据链路层的帧来说的。<br>所以说名字起的不好</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>网络层作用从整体来看为：将分组从一台发送主机移动到另一台接收主机</li><li>为此，网络层实现了两方面的重要功能：数据平面和控制平面</li></ul><p>路由表 是 数据功能和控制功能的粘合剂<br>控制平面的功能体现在最后的结果：路由表<br>路由表交给ip协议<br>ip协议根据路由表对到来的分组做转发，实现数据平面功能</p><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><p>数据平面</p><ul><li><strong>转发 forwarding</strong><ul><li>是每个路由器本地的功能</li><li>IP协议实现转发功能(局部) : IP协议根据forwarding table 将分组从路由器的输入接口转发到合适的输出接口</li><li><strong>转发方式</strong><ul><li><strong>传统</strong>：基于目标地址+转发表(forwarding table) </li><li><strong>通用转发</strong>：基于多个字段+流表 </li></ul></li><li>转发是在数据平面唯一实现的功能</li><li>转发的时间尺度很短(几ns), 通常用硬件实现</li></ul></li></ul><h4 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h4><p>控制平面</p><ul><li><strong>路由选择 routing</strong><ul><li>路由选择协议实现了路由功能(全局)<ul><li>路由选择算法 决定数据报如何在路由器之间路由 ; 决定分组从发送主机到目标接收主机的路径</li></ul></li><li><strong>路由选择算法 routing algorithm</strong><ul><li><strong>传统路由选择算法: 在路由器中实现</strong><ul><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-18-44.png"><ul><li>数据平面传统转发 &amp;&amp; 控制平面传统路由选择</li></ul></li><li>路由选择算法routing algorithm运行在每台路由器中,<strong>每台路由器中都包含 forwarding转发 和 routing路由选择 两种功能</strong></li><li>一台路由器的routing algorithm路由选择算法与其他路由器中的routing algorithm交互，以计算出其forwarding table的值</li></ul></li><li><strong>Software-Defined Networking SDN : 在远程服务器实现</strong><ul><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-11-05-42.png"><ul><li>数据平面通用转发 + 控制平面SDN控制</li></ul></li><li>与传统方式不同（各个路由器运行路由选择算法并彼此通信），控制平面或许有其他方来填写数据平面的forwarding table。<ul><li>控制平面将路由选择功能从路由器中分离，由远程服务器负责</li></ul></li><li><strong>远程服务器承担路由选择功能：计算和分发转发表给路由器</strong></li><li><strong>路由器只承担数据平面的转发功能</strong></li><li>路由器和远程控制器交换包含转发表和其他路由选择信息的报文进行通信。</li><li>为什么叫Software-Defined : 因为计算forwarding table进而与router交互的控制器由软件实现。</li></ul></li></ul></li><li>路由器采用的 路由转发算法 决定了 forwarding table 的内容(传统和sdn符合这句话?)</li><li>路由选择的时间尺度较长(几s), 通常用软件实现</li></ul></li></ul><h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><ul><li><p>从发送方主机到接收方主机传输数据报的“通道” , 网络提供什么样的服务模型？</p><ul><li>感觉就是网络层对运输层做出的保证</li></ul></li><li><p>对于单个数据报的服务</p><ul><li>可靠传送</li><li>延迟保证，如：少于40ms的延迟</li></ul></li><li><p>对于数据报流的服务:</p><ul><li>保序数据报传送</li><li>保证流的最小带宽</li><li>分组之间的延迟</li></ul></li><li><p>连接建立 : 在某些网络架构中是第三个重要的功能</p><ul><li>在分组传输之前，在两个主机之间，在通过一些路由器所构成的路径上建立一个网络层连接<ul><li>涉及到路由器</li></ul></li><li>网络层和传输层连接服务区别:<ul><li>网络层: 在2个主机之间，涉及到路径上的一些路由器</li><li>传输层: 在2个进程之间，只体现在端系统上(TCP连接)</li></ul></li></ul></li><li><p>Internet 因特网的网络层提供服务：<strong>best-effort service 尽力而为</strong></p><ul><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-12-07-05.png"></li></ul></li></ul><p>ip网络没有连接建立的功能，有些网络提供了连接建立功能<br>ip网络向上层提供转发功能 ：ip协议（数据功能），路由选择协议（控制功能）</p><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-09-18-22.png"></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><ul><li>高层面(非常简化的)通用路由器体系架构<ul><li>路由：运行路由选择算法／协议 (RIP, OSPF, BGP)-生成路由表</li><li>转发：从输入到输出链路交换数据报-根据路由表进行分组的转发</li><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-12-52-24.png"></li></ul></li></ul><h3 id="输入端口处理-基于目的地转发"><a href="#输入端口处理-基于目的地转发" class="headerlink" title="输入端口处理 + 基于目的地转发"></a>输入端口处理 + 基于目的地转发</h3><ul><li><strong>输入端口重要功能</strong>:(look up forwarding table)查找转发表，决定分组的输出端口<ul><li>转发表由路由选择处理器生成<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-14-52-02.png"></li></ul></li></ul><ul><li><strong>输入端口缓存</strong><ul><li>当交换机构的速率小于输入端口的汇聚速率时， 在输入端口可能要排队<ul><li><strong>排队延迟以及由于输入缓存溢出会造成丢失!</strong></li></ul></li><li>Head-of-the-Line (HOL) blocking: 排在队头的数据报阻止了队列中其他数据报向前移动<ul><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-15-45-13.png"></li></ul></li></ul></li></ul><ul><li><p><strong>匹配加动作</strong></p><ul><li>匹配：输入端口查找目的IP，</li><li>动作：输入端口将分组送入交换结构(差不多就是转发)</li><li>是一种匹配加动作的特定情况</li></ul></li><li><p><strong>routing processor 路由选择处理器</strong></p><ul><li>传统路由器中，routing processor 执行路由选择协议</li><li>SDN路由器中，routing processor 与远程控制器通信</li></ul></li></ul><h4 id="基于目的地转发"><a href="#基于目的地转发" class="headerlink" title="基于目的地转发"></a>基于目的地转发</h4><p><strong>关于转发</strong></p><ul><li><strong>基于目的地转发</strong> : 只依赖IP数据报的目标IP地址这一个因素，来决定分组的输出端口。<ul><li>前缀匹配（且是最长前缀匹配）<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-02-09-08-23-34.png"> -&gt;<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-02-09-08-24-03.png"></li></ul></li></ul><h4 id="通用转发-见后文"><a href="#通用转发-见后文" class="headerlink" title="通用转发 (见后文)"></a>通用转发 (见后文)</h4><ul><li><strong>通用转发</strong></li></ul><h3 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h3><ul><li><p>将分组从输入缓冲区传输到合适的输出端口</p></li><li><p>交换速率：分组可以按照该速率从输入传输到输出</p><ul><li>运行速度经常是输入/输出链路速率的若干</li><li>N 个输入端口：交换机构的交换速度是输入线路速度的N倍比较理想，才不会成为瓶颈</li></ul></li><li><p>典型交换结构</p><blockquote><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-15-50-02.png"></p></blockquote></li><li><p>经内存交换…</p></li><li><p>经总线交换…</p></li><li><p>经互联网交换…</p></li></ul><h3 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h3><ul><li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-15-59-04.png"></p></li><li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-01-20.png"></p></li><li><p>当数据报从交换机构的到达速度比传输速率快,就需要输出端口缓存</p></li><li><p>排队带来延迟，由于输出端口缓存<strong>溢出</strong>则<strong>丢弃</strong>数据报</p></li><li><p>由调度规则选择排队的数据报进行传输</p></li><li><p><strong>调度机制</strong></p><ul><li>调度: 选择下一个要通过链路传输的分组</li><li>FIFO (first in first out) scheduling:<ul><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-06-04.png"> </li><li>按照分组到来的次序发送 </li><li>丢弃策略: 如果分组到达一个满的队列，哪个分组将会被抛弃?<ul><li>tail drop: 丢弃刚到达的分组</li><li>priority: 根据优先权丢失/移除分组</li><li>random: 随机地丢弃/移除</li></ul></li></ul></li><li>Priority Queuing 优先权调度：<ul><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-13-34.png"></li><li>发送最高优先权的分组</li><li>多类，不同类别有不同的优先权 <ul><li>类别可能依赖于标记或者其他的头部字段, e.g. IP source/dest, port numbers, ds，etc. </li><li>先传高优先级的队列中的分组</li></ul></li></ul></li><li>Round Robin Queuing Discipline 循环排队规则<ul><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-13-02.png"></li><li>循环扫描不同类型的队列, 发送完一类的一个分组，再发送下一个类的一个分组，循环所有类</li></ul></li><li>Weighted Fair Queuing (WFQ)<ul><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-15-41.png"></li><li>一般化的Round Robin</li><li>在一段时间内，每个队列得到的服务时间是：Wi/(XIGMA(Wi)) *t，和权重成正比</li><li>每个类在每一个循环中获得不同权重的服务量</li></ul></li></ul></li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><ul><li>主机、路由器中的网络层功能<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-30-49.png"></li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-16-31-16.png"></p><ul><li><p>length 数据报长度 : IP数据报总长度（首部+数据）。单位字节。</p></li><li><p>identifier 标识 , flags 标志 , fragment offset 片偏移 : 与ip分片有关</p></li><li><p>time to live : 允许经过的路由器数</p></li><li><p>upper layer : 指示数据部分的协议，仅当ip数据报到达最终目的地时才有效</p></li><li><p>check sum 首部检验和 : 帮助路由器检测ip数据报的比特错误</p><ul><li>路由器会丢弃检测出错误的数据报</li><li>为什么tcp/ip在运输层和网络层都进行差错检测 ?<ul><li><ol><li>ip层只对ip首部进行检验，而tcp/udp是对整个tcp/ucp报文进行检测的。</li></ol></li><li><ol start="2"><li>ip不一定和tcp/udp在同一协议栈上</li></ol></li></ul></li></ul></li><li><p>source ip , des ip : ip字段在ip报文首部，port字段在tcp/udp报文首部</p></li><li><p>data : tcp/udp segment , icmp segment</p></li><li><p>IP数据报传输TCP段 由器的列表.时头部有多少?</p><ul><li>20 bytes of TCP +</li><li>20 bytes of IP +</li><li>app layer overhead</li></ul></li></ul><h3 id="IPv4数据报分片-和-重组"><a href="#IPv4数据报分片-和-重组" class="headerlink" title="IPv4数据报分片 和 重组"></a>IPv4数据报分片 和 重组</h3><ul><li><p>路由器进行分片，目的主机进行重组</p></li><li><p>Max Transmission Unit , MTU (最大传输单元) </p><ul><li>链路层帧所携带的最大数据长度 </li><li>不同的链路类型有不同的MTU</li></ul></li><li><p>大的IP数据报在网络上被分片(“fragmented”) </p><ul><li>一个数据报被分割成若干个小的数据报 </li><li>“重组”只在最终的目标主机进行 </li><li>IP头部的信息片偏移被用于标识，排序相关分片 <ul><li>identifier 标识 : 同一数据报的切片具有相同的ID</li><li>flags 标志 : 同一数据报的最后一个切片的flags标志字段置为0</li><li>fragment offset : 代表该切片的ip载荷部分的第一个字节，在整个ip数据报的载荷部分的位置</li></ul></li></ul></li><li><p>例子<br>  <img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-17-39-49.png"></p></li></ul><h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><ul><li>IP地址: 网络设备(包括主机,路由器)和网络的接口的标识<ul><li>一个IP地址和一个接口相关联</li><li>接口: 主机/路由器和物理链路的连接处 <ul><li>路由器通常拥有多个接口(路由器和不同网络的接口 ; 路由器至少有两个ip地址，否则路由器没有办法在网络之间进行分组转发) </li><li>主机也有可能有多个接口(只不过这多个接口很可能都是主机和同一网络的接口)</li><li>IP地址和每一个接口关联</li></ul></li><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-17-52-58.png"></li></ul></li></ul><p>主机有一个ip地址即可，也可以有多个ip地址。</p><blockquote><p>Q: 这些接口是如何连接的?<br>A: 我们将会在第5，6章学习<br>前：无需担心一个接口是如何<br>接到另外一个接口 (中间没有路由器)</p></blockquote><p>网络内部 ip之间如何进行分组的发送和接收？— 帧 – 交换机 — 数据链路层</p><h4 id="子网-Subnets"><a href="#子网-Subnets" class="headerlink" title="子网 Subnets"></a>子网 Subnets</h4><ul><li>IP地址:<ul><li>子网部分(高位bits)</li><li>主机部分(地位bits) </li></ul></li><li><strong>什么是子网(subnet)</strong> ?<ul><li>一个子网内的节点（主机或者路由器）它们的<strong>IP地址的高位部分相同</strong>，这些节点构成的网络的一部分叫做子网</li><li>子网内<strong>无需路由器介入</strong>，子网内各主机可以在物理上相互直接到达</li><li>一个子网的ip定义并不局限于多台主机到一个路由器接口的以太网段</li></ul></li></ul><ul><li><strong>判断子网</strong>:<ul><li>要判断一个子网, 将每一个接口(ip)从主机或者路由器上分开,构成了一个个网络的孤岛</li><li>每一个孤岛（网络）都是一个都可以被称之为subnet.</li><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-20-01-59.png"></li><li>223.1.1.0/24 223.1.2.0/24 223.1.3.0/24 223.1.8.0/24 223.1.7.0/24 223.1.9.0/24</li></ul></li></ul><h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><p>一种分类编址 classful addressing</p><ul><li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-20-12-50.png"></p><ul><li>A: <ul><li>0.0.0.0 - 127.255.255.255 ; </li><li>126 networks ，16777214 hosts ; </li><li>mask 255.0.0.0</li></ul></li><li>B: <ul><li>128.0.0.0 - 191.255.255.255 ; </li><li>16382networks ，65534 hosts ; </li><li>mask 255.255.0.0</li></ul></li><li>C : <ul><li>192.0.0.0 - 223.255.255.255 ; </li><li>2 million networks ，254 hosts ; </li><li>mask 255.255.255.0</li></ul></li><li>D : <ul><li>224.0.0.0 - 239.255.255.255 ; </li><li>multicast</li></ul></li><li>E : <ul><li>240.0.0.0 - 247.255.255.255 ; </li><li>reserved for future</li></ul></li></ul></li><li><p>可以看出ABC三类地址分为网络号和主机号</p><ul><li>特殊ip地址<ul><li>主机号全为 1 : 广播地址,该网络下的所有主机</li><li>主机号全为 0 : 指定本主机<ul><li>故计算网络内最大主机数 = 2^(主机号位数) - 2</li></ul></li><li>子网部分全为 0 : 本网络</li><li><blockquote><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-20-57-02.png"></p></blockquote></li><li><strong>回路地址/测试地址</strong><ul><li>127开头的ip地址为回路地址：127.x.x.x 如常见的127.0.0.1</li><li>目标地址为127.x.x.x的不会发送出网卡，到网络层监测到ip为回环地址后就直接将数据包返回到运输层</li><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-19-16-09-26.png"></li></ul></li><li>子网内的广播地址 : 255.255.255.255(理论依据呢 ?)</li><li>本机地址 : 0.0.0.0(理论依据呢 ?)</li></ul></li></ul></li><li><p>ABC三类地址中，一部分为专用ip，一部分为公用ip</p><ul><li>内网IP = 专用IP = 私有IP</li><li>私有ip只在局域网中有意义，不会出现在公网中</li><li>路由器不对目标地址是私有ip的分组进行转发</li><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-20-30-37.png"><ul><li>其中A mask为 255.0.0.0 ；B mask 255.255.0.0 ; C mask 255.255.255.0 </li></ul></li><li>那么易知，我租的服务器的ip为114.132.58.229，显然是A中的公有ip ; 易知虚拟机ifconfig看到的192.168.147.162，显然是C的私有ip ; wsl ifconfig看到的172.17.247.46，显然是B的私有ip</li></ul></li></ul><ul><li>而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E 类是预留的分类，暂时未使用。<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-09-43-41.png"></li></ul><h4 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h4><ul><li>CIDR : Classless InterDomain Routing. 无分类地址 也叫 无类域间路由<ul><li>子网部分和主机部分可以在任意的位置临界</li><li>地址格式 : a.b.c.d/x , x为子网号长度</li><li><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-21-20-29.png"></li><li>因特网的地址分配策略是CIDR</li></ul></li></ul><h4 id="子网掩码-subnet-mask"><a href="#子网掩码-subnet-mask" class="headerlink" title="子网掩码 subnet mask"></a>子网掩码 subnet mask</h4><ul><li>32bits ,0 or 1 in each bit<ul><li><strong>1: bit位置表示子网部分</strong> </li><li><strong>0: bit位置表示主机部分</strong></li></ul></li><li>原始的A、B、C类网络的子网掩码分别是 <ul><li>A：255.0.0.0 ：11111111 00000000 0000000 00000000 </li><li>B：255.255.0.0：11111111 11111111 0000000 00000000 </li><li>C：255.255.255.0：11111111 11111111 11111111 00000000</li></ul></li><li>CIDR下的子网掩码例子：<ul><li>11111111 11111111 11111100 0000000</li></ul></li><li>也可通过/x表示子网掩码<ul><li>如子网掩码为223.1.1.0/24<ul><li>意味着高24bit地址定义了子网地址. 任何其他要求接入223.1.1.0/24 网络的主机都要求具有223.1.1.xxx的形式</li></ul></li></ul></li></ul><h4 id="转发表和转发算法"><a href="#转发表和转发算法" class="headerlink" title="转发表和转发算法"></a>转发表和转发算法</h4><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-27-21-52-41.png"></p><ul><li>已知获得IP数据报的目标地址IP Des addr , 那么对于转发表中的每一个表项<ul><li>如 (IP Des addr) &amp; (mask)== destination, 则按照表项对应的接口转发该数据报</li><li>如果都没有找到,则使用默认表项转发数</li></ul></li></ul><h3 id="如何获得ip地址"><a href="#如何获得ip地址" class="headerlink" title="如何获得ip地址"></a>如何获得ip地址</h3><p>上述学习ipv4编址 那么主机或者子网最初是如何得到他们的地址的 ?</p><ol><li> 组织如何为其设备得到一个ip地址块</li><li> 组织中的设备如何从地址块中获得一个ip地址</li></ol><h4 id="获取一块地址"><a href="#获取一块地址" class="headerlink" title="获取一块地址"></a>获取一块地址</h4><ul><li>组织如何为其设备得到一个地址块 ? 即 如何为子网获取一个ip地址快 即 如何获得一个网络的子网部分（网络号部分 ? ）</li><li>解：从ISP地址块 中 被分配到一个块地址快<br>  <img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-09-40-27.png"></li><li>ISP如何获得地址块 : ICANN<ul><li>分配地址</li><li>管理DNS</li><li>分配域名，解决</li></ul></li></ul><h4 id="获取主机地址-DHCP"><a href="#获取主机地址-DHCP" class="headerlink" title="获取主机地址 : DHCP"></a>获取主机地址 : DHCP</h4><p>组织中的设备如何从地址块中获得一个ip地址</p><ul><li><p>DHCP : Dynamic Host Configuration Protocol 动态主机配置协议</p><ul><li><p>DHCP基于udp</p></li><li><blockquote><p>路由器的ip和主机的ip都可以手工配置，但更好的方法是采用dhcp. dchp允许主机每次接入网络时能得到一个临时的ip地址, 每次接入网络时得到的地址也许是不同的.</p></blockquote></li><li><p>dhcp实例: 主机频繁的加入和离开网络. 如我们在宿舍和在实验室会发现本机的ip地址不同. 就是两次接入网络时dhcp获取的ip不同</p></li><li><p><strong>目标</strong>: 允许主机在加入网络的时候，动态地从服务器那里获得IP地址： </p><ul><li>可以更新对主机在用IP地址的租用期-租期快到了 </li><li>重新启动时，允许重新使用以前用过的IP地址 </li><li>支持移动用户加入到该网络（短期在网）</li></ul></li><li><p>对于一台新到达的主机，DHCP协议分为4步</p><ul><li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-08-56-13.png"></p></li><li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-09-24-25.png"></p></li><li><p><strong>DHCP服务器发现 (寻找DHCP Server)</strong></p><ul><li>为寻找DHCP Server,主机广播 <strong>DHCP发现报文(DHCP discover message)</strong> <ul><li>目的地址 广播 255.255.255.255 </li><li>源地址 本主机0.0.0.0</li></ul></li></ul></li><li><p><strong>DHCP服务器提供 （DHCPServer 给 client推荐ip）</strong></p><ul><li>DHCPServer 广播 <strong>DHCP提供报文(DHCP offer message)</strong><ul><li>目的地址 广播: 255.255.255.255</li><li>源地址 : DHCP Server IP</li><li><strong>内容</strong>  <ul><li>IP 地址 及 租用期</li><li>第一跳路由器的IP地址（默认网关） </li><li>DNS服务器的域名和IP地址 </li><li>子网掩码 </li></ul></li></ul></li></ul></li><li><p><strong>DHCP请求    （client 确认并回显 DHCPServer的推荐）</strong></p><ul><li>主机从多个DHCP服务器中选择一个，并响应。通过发送<strong>DHCP请求报文(DHCP request message)</strong>. 回显配置的参数</li></ul></li><li><p><strong>DHCP ACK （DHCP确认）</strong></p><ul><li>DHCP Server 发送 <strong>DHCP请求确认(DHCP ACK message)</strong> DHCP请求报文</li><li>client收到ack后 交互便完成.</li></ul></li></ul></li><li><p>DHCP 缺陷 :</p><ul><li>每当节点连接到一个新子网，要从DHCP获取一个新的IP地址，当移动节点在子网之间移动时，<strong>不能维持原先的TCP连接</strong>.</li></ul></li><li><blockquote><p>由于dhcp具有将主机连接进一个网络的网络相关方面的自动能力，故被称为即插即用协议(plug-and-play protocol) / 零配置(zeroconf)协议</p></blockquote></li></ul></li><li><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-09-29-08.png"></p></li></ul><h3 id="网络地址转换-Network-Address-Translation"><a href="#网络地址转换-Network-Address-Translation" class="headerlink" title="网络地址转换 Network Address Translation"></a>网络地址转换 Network Address Translation</h3><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-11-08-29.png"><br>NAT 理解: 将内部的专用地址转化成公有唯一地址</p><ul><li><strong>NAT路由器</strong><ul><li>NAT路由器对于外部世界表现得不像一台路由器，而是一台具有单一IP地址的单一设备。<ul><li>本质 : NAT路由器对外界隐藏了子网内的细节</li></ul></li><li>动机: 本地网络只有一个有效IP地址(子网内的设备对外使用同一个ip)<ul><li>不需要从ISP分配一块地址，可用一个IP地址用于所有的（局域网）设备–省钱</li><li>可以在局域网改变设备的地址情况下而无须通知外界</li><li>可以改变ISP（地址变化）而不需要改变内部的设备地址</li><li>局域网内部的设备没有明确的地址，对外是不可见的–安全</li></ul></li></ul></li></ul><ul><li><strong>实现</strong>: NAT 路由器必须:<ul><li>外出数据包：<ul><li>重写源IP和源Port 为NAT IP地址和NAT Port，目标IP和Port不变</li><li>远端的C/S将会用NAT IP地址，新端口号作为目标地址</li></ul></li><li>在NAT转换表中记录对应关系 <ul><li>&lt;NAT IP, NAT Port ; 源IP,源Port &gt;</li><li><strong>NAT转化表 NAT translation table</strong><ul><li>{WAN端IP NATPort} , {LAN端IP SRCPort}</li></ul></li></ul></li><li>进入数据包：<ul><li>重写目标IP和目的Port 为源IP，端口 . (根据NAT table.)<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-12-41-02.png"></li></ul></li></ul></li></ul><ul><li>因为Port为16-bit: <ul><li>故一个局域网内可以至多同时有6万多个同时连接</li></ul></li><li>对NAT是有争议的: <ul><li>路由器只应该对第3层(网络层)做信息处理，而这里对端口号（4层）(应用层作了处理</li><li>违反了end-to-end 原则 <ul><li>端到端原则：复杂性放到网络边缘 <ul><li>使得无需借助中转和变换，就可以直接传送到目标主机 </li></ul></li><li>NAT可能要被一些应用设计者考虑, eg, P2P applications </li><li>外网的机器无法主动连接到内网的机器上(因为) </li></ul></li><li>地址短缺问题可以被IPv6 解决 </li><li>NAT穿越： 如果客户端需要连接在NAT后面的服务器，如何操作 ? </li></ul></li></ul><h4 id="NAT穿越-NAT-traversal"><a href="#NAT穿越-NAT-traversal" class="headerlink" title="NAT穿越 NAT traversal"></a>NAT穿越 NAT traversal</h4><ul><li>问题描述 : client需要连接ip(10.0.0.1)的server(即客户要连接一个位于NAT背后的Server) <ul><li>易知10.0.0.1 为 LAN本地地址 (client不能够使用其作为目标地址) </li><li>整网只有一个外部可见地址: 138.76.29.7<blockquote><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-09-18.png"></p></blockquote></li></ul></li></ul><ul><li>方案1: 静态配置NAT：转发进来的对服务器特定端口连接请求<ul><li>即在nat translation table上手动配置 {(123.76.29.7, port 25000) , (10.0.0.1 port 25000)} ，使得(123.76.29.7, port 2500) 总是转发到(10.0.0.1 port 25000)</li></ul></li></ul><ul><li>方案2: Universal Plug and Play (UPnP) Internet Gateway Device (IGD) 协议. 允许NATted主机可以:<ul><li>获知网络的公共 IP地址(138.76.29.7)</li><li>列举存在的端口映射</li><li>增/删端口映射 (在租用时间内)</li><li>i.e., 自动化静态NAT端口映射配置<blockquote><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-17-20.png"></p></blockquote></li></ul></li></ul><ul><li>方案 3: 中继 (used in Skype)<ul><li>?? ques 不太理解 中继是怎么和Server连起来的</li><li>NAT后面的服务器建立和中继的连接</li><li>外部的客户端链接到中继</li><li>中继在2个连接之间桥接<blockquote><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-16-15.png"></p></blockquote></li></ul></li></ul><h2 id="中间盒"><a href="#中间盒" class="headerlink" title="中间盒"></a>中间盒</h2><ul><li>还有其他种类繁多网络设备（中间盒）：<ul><li>中间盒运行在网络层且不执行传统的数据转发</li><li>如<ul><li>NAT : <strong>重写</strong>首部ip和port</li><li>防火墙 : 基于首部字段<strong>阻拦</strong>流量或<strong>重定向</strong>分组</li><li>负载均衡 : 按算法转发给server </li></ul></li><li>未来：不断增加的需求和相应的网络设备</li><li>P227</li><li>需要不同的设备去实现不同的网络功能 <ul><li>每台设备集成了控制平面和数据平面的功能 </li><li>控制平面分布式地实现了各种控制平面功能 </li><li>升级和部署网络设备非常困难</li></ul></li></ul></li></ul><h2 id="通用转发和SDN"><a href="#通用转发和SDN" class="headerlink" title="通用转发和SDN"></a>通用转发和SDN</h2><ul><li><p>路由器的网络层功能：</p><ul><li>IP转发：对于到来的分组按照路由表决定如何转发；属于数据平面</li><li>路由：决定路径，计算路由表；属于控制平面</li></ul></li><li><p>传统方式实现网络功能的问题</p><ul><li>垂直集成&gt;昂贵、不便于创新的生态</li><li>分布式、固化设备功能==网络设备种类繁多<ul><li>无法改变路由等工作逻辑，无法实现流量工程等高级特性</li><li>配置错误影响全网运行；升级和维护会涉及到全网设备：管理困难</li><li>要增加新的网络功能，需要设计、实现以及部署新的特定设备，设备种类繁多</li></ul></li></ul></li></ul><h3 id="SDN-控制平面"><a href="#SDN-控制平面" class="headerlink" title="SDN (控制平面)"></a>SDN (控制平面)</h3><ul><li><p>SDN：逻辑上集中的控制平面</p></li><li><p>一个不同的（通常是远程）控制器和CA交互，控制器决定分组转发的逻辑（可编程），CA所在设备执行逻辑。</p><ul><li><strong>远程控制器计算和分发匹配加动作表</strong></li><li>实现网络设备数据平面和控制平面分离<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-13-52-02.png"></li></ul></li><li><p>见导论功能控制平面</p></li></ul><h3 id="通用转发-数据平面"><a href="#通用转发-数据平面" class="headerlink" title="通用转发 (数据平面)"></a>通用转发 (数据平面)</h3><ul><li>基于目的地转发可分为两步骤<ul><li>匹配 : 查找目的IP地址</li><li>动作 : 将分组发送到有特定输出端口的交换结构</li><li>可以看到这是匹配 + 动作的一种特例<br>下面看一下通用的匹配加动作范式</li></ul></li><li><strong>匹配加动作</strong><ul><li>匹配: 可以对协议栈的多个首部字段进行 匹配 ， 这些首部字段与不同层次的协议关联</li><li>动作: 将分组转发到一个或多个输出端口(像基于目的地转发一样),负责均衡,重写首部值(像NAT一样),阻挡/丢弃分组(像防火墙一样)等等</li></ul></li></ul><hr><p>以下所述都是基于Open Flow<br>OpenFlow : 匹配加动作抽象,控制器,SDN概念 的标准</p><ul><li><p><strong>Flow table 流表</strong></p><ul><li><strong>匹配加动作转发表</strong>在OpenFlow中被称为<strong>流表</strong></li><li>表项包括<ul><li>首部字段值的集合 Rule </li><li>所采取<strong>动作</strong>集合 Action: <strong>转发 / 丢弃 / 重写</strong></li><li>计数器集合 Stats: Packet + byte counters</li></ul></li></ul></li><li><p>分组交换机 or 路由器 ?</p><ul><li>由于流表 除了网络层之外，还需要链路层的首部字段来做出动作决定，所以不能再叫路由器（网络层）了，当然也不能叫(第二层)交换机，我们将其称为 分组交换机</li></ul></li></ul><p><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-14-35-05.png"></p><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><ul><li>OpenFlow的匹配抽象允许对来自三个层次的协议的首部字段进行匹配</li><li>流表中的表项结构如下<br><img src="/2023/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2023-01-28-15-25-31.png"></li></ul><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><ul><li>转发 : 分组转发到指定端口 / 广播道所有端口 / 多播 / 发给远程控制器(远程控制器可能安装新的流表)等 </li><li>丢弃 : 流表项中无动作</li><li>修改字段 : 重写分组首部字段(234层)</li></ul><h3 id="匹配加动作-例子"><a href="#匹配加动作-例子" class="headerlink" title="匹配加动作 例子"></a>匹配加动作 例子</h3><p>分组交换机(路由器)匹配加动作操作 充当<br>简单转发<br>负载均衡<br>防火墙<br>这样就不必通过中间盒<br>自顶向下P234</p><h2 id="数据平面data-plane小结"><a href="#数据平面data-plane小结" class="headerlink" title="数据平面data plane小结"></a>数据平面data plane小结</h2><ul><li>网络层的数据平面功能 : <ul><li>即路由器的转发功能<ul><li>决定到达路由器的输入链路之一的分组如何转发到路由器的输出链路</li></ul></li></ul></li><li>数据平面<ul><li>传统转发 -&gt; 通用转发(匹配加动作)</li></ul></li><li>相应的控制平面<ul><li>传统路由 -&gt; SDN</li><li>(控制)SDN和(数据)通用转发搭配</li><li>(控制)传统路由和(数据)传统转发搭配</li></ul></li><li>路由器结构</li><li>除此之外还学习了IP编址 , DHCP协议 , 什么是传说中的NAT(就是通过重写以及转换表 将私有ip转化为公有ip) , 知道了中间盒都是什么，如nat 防火墙等</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络层-数据平面&lt;br&gt;路由器、IP协议(格式、IP分片、DHCP、NAT)&lt;br&gt;数据平面转发分为两类：基于目的地转发和通用转发. 通用转发涉及SDN&lt;br&gt;二者都是 匹配加动作 原则&lt;/p&gt;
&lt;p&gt;参考 《自顶向下》《中科大》&lt;/p&gt;</summary>
    
    
    
    <category term="计网" scheme="http://example.com/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-CS144-lab4-补充</title>
    <link href="http://example.com/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E8%A1%A5%E5%85%85/"/>
    <id>http://example.com/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E8%A1%A5%E5%85%85/</id>
    <published>2023-01-18T14:59:53.000Z</published>
    <updated>2023-02-27T15:23:42.339Z</updated>
    
    <content type="html"><![CDATA[<p>补充八股</p><span id="more"></span><h2 id="挥手丢失-发生什么"><a href="#挥手丢失-发生什么" class="headerlink" title="挥手丢失 发生什么"></a>挥手丢失 发生什么</h2><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86">https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86</a></p><h2 id="两军问题"><a href="#两军问题" class="headerlink" title="两军问题"></a>两军问题</h2><p>A1 B A2<br>背景: 只有A1 和 A2同时向B发起进攻，才能成功。注：A1 和 A2的通信只能通过B，且是不可靠的通信。</p><p>前提：A1发送给A2 的消息 ，可能被B截获<br>目标：A1 和 A2达成一致… 到底什么叫一致 ? 我要学raft啊啊啊。春节之前学啊啊啊。<br>困难：A1 和 A2无法达成一致<br>A1无法确定A2是否收到A1发送的消息，A2为使得A1知道A2收到消息，则A2向A1发送确认报文；然而，A2无法确认A1是否收到该确认报文，则A1为使得A2知道A1收到确认，A1需要向A2发送确认报文（用于确认A2发送的确认报文）；那么同理，A2又需要向A1发送确认报文（用于确认A1发送的，用于确认A2发送的确认报文 的报文）; …. 如此，无穷无尽。<br>一言以蔽之 : 由于信道B不可靠，A1和A2无法确定对方是否收到本端发送的消息，因此会造成无穷多的ack.</p><h2 id="TCP-Keepalive"><a href="#TCP-Keepalive" class="headerlink" title="TCP Keepalive"></a>TCP Keepalive</h2><ul><li>TCP Keepalive是TCP的保活机制，为了及时知道对方的TCP是否还存活，以判断该连接是否已经死亡.</li><li>如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。<ul><li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 TCP 保活时间会被重置，等待下一个 TCP 保活时间的到来。</li><li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。</li></ul></li><li>TCPConnection实现：segment_received()的special case<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.ackno().has_value() <span class="keyword">and</span> (seg.length_in_sequence_space() == <span class="number">0</span>) <span class="keyword">and</span> seg.header().seqno == _receiver.ackno().value() - <span class="number">1</span>) &#123;    <span class="comment">//  local TCP expect the seqno to be _receiver.ackno().value()</span></span><br><span class="line">   _sender.send_empty_segment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HTTP-Keep-Alive"><a href="#HTTP-Keep-Alive" class="headerlink" title="HTTP Keep-Alive"></a>HTTP Keep-Alive</h2><ul><li>HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接；</li><li>HTTP协议 : 请求-应答模式<ul><li><strong>HTTP短连接</strong><ul><li>一次http请求 就要发起一条tcpconnection</li><li>每次请求都会经历 : 三次握手 -&gt; 请求 -&gt; 响应 -&gt; 四次挥手</li></ul></li><li><strong>HTTP长连接</strong><ul><li>使用同一条tcpconnection 来传送多条http请求/响应 , (1)从而避免连接建立和释放的开销</li><li>http层的双方通过在请求/响应的包头中添加 <code>Connection: Keep-Alive</code>来达成协议.</li><li>http长连接不仅减少了多次连接/释放的开销，(2)也是http流水线技术的基础<ul><li>http流水线 : 客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应，服务器按照顺序响应请求<blockquote><p><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4-%E8%A1%A5%E5%85%85/2023-01-16-16-01-24.png"></p></blockquote></li><li>归功于多个请求使用同一条tcp连接，server的多条响应才能按序到达client</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;补充八股&lt;/p&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-CS144-lab5</title>
    <link href="http://example.com/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/"/>
    <id>http://example.com/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/</id>
    <published>2023-01-18T14:58:25.000Z</published>
    <updated>2023-02-27T15:23:39.183Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>关于如何发送TCP segment</p><ul><li>user负责 TCP</li><li>user负责 TCP,IP</li><li>user负责 TCP IP Ethernet</li><li>CS144目标实现的就是从TCP到Ethernet全部在用户态实现.</li><li>Ethernet报文的封装和解封装就由NetWorkInterface来做</li></ul></li><li><p>实现一个NetWorkInterface</p><ul><li>发送IP datagram –封装–&gt; <strong>linker-layer frame</strong></li><li>接收 linker-layer frame —解封–&gt; IP datagram</li><li>在执行封装IP datagram成linker-layer frame时 , 需要ip-&gt;mac地址,这时就需要用到<strong>arp协议</strong><ul><li>涉及处理 arp table , 缓存未知mac的ipdatagram等</li></ul></li></ul></li></ul><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li><p>本实验，我们将到达协议栈的最底层 并实现一个 InetWork Interface : 一个将Internet Datagram 送入世界的桥梁 ; 并且实现在每一跳之间传送的链路层Ethernet以太网帧(frame).</p><ul><li>这个InetWork Interface组件适用于你之前实现的TCP/IP的底层 , 并且可以以另一种不同的上下文使用 : 当你在lab6中建立了路由器router,其将在network interface之间路由datagrams. Figure 1 展示了network interface在主机和路由器两种上下文下的层次位置<br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-08-09-26-11.png"></li></ul></li><li><p>在过去的实验中 你实现了一个可以成功和其他主机交流TCP segment . 这些segment 实际上到底是如何传送到对端的tcp呢 ? 有以下几个选项</p></li><li><p>How are these segments actually conveyed to the peer’s TCP implementation?</p></li></ul><h2 id="如何封装并发送TCP-segment"><a href="#如何封装并发送TCP-segment" class="headerlink" title="如何封装并发送TCP segment"></a>如何封装并发送TCP segment</h2><h3 id="TCP-in-UDP-in-IP"><a href="#TCP-in-UDP-in-IP" class="headerlink" title="TCP-in-UDP-in-IP"></a>TCP-in-UDP-in-IP</h3><p><strong>TCP-in-UDP-in-IP</strong></p><ul><li><p>TCP segment 可以作为 user datagram 的 payload. 当tcp运行在用户态 , 这是一种最简单的实现.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Ethernet Header # IP Header # UDP Header # [ TCPSegment (TCP Header # Http # payload) ]  </span><br></pre></td></tr></table></figure></li><li><p>Linux提供了一个udp socket的接口 </p><ul><li>code : class UDPSocket -&gt; socket(AF_INET, SOCK_DGRAM , 0)</li><li>udp socket的user只需提供user datagram(udp datagram)的payload 和 目标 address(ip and port). kernel的send接口如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">msghdr message&#123;&#125;;</span><br><span class="line">message.msg_name = <span class="keyword">const_cast</span>&lt;sockaddr *&gt;(destination_address);</span><br><span class="line">message.msg_namelen = destination_address_len;</span><br><span class="line">message.msg_iov = iovecs.data();</span><br><span class="line">message.msg_iovlen = iovecs.size();</span><br><span class="line">sendmsg(fd_num, &amp;message, <span class="number">0</span>);   </span><br><span class="line"><span class="comment">//  msghr message : 目标ip和port(sockaddr*) + 要发送数据payload</span></span><br><span class="line"><span class="comment">//  本lab中 该sendmsg 用于通过udp socket fd 发送 udp segment</span></span><br><span class="line"><span class="comment">//  udp 的 payload 为 tcp segment. 存入 msghdr</span></span><br></pre></td></tr></table></figure></li><li>kernel 负责构造UDP header , IP header 和 Ethernet header , 然后将packet发送到正确的下一跳(next hop)</li><li>kernel 负责确保 每个socket都由独占的 本地和远端的端口组合(exclusive combination of local and remote addresses and port numbers).</li><li>由于kernel 负责构造 UDP 和 IP header , 他会保证不同应用之间的独立 </li></ul></li><li><p>听起来很神奇是吧，居然udp的负载是tcp segment. code见下<br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-20-09-15-12.png"></p></li></ul><h3 id="TCP-In-IP"><a href="#TCP-In-IP" class="headerlink" title="TCP-In-IP"></a>TCP-In-IP</h3><p><strong>TCP-in-IP</strong></p><ul><li><p>普遍情况下 , TCP Segment 是直接放入 Internet datagram中的 , 没有udp header夹在 ip header和tcp header之间</p><ul><li>这就是人们所说的 <strong>“TCP/IP”</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Ethernet Header # IP Header # [ TCPSegment (TCP Header # Http Header # payload) ]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>比上一个难实现一点. Linux 提供接口 : <strong>TUN device</strong></p><ul><li>让应用提供完整的Internet datagram. 也即应用需要提供IP Header 而不仅仅是payload</li><li>kernel 负责剩余部分 <ul><li>writing the Ethernet header 构造 Ethernet Header </li><li>actually sending via the physical Ethernet card 实际通过网卡发送帧 </li></ul></li></ul></li><li><p>我们已经完整这个了.</p><ul><li>在lab4中, 我们有一个object 代表 Inernet datagrams 并且 其知道如何解析和序列化自身. (tcp helpers/ipv4_datagram)</li><li>The CS144TCPSocket uses these tools to connect your TCPConnection to a TUN device</li><li>实验都做完之后 先分析fullstack 然后分析cs144tcp<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \class TCPSpongeSocket</span></span><br><span class="line"><span class="comment">//! This class involves the simultaneous operation of two threads.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! One, the &quot;owner&quot; or foreground thread, interacts with this class in much the</span></span><br><span class="line"><span class="comment">//! same way as one would interact with a TCPSocket: it connects or listens, writes to</span></span><br><span class="line"><span class="comment">//! and reads from a reliable data stream, etc. Only the owner thread calls public</span></span><br><span class="line"><span class="comment">//! methods of this class.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! The other, the &quot;TCPConnection&quot; thread, takes care of the back-end tasks that the kernel would</span></span><br><span class="line"><span class="comment">//! perform for a TCPSocket: reading and parsing datagrams from the wire, filtering out</span></span><br><span class="line"><span class="comment">//! segments unrelated to the connection, etc.</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! There are a few notable differences between the TCPSpongeSocket and TCPSocket interfaces:</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! - a TCPSpongeSocket can only accept a single connection</span></span><br><span class="line"><span class="comment">//! - listen_and_accept() is a blocking function call that acts as both [listen(2)](\ref man2::listen)</span></span><br><span class="line"><span class="comment">//!   and [accept(2)](\ref man2::accept)</span></span><br><span class="line"><span class="comment">//! - if TCPSpongeSocket is destructed while a TCP connection is open, the connection is</span></span><br><span class="line"><span class="comment">//!   immediately terminated with a RST (call `wait_until_closed` to avoid this)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! Helper class that makes a TCPOverIPv4SpongeSocket behave more like a (kernel) TCPSocket</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CS144TCPSocket</span> :</span> <span class="keyword">public</span> TCPOverIPv4SpongeSocket &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CS144TCPSocket();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">const</span> Address &amp;address)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="TCP-in-IP-in-Ethernet"><a href="#TCP-in-IP-in-Ethernet" class="headerlink" title="TCP-in-IP-in-Ethernet"></a>TCP-in-IP-in-Ethernet</h3><p><strong>TCP-in-IP-in-Ethernet</strong></p><ul><li>在TCP-in-IP方法中 , 我们依然依赖于Linux kernel 去实现部分networking stack.<ul><li>每次我们的code write一个IP datagram到TUN device , Linux kernel需要负责创建一个正确的链路层frame(如Ethernet frame). 将我们的IPdatagram作为帧的payload.</li><li>这就意味着Linux kernel需要负责依据给定的IP addr , 来找出下一跳的正确Mac addr ; 如果 kernel还不知道该&lt; ip-mac &gt; , 其需要广播一个ARP查询分组 (asks, “Who claims the following IP address? What’s your Ethernet address?” and waits for a response.)</li><li>这些函数由network interface负责执行<ul><li><strong>network interface 功能 :  转换 IP datagram和 linker-layer frame(Ethernet)</strong> </li><li><strong>在真实系统中 , network interface 的经典命名是(eth0, eth1, wlan0, etc.)</strong></li></ul></li></ul></li><li><strong>lab5</strong> , 实现<strong>network interface</strong> , 并将其插入到我们TCP/IP协议栈的最底层. <ul><li>我们的代码将生成未经加工的 Ethernet frame. </li><li>该frame会被传递给Linux的<strong>TAP device</strong>(比 TUN device更底层). TAP device传输未经加工的我们生成的linker-layer frames.</li><li>下图中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Ethernet Header # IP Header # UDP Header # [ TCPSegment (TCP Header # Http # payload) ]  </span><br></pre></td></tr></table></figure></li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/293658778">TAP device介绍</a><ul><li>tap是链路层的虚拟网络设备，等同于一个以太网设备，它可以收发第二层数据报文包，如以太网数据帧。Tap最常见的用途就是做为虚拟机的网卡，因为它和普通的物理网卡更加相近，也经常用作普通机器的虚拟网卡。</li><li><strong>TAP device接收上层构造好的链路层帧(link-layer frames)并直接发送出去 ;</strong> </li><li><strong>TUN device接收上层的IP数据报(IP datagrams) , TUN负责构造链路层帧(link-layer frames) 再发送出去</strong></li><li><blockquote><p><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-08-11-00-35.png"></p></blockquote></li></ul></li></ul><ul><li>network interface的主要工作都在于ARP协议 : 获取IP addr对应的 Ethernet addr.</li></ul><h2 id="地址解析协议-Address-Resolution-Protocol"><a href="#地址解析协议-Address-Resolution-Protocol" class="headerlink" title="地址解析协议 Address Resolution Protocol"></a>地址解析协议 Address Resolution Protocol</h2><ul><li><p><strong>ARP : Address Resolution Protocol</strong></p><ul><li><strong>负责网络层地址(IP地址)和链路层地址(MAC地址)的转换</strong><br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-07-11-51-58.png"> </li></ul></li><li><p>在LAN上的每个IP节点都有一个ARP表</p></li><li><p>ARP表：包括一些LAN节点IP/MAC地址的映射</p><ul><li>&lt; IP address; MAC address; TTL&gt; </li><li>TTL时间是指MAC地址映射失效的时间 ,典型是20min<br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-07-11-57-06.png"></li></ul></li><li><p>A要发送帧给B(B的IP地址已知),A需要根据ipB解析出macB.</p><ul><li>如果arp table中有该ipB的entry，那么易得mac地址</li><li>如果arp table中没有该ipB的entry(如222.222.222.222)，那么如何 ?<ul><li><strong>A广播包含B的IP地址的ARP查询包</strong><ul><li>ARP查询分组</li><li>目的地址使用MAC广播地址，子网LAN上的所有节点都会收到该查询包<ul><li>Dest MAC address = FF-FF-FF-FF-FF-FF </li></ul></li><li>子网中的其他适配器接收到该用于arp查询的帧，将该帧中的ARP分组向上传递给arp模块，arp模块检验该arp分组要查询的ip地址是否是本机的ip地址. <ul><li>无论是否匹配 , 都缓存下收到的该查询分组&lt; sender_ip - sender_mac_addr &gt; </li><li>若匹配, B给A发送回一个响应ARP分组，告知其B的MAC地址 ; 该响应分组的目的地址为A的MAC地址</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>ARP报文结构</strong><br><img src="/2023/01/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab5/2023-02-07-17-21-02.png"></p></li><li><p>ARP是即插即用的 : 节点自己创建ARP的表项  ; 无需网络管理员干预</p></li><li><p>ARP协议是网络层协议还是链路层协议.</p><ul><li>ARP分组既包含链路层地址，又包含网络层地址.</li><li>将ARP看成是跨越链路层和网络层边界的协议<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">===================</span><br><span class="line">    传输层 </span><br><span class="line">    TCP/UDP</span><br><span class="line">===================</span><br><span class="line">    网络层</span><br><span class="line">    ICMP</span><br><span class="line">    IP</span><br><span class="line">======# ARP #=======</span><br><span class="line">    链路层</span><br><span class="line">    Ethernet 以太网帧</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>A发出的ARP查询报文 , B响应arp分组<ul><li>dst_mac src_mac type 是 Ethernet报文字段. 只有mac addr 而没有ip addr</li><li>opcode开始 是 arp报文. arp message中既有ip addr又有mac addr. </li><li>arp查询分组的目的mac地址是广播地址 , 该BROADCAST地址填入链路层linker-layer(Ethernet)的dst mac addr , 而非 arp 报文字段中的dst mac addr. arp 报文字段中的dst mac addr应该填0<table><thead><tr><th>dst_mac</th><th>src_mac</th><th>type</th><th>opcode</th><th>sender_mac</th><th>sender_ip</th><th>target_mac</th><th>target_ip</th></tr></thead><tbody><tr><td>FF-FF-FF-FF-FF-FF</td><td>mac_A</td><td>ARP</td><td>REQUET</td><td>mac_A</td><td>ip_A</td><td>00-00-00-00-00-00</td><td>ip_B</td></tr><tr><td>mac_A</td><td>mac_B</td><td>ARP</td><td>REPLY</td><td>mac_B</td><td>ip_B</td><td>mac_A</td><td>ip_A</td></tr></tbody></table></li></ul></li></ul><h2 id="接口及实现"><a href="#接口及实现" class="headerlink" title="接口及实现"></a>接口及实现</h2><p><a href="https://github.com/Cstardust/CS144_LAB/blob/master/libsponge/network_interface.cc">code</a> </p><p>简单 按照逻辑实现就好 比lab0-4简单多了去了</p><ul><li><p><strong>class NetworkInterface 重要成员</strong></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">本network interface mac addr</span><br><span class="line"><span class="comment">//! Ethernet (known as hardware, network-access-layer, or link-layer) address of the interface</span></span><br><span class="line">EthernetAddress _ethernet_address;</span><br><span class="line"></span><br><span class="line">本network interface ip addr</span><br><span class="line"><span class="comment">//! IP (known as internet-layer or network-layer) address of the interface</span></span><br><span class="line">Address _ip_address;</span><br><span class="line"></span><br><span class="line">frames to send</span><br><span class="line"><span class="comment">//! outbound queue of Ethernet frames that the NetworkInterface wants sent</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;EthernetFrame&gt; _frames_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arp_table: &lt;mac addr , ttl&gt;</span><br><span class="line"><span class="keyword">using</span> MacAddrInfo = <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;EthernetAddress,<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> TTL = <span class="number">30</span> * <span class="number">1000</span>;    <span class="comment">//  keep each &lt;ip-mac&gt; for 30s</span></span><br><span class="line"><span class="comment">//  ARP table : &lt;IP addr , MAC addr&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">uint32_t</span>,MacAddrInfo&gt; _arp_table&#123;&#125;;</span><br><span class="line"></span><br><span class="line">由于不知道ip对应的mac , 等待被发送的datagrams</span><br><span class="line"><span class="comment">//  data buffer : &lt;IP addr , datagrams&gt; </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">uint32_t</span>,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InternetDatagram&gt; &gt; _data_buffer&#123;&#125;;</span><br><span class="line"><span class="comment">//  ip - time_since_last_req</span></span><br><span class="line"></span><br><span class="line">对于每个ip的请求过去的时间</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">uint32_t</span>,<span class="keyword">int</span>&gt; _wait_for_req&#123;&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WAITING_TIME = <span class="number">5</span> * <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>network interface 功能 :  在 IP datagram 和 linker-layer frame(Ethernet) 之间转换</strong></p><ul><li>发送IP datagram -&gt; linker-layer frame</li><li>接收 linker-layer frame -&gt; IP datagram</li><li>在执行封装ipdatagram成linker-layer frame时 , 需要ip-&gt;mac地址,这时就需要用到<strong>arp协议</strong></li></ul></li><li><p>void NetworkInterface::send_datagram(const InternetDatagram &amp;dgram,const Address &amp;next_hop)</p><ul><li>This method is called when the caller (e.g., your TCPConnection or a router) wants to send an outbound Internet (IP) datagram to the next hop.1</li><li>将 IP datagram 封装成 Ethernet frame , 发送到下一跳next_hop<ul><li>需要获取next_hop对应的mac addr<ul><li>send TYPE_IPv4 : 已知mac , 则直接使用mac addr,填入ethernet字段,封装成帧,发送</li><li>send TYPE_ARP : 未知mac , 广播arp request分组(查询分组封装成帧并发送),将该IP datagram缓存起来 收到arp reply后发送. <ul><li>对于同一ip对应的mac 的arp request分组 , 每5s至多发送一个<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (find &lt;ip-mac&gt; <span class="keyword">and</span> <span class="keyword">not</span> expired) &#123;</span><br><span class="line">    <span class="comment">// Encapsulate the IP datagram into Ethernet frame and send it</span></span><br><span class="line">    ethernet_frame = buildEthernetFrame(TYPE_IPv4,<span class="built_in">string</span>(datagram));</span><br><span class="line">    send ipv4 frame</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//   If the network interface already sent an ARP request about the same IP address in the last five seconds, don’t send a second request—just wait for a reply to the first one</span></span><br><span class="line">    <span class="keyword">if</span>(pass <span class="number">5</span>s since last req)</span><br><span class="line">    &#123;</span><br><span class="line">        arp = buildArpRequest(next_hop_ip);</span><br><span class="line">        ethernet_frame = buildEthernetFrame(EthernetHeader::TYPE_ARP,<span class="built_in">string</span>(arp));</span><br><span class="line">        send arp req</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  queue the dgram</span></span><br><span class="line">    _data_buffer[next_hop_ip].push_back(dgram);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li><li><p>optional<InternetDatagram> NetworkInterface::recv_frame(const EthernetFrame &amp;frame)</InternetDatagram></p><ul><li>This method is called when an Ethernet frame arrives from the network. The code should ignore any frames not destined for the network interface (meaning, the Ethernet destination is either the broadcast address or the interface’s own Ethernet address stored in the ethernet address member variable).</li><li>接收从network中发来的linker-layer frame. </li><li>对于不是本网卡需要接收的frame，丢弃<ul><li>本网卡接收的frame : frame.dst_mac = local_mac || frame.dst_mac = ff-ff-ff-ff-ff-ff</li></ul></li><li>对于frame的payload<ul><li>IPv4 : return the resulting InternetDatagram to the caller.</li><li>ARP : <ul><li>无论是reply还是request,记录下该分组的&lt; sender_ip - sender_mac &gt; . 每个entry的ttl为30s。<ul><li>及时发送之前由于mac未知而缓存的frame</li></ul></li><li>对于arp request , 发送一个arp reply. 封装成帧, 发送.</li></ul></li><li>丢弃<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (checkInValidFrame(frame)) &#123; <span class="comment">//  dst is local mac addr or broad cast</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (recv IPv4) &#123;</span><br><span class="line">    <span class="keyword">return</span> ipv4_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (recv ARP)&#123;</span><br><span class="line">    record &lt;ip-mac&gt; in arp table</span><br><span class="line"></span><br><span class="line">    clear waiting buffer of ip : send waiting datagrams</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arp is REQUEST <span class="keyword">and</span> arp.dst_ip is to us) &#123;</span><br><span class="line">        arp_reply = buildArpReply;</span><br><span class="line">        ethernet_frame = buildEthernetFrame(</span><br><span class="line">            TYPE_ARP, arp_reply.serialize());</span><br><span class="line">        send an ARP reply</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>void NetworkInterface::tick(const size_t ms_since_last_tick)</p><ul><li>处理ARP table(即IP mac表)中的entry过期(TTL)</li><li>处理等待ARP reply的ip</li></ul></li></ul><h2 id="over"><a href="#over" class="headerlink" title="over"></a>over</h2>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;关于如何发送TCP segment&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;user负责 TCP&lt;/li&gt;
&lt;li&gt;user负责 TCP,IP&lt;/li&gt;
&lt;li&gt;user负责 TCP IP Ethernet&lt;/li&gt;
&lt;li&gt;CS144目标实现的就是从TCP到Ethernet全部在用户态实现.&lt;/li&gt;
&lt;li&gt;Ethernet报文的封装和解封装就由NetWorkInterface来做&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现一个NetWorkInterface&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送IP datagram –封装–&amp;gt; &lt;strong&gt;linker-layer frame&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;接收 linker-layer frame —解封–&amp;gt; IP datagram&lt;/li&gt;
&lt;li&gt;在执行封装IP datagram成linker-layer frame时 , 需要ip-&amp;gt;mac地址,这时就需要用到&lt;strong&gt;arp协议&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;涉及处理 arp table , 缓存未知mac的ipdatagram等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-CS144-lab4</title>
    <link href="http://example.com/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/"/>
    <id>http://example.com/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/</id>
    <published>2023-01-11T02:53:08.000Z</published>
    <updated>2023-02-27T15:23:41.736Z</updated>
    
    <content type="html"><![CDATA[<ul><li>TCPConnection : 基于之前实现的 TCPReciver和TCPSender ; 作为完整的一端的TCP实现<ul><li>功能以及对应核心函数如下<ul><li>接收segment : segment_received<ul><li>本端接收seg 并根据自身receiver以及sender状态 发送相应seg给peer</li><li>注意在segment_receive中 会自动调用send_segments()</li></ul></li><li>发送segment : send_segment. (会捎带ack)</li><li>pass时间 : tick. 可能触发重传</li><li>shutdown关闭连接<ul><li>unclean_shutdown : 清空要发送的seg , 根据是否主动异常,发送rst , 设置_sender和receiver状态error , active_ = false<ul><li>active unclean_shutdown : send rst</li><li>passive unclean shut_down : not send rst</li></ul></li><li>clean_shutdown : active = false<ul><li>active clean_shutdown : 在tick时 判断是否经历完TIME_WAIT, 经历完，则clean_shutdown</li><li>passive clean_shutdown : 在segment_recieve接收完FIN的ACK后发现进入CLOSED状态，则clean_shutdown</li></ul></li></ul></li></ul></li></ul></li></ul><ul><li>最核心的一点 : <strong>如何确定结束连接</strong>. When TCPConnection is Done<ul><li>unclean shutdown : 接收或发送rst就立刻结束连接</li><li>clean shutdown<ul><li>需要满足#1#2#3#4</li><li>只有一端同时满足四个条件，该端才能认为TCPConnection is done. 结束连接.</li><li>对于#4有两种情况可以满足<ul><li>active close : A. 无法确定100%满足,只能通过TIME_WAIT接近100%<ul><li>这也就是由于两军问题,不可能去保证两端(主动关闭的无法一定达成clean shutdown)都能达成clean shutdown，但是TCP已经尽可能地接近了。</li></ul></li><li>passive close : B. 100%满足<ul><li>被动关闭的一端无需linger time，可以100%达成clean_shutdown</li></ul></li></ul></li></ul></li></ul></li></ul><span id="more"></span><h1 id="TCPConnection"><a href="#TCPConnection" class="headerlink" title="TCPConnection"></a>TCPConnection</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>为什么满足#1234 本端就能connection is donw ?</strong> </p><ul><li><p>因为首先明确clean_shutdown的目标是 双方都完全的可靠的接收到了对方的outbound stream.</p></li><li><p>其次这四个条件含义分别如下</p><ul><li>.#2是为了保证local的outbound_stream全部字节都已经被发送出去（其实按照我们所实现的，满足了#3就一定满足#2）(TCPSender.state = FIN_SENT)</li><li>.#3是为了保证local知道，local的outbound stream全部被peer接收(TCPSender.state = FIN_ACKED)</li><li>.#1是为了保证peer的outbound stream全部被local接收(TCPReceiver.state = FIN_RECV)</li><li>.#4是为了保证peer知道，其outbound stream 已经全部被local接收，不然根据重传机制，peer会不断重传outbound stream字节或如fin segment(remote TCPSender.state = FIN_ACKED)</li></ul></li><li><p><strong>为什么说TCP的字节流是双向的 ?</strong></p><ul><li>因为TCP有两条单向的字节流</li><li>每一端都有TCPSender 和 TCPReceiver</li><li><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-16-20-08-34.png"></li><li>从A到B的字节流 是 由 TCPSender A 向 TCPReceiver B 发起的 , 并由TCPSender A 和 TCPReceiver B维护.<ul><li>TCPSender A 给 TCPReceiver B发送的是 outbound_stream A的payload以及影响该连接的syn 和 fin。这三者都会占据seq空间. 这是sender A向 receiver B发送数据</li><li>TCPReceiver A给TCPSender B发送 ackno 以及 rwnd. 是receiver A向sender B反应接收情况.</li><li>TCPReceiver B给TCPSender A发送 ackno 以及 rwnd. 是receiver B向sender A反应接收情况.</li><li>TCPSender B 给 TCPReceiver A发送的是 outbound_stream B的payload以及影响该连接的syn 和 fin。这三者都会占据seq空间. 这是sender B向 receiver A发送数据</li></ul></li></ul></li></ul><ul><li><p><strong>为什么(A发送的)ack不占据(A发送的)seqno空间 ? 也即为什么 empty ack segment的大小为0 ?</strong></p><ul><li>约定下A的seqno空间 : TCPSender A 发起 并 维护的 seqno空间. TCPReceiver B依据该seqno空间发送ackno报文向B进行确认(当然报文中的rwnd是依据TCPReceiver B自己的接收窗口空间)</li><li><strong>一言以蔽之</strong>：A发送给B的ack，并不是A要发送给B的数据，而仅仅是A为了使得B正常工作，所发送的交互辅助信息. 只有A要发送给B的数据(outbound_stream(payload))才会占据A的seqno空间,除此之外还有syn和fin（因为他们会对A到B的连接产生影响）</li><li><strong>复杂来说如下</strong>（已知每一端都可分为Receiver和Sender）<ul><li><ol><li>A端发送给B端的segment , 其中的seqno , 是A发送给B的字节 在 A的空间的下标.</li></ol></li><li><ol start="2"><li><strong>只有TCPSender A 发送给 TCPReceiver B 的 报文内容才会占据seqno空间(syn + payload(outbound_stream) + fin)</strong></li></ol></li><li><ol start="3"><li>而TCPReceiver A发送给TCPSender B的ackno 并不会占据TCPSender A的seqno空间</li></ol><ul><li>因为这是<strong>TCPReceiver A发送给TCPSender B的,ackno</strong>并不是来自TCPSender。况且<strong>ackno</strong>本身也并不是数据，而是一个辅助TCPSender B进行工作的<strong>辅助信息</strong>.</li></ul></li></ul></li></ul></li><li><p>所有报文都有ack吗？所有报文都有seqno吗？</p><ul><li>任何报文都有seqno，发送的任何segment都需要有一个seqno,即便该segment本身可能并不占据/消耗seqno空间。</li><li>几乎所有报文都有ackno 以及 rwnd. (除了client发送给sender的第一个syn 报文)</li><li>如A给B发送了一个empty ack segment with seqno x, 那么A给B发送的下一个segment的seqno仍然是x</li></ul></li><li><p>How does the application read from the inbound stream?</p><ul><li>TCPConnection::inbound_stream() is implemented in the header file already. </li></ul></li></ul><ul><li>关于rst<ul><li>This flag (“reset”) means instant death to the connection</li><li>发送和接收到rst segment的后果是一样的：<ul><li>unclean shutdown :<ul><li>将outbound_stream和outbound_stream置为error</li><li>销毁连接 active = false</li></ul></li></ul></li><li>什么时候发送rst segment ?<ul><li>重传次数过多</li><li>当active = true时 调用了TCPConnection的析构函数</li><li><blockquote><p>There are two situations where you’ll want to <strong>abort the entire connection</strong>:</p><ol><li>If the sender has sent too many consecutive retransmissions without success (more than TCPConfig::MAX RETX ATTEMPTS, i.e., 8).</li><li>If the TCPConnection destructor is called while the connection is still active (active() returns true).</li></ol></blockquote></li></ul></li><li>rst不占据seqno空间</li></ul></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-16-08-40-28.png"> </p><ul><li>You have reached the summit.</li><li>lab0 ，我们实现了一个 flow-controlled(流量控制) 的 bytestream</li><li>lab123 , 我们实现了一个 in-both-direction(双向的) 在bytestream和网络提供的unreliable datagrams之间进行通信的 工具（TCPSender和TCPReceiver）</li><li>lab4 , now , 我们将实现一个称为TCPConnection的整体模块 , 整合我们的TCPSender 和 TCPReceiver ，并处理connection的global housekeeping.</li><li>connection的TCPSegment 可以被封装进 uesr UDP segment(TCP-in-UDP) 或者 Internet IP datagrams(TCP/IP) -&gt; 使得你的代码可以和Internet上同样使用TCP/IP的主机进行交互.</li><li>需要注意的是 , TCPConnection只是将TCPSender和TCPReceiver进行组合. TCPConnection本身的实现只需要100行代码. TCPConnection依赖于TCPSender和TCPReceiver的鲁棒性</li></ul><ul><li><strong>Lab4 : the TCP Connection</strong><ul><li>本周 实现一个可工作的TCP, 我们已将做了大部分的工作 : 已经实现了TCPSender 和 TCPReceiver. lab4的工作是将他们组合在一起，组成一个class TCPConnection , 处理一些对于connection来说全局的事务</li><li>class TCPConnection就是一个peer. 负责接收和发送segment. 确保TCPSender和TCPReceiver 都可以在收到和发送的segment上 添写和读取相应的字段.</li><li>回忆 : <ul><li>TCP reliably conveys a pair of flow-controlled byte streams, one in each direction<ul><li>TCP可靠的 传输一对双向的流量控制的字节流.</li></ul></li><li>Two parties participate in the TCP connection, and each party acts as both “sender” (of its own outbound byte-stream) and “receiver” (of an inbound byte-stream) at the same time<ul><li>TCPConnection的两端，每一端都同时扮演者sender和receiver的角色.</li></ul></li></ul></li><li>AB两方被称为connection的endpoint / peer.<img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-16-20-08-14.png"></li></ul></li></ul><p>Here are the basic rules the TCPConnection has to follow</p><p>约定一下 将本端称为local … , 将对端称为 peer …</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h3 id="Receiving-segments"><a href="#Receiving-segments" class="headerlink" title="Receiving segments"></a>Receiving segments</h3><ul><li>TCPConnection收到segment : <strong>segment_received()</strong> called<br>In this method :  </li><li><strong>对于rst segment</strong><ul><li>如果local收到的segment 有 rst flag , 那么将 <ul><li>set inbound_stream and outbound_stream as error state , </li><li>并且不发送任何报文回复给peer , </li><li>并立刻杀死本连接. </li></ul></li></ul></li><li><strong>对于非rst segment</strong><ul><li>报文发送给 TCPReceiver : <strong>TCPReceiver</strong>接收<strong>segment中的seqno , syn , payload , fin</strong></li><li>如果ack flag , segment 告知 <strong>TCPSender</strong> 接收 <strong>ackno + window_size</strong>  </li><li>只要收到的segment占据了peer的seqno空间, 那么TCPConnection(本端的TCPReceiver)需要至少回复一个segment,来告知对端(的TCPSender) ackno 以及 window_size<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seg.length_in_sequence_space() &gt; <span class="number">0</span>)  <span class="comment">//  receiver recv syn , payload , fin</span></span><br><span class="line">        ack_to_send = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li>special case:<ul><li>TCP : Keepalive保活机制. 我们只实现回复keep-alive segment,不实现发送keep-alive segment <ul><li>对端会发送segment with invalid seqno 去检验本端的TCP是否还活着.</li><li>本端的TCPConnection需要回复该segment , 即便该segment不消耗任何 seqno.</li><li>如下<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.ackno().has_value() <span class="keyword">and</span> (seg.length_in_sequence_space() == <span class="number">0</span>) <span class="keyword">and</span> seg.header().seqno == _receiver.ackno().value() - <span class="number">1</span>) &#123;    <span class="comment">//  local TCP expect the seqno to be _receiver.ackno().value()</span></span><br><span class="line">  _sender.send_empty_segment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>从这里也可以看出，keep-alive segment只是检验对端的TCP层是否存活,而不是检验对端的应用层是否正常工作. 因为该keep-alive报文根本不会被送到应用层程序.</strong></li></ul></li></ul></li></ul><h3 id="Sending-segments"><a href="#Sending-segments" class="headerlink" title="Sending segments."></a>Sending segments.</h3><ul><li>The TCPConnection will send TCPSegments over the Internet:</li><li>TCPConnection将要发送的报文 其字段由两部分组成: TCPSender添写 + TCPReceiver添写<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-16-16-13-02.png"><ul><li>TCPSender负责 seqno + syn + payload + fin + rst</li><li>TCPReceiver负责ackno 以及receive window_size , 如果存在ackno 则 将ackno填入将要发送的segment（应该只有client主动发起连接的那一条syn segment中没有ackno）</li></ul></li><li>How does the TCPConnection actually send a segment?<ul><li>Similar to the TCPSender—push it on to the segments out queue. As far as your TCPConnection is concerned, consider it sent as soon as you push it on to this queue.</li><li>Soon the owner will come along and pop it (using the public segments_out() accessor method) and really send it.</li></ul></li></ul><h3 id="When-time-passes"><a href="#When-time-passes" class="headerlink" title="When time passes."></a>When time passes.</h3><ul><li>TCPConnection通过调用tick()代表时间流逝</li><li>TCPConnection::tick():<ul><li>tell the TCPSender about the passage of time : TCPSender::tick()</li><li>当重传次数过多, 放弃该连接 , 并发送an empty segment with the rst flag set给对端</li><li>end the connection cleanly if necessary  <ul><li>necessary : 满足#1234，TIME_WAIT阶段结束</li></ul></li></ul></li></ul><h3 id="Decide-when-connection-is-done"><a href="#Decide-when-connection-is-done" class="headerlink" title="Decide when connection is done"></a><strong>Decide when connection is done</strong></h3><p><strong>One important function of the TCPConnection is to decide when the TCP connection is fully “done.”</strong></p><p>以下就是关于tcp何时结束的讨论</p><p><strong>The end of a TCP connection: consensus takes work</strong></p><h4 id="connection-is-down-的方式"><a href="#connection-is-down-的方式" class="headerlink" title="connection is down 的方式"></a>connection is down 的方式</h4><ul><li><p><strong>when tcpconnection is down</strong></p><ul><li><strong>释放其对本地端口号的独占声明</strong></li><li><strong>停止发送ack作为回复</strong></li><li><strong>将连接视为历史记录</strong></li><li><strong>active() return false</strong></li></ul></li><li><p><strong>connection有两种结束的方式</strong></p></li><li><p><strong>Unclean shutdown</strong></p><ul><li>情况: 本端发送或者收到一个rst segment<ul><li>关于rst segment : 接收和发送的作用都是一样的：导致unclean shutdown</li></ul></li><li>动作: <ul><li>outbound and inbound stream 置为 state error</li><li>active() return false from now on immediately</li></ul></li></ul></li><li><p><strong>clean shutdown</strong></p><ul><li>the connection get to “done” without error</li><li>clean shutdown更复杂但是更优美，因为他尽可能地保证了双方的outbound bytestream被可靠的完全的交付给peer receiver.</li></ul></li></ul><h4 id="如何尽可能达成clean-shutdown"><a href="#如何尽可能达成clean-shutdown" class="headerlink" title="如何尽可能达成clean_shutdown"></a>如何尽可能达成clean_shutdown</h4><ul><li><strong>由于Two Generals Problem两军问题,不可能去保证两端都能达成clean shutdown，但是TCP已经尽可能地接近了。</strong>下面从一端的角度来看tcp如何做到这点 </li><li><strong>若要在一条连接中 和 remote peer 达成clean shutdown，需要先满足四个先决条件</strong><ul><li><strong>Prereq #1 The inbound_stream has been fully assembled and has ended.</strong><ul><li>TCPReceiver的inbound_stream已经顺序的存了所有字节，且 已经存了最后的那个fin.(TCPReciever receive fin —&gt; inbound_stream.end_input())</li><li><strong>即 TCPReceiver.state = FIN_RECV</strong></li></ul></li><li><strong>Prereq #2 The outbound_stream has been ended by the local application and fully sent (including the fact that it ended, i.e. a segment with fin ) to the remote peer.</strong><ul><li>local outbound_stream 已经关闭(上层app调用了outbound.end_input()),且outbound_stream的全部字节都已经发送，且TCPSender 已经发送了最后的fin segment.</li><li><strong>即TCPSender.state = FIN_SENT</strong></li></ul></li><li><strong>Prereq #3 The outbound stream has been fully acknowledged by the remote peer.</strong><ul><li>local outbound_stream 已经全部被remote peer 所确认.<ul><li>即 local收到了remote peer 为fin返回的一个ack。因为这代表local发送的fin及之前的全部都被确认；且fin代表这就是发送的全部字节。</li></ul></li><li><strong>即TCPSender.state = FIN_ACKED</strong></li><li>易知若达成#3 则#2必然已经达成 </li></ul></li><li><strong>Prereq #4 The local TCPConnection is confident that the remote peer can satisfy prerequisite #3</strong>. This is the brain-bending part. There are two alternative ways this can happen:<ul><li><strong>即local确认 remote peer满足TCPSender.state = FIN_ACKED</strong></li><li>即local确认 remote peer 接收到了自己回复fin的ack</li><li>这有点绕，有两种方式满足#4<ul><li><strong>option A</strong> : local 几乎可以认为 peer满足#3，但并不肯定。也即<strong>local几乎满足#4</strong></li><li><strong>option B</strong> : local 可以百分之分确定 peer满足#3，即<strong>local肯定满足#4</strong></li></ul></li></ul></li></ul></li></ul><ul><li><strong>为什么满足了1234，local就可以销毁了？local就可以完全断开连接了？（关闭Sender和Receiver，不再与外界交互）</strong><ul><li>因为首先明确clean_shutdown的目标是 双方都完全的可靠的接收到了对方的outbound stream.</li><li>其次这四个条件含义分别如下<ul><li>.#2是为了保证local的outbound_stream全部字节都已经被发送出去（其实按照我们所实现的，满足了#3就一定满足#2）(TCPSender.state = FIN_SENT)</li><li>.#3是为了保证local知道，local的outbound stream全部被peer接收(TCPSender.state = FIN_ACKED)</li><li>.#1是为了保证peer的outbound stream全部被local接收(TCPReceiver.state = FIN_RECV)</li><li>.#4是为了保证peer知道，其outbound stream 已经全部被local接收，不然根据重传机制，peer会不断重传outbound stream字节或如fin segment(remote TCPSender.state = FIN_ACKED)</li></ul></li></ul></li></ul><h5 id="条件4如何达成"><a href="#条件4如何达成" class="headerlink" title="条件4如何达成"></a>条件4如何达成</h5><h6 id="Option-A"><a href="#Option-A" class="headerlink" title="Option A"></a>Option A</h6><p><strong>Option A: lingering after both streams end.</strong><br>这种情况发生在local<strong>主动发起关闭</strong>，<strong>lingering</strong> 即 close前的最后一个状态的 <strong>TIME_WAIT</strong>。<br>等待linger time是为了local尽可能地满足#4</p><ul><li><p><strong>local满足#1 和 #3 ; 且peer似乎满足#3。(即local似乎满足#4.)</strong></p><ul><li><strong>local并不能准确的得知peer满足#3,因为TCP不可靠的传输ack（TCP不会为ack回复ack）</strong>，local发给对方的ack可能丢失.</li></ul></li><li><p><strong>local</strong>可以通过很<strong>自信的认为</strong>remote peer满足#3</p><ul><li><strong>local通过等待一段时间（linger time），且这段时间内remote peer没有重传任何报文</strong></li></ul></li><li><p>linger time = 10 * initial _retransmission_timeout; 在生产环境中 = 2 MSL(60~120s)</p><ul><li>具体的，当本端满足#1和#3，且距离上次收到ack已经至少过去了10倍的initial _retransmission_timeout 时 , the connection is done . 这种双方stream结束之后的等待 称为 lingering : 它的目的是确保远端不会尝试重传 [本端需要回复ack的] 报文.</li><li>这也就意味着local class TCPConnection需要再存活一会，仍旧占据着端口，并为收到的segment回复ack.即使本端的inbound,outbound stream已经关闭,并且TCPSender,TCPReceiver都已经正确的完成了所负责的工作。我的实现也做到了这一点</li></ul></li><li><p>TIME_WAIT作用例子如下</p><blockquote><p><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-17-00-20-17.png"><br>在TCP的生产环境中，linger timer (also known as the time-wait timer or twice the Maximum Segment Lifetime (MSL)) 一般来说是60～120秒。实际上这是一段相当长的时间占据着端口，没有人愿意等这么久，尤其是当你还想用这个端口号去启动本地的另一个服务的时候。Socket编程里，有一个选项是SO_REUSEADDR，可以让Linux忽视端口的占用，强制把一个Socket服务绑定到正在被使用中的端口号上。</p></blockquote></li><li><p>但是即便有lingering，也不能保证peer一定满足#3，因为peer重传的FIN可能在linger time之后才到达local 或者 根本就是丢失了. 故可能会造成peer的class tcpconnection一直存在，一直重传fin segment。即便此时local的outbound stream 和 inbound stream已经关闭；peer的outbound stream 和 inbound stream都已经关闭.</p></li></ul><ul><li><strong>综上，active close 时 , 若满足#1#3，则local不一定满足了#4，需通过linger time来尽可能地满足#4</strong></li></ul><h6 id="Option-B"><a href="#Option-B" class="headerlink" title="Option B"></a>Option B</h6><p><strong>Option B: passive close.</strong><br><strong>发生在local被动关闭连接，直接进入CLOSED状态，而不必进入TIME_WAIT</strong></p><ul><li><p><strong>满足 #1和#3，且local100%确认remote peer满足#3</strong>.(既local确定renmote收到了local的所发送的fin ack)</p><ul><li><strong>怎么做到100%确认的？由上所述TCP也不ack ack.</strong>  </li><li><strong>因为在这种passive close的情况下，remote peer首先关闭了其outbound_stream。</strong></li></ul></li><li><p>OptionB rule是如何工作的 ? <strong>为什么passive close的时候就可以100%确定remote peer满足#4 ?</strong></p><ul><li>这有一点烧脑，不过可以更深入的理解 两军问题 以及 在不可靠的网络上提供可靠服务的固有限制<ul><li>it’s fun to think about and gets to the deep reasons for the Two Generals Problem and the inherent constraints on reliability across an unreliable network.</li></ul></li><li><strong>原因如下</strong>: <ul><li>local在收到了remote peer的fin之后(#1)，发送ack报文（至少要发送<strong>FIN segment with ack and fin</strong>以满足 #2），易知该local发送的fin报文ack的是remote peer’s fin. </li><li>已知local满足#3 , 那么remote peer 一定已经ack了该local发送的fin+ack报文, 意味着remote peer已经看到了local peer发送的fin报文（上的ackno）, <strong>该ackno ack了remote之前发送的fin。那么，就可以保证 remote peer一定已经满足#3了</strong>。</li></ul></li></ul></li><li><p><strong>综上，passive close 时 , 若满足#1#3，则local一定满足了#4，无需通过linger time来尽可能地满足#4</strong></p></li></ul><ul><li>The bottom line is that if the TCPConnection’s inbound stream ends before the TCPConnection has ever sent a fin segment(local outbound_stream_end), （即如果local被动关闭连接）then the TCPConnection doesn’t need to linger after both streams finish</li></ul><h4 id="The-end-of-a-TCP-connection-practical-summary）"><a href="#The-end-of-a-TCP-connection-practical-summary）" class="headerlink" title="The end of a TCP connection (practical summary）"></a>The end of a TCP connection (practical summary）</h4><p>指导书给出的实践指导<br>我们可以根据local的state，来判断是active close(optionA) 还是 passive close(optionB)</p><ul><li><p>class TCPConnection 有一个变量linger_after_streams_finish 代表本端是否需要等待linger time再关闭连接</p><ul><li>一开始是true</li><li>如果inbound_stream在outbound_stream eof之前被对端end,那么置为false. (即如果是被动关闭连接)</li></ul></li><li><p><strong>在任何时候 #1 和 #3 被满足</strong>，</p><ul><li><strong>a.</strong> 如果linger_after_streams_finish = false ，则 connection is done(active() should return false)</li><li><strong>b.</strong> 如果linger_after_streams_finish = true , 则 本端等待足够长的时间(尽可能的满足#4），然后connection is done(active() should return false)</li></ul></li></ul><p>约定 TCPConnection的调用者称为owner<br>约定 A主动关闭连接 ：A先断开 A到B的字节流<br>约定 A主动被动连接 ：A后断开 A到B的字节流</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h3><ul><li>TCPConnection如何发送segment:<ul><li><strong>std::queue<TCPSegment> _segments_out{}</TCPSegment></strong>;</li><li><strong>void TCPConnection::send_segments()</strong><ul><li>将TCPSender的segment移动到TCPConnection的segment_queue中</li><li>而后owner会将该segment_queue发送出去</li><li>注意会捎带ack</li></ul></li></ul></li></ul><ul><li><p><strong>关于_linger_after_streams_finish</strong></p><ul><li><strong>只有在clean_shutdown的情况下 , _linger_after_streams_finish才有意义</strong></li><li><strong>unclean_shutdown 时 , _linger_after_streams_finish无意义</strong>。因为unclean_shutdown 不在乎bytestream有没有 正确的完全的 递送给接收方</li><li>_linger_after_streams_finish含义 : <strong>本端在满足#1 #3之后 是否需要再等待一段时间以满足 #4</strong><ul><li>也即，断开连接时是进入TIME_WAIT状态,还是直接进入CLOSED</li><li><strong>bool _linger_after_streams_finish{true};</strong><ul><li>在TCPConnection刚构造时初始化为true , 意味着初始时认为本端在满足#1#2#3之后，必须等待linger time才能满足#4，达成connection is down条件</li><li>宏观来看只有<strong>主动关闭连接</strong>时才有_linger_after_streams_finish = true</li></ul></li><li><strong>_linger_after_streams_finish = false</strong><ul><li>本端在满足#1#2#3之后，#4自动满足，不必等待linger time</li><li><strong>如果本端的inbound_stream 在本端的outbound_stream发送fin segemnt之前就end了，那么 本端是不必在双端stream finish后，等待linger time再关闭连接</strong>。</li><li>宏观来看只有<strong>被动关闭连接</strong>时才有_linger_after_streams_finish = false<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.state() == TCPReceiver::State::FIN_RECV &amp;&amp;</span><br><span class="line">    (_sender.state() == TCPSender::State::SYN_ACKED_2 || _sender.state() == TCPSender::State::SYN_ACKED_1))</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><strong>使用</strong>: 由后文易知，在满足#1#2#3#4时，本端tcpconnection is done<ul><li>被动关闭连接 </li><li>CLOSE_WAIT -&gt; [LAST ACK -&gt; CLOSED]</li><li>满足#123 , 且自动满足#4(!_linger_after_streams_finish), 进入closed<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> :</span></span><br><span class="line"><span class="function"><span class="comment">//  clean shutdown 之 本端 主动被动连接 进入 CLOSED</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(_receiver.state() == TCPReceiver::State::FIN_RECV &amp;&amp; _sender.state() == TCPSender::State::FIN_ACKED &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">    !_linger_after_streams_finish)</span> </span>&#123;</span><br><span class="line">    clean_shutdown();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// //  clean shutdown 之 本端 主动关闭连接 进入 TIME_WAIT</span></span><br><span class="line"><span class="comment">// if (_receiver.state() == TCPReceiver::State::FIN_RECV &amp;&amp; _sender.state() == TCPSender::State::FIN_ACKED &amp;&amp;</span></span><br><span class="line"><span class="comment">//     _linger_after_streams_finish) &#123;</span></span><br><span class="line"><span class="comment">//         //  TIME_WAIT !</span></span><br><span class="line"><span class="comment">//         //  在tick时检验是否需要断开连接</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li><li>主动关闭连接</li><li>FIN_WAIT1 -&gt; [FIN_WAIT2 -&gt; TIME_WAIT -&gt; CLOSED]</li><li>满足#123，且需要等待linger time才能满足#4<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> :</span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="params">(_receiver.state() == TCPReceiver::State::FIN_RECV &amp;&amp; _sender.state() == TCPSender::State::FIN_ACKED &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">    _linger_after_streams_finish)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_time_since_last_segment_received &gt;= <span class="number">10</span> * _cfg.rt_timeout)</span><br><span class="line">        clean_shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>反应本端tcp是否仍然存活</p><ul><li>bool _active{true};</li><li>什么时候为true ?<ul><li>一开始就是true</li></ul></li><li>什么时候为false ?<ul><li>clean shutdown 和 unclean shutdown</li></ul></li></ul></li><li><p>size_t _time_since_last_segment_received{0};  </p><ul><li>距离收到上个sgement过去了多长时间，用于TIME_WAIT</li></ul></li><li><p><strong>clean shutdown</strong></p><ul><li><strong>each of the two ByteStreams has been reliably delivered completely to the receiving peer</strong><ul><li>more complicated but beautiful</li><li>尽可能地保证两个outbound_stream 都被<strong>完全的可靠的</strong> 传递给receiver_peer</li></ul></li><li>clean_shutdown()<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::clean_shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>unclean shutdown</strong></p><ul><li>tcpconnection 接收或者发送 rst segment</li><li>动作<ul><li>outbound and inbound stream 置为 state error</li><li>active() can return false immediately.</li></ul></li><li>unclean shutdown()<ul><li>发送rst segment，主动: true ;</li><li>接收rst segment，被动: false</li><li>已知在发送rst segment之前，segments_out()可能会有未发送的报文，将他们清空。（未找到理论依据，不过test让我们这么干）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::unclean_shutdown</span><span class="params">(<span class="keyword">bool</span> rst_to_send <span class="comment">/* = false */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TCPSegment&gt; empty;</span><br><span class="line">    _sender.segments_out().swap(empty);</span><br><span class="line">    <span class="keyword">if</span> (rst_to_send) &#123;</span><br><span class="line">        _sender.send_empty_segment(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;send_segments();</span><br><span class="line">    &#125;</span><br><span class="line">    _sender.stream_in().set_error();</span><br><span class="line">    _receiver.stream_out().set_error();</span><br><span class="line"></span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">    _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="TCP-State-Transitions"><a href="#TCP-State-Transitions" class="headerlink" title="TCP State Transitions"></a><strong>TCP State Transitions</strong></h3><p><a href="https://ttcplinux.sourceforge.net/documents/one/tcpstate/tcpstate.html">重要参考</a></p><p>tcpconnection状态<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-12-11-03-42.png"></p><ul><li>我的实现中，虽然指导书说不要求在Sender和Receiver维护状态，不过为了更清晰，我还是为Sender和Reciever依据lab123所述分别维护了状态。<ul><li>Receiver<img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-16-49-28.png"></li><li>Sender<img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-16-50-02.png"></li></ul></li></ul><ul><li>TCPConnection和TCPSender、TCPReciever的状态关系如下表<ul><li>背景:1. client 主动发起连接 到 server，2. client主动断开连接.</li><li>server状态表如下<table><thead><tr><th>TCPConnection State</th><th>TCPReceiver State</th><th>TCPSender State</th><th>linger_after_stream_finish</th><th>active</th></tr></thead><tbody><tr><td>1. (被动发起连接)LISTEN</td><td>LISTEN</td><td>CLOSED</td><td>true</td><td>true</td></tr><tr><td>SYN_RCVD</td><td>SYN_RECV(recv syn)</td><td>SYN_SENT(send syn)</td><td>true</td><td>true</td></tr><tr><td>ESTABLISHED</td><td>SYN_RECV</td><td>SYN_ACKED(recv ack)</td><td>true</td><td>true</td></tr><tr><td>2. (被动关闭连接)CLOSE_WAIT</td><td>FIN_RECV(recv fin)</td><td>SYN_ACKED</td><td>false</td><td>true</td></tr><tr><td>LAST_ACK</td><td>FIN_RECV</td><td>FIN_SENT(fin send)</td><td>false</td><td>true</td></tr><tr><td>CLOSED</td><td>FIN_RECV</td><td>FIN_ACKED(recv ack)</td><td>false</td><td>false</td></tr></tbody></table></li><li>client状态表如下<table><thead><tr><th>TCPConnection State</th><th>TCPReceiver State</th><th>TCPSender State</th><th>linger_after_stream_finish</th><th>active</th></tr></thead><tbody><tr><td>1. (主动发起连接)LISTEN</td><td>LISTEN</td><td>CLOSED</td><td>true</td><td>true</td></tr><tr><td>SYN_SENT</td><td>LISTEN</td><td>SYN_SENT</td><td>true</td><td>true</td></tr><tr><td>ESTABLISHED</td><td>SYN_RECV(recv syn)</td><td>SYN_ACKED(recv ack)</td><td>true</td><td>true</td></tr><tr><td>2. (主动关闭连接)FIN_WAIT1</td><td>SYN_RECV</td><td>FIN_SENT(send syn)</td><td>true</td><td>true</td></tr><tr><td>FIN_WAIT2</td><td>SYN_RECV</td><td>FIN_ACKED(recv ack)</td><td>true</td><td>true</td></tr><tr><td>TIME_WAIT</td><td>FIN_RECV</td><td>FIN_ACKED</td><td>true</td><td>true</td></tr><tr><td>CLOSED</td><td>FIN_RECV</td><td>FIN_ACKED</td><td>false</td><td>false</td></tr></tbody></table></li></ul></li></ul><h4 id="主动关闭连接可能会经历的四种状态"><a href="#主动关闭连接可能会经历的四种状态" class="headerlink" title="主动关闭连接可能会经历的四种状态"></a>主动关闭连接可能会经历的四种状态</h4><ul><li><p>关于连接关闭时的state <strong>FIN_WAIT1 , FIN_WAIT2 , CLOSING , CLOSED</strong> 关系。<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-18-26-39.png"></p></li><li><p>FIN_WAIT1 -&gt; FIN_WAIT2 -&gt; TIME_WAIT -&gt; CLOSED </p><ul><li>是常规的client主动关闭连接。如上client表所述</li></ul></li><li><p><strong>FIN_WAIT1 -&gt; CLOSING -&gt; TIME_WAIT -&gt; CLOSED</strong></p><ul><li><strong>为什么会有 CLOSING</strong> ? <ul><li><strong>双方同时主动的关闭连接，也即都主动的发送fin segment</strong><ul><li>使得local 在收到local发送的fin的ack之前，先收到了remote peer发送的fin</li><li><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-12-59.png"><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-15-51.png"></li></ul></li><li>好比说 client主动关闭连接,发送fin；同时server也主动关闭连接,发送fin<ul><li>下图为client表,server表和client表一模一样。<ul><li>为什么需要有time_wait：当从closing -&gt; 变成 fin_recv + fin_acked的时候，已经满足#123，但无法满足#4，因为是主动发送fin，无法保证对方收到了fin的ack（被动发送fin的话，对方fin的ack会随着我方的fin被发送过去，而对方返回的对我们的fin的ack，就代表了对方收到了fin ack）<table><thead><tr><th>TCPConnection State</th><th>TCPReceiver State</th><th>TCPSender State</th><th>linger_after_stream_finish</th><th>active</th></tr></thead><tbody><tr><td>(主动关闭连接)FIN_WAIT1</td><td>SYN_RECV</td><td>FIN_SENT(send syn)</td><td>true</td><td>true</td></tr><tr><td>CLOSING</td><td>FIN_RECV(recv fin)</td><td>FIN_SENT</td><td>true</td><td>true</td></tr><tr><td>TIME_WAIT</td><td>FIN_RECV</td><td>FIN_ACKED</td><td>true</td><td>true</td></tr><tr><td>CLOSED</td><td>FIN_RECV</td><td>FIN_ACKED</td><td>false</td><td>false</td></tr></tbody></table></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><a href="https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B">FIN_WAIT1 -&gt; TIME_WAIT</a><ul><li>peer的fin和ack for local fin在同一个segment里一起发送过来</li><li>当被动关闭方（上图的服务端）在 TCP 挥手过程中，「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。</li><li>TCP 延迟确认机制:为尽量减少发送空的ack segment</li><li><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-19-35.png"></li></ul></li></ul><h4 id="Simultaneous"><a href="#Simultaneous" class="headerlink" title="Simultaneous"></a><strong>Simultaneous</strong></h4><h5 id="Simultaneous-Open"><a href="#Simultaneous-Open" class="headerlink" title="Simultaneous Open"></a>Simultaneous Open</h5><ul><li>双方同时发送syn报文</li><li>It’s possible for two applications to send a SYN to each other to start a TCP connection, although the possibility is small, because both sides have to know which port on the other side to send to. This process is called “<strong>Simultaneous Open</strong>“, or “<strong>simultaneous active open on both sides</strong>“.</li><li>For example: An application at host A uses 7777 as the local port and connects to port 8888 on host B. At the same time, an application at host B uses 8888 as the local port and connects to port 7777 on host A. This is “Simultaneous Open”.</li><li>TCP is specially designed to deal with “Simultaneous Open”, during which only one TCP connection is established, not two. The state transitions are shown in the following figure:<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-43-12.png"></li></ul><h5 id="Simultaneous-Close"><a href="#Simultaneous-Close" class="headerlink" title="Simultaneous Close"></a>Simultaneous Close</h5><ul><li>双方同时发送 fin 报文</li><li>It’s permitted in TCP for both sides to do “active close”, which is called “<strong>Simultaneous Close</strong>“. The state transitions are shown in the following figure:<br><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-18-19-21-53.png"></li></ul><p>故此 当然我的实现也可以正常处理这2种情况</p><h2 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h2><p>我写完第一次测试时 在模拟测试阶段，遇到了一些special case的bug，不过改起来也很愉快，写在case里。</p><p>第二次测试时，惊人的发现所有真实发送segment的测试都fail了，一度心态崩溃道心破碎，自己开server client 来回发送segment抓包还能正常工作，也看不到有什么异常的segment。明明没错啊但是还一个test都过不了，简直是给我搞得抓心挠肝。</p><p>后来研究了一下他的测试原理，应该是将我们tcpconnection收发的segment以及tcpconnection的类中所有的输出 都重定向到了测试文件a里。然后将这个a和输入的文件进行比较是否相等。由于重定向，我在code中的cout也被输入到了文件a中，故fail。</p><p>相等，则pass<br>不等，则fail</p><p>这谁能想到，遂将所有cout注释掉，测试，all passed，吾喜而笑，洗盏更酌，睡觉。</p><p>测试原理明天再整理.</p><h2 id="Over"><a href="#Over" class="headerlink" title="Over !"></a>Over !</h2><p><img src="/2023/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab4/2023-01-15-23-44-33.png"></p><h2 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h2><p>closing case. 整理完上面的Closing State , 这个就很显然了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;*********************start in CLOSING, send ack, time out**********************&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//  review</span></span><br><span class="line"><span class="comment">// test #2: start in CLOSING, send ack, time out</span></span><br><span class="line">&#123;</span><br><span class="line">    TCPTestHarness test_2 = TCPTestHarness::in_closing(cfg);    <span class="comment">//  closing . TCPSender : FIN_SENT , TCPReceiver : FIN_RECV</span></span><br><span class="line">    test_2.execute(Tick(<span class="number">4</span> * cfg.rt_timeout));                   <span class="comment">//  超时 local重传fin segment</span></span><br><span class="line">    test_2.execute(ExpectOneSegment&#123;&#125;.with_fin(<span class="literal">true</span>));          <span class="comment">//  check local是否重传fin segment</span></span><br><span class="line">    test_2.execute(ExpectState&#123;State::CLOSING&#125;);                <span class="comment">//  local state still = closing</span></span><br><span class="line">    test_2.send_ack(WrappingInt32&#123;<span class="number">2</span>&#125;, WrappingInt32&#123;<span class="number">2</span>&#125;);        <span class="comment">//  收到ack</span></span><br><span class="line">    test_2.execute(ExpectNoSegment&#123;&#125;);                          <span class="comment">//  local send no segment</span></span><br><span class="line">    test_2.execute(ExpectState&#123;State::TIME_WAIT&#125;);              <span class="comment">//  local in time_wait</span></span><br><span class="line">    test_2.execute(Tick(<span class="number">10</span> * cfg.rt_timeout - <span class="number">1</span>));              </span><br><span class="line">    test_2.execute(ExpectState&#123;State::TIME_WAIT&#125;);</span><br><span class="line">    test_2.execute(Tick(<span class="number">2</span>));</span><br><span class="line">    test_2.execute(ExpectState&#123;State::CLOSED&#125;);                 <span class="comment">//  local pass time_wait</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举出一个client、server的例子</p><hr><h2 id="优化-后续"><a href="#优化-后续" class="headerlink" title="优化.. 后续"></a>优化.. 后续</h2><ul><li>Does the TCPConnection need any fancy data structures or algorithms?<ul><li>No, it really doesn’t. The <strong>heavy lifting is all done by the TCPSender and TCPReceiver</strong> that you’ve already implemented.  </li><li>The work here is really just about wiring everything up, and dealing with some lingering connection-wide subtleties that can’t easily be factored in to the sender and receiver.</li><li><strong>The hardest part will be deciding when to fully terminate a TCPConnection and declare it no longer active.</strong></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;TCPConnection : 基于之前实现的 TCPReciver和TCPSender ; 作为完整的一端的TCP实现&lt;ul&gt;
&lt;li&gt;功能以及对应核心函数如下&lt;ul&gt;
&lt;li&gt;接收segment : segment_received&lt;ul&gt;
&lt;li&gt;本端接收seg 并根据自身receiver以及sender状态 发送相应seg给peer&lt;/li&gt;
&lt;li&gt;注意在segment_receive中 会自动调用send_segments()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;发送segment : send_segment. (会捎带ack)&lt;/li&gt;
&lt;li&gt;pass时间 : tick. 可能触发重传&lt;/li&gt;
&lt;li&gt;shutdown关闭连接&lt;ul&gt;
&lt;li&gt;unclean_shutdown : 清空要发送的seg , 根据是否主动异常,发送rst , 设置_sender和receiver状态error , active_ = false&lt;ul&gt;
&lt;li&gt;active unclean_shutdown : send rst&lt;/li&gt;
&lt;li&gt;passive unclean shut_down : not send rst&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;clean_shutdown : active = false&lt;ul&gt;
&lt;li&gt;active clean_shutdown : 在tick时 判断是否经历完TIME_WAIT, 经历完，则clean_shutdown&lt;/li&gt;
&lt;li&gt;passive clean_shutdown : 在segment_recieve接收完FIN的ACK后发现进入CLOSED状态，则clean_shutdown&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;最核心的一点 : &lt;strong&gt;如何确定结束连接&lt;/strong&gt;. When TCPConnection is Done&lt;ul&gt;
&lt;li&gt;unclean shutdown : 接收或发送rst就立刻结束连接&lt;/li&gt;
&lt;li&gt;clean shutdown&lt;ul&gt;
&lt;li&gt;需要满足#1#2#3#4&lt;/li&gt;
&lt;li&gt;只有一端同时满足四个条件，该端才能认为TCPConnection is done. 结束连接.&lt;/li&gt;
&lt;li&gt;对于#4有两种情况可以满足&lt;ul&gt;
&lt;li&gt;active close : A. 无法确定100%满足,只能通过TIME_WAIT接近100%&lt;ul&gt;
&lt;li&gt;这也就是由于两军问题,不可能去保证两端(主动关闭的无法一定达成clean shutdown)都能达成clean shutdown，但是TCP已经尽可能地接近了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;passive close : B. 100%满足&lt;ul&gt;
&lt;li&gt;被动关闭的一端无需linger time，可以100%达成clean_shutdown&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>muduo-http</title>
    <link href="http://example.com/2023/01/10/muduo-http/"/>
    <id>http://example.com/2023/01/10/muduo-http/</id>
    <published>2023-01-10T11:25:00.000Z</published>
    <updated>2023-02-27T15:19:08.265Z</updated>
    
    <content type="html"><![CDATA[<p>muduo httpServer原理以及使用</p><p>为什么要加个httpServer ?<br>因为之前做校园猫管理平台的时候，底层用的就是这个之前学习做的tinyMuduo.<br>但是由于时间紧张，当时只是client和server裸发送json字符串，没有使用正经的应用层协议，遂在期末结束后给原先光秃秃的tcp server加一层http.<br>基本都是看完Muduo之后默着写 然后再改的。。<br>不难，就是string处理琐碎烦人.</p><span id="more"></span><h2 id="相关类及使用"><a href="#相关类及使用" class="headerlink" title="相关类及使用"></a>相关类及使用</h2><ul><li><p>http部分就是基于tcp server之上，增加了几个内置的类和回调函数.是对tcpServer的使用. http部分负责解析http请求以及生成响应。并提供给用户注册回调函数的接口.</p><ul><li>用户负责注册的callback : 针对不同url以及method等 返回资源(实体体)和生成响应码(状态行),以及首部行. 实现的HTTPServer会帮助user将response存入Buffer并发送出去</li></ul></li><li><p>muduo http类图</p><ul><li><img src="/muduo-http/2023-02-22-11-05-31.png"></li></ul></li><li><p>相关类</p><ul><li>HTTPContext : FSM解析http request</li><li>HTTPRequest : 解析后的request信息存在这里</li><li>HTTPResponse : user向其中写入要发送的信息,然后http server会序列化到buf中,最后send出去.</li><li>HTTPServer:<ul><li>void HttpServer::onMessage(const TcpConnectionPtr&amp; conn, Buffer* buf,Timestamp receiveTime)<ul><li>解析http请求，调用user的callback(httpCallback_)，发送生成的response.</li></ul></li></ul></li></ul></li><li><p>user使用很简单</p><ul><li>只需注册一个respond即可. 该callback负责根据已经解析好的http request 填充http response<blockquote><p><img src="/muduo-http/2023-02-22-11-12-26.png"></p></blockquote></li></ul></li><li><p>更多注释见代码</p></li></ul><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><ul><li><p>http请求报文格式</p><ul><li>每行的末尾都是\r\n ; 首部行和实体体之间有一行\r\n</li><li>网上又将首部行称为请求头，实体体称为请求体</li><li><img src="/muduo-http/2023-02-21-19-25-13.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请求行 requestline : GET /hello.txt HTTP/<span class="number">1.1</span>\r\n</span><br><span class="line">首部行 headerline  : User-Agent: curl/<span class="number">7.16</span><span class="number">.3</span> libcurl/<span class="number">7.16</span><span class="number">.3</span> OpenSSL/<span class="number">0.9</span><span class="number">.7l</span> zlib/<span class="number">1.2</span><span class="number">.3</span>\r\n</span><br><span class="line">首部行 headerline  : Host: www.example.com\r\n</span><br><span class="line">首部行 headerline  : Accept-Language: en, mi\r\n</span><br><span class="line">\r\n</span><br><span class="line">实体体 entity body</span><br></pre></td></tr></table></figure></li></ul></li><li><p>http响应报文格式</p><ul><li>每行的末尾都是\r\n ; 首部行和实体体之间有一行\r\n</li><li>网上又将状态行称为响应行, 首部行称为响应头 , 实体体称为响应体</li><li><img src="/muduo-http/2023-02-21-20-09-13.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">状态行 statusline : HTTP/<span class="number">1.1</span> <span class="number">200</span> OK\r\n</span><br><span class="line">首部行 headerline : Content-Encoding: gzip\r\n</span><br><span class="line">首部行 headerline : Content-Type: text/html\r\n</span><br><span class="line">首部行 headerline : Date: Thu, <span class="number">16</span> Jul <span class="number">2020</span> <span class="number">06</span>:<span class="number">45</span>:<span class="number">26</span> GMT\r\n</span><br><span class="line">首部行 headerline : Content-Length: <span class="number">78</span>\r\n</span><br><span class="line">首部行 headerline : Connection: keep-alive\r\n</span><br><span class="line">\r\n</span><br><span class="line">实体体 entity body : &lt;div&gt;&lt;div id=<span class="string">&quot;__status&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;&lt;div id=<span class="string">&quot;__redirect&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;&lt;div id=<span class="string">&quot;__switchtime&quot;</span>&gt;<span class="number">0</span>&lt;/div&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>压测<br>  <img src="/muduo-http/2023-02-22-12-23-54.png"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;muduo httpServer原理以及使用&lt;/p&gt;
&lt;p&gt;为什么要加个httpServer ?&lt;br&gt;因为之前做校园猫管理平台的时候，底层用的就是这个之前学习做的tinyMuduo.&lt;br&gt;但是由于时间紧张，当时只是client和server裸发送json字符串，没有使用正经的应用层协议，遂在期末结束后给原先光秃秃的tcp server加一层http.&lt;br&gt;基本都是看完Muduo之后默着写 然后再改的。。&lt;br&gt;不难，就是string处理琐碎烦人.&lt;/p&gt;</summary>
    
    
    
    <category term="Muduo" scheme="http://example.com/categories/Muduo/"/>
    
    
    <category term="Muduo" scheme="http://example.com/tags/Muduo/"/>
    
    <category term="源码分析" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-传输层-拥塞控制</title>
    <link href="http://example.com/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://example.com/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</id>
    <published>2023-01-10T08:59:44.000Z</published>
    <updated>2023-02-27T15:24:21.079Z</updated>
    
    <content type="html"><![CDATA[<p>TCP 拥塞控制 : 为了公平性<br>原理(拥塞窗口)、原因、算法<br>算法包括 慢启动 拥塞避免 快速恢复 拥塞发生</p><span id="more"></span><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><ul><li>拥塞:<ul><li>非正式的定义: “太多的数据需要网络传输，超过了网络的处理能力” </li><li>与流量控制含义不同<ul><li>流量控制 是为了 让发送端的发送速度和接收端的接受速度匹配，避免接收端接收缓存溢出</li><li>拥塞 是指 网络拥塞导致发送端发送的分组在路由器缓存溢出。</li><li>但行为是一致的：都是遏制发送方。</li></ul></li><li>拥塞的表现:<ul><li>分组丢失 (路由器缓冲区溢出)</li><li>分组经历比较长的延迟(在路由器的队列中排队)</li></ul></li></ul></li><li>拥塞控制问题<ul><li>与rdt一样，是网络中前十位的问题</li><li>如 ：拥塞控制如何在上层应用得到的服务性能中明确的显露出来？如何可用各种方法来避免网络拥塞或对他作出反应？</li></ul></li></ul><h2 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h2><ul><li><p>代价</p><ul><li>在分组的到达速率接近链路容量时，分组经历巨大的排队时延</li><li>发送方必须重传以补偿因为缓存溢出而丢失的分组</li><li>发送方在遇到大时延所进行的不必要重传会引起路由器利用其链路带宽转发不必要的分组副本</li><li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了</li></ul></li><li><p>场景见补充</p></li></ul><h2 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h2><p>根据网络层是否为运输层拥塞控制提供显示支持</p><ul><li><p>端到端拥塞控制</p><ul><li>没有来自网络的显式反馈，即网络层不为运输层拥塞控制提供显示支持</li><li>端系统根据分组丢失和时延推断是否有拥塞</li><li>TCP采用的方法</li></ul></li><li><p>网络辅助的拥塞控制</p><ul><li>路由器提供给端系统以反馈信息,即网络层为运输层拥塞控制提供显示支持</li><li>单个bit置位，显示拥塞情况 (SNA, DECbit, TCP/IP ECN, ATM)</li><li>显式提供发送端可以采用的速率</li><li>例子：ATM可用比特率 (略)</li></ul></li></ul><h2 id="TCP拥塞控制概述"><a href="#TCP拥塞控制概述" class="headerlink" title="TCP拥塞控制概述"></a>TCP拥塞控制概述</h2><ul><li><strong>一种形式受限的拥塞控制</strong> : <strong>Timer定时器的RTO在每次重传之后呈指数型增长</strong><ul><li>定时器过期很可能是由网络拥塞引起的，即太多的分组到达路径中的路由器队列中，造成分组丢失或较长排队时延。在拥塞时如果持续重传分组，会使得分组更加严重；于是，TCP采用更文雅的方式，每个发送方的分组都是经过越来越长的时间间隔后进行。</li></ul></li><li>下面介绍更复杂的TCP拥塞控制形式。</li></ul><h3 id="拥塞感知"><a href="#拥塞感知" class="headerlink" title="拥塞感知"></a>拥塞感知</h3><p>发送端如何探测到拥塞 ?<br>根据《自顶向下》: 发生丢包<br>先声明：TCP的丢包事件 定义为<br>要么 1. 出现超时<br>要么 2. 收到来自接收方的3个冗余ACK(一般收到三个冗余ack时还没超时 因为RTO设置的相对保守)</p><ul><li><strong>某个segment超时了 : 拥塞</strong><ul><li>超时时间到，某个段的确认没有来 </li><li>原因1：网络拥塞（某个路由器缓冲区没空间了，被丢弃）概率大 </li><li>原因2：出错被丢弃了（各级错误，没有通过校验，被丢弃）概率小 </li><li>一旦超时，就认为拥塞了，有一定误判，但是总体控制方向是对</li></ul></li></ul><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-50-36.png"></p><ul><li><strong>有关某个段的3次冗余ACK：轻微拥塞</strong><ul><li>第1个ACK : 正常ACK. ackno = 3460 , 确认绿色segment</li><li>2，3，4次ACK：三次冗余ack. ackno = 3460 , 确认乱序到达的蓝色,橙色,灰色segment</li><li>粉色segment仍然没被确认，其后面的segment却确认了，故粉色segment丢失的可能性很大</li><li>网络这时还能够进行一定程度的传输，拥塞情况轻于第一种</li></ul></li></ul><h3 id="拥塞控制-1"><a href="#拥塞控制-1" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制中，TCP如何限制Sender发送segment ? –&gt; 通过维护拥塞窗口</p><ul><li><strong>拥塞窗口 Congestion Window</strong><ul><li><strong>cwnd</strong></li><li>TCPSender 维护一个 <strong>拥塞窗口</strong><ul><li>在整个过程中保证(<strong>流量控制和拥塞控制的联合动作</strong>) <ul><li><strong>send_window(bytes sent but not acked) &lt;= min {cwnd(拥塞控制),rwnd(流量控制)}</strong><ul><li>rwnd : 满足接收方不会缓存溢出</li><li>cwnd : 满足网络可以不拥塞的传输分组</li></ul></li><li>本part关注拥塞控制，故假设接收缓存无限大 -&gt; receive_window_size 无限大<ul><li>故 bytes sent but not acked &lt; cwnd</li><li>Sender 发送速率 为 cwnd / RTT   byte/s</li></ul></li></ul></li><li>从而粗略地控制发送方的往网络中注入的速率</li></ul></li><li><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-22-04-18.png"></li></ul></li></ul><h3 id="cwnd变化"><a href="#cwnd变化" class="headerlink" title="cwnd变化"></a>cwnd变化</h3><p>通过调节cwnd来控制发送速率,那么TCPSender该怎样确定应当发送的速率呢 ?</p><ul><li>CongWin是动态的，是感知到的网络拥塞程度的函数<ul><li>超时或者3个重复ack，CongWin↓<ul><li>超时：CongWin降为1MSS,进入SS阶段然后再倍增到 CongWin/2（每个RTT），从而进入CA阶段 </li><li>3个重复ack ：CongWin降为CongWin/2,CA阶段</li></ul></li><li>否则（正常收到Ack，没有发送以上情况）：CongWin跃跃欲试↑<ul><li>SS阶段：加倍增加(每个RTT)</li><li>CA阶段：线性增加(每个RTT)</li></ul></li></ul></li></ul><h2 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h2><h3 id="慢启动-slow-start-SS"><a href="#慢启动-slow-start-SS" class="headerlink" title="慢启动 slow-start (SS)"></a>慢启动 slow-start (SS)</h3><ul><li><p>连接刚建立, CongWin = 1 MSS </p><ul><li>如: MSS = 1460bytes &amp; RTT = 200 msec </li><li>初始速率 = 58.4kbps</li><li>可用带宽可能&gt;&gt;MSS/RTT<ul><li>应该尽快加速，到达希望的速率</li></ul></li></ul></li><li><p><strong>指数性增加CongWin</strong> </p><ul><li>每经过一个RTT， CongWin加倍  &lt;—&gt; 每收到一个ACK时，CongWin加1MSS (这两个概念是一致的) </li><li><strong>慢启动阶段：只要不超时或3个冗余ack 且 cwnd &lt; sstresh，每经过一个RTT，CongWin *= 2</strong></li><li><strong>在丢包之前，当cwnd达到sstresh，进入拥塞避免阶段，cwnd线性增长</strong></li><li>ssthresh : 上次发生超时时的窗口的一半<br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-22-40-38.png"></li></ul></li><li><p><strong>SS总结: 初始速率很慢，但是加速却是指数性的</strong> </p><ul><li><strong>SS时间很短，长期来看可以忽略</strong></li><li>慢启动阶段并不慢</li></ul></li></ul><h3 id="AIMD"><a href="#AIMD" class="headerlink" title="AIMD"></a>AIMD</h3><ul><li><strong>AMID : Additive-Increase , Multiplicative-Decrease</strong><ul><li>TCP拥塞控制常被称为<strong>加性增，乘性减</strong>的拥塞控制方式<br>cwnd窗口大小随时间：锯齿形<br>慢启动阶段忽略不计，因为很快<br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-22-34.png"></li></ul></li></ul><h4 id="加性增"><a href="#加性增" class="headerlink" title="加性增"></a><strong>加性增</strong></h4><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><ul><li>还没发生拥塞</li><li>当cwnd &gt; ssthresh时，进入<strong>拥塞避免</strong><ul><li><strong>一个RTT如没有发生丢失事件 ,将cwnd加1MSS(为了探测)</strong><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-33-55.png"></li></ul></li></ul><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>不知道该不该放在加性增下面 我觉得应该反正放在这个下面<br>参考小林coding &amp; 自顶向下 &amp; 郑老师</p><ul><li>快速重传的拥塞发生 和 快速恢复算法 搭配使用</li><li>快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。</li><li>如拥塞发生所说<ul><li>cwnd = cwnd/2</li><li>ssthresh = cwnd;</li></ul></li><li>然后，进入快速恢复算法如下<ul><li>cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值<ul><li>原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态</li></ul></li><li><blockquote><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-09-43.png"></p></blockquote></li></ul></li></ul><h4 id="乘性减"><a href="#乘性减" class="headerlink" title="乘性减"></a><strong>乘性减</strong></h4><h5 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h5><p>发生拥塞时</p><ul><li><p>根据是快速重传还是超时重传区分<strong>拥塞发生算法</strong></p></li><li><ol><li><strong>当收到3个重复的ACKs</strong>: 不进入慢启动阶段</li></ol><ul><li>cwnd /= 2</li><li>ssthresh = cwnd</li><li>进入快速恢复阶段 / 或者仅仅就是cwnd线性增长</li></ul></li><li><ol start="2"><li>当<strong>超时事件发生</strong>时: 进入慢启动阶段</li></ol><ul><li>ssthresh = cwnd / 2</li><li>cwnd = 1 MSS，<strong>进入SS阶段</strong><blockquote><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-09-57-23.png"></p></blockquote></li></ul></li></ul><ol><li>3个重复的ACK表示网络还有一定的段传输能力<br>超时之前的3个重复的ACK表示“警报” : 即将发生拥塞<br>故收到三个重复ACK并不会使得cwnd = 1</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>当CongWin＜Threshold, 发送端处于<strong>慢启动阶段（slow-start）</strong>, 窗口指数性增长. </li><li>当CongWin &gt; Threshold, 发送端处于<strong>拥塞避免（congestion-avoidance）</strong>, 窗口线性增长. </li><li>当收到三个重复的ACKs (triple duplicate ACK),<ul><li>Threshold设置成 CongWin/2</li><li>进入<strong>快速恢复</strong> , CongWin=Threshold+3. </li></ul></li><li>当超时事件发生时timeout, <ul><li>Threshold=CongWin/2</li><li>CongWin=1 MSS，进入 <strong>SS慢启动阶段</strong></li></ul></li></ul><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-16-08.png"></p><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-19-04.png"></p><h2 id="TCP公平性"><a href="#TCP公平性" class="headerlink" title="TCP公平性"></a>TCP公平性</h2><ul><li>公平性目标: <ul><li>如果 K个TCP会话分享一个链路带宽为R的瓶颈，每一个会话的有效带宽为 R/K<br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-39-36.png"></li></ul></li></ul><ul><li>为什么公平 ? <ul><li>因为拥塞控制算法</li><li>2个竞争的TCP会话:<ul><li>加性增加，斜率为1, 吞吐量增加</li><li>乘性减，吞吐量比例减少<br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-38-03.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-40-35.png"></li></ul></li></ul></li></ul><ul><li>公平性和 UDP<ul><li>多媒体应用通常不是用TCP <ul><li>应用发送的数据速率希望不受拥塞控制的节制</li></ul></li><li>使用UDP: <ul><li>音视频应用泵出数据的速率是恒定的, 忽略数据的丢失</li></ul></li><li>研究领域: TCP 友好性</li></ul></li><li>公平性和并行TCP连接<ul><li>2个主机间可以打开多个并行的TCP连接</li><li>例如: <ul><li>带宽为R的链路支持了9个BB’TCP连接;</li><li>AA’建立一条新TCP连接,占据带宽R/10</li><li>那么AA’占据带宽9/10,BB’占据带宽9/10</li><li><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-11-10-43-20.png"></li></ul></li><li>故TCP的公平也只是大致公平<h2 id="补充-拥塞场景"><a href="#补充-拥塞场景" class="headerlink" title="补充 : 拥塞场景"></a>补充 : 拥塞场景</h2>《自顶向下》P172</li></ul></li><li>场景一<ul><li><blockquote><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-20-58-17.png"></p></blockquote></li></ul></li><li>场景二<blockquote><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-20-59-05.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-01-13.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-01-18.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-01-31.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-01-44.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-20-59-59.png"></p></blockquote></li><li>场景三<blockquote><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-00-48.png"><br><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/2023-01-10-21-00-57.png"></p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;TCP 拥塞控制 : 为了公平性&lt;br&gt;原理(拥塞窗口)、原因、算法&lt;br&gt;算法包括 慢启动 拥塞避免 快速恢复 拥塞发生&lt;/p&gt;</summary>
    
    
    
    <category term="计网" scheme="http://example.com/categories/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://example.com/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-CS144-lab3</title>
    <link href="http://example.com/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/"/>
    <id>http://example.com/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/</id>
    <published>2023-01-04T00:57:07.000Z</published>
    <updated>2023-02-27T15:23:43.486Z</updated>
    
    <content type="html"><![CDATA[<ul><li>实现 TCPSender<ul><li>发送新segment : fill_window() when 上层有数据 &amp;&amp; receive_window有空间<ul><li>fill_window 负责一直向后走 发送新数据. 更新send_window</li><li>重传的部分交由tick()来做</li></ul></li><li>定时器超时重传 : tick()<ul><li>更新send_window ; 重启定时器 ; 超时重传 , RTO加倍</li><li><a href="https://datatracker.ietf.org/doc/rfc6298/?include_text=1">Retransmission Timer [RFC]</a></li></ul></li><li>收到ACK报文 : ack_received()<ul><li>更新rwnd , sender自动继续发送fill_window.(因为rwnd可能变大)</li></ul></li></ul></li><li>我们Sender并没有实现快速重传(可以不实现，易知不影响其正确性，仍然可以可靠传输)</li><li>有趣的是我们Sender并没有实现拥塞控制，但TCP仍然可以正常运行.<ul><li>原因如下 : 拥塞控制只是为了TCP的公平性，使得其不会无节制的占用带宽. 如我们的信道中有两条TCP连接，若都实现了拥塞控制，那么最终二者所占带宽会向y=x收敛.</li><li>而为了保证己方Sender可以和对端Receiver正常交互，我们只需要保证：<ul><li>每个字节都令对方接受到并返回ACK : 重传保证</li><li>对端receiver不会由于己方发送过快而导致receiver buf缓存溢出<ul><li>这通过流量控制就解决了.</li></ul></li></ul></li></ul></li></ul><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-06-15-35-14.png"></p><ul><li>lab0中, 我们实现了bytestream</li><li>lab1 和 lab2中, 我们实现了StreamReassembler 和 TCPReceiver : 将通过不可靠的datagrams传送来的segment 重组到 bytestream中</li><li>lab3中, 我们将实现tcp connection的另一端 : TCPSender：TCPSender 将 outbound bytestream 转化成 不可靠datagrams的负载内容</li><li>lab4中，我们将组装lab0123 来实现tcp：一个包含 TCPSender 和 TCPReceiver 的 tcp connection。我们将使用lab4实现的tcp 去和互联网上真实的server进行通信</li></ul><h2 id="TCP-Sender-概述"><a href="#TCP-Sender-概述" class="headerlink" title="TCP Sender 概述"></a>TCP Sender 概述</h2><ul><li>TCP 协议 是一个 在不可靠的 datagram之上 传输可靠 的 流量控制的 字节流 的协议。<br>参与TCP连接的双方 都同时扮演了sender和 receiver的角色。</li><li>本周，我们将实现 TCP Sender。TCPSender 负责读取 outbound bytestream ，并将 stream转化成将要发出的一系列 tcp segment。（在对端，TCP receiver 将这些 segment(those that arrive—they might not all make it)重组为原先的字节流，并发送ack 和 window size 给sender。）</li><li>TCP sender 和 receiver 各自负责 TCP segment的一部分. <ul><li>TCP Sender 添写 lab2 中 TCP receiver 相关的 所有字段 sequence number , syn , fin , payload (其他的在wrap in ip , unwrap in ip)</li><li>TCP Sender 只读取 receiver 填写的字段 : ackno , window size<br><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-06-16-53-45.png"></li></ul></li></ul><h2 id="TCPSender-责任"><a href="#TCPSender-责任" class="headerlink" title="TCPSender 责任"></a>TCPSender 责任</h2><ul><li><p>TCP Sender 负责</p></li><li><p>关注 receiver window , 处理传入的 ackno 和 window size</p></li><li><p>填充receiver window : 在可能的时候 通过 读取outbound bytestream ，创建 tcp segment(include syn , fin) 并发送。TCP Sender应当持续发送segment 直到 receiver window满了 或者 bytestream 空了。（没有可发送的segment，即 no data payload(bytestream.eof()) &amp;&amp; no flags)</p></li><li><p>outstanding segment : 关注sent but not acked 的segment，我们称之为 outstanding segment（未完成的segment，就是之前学的send window).</p></li><li><p>重传 outstanding segment 当超时（从发送之后开始计时）</p></li><li><p>我为什么要做这个 ？</p><ul><li>基本原理是 automatic repeat request(ARQ) : (fill window)sender发送任何receiver允许发送的segment，并且持续重传segment，直到receiver ack了每个segment。</li><li>TCP sender 将流切分成segment，并在receiver允许的范围内尽可能地发送他们。</li><li>由之前实现易知, tcp receiver 可以重组至少接收到一次的byte；那么Sender需要保证receiver对于每个byte都至少接收到了一次</li></ul></li></ul><h2 id="TCPSender如何知道-segment-lost"><a href="#TCPSender如何知道-segment-lost" class="headerlink" title="TCPSender如何知道 segment lost"></a>TCPSender如何知道 segment lost</h2><ul><li><p>TCPSender 如何知道一个segment丢失了 ? (即发送方没有接收到 接收方 发送的 对该segment的ack)</p></li><li><p>TCPSender 将会持续发送一堆segment,每个segment都包含了来自outbound bytestream的substring，每个segment都有一个seqno作为下标来代表其在字节流中的位置,并且用SYN flagstream的开始,FIN flag标记stream的结束。</p></li><li><p>除了发送segment，TCPSender还需要关注 outstanding segment 直到 其被 ack。</p></li><li><p>TCP Sender也会周期性的调用tick方法，标记着时间的流逝。</p></li><li><p>TCP Sender负责 查询所有outstanding segment 然后决定 最老的outstanding segment是否已经超时（长时间没被ack,outstanding for too long）。（这句话就是说在tick的时候 如果定时器超时（全局只有一个最老的outstanding segment的定时器））</p><ul><li>如果是，则重传该分组</li></ul></li><li><p>Here are outstanding for too long的含义 </p><ul><li>These are based on a simplified version of the “real” rules for TCP: RFC 6298, recommendations 5.1 through 5.6. The version here is a bit simplified, but your TCP implementation will still be able to talk with real servers on the Internet</li><li>你将要实现如下逻辑，有一点详细，但我们不希望你过于教条或者面向case编程。（感觉就是这意思）。lab3将给你一些合理的测试。lab4会给全部测试</li></ul></li><li><p>我为什么要做这个 ?</p><ul><li>总体目标是 让sender及时检测到segment丢失 并 需要重新发送。</li><li>超时时间很重要：你不会希望发送方在重传segment之前等待过长时间（因为这样延迟了字节流向发送方），但是你也不会想重传一个即将收到ack的segment，因为这样会浪费宝贵的网络流量。（重传出去的这个segment就相当于没用了，因为之前发送的该segment的ack马上就收到，而之后再收到的重传的segment的ack就没用了，因为segment已经被ack了，已经不在send_window中了）</li></ul></li><li><ol><li>每隔一些微秒，TCPSender 就会调用 tick(elapsed_milliseconds)，来告知tcp sender 举例上次调用tick已经过去了多长时间(elapsed_milliseconds)。</li></ol><ul><li>使用tick来维护TCPSender处于活跃状态的总微秒数。不要调用syscall 如 time,clock function. tick 是我们操作时间流逝的唯一途径。这使得事情具有确定性和可测试性。</li></ul></li><li><ol start="2"><li>TCPSender 在构建是就会初始化 retransmission timeout (RTO) 的初始值(initial retransmission timeout)</li></ol><ul><li>RTO是超时时间。RTO的值 会随着超时次数变化，但是初始值不变。</li></ul></li><li><ol start="3"><li>你将实现 重传定时器retransmission timer : 一个可以计时 RTO时间 时钟。当RTO过去之后，alarm goes off 报警。我们强调通过tick method来获取时间流逝的概念 而非通过获取真实的时间。</li></ol></li><li><ol start="4"><li>每次发送segment时（nonzero length in sequence space），不管是第一次发送该报文还是重传该报文，如果timer没有启动，那么启动timer，这样RTO之后，timer就会expire过期(感觉可以理解成报警）。</li></ol></li><li><ol start="5"><li>当所有的outstanding data都被ack了，那么停止 retransmission timer</li></ol></li><li><ol start="6"><li>调用tick , timer过期</li></ol><ul><li>a. 重传outstanding segment中 最早发送的segment(lowest sequence number)。<pre><code>为实现此功能，你需要用一个数据结构来存储这些outstanding segment</code></pre></li><li>b. if receiver window size != 0 <ul><li>i. 关注consecutive retransmissions，当重传sth时 ++cnt。<ul><li>你的TCP连接将使用该信息，来决定一条连接是否已经没有希望，需要被放弃.(当重传次数cnt过多时)</li></ul></li><li>ii. RTO *= 2 , 减缓了我们在糟糕的网络上进行重传，以免进一步把事情搞糟(拥塞控制这就是 ?)</li></ul></li><li>c.  重置timer 并启动timer，使其在RTO之后过期（注意RTO可能翻倍） </li><li>可以看到，在tick函数的具体实现里，基本就是完全照着这abc三步做的</li></ul></li></ul><ul><li><ol start="7"><li>当发送端接收了接收方发送的确认新数据的ackno时（ackno比之前接收到的ackno都要大）（就是说ackno确认了outstanding的segment(即send window中的segment)）</li></ol><ul><li>a. 重置RTO = initial(我的实现是将RTO交给timer保管)</li><li>b. 如果TCP Sender有任何outstanding segment，那么重启timer</li><li>c. 重置consecutive retransmissions = 0</li></ul></li></ul><h2 id="Retransmission-Timer-RFC"><a href="#Retransmission-Timer-RFC" class="headerlink" title="Retransmission Timer [RFC]"></a>Retransmission Timer [RFC]</h2><p><a href="https://datatracker.ietf.org/doc/rfc6298/?include_text=1">RFC 中 共识的 TCP retransmission timer 实现</a></p><ul><li><ol start="5"><li> Managing the RTO Timer</li></ol><ul><li>An implementation MUST manage the retransmission timer(s) in such a<br>way that a segment is never retransmitted too early, i.e., less than<br>one RTO after the previous transmission of that segment.</li><li>The following is the RECOMMENDED algorithm for managing the<br>retransmission timer:</li><li>(5.1) Every time a packet containing data is sent (including a<pre><code> retransmission), if the timer is not running, start it running so that it will expire after RTO seconds (for the current value of RTO).</code></pre></li><li>(5.2) When all outstanding data has been acknowledged, turn off the<pre><code> retransmission timer.</code></pre></li><li>(5.3) When an ACK is received that acknowledges new data, restart the<pre><code> retransmission timer so that it will expire after RTO seconds (for the current value of RTO).</code></pre></li><li>When the retransmission timer expires, do the following:<ul><li>(5.4) Retransmit the earliest segment that has not been acknowledged<br>   by the TCP receiver.</li><li>(5.5) The host MUST set RTO &lt;- RTO * 2 (“back off the timer”).  The<br>   maximum value discussed in (2.5) above may be used to provide<br>   an upper bound to this doubling operation.</li><li>(5.6) Start the retransmission timer, such that it expires after RTO<br>   seconds (for the value of RTO after the doubling operation<br>   outlined in 5.5).</li><li>(5.7) If the timer expires awaiting the ACK of a SYN segment and the<br>   TCP implementation is using an RTO less than 3 seconds, the RTO<br>   MUST be re-initialized to 3 seconds when data transmission<br>   begins (i.e., after the three-way handshake completes).</li></ul></li></ul></li></ul><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>next_seqno_abs : sender要发送的下一个字节的绝对索引，syn和fin也会占据一个字节。<br>bytes_in_flight : bytes sent but not acked</p><p><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-07-00-17-39.png"></p><ul><li><p><strong>State</strong></p><ul><li>为了测试你的代码，test会期待你的sender经历一系列状态：从发送第一个syn报文，到发送所有数据，到发送fin报文，以及最终获得fin的ack。我们不认为你需要设计更多的变量来追踪这些状态。这些状态被简单的定义在tcp sender的接口中。但是为了让你理解test的输出，这里有一个tcpsender在stream的生命中的演化图。你不必要担心error state 或者 rst flag 直到lab4</li></ul></li><li><p><strong>CLOSED</strong> : waiting for stream to begin</p><ul><li>next_seqno_absolute() = 0</li><li>字节流中还没有任何字节，连最一开始的syn segment也没有发送</li></ul></li><li><p><strong>SYN_SENT</strong> : stream started but nothing acked</p><ul><li>sender发送了第一个syn报文(可能携带数据)(可能也接着发送了其他带data得segment)，但是sender还没有收到receiver对该syn报文的ack</li><li>next_seqno_absolute() == bytes_in_flight() &amp;&amp; next_seqno_absolute() &gt; 0<ul><li>next_seqno_absolute() == bytes_in_flight() : syn 和 data segment 都在 send_window中</li><li>next_seqno_absolute() &gt; 0 : 至少有一个syn了 </li></ul></li></ul></li><li><p><strong>SYN_ACKED</strong> : stream outgoing</p><ul><li>sender已经接收到了 syn 的 ack，那么syn就不会在bytes_in_flight中占据字节了（即不会在send window中占据字节了），但是syn仍然一直占据着abs_seqno空间里的0号位置。故会next_seqno_abs &gt; bytes_in_flight）</li><li>next_seqno_absolute() &gt; bytes_in_flight() &amp;&amp; not stream_in().eof()<ul><li>next_seqno_absolute() &gt; bytes_in_flight() : syn 不在 send_window中 (即syn已经acked)</li><li>not stream.eof() : stream还没到结尾</li></ul></li></ul></li><li><p><strong>SYN_ACKED (also)</strong> ： stream outgoing (stream has reached EOF , but FIN flag hasn’t been sent yet)</p><ul><li>sender的stream已经到eof了，但是sender还没有发送FIN seg</li><li>outbound_stream.eof() &amp;&amp; next_seqno_absolute() &lt; outbound_stream.bytes_written() + 2;</li><li>那么sender应该何时发送fin seg : <ul><li>在sender 处于syn_acked(also)状态时，且此时接受窗口的大小 还能装下 当前seg(syn + data)附带上一个fin flag,那么，发送fin segment</li></ul></li></ul></li><li><p><strong>FIN_SENT</strong> : stream finished(FIN sent) but not fully acked</p><ul><li>sender 已经 发送了 fin segment 但是还没有接收到 fin segment的ack</li><li>也即 sender 已经 将outbound stream的 字节全部发送出去，并发送了代表关闭的fin seg ， 但是sender还没有收到receiver对outbound stream中的所有字节的确认（因为fin还没被确认）</li><li>bytes_in_flight() &gt; 0 &amp;&amp; outbound_stream.eof() &amp;&amp; next_seqno_abs() == outbound_stream.bytes_written() + 2 &amp;&amp; bytes_in_flight() &gt; 0<ul><li>bytes_in_flight() &gt; 0 : 至少有一个fin segment sent but not acked</li><li>outbound_stream.eof() : 好理解，outbound已经走到了eof</li><li>next_seqno_abs() == outbound_stream.bytes_written() + 2 : 已经发送了fin<ul><li>next_seqno_abs = fin seq + 1。</li><li>好比outbound_stream发送了abcdef,那么下标为<ul><li>////   0  1 2 3 4 5 6 7   8///</li><li>////  syn a b c d e f fin ////</li><li>易知 next_abs_seq = 8</li><li>同时，outbound_stream.bytes_written() = 6 , 因为bytestream 并不会将 syn fin 作为占据stream_idx的字节。故+2 = next_seqno_abs</li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><strong>FIN_ACKED</strong> : stream finished fully acked<ul><li>outbound_stream的字节已经全部被acked</li><li>outbound_stream.eof() &amp;&amp; next_seq_abs = outbound_stream.bytes_written() + 2 &amp;&amp; bytes_in_flight() == 0<ul><li>outbound_stream.eof() : outbound_stream已经走到of</li><li>next_seq_abs = outbound_stream.bytes_written() + 2 : sender已经发送fin</li><li>bytes_in_flight() == 0 : sender没有sent but not acked 的segment（ -&gt; fin segment已经被acked）</li></ul></li></ul></li></ul><h2 id="TCPSender-实现"><a href="#TCPSender-实现" class="headerlink" title="TCPSender 实现"></a>TCPSender 实现</h2><ul><li>We’ve discussed the basic idea of what the TCP sender does (given an outgoing ByteStream, split it up into segments, send them to the receiver, and if they don’t get acknowledged soon enough, keep resending them). And we’ve discussed when to conclude that an outstanding segment was lost and needs to be resend.</li></ul><ul><li><p>TCPsender 主要关注以下几类事件</p><ul><li>发送新segment : fill_window() when 上层有数据 &amp;&amp; receive_window有空间</li><li>定时器超时重传 : tick()</li><li>收到ACK报文 : ack_received()<ul><li>维护receive_window</li><li>新ackno : 更新recv_window</li><li>老ackno : 我的实现是忽略·<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">event: <span class="function">data received from application above </span></span><br><span class="line"><span class="function">  create TCP segment with sequence number NextSeqNum </span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(timer currently <span class="keyword">not</span> running)</span> </span></span><br><span class="line"><span class="function">    start timer pass segment to IP </span></span><br><span class="line"><span class="function">  NextSeqNum </span>= NextSeqNum + length(data) </span><br><span class="line"></span><br><span class="line">event: timer timeout </span><br><span class="line">  retransmit <span class="keyword">not</span>-yet-acknowledged segment with smallest sequence number </span><br><span class="line">  start timer </span><br><span class="line"></span><br><span class="line">event: ACK received, <span class="function">with ACK field value of y </span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(y &gt; SendBase)</span> </span>&#123; </span><br><span class="line">    SendBase = y</span><br><span class="line">    <span class="keyword">if</span> (there are currently <span class="keyword">not</span>-yet-acknowledged segments) </span><br><span class="line">      start timer </span><br><span class="line">  &#125; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>接口如下。这四个接口每个都可能以发送tcp segment作为结尾</p></li></ul><h3 id="重要成员"><a href="#重要成员" class="headerlink" title="重要成员"></a>重要成员</h3><ul><li>图<br><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-09-22-03-33.png"></li></ul><p>约定outstanding segment : segment sent but not acked<br>约定超时时间：在重传一个outstanding segment之前所等待的时间。（从该segment被发送出去之后开始计时）<br>约定rwnd :  receive_window_size<br>约定 earliest outstanding segment : 最早发送的outstanding segment，即 send_window的左边界的segment的timer。<br>约定：携带数据的segment：即占据了sequence num的分组，即syn + payload + fin 不为空</p><ul><li><p><strong>_next_seqno{0}</strong></p><ul><li>含义：sender将要发送的下一个byte 在 字节流中的 abs_seqno</li><li>_next_seqno 是 单增的，只从stream中读取新数据来发送，而不管需要超时重传的数据。</li></ul></li><li><p><strong>约定 : send_window</strong>(中科大郑老师这么叫的，不过书上和rfc似乎没有这种叫法hhh)</p><ul><li>即将 bytes_in_flight 的 bytes 都称为落在 send_window中的bytes</li><li>即将 outstanding segment 都称为落在send_window中的segment</li><li><strong>[last_ackno , _next_seqno)</strong></li><li><strong>bytes sent but not acked : sebder已经发送但还没被接收到ack确认的字节</strong></li><li>随着sender接收到的ack_no的增大，send_window的左端也随之增大</li><li>随着sender发送新segment(_next_seqno增大)，send_window的右端也随之增大</li><li>实现<ul><li><strong><code>deque&lt;TCPSegment&gt; _send_window&#123;&#125;</code></strong></li></ul></li></ul></li></ul><ul><li><p><strong>std::queue<TCPSegment> _segments_out{};</TCPSegment></strong></p><ul><li>sender发送segment：将 segment 压入queue </li></ul></li><li><p><strong>size_t _receive_window_size{1}</strong></p><ul><li>sender认为receive_window_size</li><li><strong>rwnd初始化为1</strong>（在还没有接收到接收方的任何ack报文时）<ul><li><strong>原因 ？</strong>：我觉得为了使得sender可以发送出第一个SYN报文？不然会一直等待</li><li><strong>或许rfc中有</strong></li></ul></li></ul></li><li><p><strong>unsigned int _initial_retransmission_timeout</strong></p><ul><li>retransmission timer for the connection</li></ul></li><li><p><strong>Timer _timer</strong></p><ul><li>TCPSender全局只有一个定时器</li><li>该timer监测：earliest outstanding segment</li><li>该timer超时，重传earliest outstanding segment</li><li>sender的使用者通过tick()来使用_timer</li></ul></li><li><p>ByteStream _stream</p><ul><li>outgoing stream of bytes that have not yet been sent</li></ul></li><li><p><strong>uint64_t _consecutive_retransmissions_cnt;</strong></p><ul><li>对于同一分组的 重传次数</li></ul></li><li><p>enum <strong>State</strong> { ERROR = 0, CLOSED , SYN_SENT, SYN_ACKED_1,SYN_ACKED_2,FIN_SENT,FIN_ACKED,};</p><ul><li>见State</li></ul></li></ul><h3 id="fill-window"><a href="#fill-window" class="headerlink" title="fill_window"></a>fill_window</h3><ul><li><p><strong>fill_window含义: 从outbound_stream中读取新数据（还没发送过的数据），依据receive_window大小，尽可能多的发送出去。该方法并不负责重传segment，重传segment由tick方法负责。</strong></p></li><li><p><strong>fill_window 到什么时候停止发送 segment ?</strong></p><ul><li>只要同时满足AB两个条件，就一直发送segment<ul><li>(as long as there are new bytes to be read and space available in the window.) </li><li>A. 还有segment可以发送 <ul><li>payload!=0 (outbound_bytestream 中还有可读字节) + 需要发送 syn / fin flag </li></ul></li><li>B. receive_window还有空间</li></ul></li></ul></li><li><p><strong>在正确的时刻发送syn和fin flag</strong></p><ul><li>发送syn flag<ul><li>TCP Sender 处于 CLOSED 状态 : 字节流中还没有任何字节，连最一开始的syn segment也没有发送</li></ul></li><li>发送fin flag<ul><li>TCP Sender 处于 SYN_ACKED_2 状态 : TCP Sender的stream已经到eof了，但是TCP Sender还没有发送FIN seg</li></ul></li></ul></li></ul><ul><li><p><strong>发送segment</strong> : _segment_out.push(seg)</p></li><li><p><strong>start timer</strong> : 如果没有开启定时器（send_window empty之后 第一次发送数据），那么重新开启定时器 </p></li><li><p>更新_next_seqno</p><ul><li>_next_seqno含义：将要发送的下一个byte 在 字节流中的 abs_seqno</li><li>_next_seqno 是 单增的，只从stream中读取新数据来发送，而不管需要超时重传的数据。</li><li>代表sender将要发送到第几个字节了。</li></ul></li><li><p><strong>当sender收到receiver声明的rwnd = 0时，sender应当保持发送1byte的segment给receiver</strong></p><ul><li><strong>代码体现</strong>：调用fill_window时，若<strong>receive_window_size = 0</strong> , 则 fill_window() 先将其<strong>视为1</strong>。</li><li><strong>为什么sender要发送1 byte的segment？</strong><ul><li>其实感觉就是一个<strong>探测报文</strong>的作用，<strong>sender为了及时获知receiver的receive_window是否有了空闲空间。</strong><ul><li>如果receiver没有空闲空间，那么sender发送的这个segment就被receiver丢弃，且sender也不会收到任何报文</li><li>如果receiver有空闲空间，那么就会接收该探测segment到receive_window中，且发送一个携带了receive_window_size的ack segment给sender。sender得知rwnd之后，会fill_window。</li></ul></li><li>既然是为了起到探测报文的作用，自然发送的大小越小越好，所以其payload = 1byte。</li></ul></li><li><blockquote><p>如《自顶向下》中所说</p></blockquote><ul><li><blockquote><p>假设receiver 的 receive_window_size = 0, 在将rwnd告知sender后，还要假设receiver没有任何数据要发送给sender。此时，考虑发生什么情况：</p></blockquote></li><li><blockquote><p>因为TCP中，receiver只在有数据或者有确认要发送时，才会给sender发送segment，因此在receiver将接收缓存清空的过程中以及清空后，receiver不会给sender发送任何带有rwnd新值的报文。</p></blockquote></li><li><blockquote><p>那么 sender就永远也无法得知  receiver的 receive_window中有空闲空间了(rwnd!=0)，那么sender就被阻塞而永远也不会发送新数据。（如fill_window中，如果按照receive_window_size = 0来运行，那么不会发送数据）。</p></blockquote></li><li><blockquote><p>为解决该问题，TCP规范中要求：当sender认为receiver的receive_window_size = 0时，sender继续发送只有1个byte数据的报文段，这些segment最终会被receiver确认（因为receiver的receve_window迟早会出现空闲空间），receiver会向sender发送对该1byte的segment的ack segment（其中会有新的receive_window_size）</p></blockquote></li></ul></li></ul></li><li><p><strong>fill_window核心逻辑</strong>: </p><ul><li><ol><li>计算 remaining_recv_window，然后开始发送segment，直到消耗完recv_window_space</li></ol></li><li><ol start="2"><li>创建tcp segment</li></ol><ul><li>syn + payload from bytestream + fin</li></ul></li><li>3.1 发送tcp segment<ul><li>_segments_out.push(seg);</li></ul></li><li>3.2 存入send_window<ul><li>_send_window.push_back(seg);</li></ul></li><li><ol start="4"><li>start timer if need</li></ol></li><li><ol start="5"><li>update vars such as_next_seqno<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  try to send segment to fill the receive window</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. 计算 remaining_recv_window</span></span><br><span class="line">    <span class="keyword">size_t</span> remaining_recv_window_sz = _receive_window_size == <span class="number">0</span> ? <span class="number">1</span> : _receive_window_size;</span><br><span class="line">    <span class="keyword">if</span>(bytes_in_flight() &gt; remaining_recv_window_sz)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    remaining_recv_window_sz -= bytes_in_flight();</span><br><span class="line">    <span class="comment">//  开始发送segment</span></span><br><span class="line">    <span class="keyword">while</span>(remaining_recv_window_sz &gt; <span class="number">0</span>)     <span class="comment">//  check B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  2. build tcpsegment</span></span><br><span class="line">        TCPSegment seg;</span><br><span class="line">            seg.header().seqno = next_seqno();</span><br><span class="line">            <span class="comment">//  syn flag</span></span><br><span class="line">            <span class="keyword">if</span>(state() == State::CLOSED)    <span class="comment">//  remain_recv_window_sz &gt;= 1 （肯定的）</span></span><br><span class="line">                seg.header().syn = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  payload</span></span><br><span class="line">            <span class="keyword">size_t</span> payload_sz = min(&#123;TCPConfig::MAX_PAYLOAD_SIZE,remaining_recv_window_sz - seg.header().syn,_stream.buffer_size()&#125;);</span><br><span class="line">            seg.payload() = _stream.read(payload_sz);       </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//  fin flag</span></span><br><span class="line">            <span class="comment">//  疑问a</span></span><br><span class="line">            <span class="keyword">if</span>(state() == SYN_ACKED_2 &amp;&amp; remaining_recv_window_sz &gt; payload_sz + seg.header().syn)</span><br><span class="line">                seg.header().fin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  check A : 如果这个segment 既没有 flag 如 syn fin；又没有 payload 则 不必发送该seg</span></span><br><span class="line">        <span class="keyword">if</span>(seg.length_in_sequence_space() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  3.1 send seg !</span></span><br><span class="line">        _segments_out.push(seg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  3.2 update send_window</span></span><br><span class="line">        _send_window.push_back(seg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  4. 如果这是 send_window empty之后 第一次发送数据（装入数据到_send_window）。</span></span><br><span class="line">        <span class="keyword">if</span>(!_timer.active())</span><br><span class="line">        &#123;</span><br><span class="line">            _timer.reset();</span><br><span class="line">            _timer.start(_initial_retransmission_timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  5.  update</span></span><br><span class="line">        <span class="comment">//  update _next_seq</span></span><br><span class="line">        _next_seqno += seg.length_in_sequence_space();</span><br><span class="line">        <span class="comment">//  update receive_window_size</span></span><br><span class="line">        remaining_recv_window_sz -= seg.length_in_sequence_space();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- remaining_recv_window_sz -= bytes_in_flight() : </span><br><span class="line">- 如sender给receiver分别发送a b c <span class="number">3</span>个segment(已知receive_window = <span class="number">3</span>).receiver接收到了a之后，给sender发送ack segment，（abs_ackno = <span class="number">1</span> , rwnd = <span class="number">2</span>),那么ack_received会更新rwnd，并且调用fill_window。易知fill_window会依照rwnd的大小，继续从bytestream读取新数据发送,那么实际上，虽然sender收到的rwnd=<span class="number">2</span>，但是sender不能直接使用，还要减去bytes_in_flight，这些byte，sent but <span class="keyword">not</span> acked，receiver稍后就会对他们ack，存入receive_window. sender发送新segment时，这些新segment在recv_window所占的空间应当在bc之后，故应当将recv_window - bytes_in_flight。获取当sender继续发送数据时，应当认为recv_window是多大。</span><br><span class="line">- <span class="keyword">if</span>(bytes_in_flight() &gt; remaining_recv_window_sz) <span class="keyword">return</span> ;</span><br><span class="line">- 此时receive_window没有空闲空间，无法发送，返回即可。</span><br><span class="line">- 由于我们ack_received 没有实现将segment拆开了acked，也即更新了recv_window（减小），但是send_window中的字节并没有移除，故可能会出现recv_window &lt; bytes_in_flight的情况，无法成功的remaining_recv_window_sz -= bytes_in_flight() = <span class="number">0</span>(溢出)，所以需要特判返回。</span><br><span class="line">- 如果实现了则应当不需要。</span><br><span class="line">- In fact , the receive_window is full now , but because of our sender implementation , we can<span class="number">&#x27;</span>t acked part of the segment , so we can<span class="number">&#x27;</span>t bascially remaining_recv_window_sz -= bytes_in_flight() to get <span class="number">0</span> . Instead, we should <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h3 id="ack-received"><a href="#ack-received" class="headerlink" title="ack_received"></a>ack_received</h3><ul><li>void ack received( const WrappingInt32 ackno, const uint16 t window size)<ul><li>含义:(何时调用) sender收到了包含 ackno 和 rwnd 的 segment</li><li>更新sender看到的receive_window_sz</li><li>sender 查询send_window中所有segment，并移除其中被ackno确认的segment<ul><li>什么样的segment才是被ackno确认的segment？<ul><li>segment.abs_seqno + seg.length &lt;= abc_ackno</li><li><strong>我们的实现中，sender 认为 segment只能被完整的确认，而不能部分确认</strong>。也即如下，sender发送了”abc”segment，receiver分别返回了ack_for_a , ack_for_b , ack_for_c，那么对于我们实现的sender,收到的ack_for_a 和 ack_for_b 都是无用的，只有收到了ack_for_c时，sender会知道receiver确认了”abc”segment，将其从send_window中移除。</li><li>以下摘自指导书<ul><li><blockquote><p>我应该怎么做，如果有一个ack报文只确认了某个outstanding segment的一部分?我应该将该segment进行切割吗？将确认的字节切割出去？</p></blockquote></li><li><blockquote><p>一个TCP Sender 可以做到这点，不过就这个类的目的而言，没有必要这么花哨。</p></blockquote></li><li><blockquote><p>将每个segment视为一个整体都outstanding,直到她完全被一个ack确认（直到它每个字节的seqno都小于收到的ack）</p></blockquote></li></ul></li></ul></li></ul></li></ul></li></ul><ul><li><p>TCP Sender 需要 查询outstanding segment的集合，并且移除其中 seqno &lt; ack的 segment</p></li><li><p>TCP Sender 需要 再次fill window 如果receive window中有新的空间</p></li><li><p><strong>核心逻辑：核心代码见下</strong></p><ul><li><strong>0.</strong> update window_size</li><li><ol><li>检验ackno是否合法</li></ol></li><li><strong>2.</strong> 从send_window中移除被acked的segment</li><li><strong>3.1</strong> 为send_window中的 新的 earliest outstanding segment 计数 _consecutive_retransmissions_cnt = 0;</li><li><strong>3.2</strong> 为send_window中的 新的 earliest outstanding segment 开启 timer</li><li><strong>4. fill_window(起到自动响应receiver，sender继续发送的作用)</strong> : 因为更新了rwnd 且 bytes_in_flight可能也减少了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//  0. </span></span><br><span class="line">    _receive_window_size = window_size;</span><br><span class="line">    <span class="keyword">uint64_t</span> abs_ackno = unwrap(ackno,_isn,_next_seqno);</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">//  1. some check for ackno</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. remove acked seg from window</span></span><br><span class="line">    <span class="comment">//  remove acked seg from the send_window  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">deque</span>&lt;TCPSegment&gt;::iterator iter = _send_window.begin();iter!=_send_window.end();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> abs_idx = unwrap(iter-&gt;header().seqno,_isn,_next_seqno);</span><br><span class="line">        <span class="keyword">uint64_t</span> len = iter-&gt;length_in_sequence_space();</span><br><span class="line">        <span class="keyword">if</span>(abs_idx + len &lt;=  abs_ackno)     <span class="comment">//  如果对于abs_idx &lt; abs_ackno , abs_idx + len &gt; abs_ackno的情况呢 ? 该如何处理 ?</span></span><br><span class="line">        &#123;</span><br><span class="line">            seg_acked = <span class="literal">true</span>;</span><br><span class="line">            iter = _send_window.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">    <span class="comment">//  3.1 上一个计时重传的分组被移除 故 下一个重新计数</span></span><br><span class="line">    _consecutive_retransmissions_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  3.2 如果send_window中还有未发送的分组 则 为send_window新的最左侧分组开启timer</span></span><br><span class="line">    <span class="keyword">if</span>(!_send_window.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        _timer.reset();</span><br><span class="line">        _timer.start(_initial_retransmission_timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  否则关闭老timer</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _timer.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4. 因为更新了rwnd 且 bytes_in_flight可能也减少了。 故 接着从next_seqno发送新分组  </span></span><br><span class="line">    fill_window();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h3><ul><li><p><strong>void TCPSender::tick(const size_t milli_secs)</strong></p><ul><li>sender 每过milli_secs 就调用一次tick，代表时间流逝. </li><li><strong>核心逻辑：</strong><ul><li>如果超时<ul><li>a. 重传earliest outstanding segment。</li><li>b. <strong>if receive_window_size != 0 (我目前也不知道为什么必须rwnd!=0)</strong><ul><li>对于rwnd == 0时 不double rwnd 可能是为了</li><li>i. 关注consecutive retransmissions，当重传sth时 ++cnt。<ul><li>你的TCP连接将使用该信息，来决定一条连接是否已经没有希望，需要被放弃.(当重传次数cnt过多时)</li></ul></li><li>ii. RTO *= 2 , 减缓了我们在糟糕的网络上进行重传，以免进一步把事情搞糟</li></ul></li><li>c.  重置timer 并启动timer，使其在RTO之后过期（注意RTO可能翻倍） </li><li>可以看到，在tick函数的具体实现里，基本就是完全照着这abc三步做的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!_timer.active())        </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(_timer.elapse(ms_since_last_tick))</span><br><span class="line">    &#123;</span><br><span class="line">        TCPSegment &amp; oldest_seg = _send_window.front();</span><br><span class="line">        <span class="keyword">uint64_t</span> timeout = _timer.initial_alarm();</span><br><span class="line">        <span class="comment">//  b. </span></span><br><span class="line">        <span class="keyword">if</span>(_receive_window_size &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            timeout &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            ++_consecutive_retransmissions_cnt;         </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  c. </span></span><br><span class="line">        _timer.reset();</span><br><span class="line">        _timer.start(timeout);</span><br><span class="line">        <span class="comment">//  a. 超时重传</span></span><br><span class="line">        _segments_out.push(oldest_seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>超时重传相关FAQ</p><ul><li>如果我发送了三个独立的segment，其payload分别为”a”, “b”, “c”,并且他们还都没被acked，那么稍后当我重传a的时候，我需要将abc三个segment拼接成一个大的segment吗？还是说我需要分别的独立的传输每个segment？<ul><li>TCP Sender可以做到这点，但是就这个类的目的而言，没有必要这么花哨</li><li>只需要独立的关注每个segment即可，并且当timer到期的时候，重传最早的outstanding segment。</li></ul></li><li>我需要在数据结构中存储empty segment，然后在必要的时候重传他们吗 ？ <ul><li>不需要。只有携带了数据(consume some length in sequence space)的segment需要被关注是否重传的</li><li>一个没有占据seqno的segment(no payload, SYN, or FIN),不需要被记录或者重传。</li></ul></li></ul></li></ul><h3 id="流量控制-flow-control"><a href="#流量控制-flow-control" class="headerlink" title="流量控制 flow-control"></a>流量控制 flow-control</h3><ul><li><p><strong>一言以蔽之：receiver 通过 将 recv_window （ackno + recv_window_size)发送给 sender , 来告知sender自己可接收的字节下标范围,sender通过receive_window,来获知自己还能发送多少字节</strong>.</p></li><li><p><strong>背景</strong>: 当TCP连接的 receiver 接收到 正确的、按序的字节后，就将数据放入接收缓存（receiver 的 bytestream）。相关联的应用进程会从该缓存中读取数据，但不必是数据刚一到达就立即读取。事实上，接收方应用也许正忙于其他服务，甚至要过很长时间之后才读取该数据。如果某应用程序读取数据时相对缓慢。而sender发送的太快太多，发送的数据会从接受缓存溢出。</p><ul><li>我所实现的<strong>receiver接收缓存溢出</strong> 情况.<ul><li><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-09-20-52-20.png"></li><li>约定接收缓存 : bytestream(顺序) + recv_window(乱序)</li><li><strong>receiver接收缓存溢出</strong>实现 : bytestream_size + recv_window_size == capacity —&gt; 最终会变成bytestream_size == capacity,(接收缓存中只有bytestream而没有recv_window的空间了)，那么再来的data就会全部落入接收缓存之外(first_unacceptable之外),也即被discarded.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">receiver_code</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">StreamReassembler::cached_into_receiving_window</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index,<span class="keyword">bool</span> &amp;non)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(index &gt;= first_unacceptable())</span> </span>&#123;</span><br><span class="line">        non = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//  nothing</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>flow-control 流量控制</strong></p><ul><li>TCP为其应用程序提供了流量控制服务，目的：避免Receiver的接收缓存溢出</li><li>也即流量控制 是一个 速度匹配服务 , 通过遏制sender，来让sender和发送速率和receiver的接收速率相匹配</li></ul></li><li><p><strong>流量控制实现途径 : receive_window</strong></p><ul><li>ackno + recv_window_size</li><li>sender通过ack报文维护 (recv_window) recv_window_size</li><li><strong>实现核心：sender 在 整个 TCPConnection 中，始终保证send_window_size &lt;= recv_window_size。</strong> <ul><li><strong>recv_window(recv_window_size + ackno) 即 receiver 可以接收的 字节的 范围</strong></li><li><strong>sender 所能发送的 字节范围 被限制在recv_window中</strong>. </li></ul></li><li><img src="/2023/01/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab3/2023-01-09-22-03-33.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fill_window()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(recv_window_size &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//  send segment from _next_seqno</span></span><br><span class="line">    <span class="comment">//  update recv_window_size</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关于receive_window具体含义 可见 lab2 blog</p></li></ul><h3 id="拥塞控制-Congestion-Control"><a href="#拥塞控制-Congestion-Control" class="headerlink" title="拥塞控制 Congestion Control"></a>拥塞控制 Congestion Control</h3><ul><li><p>可以看到，TCPSender并没有实现TCP拥塞控制算法</p><ul><li>根本就没维护拥塞窗口cwnd变量，只有一个接收窗口rwnd</li><li>那就更没有慢启动,拥塞避免,拥塞控制,快速恢复</li></ul></li><li><p>我们只实现了一种形式受限的拥塞控制</p><ul><li>对于同一报文段 , 每次Timer超时之后 , RTO翻倍</li></ul></li></ul><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><ul><li><ol><li>fin 占据 receive_window seqno空间</li></ol><ul><li>发送syn</li><li>发送abc</li><li>发送fin<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    TCPConfig cfg;</span><br><span class="line">    <span class="function">WrappingInt32 <span class="title">isn</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> rto = uniform_int_distribution&lt;<span class="keyword">uint16_t</span>&gt;&#123;<span class="number">30</span>, <span class="number">10000</span>&#125;(rd);</span><br><span class="line">    cfg.fixed_isn = isn;</span><br><span class="line">    cfg.rt_timeout = rto;</span><br><span class="line"></span><br><span class="line">    TCPSenderTestHarness test&#123;<span class="string">&quot;Don&#x27;t add FIN if this would make the segment exceed the receiver&#x27;s window&quot;</span>, cfg&#125;;        </span><br><span class="line">        <span class="comment">//  sender.fill_window(); 发送syn报文 </span></span><br><span class="line">    test.execute(ExpectSegment&#123;&#125;.with_no_flags().with_syn(<span class="literal">true</span>).with_payload_size(<span class="number">0</span>).with_seqno(isn));</span><br><span class="line">        <span class="comment">//  check 刚才发送的报文 : seq(isn) + syn + payload(0)</span></span><br><span class="line">        <span class="comment">//  [0](isn)  1  2  3  4</span></span><br><span class="line">        <span class="comment">//  syn </span></span><br><span class="line">    test.execute(WriteBytes(<span class="string">&quot;abc&quot;</span>).with_end_input(<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//  sender.stream_in().write(std::move(_bytes));    sender.stream_in().end_input();     sender.fill_window();     </span></span><br><span class="line">        <span class="comment">//  [0]  1  2  3  4</span></span><br><span class="line">        <span class="comment">//  syn  </span></span><br><span class="line">        <span class="comment">//  in stream wait for send : a b c fin   </span></span><br><span class="line">    test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">1</span>&#125;&#125;.with_win(<span class="number">3</span>));</span><br><span class="line">    test.execute(ExpectState&#123;TCPSenderStateSummary::SYN_ACKED&#125;);</span><br><span class="line">    test.execute(ExpectSegment&#123;&#125;.with_payload_size(<span class="number">3</span>).with_data(<span class="string">&quot;abc&quot;</span>).with_seqno(isn + <span class="number">1</span>).with_no_flags());</span><br><span class="line">        <span class="comment">// sender.ack_received(_ackno, _window_advertisement.value_or(DEFAULT_TEST_WINDOW));</span></span><br><span class="line">        <span class="comment">//  0   [1  2  3]  4</span></span><br><span class="line">        <span class="comment">//  syn  a  b  c</span></span><br><span class="line">        <span class="comment">//  in stream wait for send : fin   </span></span><br><span class="line">    <span class="comment">//  ack for a</span></span><br><span class="line">    test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">2</span>&#125;&#125;.with_win(<span class="number">2</span>));</span><br><span class="line">    test.execute(ExpectNoSegment&#123;&#125;);</span><br><span class="line">    <span class="comment">//  ack for b</span></span><br><span class="line">    test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">3</span>&#125;&#125;.with_win(<span class="number">1</span>));</span><br><span class="line">    test.execute(ExpectNoSegment&#123;&#125;);</span><br><span class="line">    <span class="comment">//  ack for c</span></span><br><span class="line">    test.execute(AckReceived&#123;WrappingInt32&#123;isn + <span class="number">4</span>&#125;&#125;.with_win(<span class="number">1</span>));</span><br><span class="line">    test.execute(ExpectSegment&#123;&#125;.with_payload_size(<span class="number">0</span>).with_seqno(isn + <span class="number">4</span>).with_fin(<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">// sender.ack_received(_ackno, _window_advertisement.value_or(DEFAULT_TEST_WINDOW));</span></span><br><span class="line">        <span class="comment">//  0   1  2  3  [4]</span></span><br><span class="line">        <span class="comment">// syn  a  b  c  fin</span></span><br><span class="line">        <span class="comment">//  in stream wait for send</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul><li>FAQ and sepcial cases<ul><li>我该如何既发送segment，又追踪该segment作为outstanding segment，以便我知道稍后将要重传该segment ？ 我是否需要为每个segment做一份拷贝?可那样的话不会很浪费吗？<ul><li>不会。虽然TCPSegment在send_window和segments_out中会有两个副本，但是由TCPSegment实现可知，其payload的实现是Buffer，Buffer中保存的是对string payload的引用。（<code>std::shared_ptr&lt;std::string&gt; _storage&#123;&#125;;</code>）。故不必担心会真实的拷贝一份payload。代价不是太大。</li></ul></li></ul></li></ul><p>receiver reassembler 看来 SYN 和 FIN就不占据 recv_window 空间<br>在sender看来 SYN和FIN就占据 recv_window 空间<br>因为reassembler使用的是stream_idx 发送时sender使用的是seqno<br>他们之间通过wrap进行转化 见 lab2</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;实现 TCPSender&lt;ul&gt;
&lt;li&gt;发送新segment : fill_window() when 上层有数据 &amp;amp;&amp;amp; receive_window有空间&lt;ul&gt;
&lt;li&gt;fill_window 负责一直向后走 发送新数据. 更新send_window&lt;/li&gt;
&lt;li&gt;重传的部分交由tick()来做&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定时器超时重传 : tick()&lt;ul&gt;
&lt;li&gt;更新send_window ; 重启定时器 ; 超时重传 , RTO加倍&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/rfc6298/?include_text=1&quot;&gt;Retransmission Timer [RFC]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;收到ACK报文 : ack_received()&lt;ul&gt;
&lt;li&gt;更新rwnd , sender自动继续发送fill_window.(因为rwnd可能变大)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;我们Sender并没有实现快速重传(可以不实现，易知不影响其正确性，仍然可以可靠传输)&lt;/li&gt;
&lt;li&gt;有趣的是我们Sender并没有实现拥塞控制，但TCP仍然可以正常运行.&lt;ul&gt;
&lt;li&gt;原因如下 : 拥塞控制只是为了TCP的公平性，使得其不会无节制的占用带宽. 如我们的信道中有两条TCP连接，若都实现了拥塞控制，那么最终二者所占带宽会向y=x收敛.&lt;/li&gt;
&lt;li&gt;而为了保证己方Sender可以和对端Receiver正常交互，我们只需要保证：&lt;ul&gt;
&lt;li&gt;每个字节都令对方接受到并返回ACK : 重传保证&lt;/li&gt;
&lt;li&gt;对端receiver不会由于己方发送过快而导致receiver buf缓存溢出&lt;ul&gt;
&lt;li&gt;这通过流量控制就解决了.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-CS144-lab2</title>
    <link href="http://example.com/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/"/>
    <id>http://example.com/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/</id>
    <published>2023-01-01T07:09:22.000Z</published>
    <updated>2023-02-27T15:23:43.967Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-16-17-59.png"></p><p>一言以蔽之</p><ul><li><p>lab2实现的tcp receiver</p><ul><li>（0） 转换stream_idx ，abs_seq ，seq（属于内部功能)  </li><li>（1） 利用 StreamReassembler对 接收到的segment进行重组 并压入bytestream</li><li>（2） 填充receive_window的相关信息：ackno , window_size， 从而实现flow-control流量控制</li><li>（3） 根据 接收到的报文 对tcp receiver进行状态划分. listen syn_recv fin_recv</li></ul></li><li><p>我们的receiver只实现了234</p><ul><li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-02-27-22-58-04.png"></li></ul></li></ul><span id="more"></span><h2 id="背景-amp-Receiver功能-amp-分析"><a href="#背景-amp-Receiver功能-amp-分析" class="headerlink" title="背景 &amp; Receiver功能 &amp; 分析"></a>背景 &amp; Receiver功能 &amp; 分析</h2><p><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-16-17-59.png"></p><ul><li><p>lab0实现了ByteStream，lab1实现了StreamReassembler，lab2要求我们实现TCPReceiver</p></li><li><p>TCP是一个在不可靠数据报之上 可靠地传输 可控制的字节流。TCP连接有两方参与，每一方都同时扮演着sender和receiver的角色。这两方被称为TCP连接的端点endpoint或者对等方peers</p></li><li><p><strong>TCP receiver</strong></p><ul><li><strong>(1) 接收对端发来的segment</strong></li><li><strong>(2) 使用我们之前实现的StreamReassembler将segment重组进ByteStream</strong></li><li><strong>(3) 计算出receive_window的相关信息：ackno以及receive_window size</strong>. 随output segment被传输给对端<ul><li><strong>receive_window</strong>：<ul><li>含义：receiver感兴趣的、愿意接受的字节的下标范围，也是允许 tcp sender 发送的字节范围。</li><li>作用：tcp receiver使用该receive window，可以进行流量控制，使得sender限制自己的发送量，直到receiver可以接收更多data。（Using the window, the receiver can control the flow of incoming data, making the sender limit how much it sends until the receiver is ready for more.）</li><li><strong>ackno</strong> : 即tcp header中的acknowledgement number字段。<ul><li>即 lab1中所实现的receive_window [first_unassembled,first_unacceptable)的左边界</li><li>即 ackno = first_unassembled</li><li>含义如下<ul><li>receiver期望从另一方收到的下一个字节的序号，（接收该字节可以使得receiver重组更多的字节流）</li><li><strong>累计确认</strong></li><li>ack number：已经收到了[begin,ack-1]的所有bytes，期待收到的下一个byte是ack 。 即期待收到的下一个TCP报文段的body的起始字节的序号是ack</li></ul></li></ul></li><li><strong>window_size</strong> : 即TCP Header中的window size字段 <ul><li>即lab1中所实现的receiving_window的大小</li><li>receive_window size + stream size = capacity</li><li>receive_window size = first_unacceptable - first_unassembled</li><li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-16-36-11.png"></li></ul></li><li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-18-54-16.png"></li></ul></li></ul></li></ul></li><li><p>为什么要实现这些？</p><ul><li>这些信号对实现TCP的功能至关重要，为了TCP能够在不可靠的数据报网络之上提供流量控制、可靠的字节流。</li><li>TCP中，<strong>ack</strong>意味着，接收方所期待的下一个字节，使其能够重组更多的bytestream。它告诉sender应该发送什么字节</li><li><strong>Flow Control</strong>流量控制意味着 receiver感兴趣的、愿意接受的字节的下标范围。这告知了sender其被允许发送多少字节。</li></ul></li></ul><h2 id="index-关系"><a href="#index-关系" class="headerlink" title="index 关系"></a>index 关系</h2><p><strong>seqno , absolute seqno , stream idx</strong></p><ul><li><p>A 64-bit index is big enough that we can treat it as never overflowing.</p><ul><li>Transmitting at 100 gigabits/sec, it would take almost 50 years to reach 2^64 bytes. By contrast, it takes only a third of a second to reach 2^32 bytes</li></ul></li><li><p><strong>seqno</strong></p><ul><li>32bits , wrapping<ul><li>tcp 的 stream 可以任意长</li></ul></li><li>start from isn(Initial Sequence Number)<ul><li>TCP sequence numbers start at a random value.</li><li>To improve security and avoid getting confused by old segments belonging to earlier connections between the same endpoints, TCP tries to make sure sequence numbers can’t be guessed and are unlikely to repeat. So the sequence numbers for a stream don’t start at zero.</li></ul></li><li>Include SYN/FIN<ul><li>The logical beginning and ending each occupy one sequence number</li><li>SYN报文 代表 beginning of the stream , 占据ISN seq，</li><li>FIN报文 代表 end of the stream , 占据最后一个seq</li><li>SYN和FIN之间的每个byte都占据一个seq</li></ul></li></ul></li><li><p><strong>absolute seq</strong> : </p><ul><li>不考虑(isn)initial seq num，即seq - isn。(即start at 0)</li><li>64bit , non-wrapping。</li><li>包含SYN/FIN。</li></ul></li><li><p><strong>stream idx</strong> : </p><ul><li>StreamReassembler中，stream中每个字节的idx。</li><li>start at 0</li><li>64bit , non-wrapping。</li><li>不包含SYN/FIN</li></ul></li><li><p><strong>seqno , absolute seqno , stream idx之间的关系 关键图</strong><br><strong><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-11-51-52.png"></strong><br><strong><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-18-46-55.png"></strong></p></li><li><p>转换：stream_idx &lt;-&gt; abs_seq &lt;-&gt; seq</p></li><li><p>易知stream_idx和abs_seq之间的转换</p><ul><li>assert(absolute seq &gt; 0) : stream_idx = absolute seq - 1 </li></ul></li><li><p>abs_seq和seq之间的转换见下。</p></li></ul><h3 id="WrappingInt32-seq-lt-gt-abs-seq"><a href="#WrappingInt32-seq-lt-gt-abs-seq" class="headerlink" title="WrappingInt32 seq &lt;-&gt; abs_seq"></a>WrappingInt32 seq &lt;-&gt; abs_seq</h3><ul><li><p>WrappingInt32 </p><ul><li>实现absolute sequence number和sequence nunmber的转换</li></ul></li><li><p>absolute sequence number -&gt; sequence number</p><ul><li>WrappingInt32 wrap(uint64_t abs_seq, WrappingInt32 isn)</li><li>abs_seq : seq = (abs_seq + isn) % 2^32<ul><li><code>[63,32][31,0]</code>,舍去<code>[63,32]</code>，转化成seq只需要其低32bit加上isn即可。</li><li>因为seq的域是<code>[0,2^32-1]</code>，abs_seq每增加<code>2^32</code>，其对应的seq就回到起点的isn</li><li><code>对于任意isn，abs_seq : 0 / 2^32 / k * 2^32 + x  ---&gt;  seq : isn + x</code></li><li><code>如 abs_seq = 2^32 + 3 ---&gt; seq = isn + 3 = 1 ，当isn = 2^32-2时，seq = 1</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="keyword">uint64_t</span> abs_seq, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isn + <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(abs_seq);  </span><br><span class="line">    <span class="comment">//  该加法（底层就是uint32位加法)会自动对2^32取模  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>sequence number -&gt; absolute sequence number</p><ul><li>uint64_t unwrap(WrappingInt32 seq, WrappingInt32 isn, uint64_t checkpoint)<ul><li>Given a sequence number (n), the Initial Sequence Number (isn), and an absolute checkpoint sequence number, compute the absolute sequence number that corresponds to n that is closest to the checkpoint</li><li>closet : 没有向上取最接近还是向下取最接近之分，无论上下，只要求最接近即可。</li></ul></li><li>易知对于任意seq，其在<code>[0,2^64-1]</code>的每个2^32大小的域上，都有一个abs_seq_num，wrap函数的目标就是返回其中最接近checkpoint的abs_seq_num</li><li>思路：<ul><li><ol><li>先求出abs no 在域<code>[0,2^32-1]</code>上的值为abs_base，易知目标abs_seq_num = abs_base + k * 2^32。</li></ol><ul><li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-13-11-45.png"></li></ul></li><li><ol start="2"><li>求出最接近的abs_seq_num ? </li></ol><ul><li>找到abs_base和checkpoint的距离offset：令checkpoint在[0,2^32-1|域上对应的值 和 [0,2^32-1]域上的abs_base求差。|checkpoint(low 32bit) - abs_base|。</li><li>a. 先假设checkpoint lowbit &gt; abs_base。<ul><li>然后讨论abs_seq的两种情况：<ul><li>落在checkpoint左侧，abs_seq1 = check_point - offset ；落在checkpoint右侧，abs_seq2 = check_point + 2^32 - offset。如下图1</li><li>等价为 offset的两种情况。<ul><li>offset &lt; 2^31 , then abs_seq1; offset &gt;= 2^31 , then abs_seq2。</li></ul></li><li>（对于左右abs_seq和check_point距离相等时，我选择了右侧的check_point，因为我觉着从定义来讲，我们传入的check_point是接收窗口最左端，也即_first_unassembled，也即ackno，_first_unassembled左侧的字节都已经读完了进入bytestream，我们期待的，以及理论上应该接接收的是位于滑动窗口最左端往右的字节，故选择右侧而非左侧。</li></ul></li></ul></li><li>b. 同理，当checkpoint lowbit &lt; abs_base，情况如下图2。<ul><li>offset &lt;= 2^31 , then abs_seq1 ; offset &gt; 2^31 , them abs_seq2。</li></ul></li><li><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-13-12-10.png"></li></ul></li></ul></li><li>seq -&gt; abs_seq举例<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Unwrap the first byte after ISN</span></span><br><span class="line">seq = <span class="number">1</span> , isn = <span class="number">0</span> , check_point = <span class="number">0</span> -&gt; closet abs_seq = <span class="number">1</span> = seq - isn（逻辑）</span><br><span class="line">test_should_be(unwrap(WrappingInt32(<span class="number">1</span>), WrappingInt32(<span class="number">0</span>), <span class="number">0</span>), <span class="number">1ul</span>);</span><br><span class="line"><span class="comment">// 2. Unwrap the last byte before the third wrap</span></span><br><span class="line">seq = <span class="number">2</span>^<span class="number">32</span> - <span class="number">2</span> , isn = <span class="number">0</span> , check_point = <span class="number">3</span> * <span class="number">2</span>^<span class="number">32</span> -&gt; closet abs_seq = <span class="number">3</span> * <span class="number">2</span>^<span class="number">32</span> - <span class="number">2</span> = check_point - <span class="number">2</span></span><br><span class="line">test_should_be(unwrap(WrappingInt32(UINT32_MAX - <span class="number">1</span>), WrappingInt32(<span class="number">0</span>), <span class="number">3</span> * (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>)), <span class="number">3</span> * (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>) - <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3. Non-zero ISN</span></span><br><span class="line">seq = <span class="number">2</span>^<span class="number">32</span> - <span class="number">1</span> , isn = <span class="number">10</span> , check_point = <span class="number">2</span> * <span class="number">2</span>^<span class="number">32</span> -&gt; closet abs_seq = <span class="number">3</span> * <span class="number">2</span>^<span class="number">32</span> - <span class="number">1</span> - <span class="number">10</span></span><br><span class="line">test_should_be(unwrap(WrappingInt32(UINT32_MAX), WrappingInt32(<span class="number">10</span>), <span class="number">3</span> * (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>)), <span class="number">3</span> * (<span class="number">1ul</span> &lt;&lt; <span class="number">32</span>) - <span class="number">11</span>);</span><br><span class="line"><span class="comment">// 4. Unwrap a non-zero ISN</span></span><br><span class="line">seq = <span class="number">16</span> , isn = <span class="number">16</span> , check_point = <span class="number">0</span> -&gt; closet <span class="built_in">abs</span> seq = seq - isn = <span class="number">0</span></span><br><span class="line">test_should_be(unwrap(WrappingInt32(<span class="number">16</span>), WrappingInt32(<span class="number">16</span>), <span class="number">0</span>), <span class="number">0ul</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>corner case : 对于下溢情况，选择非下溢的一侧</strong> <ul><li>seq = 2^32 - 1 , isn = 0 , check_point = 0 -&gt; closet seq = 2 ^ 32 - 1<ul><li>按照closet的逻辑，closet seq 有两个选择</li><li>位于check_point左侧，即 abs_seq = checkpoint(0) - 1 = 18446744073709551615 </li><li>位于check_point右侧，即 abs_seq = checkpoint(0) + 2^32 - 1 = 2^32 - 1</li><li>若仅仅按照closet，则应当选择check_point左侧的abs_seq(18446744073709551615)，但实际上，应当选择check_point右侧的abs_seq</li><li>原因如下：unwrap的意义<ul><li>目的是将字节流中的seq，依据checkpoint，转化成正确的对应的abs_seq。</li><li>易知按照100 GB/sec的传输速度，要发送五十多年，才能发送到2^64bytes，可以看作abs_seq是不可能到达2^64级别的byte。</li><li>故本case中check_point(0)左侧的下溢情况应当为非法情况。应选择 abs_seq = 2^32 - 1</li></ul></li></ul></li><li>故：<ul><li>当abs_seq位于check_point左侧 且 发生 下溢(到2^64bytes) 时，选择check_point右侧的abs_seq。</li><li>当abs_seq位于check_point右侧 且 发生 上溢（重新到0）时，正常计算、上溢取模即可。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// corner case : 4. Big unwrap</span></span><br><span class="line">test_should_be(unwrap(WrappingInt32(UINT32_MAX), WrappingInt32(<span class="number">0</span>), <span class="number">0</span>), <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(UINT32_MAX));</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>实现  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 seq, WrappingInt32 isn, <span class="keyword">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line"><span class="comment">//  seqno -&gt; absolute seq no</span></span><br><span class="line">    <span class="keyword">uint32_t</span> base_abs = seq - isn;</span><br><span class="line">    <span class="keyword">if</span>( base_abs &gt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(checkpoint))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">uint32_t</span> offset = base_abs - <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(checkpoint);</span><br><span class="line">          <span class="keyword">if</span>(offset &lt;= (<span class="number">1ul</span>&lt;&lt;<span class="number">31</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> checkpoint + offset;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//  corner case : 当下溢时 选择右侧 而不是左侧溢出到2^64</span></span><br><span class="line">              <span class="keyword">if</span>(checkpoint &lt; (WrappingInt32::_MOD - offset))</span><br><span class="line">                  <span class="keyword">return</span> checkpoint + offset;</span><br><span class="line">              <span class="keyword">return</span> checkpoint - (WrappingInt32::_MOD - offset);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">uint32_t</span> offset = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(checkpoint) - base_abs;</span><br><span class="line">          <span class="keyword">if</span>(offset &gt; (<span class="number">1ul</span>&lt;&lt;<span class="number">31</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> checkpoint + (WrappingInt32::_MOD - offset);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(checkpoint &lt; offset)</span><br><span class="line">                  <span class="keyword">return</span> checkpoint + (WrappingInt32::_MOD - offset);</span><br><span class="line">              <span class="keyword">return</span> checkpoint - offset;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="TCP-Receiver实现"><a href="#TCP-Receiver实现" class="headerlink" title="TCP Receiver实现"></a>TCP Receiver实现</h2><h3 id="报文信息-amp-阶段"><a href="#报文信息-amp-阶段" class="headerlink" title="报文信息 &amp; 阶段"></a>报文信息 &amp; 阶段</h3><ul><li>关于报文<br><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-18-59-44.png"><ul><li>蓝色：receiver需要读取、关注的<ul><li>seq , syn flag , fin flag , playload</li></ul></li><li>红色：receiver需要填充的<ul><li>ackno , window_size</li></ul></li></ul></li></ul><ul><li>复习一下三次握手四次挥手的图<blockquote><p><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-19-17-34.png"><br><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-19-17-45.png"></p></blockquote></li></ul><ul><li>将receiver划分为如下阶段。<br><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-19-27-00.png"><ul><li>LISTENING : 还没接收到初始化ISN的SYN报文.(the begining of the stream)</li><li>SYN_RECV : 已经接收SYN报文 &amp;&amp; 还没接收FIN报文</li><li>FIN_RECV : 已经接收到FIN报文且已经传入给bytestream。（即bytestream已经关闭）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">listening</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> !_isn.has_value(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">syn_recv</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _isn.has_value() &amp;&amp; !_reassembler.stream_out().input_ended(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fin_recv</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _reassembler.stream_out().input_ended(); &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>再看一眼receive_window图<br><img src="/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-22-14-58.png"></li></ul><h3 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h3><h4 id="ackno"><a href="#ackno" class="headerlink" title="ackno"></a>ackno</h4><ul><li><strong>std::optional<WrappingInt32> ackno() const;</WrappingInt32></strong><ul><li><strong>注意：实现的ackno 是 累计确认 ackno</strong></li><li>如分析中所述，seqno = receive window left edge = reciver第一个没被写入bytestream的字节。</li><li>注意以seqno的形式获取，而非stream_idx：stream_idx –&gt; abs_seq –&gt; seq</li><li>注意receiver在不同阶段，所获取的abs_seq不同，自然得出seq不同。<ul><li>LISTENING : 还没接收到第一个SYN报文，也即还没建立连接，即还没初始化isn。返回空即可。</li><li>SYN_RECV : abs_seq = stream_idx + 1。因为SYN报文会占据abs_seq的起始索引.</li><li>FIN_RECV : abs_seq = stream_idx + 2。因为SYN、FIN报文均会占据abs_seq索引位置。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  还没初始化isn，也即还没建立连接，还没接收到第一个SYN报文 </span></span><br><span class="line">    <span class="keyword">if</span>(_state == LISTENING)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::nullopt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  +1 是为了第一个初始化syn报文 规定其占据一个字节的位置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(_state == SYN_RECV)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> wrap(_reassembler.first_unassembled() + <span class="number">1</span>,_isn.value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  +2 : syn + fin</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(_state == FIN_RECV)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> wrap(_reassembler.first_unassembled() + <span class="number">2</span>,_isn.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="segment-received"><a href="#segment-received" class="headerlink" title="segment_received"></a>segment_received</h4><ul><li><strong>void TCPReceiver::segment_received(const TCPSegment &amp;seg)</strong><ul><li>每次接收到对端发送的segment时，都会调用该segment_received</li><li>主要工作<ul><li>接收第一个具有syn flag的报文时 , 初始化isn = seq.</li><li>对于data,push_substring(data).</li><li>接收fin报文(end-of-stream marker)，代表该fin是该stream的最后一个字节.</li></ul></li><li>注意<ul><li>同一个报文中可能同时有syn flag和fin flag.</li><li>state什么时候变成fin_recv , 是segment_received刚收到fin flag ,state就改变吗 ?<ul><li>不是，此时可能fin flag只是位于receive_window中 ;当fin -&gt; eof被加入到reassembler中的bytestream时(bytestream.end_input())，state才变成fin_recv</li></ul></li><li>对于第一个建立连接,初始化isn的syn报文，其也有可能携带应用层报文数据，即（这和我之前学的三次握手不一样啊。我记着第一次握手的syn报文是连接初始化isn，没有携带应用层数据。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.execute(ExpectState&#123;TCPReceiverStateSummary::LISTEN&#125;);</span><br><span class="line">test.execute(SegmentArrives&#123;&#125;.with_syn().with_seqno(isn).with_data(<span class="string">&quot;Hello, CS144!&quot;</span>).with_result(SegmentArrives::Result::OK));</span><br></pre></td></tr></table></figure></li><li>对于invalid segment seq: ignore<ul><li>如segment的seq == isn<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCPReceiverTestHarness test&#123;<span class="number">4</span>&#125;;</span><br><span class="line">test.execute(SegmentArrives&#123;&#125;.with_syn().with_seqno(isn).with_result(SegmentArrives::Result::OK));</span><br><span class="line">test.execute(SegmentArrives&#123;&#125;.**with_seqno(isn)**.with_data(<span class="string">&quot;a&quot;</span>).with_result(SegmentArrives::Result::OK));  <span class="comment">//  WRONG INDEX isn ! </span></span><br></pre></td></tr></table></figure></li></ul></li><li>核心逻辑  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  0.  corner case such as invalid idx</span></span><br><span class="line">    <span class="keyword">if</span>(corner(seg))</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//  1.  首次确立isn</span></span><br><span class="line">    <span class="keyword">if</span>(_state == LISTENING &amp;&amp; seg.header().syn)</span><br><span class="line">    &#123;</span><br><span class="line">        _isn = seg.header().seqno;</span><br><span class="line">        update_state();     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  2.  如果还没初始化isn，且该报文不是syn报文</span></span><br><span class="line">    <span class="keyword">if</span>(_state == LISTENING)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//  3.  seq -&gt; abs_seq -&gt; stream_idx</span></span><br><span class="line">    <span class="keyword">size_t</span> abs_seq = unwrap(seg.header().seqno,_isn.value(),_reassembler.first_unassembled());   </span><br><span class="line">    <span class="keyword">size_t</span> stream_idx = abs_seq_to_stream_idx(abs_seq);</span><br><span class="line">    <span class="comment">//  4.  push_substring(segment)</span></span><br><span class="line">    _reassembler.push_substring(<span class="built_in">string</span>(seg.payload().str()),stream_idx,seg.header().fin);   </span><br><span class="line"></span><br><span class="line">    update_state();         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="window-size"><a href="#window-size" class="headerlink" title="window_size"></a>window_size</h4><ul><li>window_size() : [_first_unassembled , first_unacceptable())<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">window_size</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">  <span class="comment">// _first_unassembled = _output.bytes_written(); </span></span><br><span class="line">  <span class="comment">//  first_unacceptable() =  _capacity + _output.bytes_read()</span></span><br><span class="line">  <span class="comment">// return first_unacceptable() - _first_unassembled;</span></span><br><span class="line">  <span class="keyword">return</span> _capacity + _output.bytes_read() - _output.bytes_written();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>值得后续 注意 &amp; 疑问 <ul><li>可以看到 对于 receiver 只有第一个syn报文 的syn 可以被receiver识别到，后来的报文，即使syn为true，receiver也识别不到</li><li>可以看到，本lab中并没有要求做出ESTABLISHED状态，也并没有FIN_WAIT状态。留待观察，日后应该会实现。</li><li><strong>流量控制 – 拥塞控制区别</strong><ul><li>已知流量控制 是 flow-controled ，是通过receiver的 receive_window 的ackno以及 window_size实现的。</li><li>那么拥塞控制呢？？？<ul><li>并没有实现拥塞控制. 见lab3 以及 计网-拥塞控制 blog</li></ul></li></ul></li></ul></li></ul><hr><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><ul><li>添加示例case1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  ===============my test3==============</span><br><span class="line">  capacity <span class="number">4000</span></span><br><span class="line">  <span class="number">1000</span> <span class="number">0</span> <span class="number">0</span> shc</span><br><span class="line">  shc</span><br><span class="line">        <span class="comment">/* segment with SYN + data + FIN */</span></span><br><span class="line">        &#123;</span><br><span class="line">            TCPReceiver receiver(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> isn = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//  now LISTEN</span></span><br><span class="line">            Assert(<span class="keyword">not</span> receiver.ackno().has_value());</span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;shc&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">true</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">true</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(isn);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(seg);</span><br><span class="line">            <span class="comment">//  already has received syn</span></span><br><span class="line">            Assert(receiver.ackno().has_value());</span><br><span class="line">            <span class="comment">//  now FIN_RECV</span></span><br><span class="line">            Assert(receiver.stream_out().input_ended());</span><br><span class="line">            Assert(receiver.ackno().value() == WrappingInt32(<span class="number">0</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> + isn));  <span class="comment">//  syn(0) + &quot;shc&quot;[123] + fin(4) -&gt; 5 + isn = 1005;</span></span><br><span class="line">            Assert(receiver.unassembled_bytes() == <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;receiver.stream_out().read(receiver.stream_out().buffer_size())&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//  shc</span></span><br><span class="line">            <span class="comment">//  stream empty &amp;&amp; closed</span></span><br><span class="line">            Assert(receiver.stream_out().eof());</span><br><span class="line">                <span class="comment">//////// bytestream   //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////syn shc         //////////   ////// fin empty       //////</span></span><br><span class="line"><span class="comment">// abs_seq      //////0   123         //////////   ////// 4  5          //////</span></span><br><span class="line"><span class="comment">// seq = abs_seq + isn</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>添加示例case0 : 普通通信<ul><li>syn报文 , data报文 , fin报文<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">======================my test <span class="number">02</span>==============</span><br><span class="line">capacity <span class="number">200</span></span><br><span class="line"><span class="number">5</span> <span class="number">0</span> <span class="number">0</span> abcdefg</span><br><span class="line"><span class="number">14</span> <span class="number">9</span> <span class="number">8</span> abc</span><br><span class="line"><span class="number">13</span> <span class="number">8</span> <span class="number">7</span> a</span><br><span class="line">abcdefgaabc</span><br><span class="line"><span class="number">17</span> <span class="number">12</span> <span class="number">11</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;======================my test 02==============&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="function">TCPReceiver <span class="title">receiver</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line">            <span class="comment">//  window size</span></span><br><span class="line">            Assert(receiver.window_size() == <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  tcp segment abcdefg , syn isn = 5</span></span><br><span class="line">            &#123;</span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">false</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">true</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(<span class="number">5</span>);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(<span class="built_in">std</span>::move(seg));</span><br><span class="line">                Assert(receiver.ackno().has_value() == <span class="literal">true</span>);</span><br><span class="line">                Assert(receiver.stream_out().bytes_written() == <span class="number">7</span>);</span><br><span class="line">                Assert(receiver.ackno() == WrappingInt32(<span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">//////// bytestream //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////// abcdefg    //////////   ////// empty       ////// </span></span><br><span class="line"><span class="comment">// abs_seq      ////////01234567    //////////   ////// 8           //////</span></span><br><span class="line"><span class="comment">// seq = abs_seq + 5</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  abc , seqno = 14</span></span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">false</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">false</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(<span class="number">14</span>);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(<span class="built_in">std</span>::move(seg));</span><br><span class="line">                Assert(receiver.stream_out().bytes_written() == <span class="number">7</span>);</span><br><span class="line">                Assert(receiver.unassembled_bytes() == <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//////// bytestream //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////// abcdefg    //////////   ////// abc       //////</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  a , seqno = 13</span></span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">false</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">false</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(<span class="number">13</span>);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(<span class="built_in">std</span>::move(seg));</span><br><span class="line">                Assert(receiver.stream_out().bytes_written() == <span class="number">11</span>);    <span class="comment">//  abcdefgaabc</span></span><br><span class="line">                Assert(receiver.unassembled_bytes() == <span class="number">0</span>);</span><br><span class="line">                Assert(receiver.ackno() == WrappingInt32(<span class="number">17</span>));          <span class="comment">//  syn(0) + abcdefgaabc[1,11] -&gt; 12 +  isn(5) </span></span><br><span class="line">                ByteStream stream = receiver.stream_out();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;stream.read(stream.buffer_size())&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//////// bytestream  //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////// abcdefgaabc //////////   ////// empty       //////</span></span><br><span class="line"><span class="comment">// abs_seq      //////0 1234567891011//////////   ////// 12          //////</span></span><br><span class="line"><span class="comment">// seq = abs_seq + 5</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//  &quot;&quot; , fin , seqno = 17</span></span><br><span class="line">                TCPSegment seg;</span><br><span class="line">                seg.payload() = <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                seg.header().ack = <span class="literal">false</span>;</span><br><span class="line">                seg.header().fin = <span class="literal">true</span>;</span><br><span class="line">                seg.header().syn = <span class="literal">false</span>;</span><br><span class="line">                seg.header().rst = <span class="literal">false</span>;</span><br><span class="line">                seg.header().ackno = WrappingInt32(<span class="number">0</span>);</span><br><span class="line">                seg.header().seqno = WrappingInt32(<span class="number">17</span>);</span><br><span class="line">                seg.header().win = <span class="number">0</span>;</span><br><span class="line">                receiver.segment_received(<span class="built_in">std</span>::move(seg));</span><br><span class="line">                Assert(receiver.stream_out().bytes_written() == <span class="number">11</span>);    <span class="comment">//  abcdefgaabc</span></span><br><span class="line">                Assert(receiver.unassembled_bytes() == <span class="number">0</span>);</span><br><span class="line">                Assert(receiver.ackno().value() == WrappingInt32(<span class="number">18</span>));          <span class="comment">//  syn(0) + abcdefgaabc[1,11] + fin[12] -&gt; 13 + isn(5) </span></span><br><span class="line">                <span class="comment">//////// bytestream  //////////   ////// recv_window //////</span></span><br><span class="line">                <span class="comment">//////// abcdefgaabc //////////   ////// fin empty       //////</span></span><br><span class="line"><span class="comment">// abs_seq      //////0 1234567891011//////////   ////// 12  13          //////</span></span><br><span class="line"><span class="comment">// seq = abs_seq + 5</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-01-03-16-17-59.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;一言以蔽之&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;lab2实现的tcp receiver&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（0） 转换stream_idx ，abs_seq ，seq（属于内部功能)  &lt;/li&gt;
&lt;li&gt;（1） 利用 StreamReassembler对 接收到的segment进行重组 并压入bytestream&lt;/li&gt;
&lt;li&gt;（2） 填充receive_window的相关信息：ackno , window_size， 从而实现flow-control流量控制&lt;/li&gt;
&lt;li&gt;（3） 根据 接收到的报文 对tcp receiver进行状态划分. listen syn_recv fin_recv&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们的receiver只实现了234&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;/2023/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-CS144-lab2/2023-02-27-22-58-04.png&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CS144" scheme="http://example.com/categories/CS144/"/>
    
    
    <category term="CS144" scheme="http://example.com/tags/CS144/"/>
    
  </entry>
  
</feed>
