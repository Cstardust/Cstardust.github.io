<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitment","storage":true,"lazyload":false,"nav":{"gitment":{"order":-1}}},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合SGI STL 二级空间配置器 原理图示  template&lt;typename T&gt; class my_allocator&amp;#123;&amp;#125; 整体    _S_chunk_alloc     相关定义 SGI STL包含了一级空间配置器和">
<meta property="og:type" content="article">
<meta property="og:title" content="sgi_stl二级空间配置器">
<meta property="og:url" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/index.html">
<meta property="og:site_name" content="不落辰">
<meta property="og:description" content="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合SGI STL 二级空间配置器 原理图示  template&lt;typename T&gt; class my_allocator&amp;#123;&amp;#125; 整体    _S_chunk_alloc     相关定义 SGI STL包含了一级空间配置器和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-17-24.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-18-11.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-07-18.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-08-25.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-20-41-44.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-21-13-13.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-09-38.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-10-52.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-08-16.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-08-39-50.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-10-58-25.png">
<meta property="og:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-32-12.png">
<meta property="article:published_time" content="2022-04-16T01:52:38.000Z">
<meta property="article:modified_time" content="2022-05-28T14:20:29.056Z">
<meta property="article:author" content="Cstardust">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="SGI_STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-17-24.png">

<link rel="canonical" href="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>sgi_stl二级空间配置器 | 不落辰</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不落辰</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知不可乎骤得,托遗响于悲风</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="小窝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          sgi_stl二级空间配置器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-16 09:52:38" itemprop="dateCreated datePublished" datetime="2022-04-16T09:52:38+08:00">2022-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-28 22:20:29" itemprop="dateModified" datetime="2022-05-28T22:20:29+08:00">2022-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。"><a href="#一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。" class="headerlink" title="一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。"></a>一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。</h2><h2 id="二级空间配置器就是-一级空间配置器-基于freelist实现的内存池的结合"><a href="#二级空间配置器就是-一级空间配置器-基于freelist实现的内存池的结合" class="headerlink" title="二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合"></a>二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合</h2><h1 id="SGI-STL-二级空间配置器-原理"><a href="#SGI-STL-二级空间配置器-原理" class="headerlink" title="SGI STL 二级空间配置器 原理"></a>SGI STL 二级空间配置器 原理</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><ul>
<li> <code>template&lt;typename T&gt; class my_allocator&#123;&#125;</code></li>
<li>整体<ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-17-24.png"></li>
</ul>
</li>
<li>_S_chunk_alloc<ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-09-18-11.png"></li>
</ul>
</li>
</ul>
<h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><ul>
<li>SGI STL包含了一级空间配置器和二级空间配置器，<ul>
<li>其中一级空间配置器allocator采用malloc和free来管理内存，和C++标准库中提供的allocator是一样的，</li>
<li>但其二级空间配置器allocator采用了基于freelist（自由链表）原理的内存池机制实现内存管理。</li>
</ul>
</li>
<li>SGI STL二级空间配置器：线程安全</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __STL_DEFAULT_ALLOCATOR</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_STD_ALLOCATORS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) allocator<span class="meta-string">&lt; T &gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __STL_DEFAULT_ALLOCATOR(T) alloc</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  一级空间配置器</span></span><br><span class="line">allocator&lt; T &gt;：</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> // 一级空间配置器内存管理类 -- 通过<span class="title">malloc</span>和<span class="title">free</span>管理内</span></span><br><span class="line"><span class="class">存</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//  二级空间配置器</span></span><br><span class="line"><span class="class"><span class="title">alloc</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span> <span class="comment">// 二级空间配置器内存管理类 -- 通过自定义内存池实现内存管理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> :</span> <span class="keyword">protected</span> _Vector_base&lt;_Tp, _Alloc&gt;</span><br></pre></td></tr></table></figure>

<h2 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h2><ul>
<li><p>内存池粒度信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;       <span class="comment">//  内存对齐</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;; <span class="comment">//  最大块大小   &gt;128就不会放到内存池里了，也即不会用二级空间配置器。会用一级空间配置器  </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">//  静态链表的成员个数 _MAX_BYTES/_ALIGN</span></span><br></pre></td></tr></table></figure></li>
<li><p>每一个内存chunk块的头信息</p>
<ul>
<li>chunk：数据块，区块。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>自由链表数组。数组的每个成员是静态的_Obj*指针。_STL_VOLATILE是为了保证多线程安全（通过防止线程缓存？多线程中一般堆上和数据段都会加volatile）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;__threads, __inst&gt;::_Obj* __STL_VOLATILE</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt; ::</span><br><span class="line">_S_free_list[_NFREELISTS] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Chunk allocation state</code>. 记录内存<code>chunk</code>块的分配情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  static：类内声明、类外定义。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;         <span class="comment">//   空闲free内存的起始start位置 [</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;           <span class="comment">//   空闲free内存的结束end位置 )       (包括回收的吗？)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;         <span class="comment">//   总共malloc过的内存大小（因为malloc是从堆heap上请求的，所以叫heapsize）</span></span><br><span class="line"><span class="comment">//  类外定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>我认为SGI STL二级空间配置器中的<strong>内存池</strong>，分为<strong>三部分</strong></p>
<ul>
<li>一部分给用户使用</li>
<li>一部分是用户还没使用的，已经形成chunk链表内存池</li>
<li>一部分是还没加入chunk链表内存池的原始空闲内存</li>
</ul>
</li>
</ul>
<h2 id="重要辅助函数"><a href="#重要辅助函数" class="headerlink" title="重要辅助函数"></a>重要辅助函数</h2><ul>
<li>将bytes上调至最邻近的_ALIGN = 8的倍数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>分析<ul>
<li>计组复习：<ul>
<li>机器数的解释规则都是补码。也就是计算机里的数都是以补码形式存储的。</li>
<li>补码<ul>
<li>正数：补码=原码=真值</li>
<li>负数：补码=~原码+1<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">枚举变量的取值为花括号内的任意一个值（有且只能有其中一个值），而这个值是<span class="keyword">int</span>型的。</span><br><span class="line">在X86系统中，所以<span class="built_in"><span class="keyword">sizeof</span></span>(_ALIGN) = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) = <span class="number">4</span>，也就是枚举变量的值为<span class="number">4</span></span><br><span class="line">_ALIGN</span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00001000</span></span><br><span class="line">_ALIGN - <span class="number">1</span></span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000111</span></span><br><span class="line">~(ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN</span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00001000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span></span><br><span class="line"><span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000000</span> | <span class="number">00000111</span></span><br><span class="line"></span><br><span class="line">~((<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111111</span> | <span class="number">11111000</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span> + bytes</span><br><span class="line"><span class="number">000.</span>..| <span class="number">00000111</span>    +<span class="number">0</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001000</span>    +<span class="number">1</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001001</span>    +<span class="number">2</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00001111</span>    +<span class="number">8</span></span><br><span class="line"><span class="comment">// -&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00010000</span>    +<span class="number">9</span></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00010111</span>    +<span class="number">16</span></span><br><span class="line"><span class="comment">// -&gt; 16</span></span><br><span class="line"></span><br><span class="line"><span class="number">000.</span>..| <span class="number">00011000</span>    +<span class="number">17</span></span><br><span class="line"><span class="comment">// -&gt; 24</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp; </span><br><span class="line">~((<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)</span><br><span class="line"><span class="number">111.</span>..| <span class="number">11111000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>返回位于第几个内存块<ul>
<li>bytes &gt;= 1  内存块号 &gt;= 0<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  bytes &gt;= 1  内存块号 &gt;= 0</span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">      <span class="comment">//  (bytes + 7)/(ALIGN = 8) - 1。（+7(ALIGN-1)：为了保证12345678位于同一组？</span></span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">8</span>][<span class="number">9</span>,<span class="number">16</span>][<span class="number">17</span>,<span class="number">24</span>]</span><br><span class="line">  <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>例子<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> _ALIGN = <span class="number">8</span> &#125;;     <span class="comment">//  4</span></span><br><span class="line"><span class="comment">//  将bytes上调至最邻近的8的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &amp; ~((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  返回位于第几个内存块</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">    <span class="keyword">return</span> (((__bytes)+(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) / (<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);   <span class="comment">//  (bytes + 7)/8  -1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &lt;&lt; endl;                    <span class="comment">//  4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;              <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; endl;     <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">size_t</span>) &lt;&lt; endl;                 <span class="comment">//  8    </span></span><br><span class="line">    <span class="comment">//  size_t ：unsigned long long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(_ALIGN) &lt;&lt; endl;                 <span class="comment">//  4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(_ALIGN).<span class="built_in">name</span>() &lt;&lt; endl;          <span class="comment">//  enum &lt;unnamed-enum-_ALIGN&gt;</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>((<span class="keyword">size_t</span>)_ALIGN) &lt;&lt; endl;         <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>((<span class="keyword">size_t</span>)_ALIGN).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">//  unsigned __int64</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; _ALIGN &lt;&lt; endl;                         <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _ALIGN<span class="number">-1</span> &lt;&lt; endl;                       <span class="comment">//  7</span></span><br><span class="line">    cout &lt;&lt; ~(_ALIGN - <span class="number">1</span>) &lt;&lt; endl;                  <span class="comment">//  -8</span></span><br><span class="line">    cout &lt;&lt; ((<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &lt;&lt; endl;           <span class="comment">//  7</span></span><br><span class="line">    cout &lt;&lt; (~(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>) &lt;&lt; endl;          <span class="comment">//  18446744073709551606</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">0</span>) &lt;&lt; endl;                 <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">1</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">7</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">8</span>) &lt;&lt; endl;                 <span class="comment">//  8</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">9</span>) &lt;&lt; endl;                 <span class="comment">//  16</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">16</span>) &lt;&lt; endl;                <span class="comment">//  16</span></span><br><span class="line">    cout &lt;&lt; _S_round_up(<span class="number">17</span>) &lt;&lt; endl;                <span class="comment">//  24</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;=============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//  cout &lt;&lt; _S_freelist_index(0) &lt;&lt; endl;   bytes至少&gt;=1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">1</span>) &lt;&lt; endl;           <span class="comment">//  0   </span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">7</span>) &lt;&lt; endl;           <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">8</span>) &lt;&lt; endl;           <span class="comment">//  0</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">15</span>) &lt;&lt; endl;          <span class="comment">//  1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">16</span>) &lt;&lt; endl;          <span class="comment">//  1</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">17</span>) &lt;&lt; endl;          <span class="comment">//  2</span></span><br><span class="line">    cout &lt;&lt; _S_freelist_index(<span class="number">24</span>) &lt;&lt; endl;          <span class="comment">//  2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h2><ul>
<li>概述：根据n大小，采取相应方式获取内存，并返回。<ul>
<li>n&gt;128<ul>
<li>malloc_alloc::allocate(__n)。同一级空间配置器。开辟后返回</li>
</ul>
</li>
<li>n&lt;128<ul>
<li>根据n大小，借助free从freelist相应元素管理的内存池中取出相应大小内存块。当内存池不存在时，开辟内存池。</li>
<li>对于传入的请求内存大小n，n决定了请求那个freelist成员指向的内存池的内存块。<ul>
<li><code>_Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n)</code></li>
</ul>
</li>
<li>如果相应的<code>freelist</code>成员=nullptr的话，<ul>
<li>调用<code>_S_refill</code>：<code>__ret = _S_refill(_S_round_up(__n));</code><ul>
<li>开辟内存块数=nobjs(20)的内存池，内存池中的每个内存块的大小都是传入的<code>__n</code><ul>
<li><code>char* __chunk = _S_chunk_alloc(__n, __nobjs);</code></li>
</ul>
</li>
<li>_S_refill根据传入的n大小，计算出开辟的内存池应该由哪个freelist成员管理。<ul>
<li><code>__my_free_list = _S_free_list + _S_freelist_index(__n);</code></li>
</ul>
</li>
<li>将内存池挂到freelist相应成员下，</li>
<li>并维护每个空闲内存块之间指向关系。（每个空闲内存块连接在一起组成内存池）</li>
<li>返回第一个内存块。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>freelist[]（自由链表）是一个静态的链表</li>
<li>数组的每个元素指向一个内存池。</li>
<li>同一内存池的chunk内存块的大小一致。</li>
<li>不同内存池的chunk内存块大小不一致。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span>     <span class="comment">//  请求的一块大小为n的空间</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果&gt;128bytes，那么调用malloc_alloc::allocate（同一级空间配置器的allocator的allocate一样)</span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);          <span class="comment">//  应当在哪个</span></span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;                            <span class="comment">//  上锁</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;      <span class="comment">//  __RESTRICT线程安全</span></span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//  _S_round_up(n)（向上取8的倍数）。根据n的大小，计算出应该开辟多大内存。</span></span><br><span class="line">      <span class="comment">//  _S_refill：在相应freelist成员下开辟内存池，且内存池的每个内存块大小都为__n向上取8的倍数。并返回内存池的第一个内存块。</span></span><br><span class="line">      <span class="comment">//   如何确定将内存池接在哪个freelist成员下？通过_S_freelist_index(n)计算出。</span></span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));            <span class="comment">//  开辟内存池</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-07-18.png"></p>
<h2 id="S-refill"><a href="#S-refill" class="headerlink" title="_S_refill"></a>_S_refill</h2><ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-08-25.png"></li>
<li>__n：内存池里每个内存块的大小。并且可以借助n计算出该内存池应该接在那个freelist成员下。</li>
<li>概述：当freelist的某个元素obj*=nullptr时，会调用_S_refill，(<code>_S_refill</code>向下调用<code>_S_chunk_alloc</code>)开辟内存池，并返回内存池的第一个内存块。并且<code>_S_refill</code>内维护从原始内存中申请来的内存池中每个内存块chunk节点之间的指向关系。<ul>
<li><code>_S_chunk_alloc</code>：分配指定大小的内存池</li>
<li>静态链表：把每个chunk块通过Obj*里的指针连接起来</li>
</ul>
</li>
<li>allocate函数中调用_S_refill。n是传入的参数，代表allocate请求一个多大的内存块。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns an object of size __n, and optionally adds to size __n free list.*/</span></span><br><span class="line"><span class="comment">/* We assume that __n is properly aligned.                                */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n)  <span class="comment">//  n是一个chunk块的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  分配指定大小的内存池    __nobjs：chunk内存块数量 ；这里的 __n：每个chunk内存块大小。</span></span><br><span class="line">    <span class="keyword">int</span> __nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">    _Obj* __result;</span><br><span class="line">    _Obj* __current_obj;</span><br><span class="line">    _Obj* __next_obj;</span><br><span class="line">    <span class="keyword">int</span> __i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  __nobjs：申请到的chunk块数量。当只申请到一个时，直接返回该内存块给上一级使用。无需建立各个chunk的连接关系，无需挂载到相应的freelist成员下。（因为只有一个）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);  </span><br><span class="line">    </span><br><span class="line">    __my_free_list = _S_free_list + _S_freelist_index(__n);     <span class="comment">//  根据内存块大小求出内存池应该在由freelist第几个成员管理（指向）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  静态链表：把每个chunk块通过Obj*里的指针连接起来</span></span><br><span class="line">    <span class="comment">//  每个内存块，有一部分的内存时union联合体Obj，里面有一个Obj*指针，负责连接每个空闲内存块。</span></span><br><span class="line">    <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">      __result = (_Obj*)__chunk;</span><br><span class="line">      *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);    <span class="comment">//  __n：一个内存块的大小（因为第一个内存块要分配出去）</span></span><br><span class="line">      <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;</span><br><span class="line">        __current_obj = __next_obj;                             </span><br><span class="line">        __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);          <span class="comment">//   维护内存块间的连接  char* 因此+__n是偏移n个bytes +n是为了一次跑一个chunk块</span></span><br><span class="line">        <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;                               <span class="comment">//   空闲内存块数为0?</span></span><br><span class="line">            __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span>(__result);   <span class="comment">//  返回第一个内存块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="S-chunk-alloc"><a href="#S-chunk-alloc" class="headerlink" title="_S_chunk_alloc"></a>_S_chunk_alloc</h2><ul>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-20-41-44.png"></li>
<li><code>allocate(size_t n) -&gt; _S_refill(size_t n) -&gt; _S_chunk_alloc(size_t __size__,int &amp;nobjs)</code></li>
<li>将所有备用内存池都应用到，哪怕只剩下<code>8bytes</code>（最小的块就是<code>8bytes</code>，将这些用不到的小内存块挂载到相应的<code>freelist</code>成员下。）。</li>
<li><code>chunk_alloc</code>里可能<code>malloc</code>，也可能不<code>malloc</code>。<ul>
<li><code>malloc</code>：备用内存(当前<code>start-end</code>)不够</li>
<li>不<code>malloc</code>：备用内存(当前<code>start-end</code>)本身就够<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3></li>
</ul>
</li>
<li>从 【备用空闲内存池申请】 或者 【操作系统中开辟】 内存池。这个内存池中，每个<code>chunk</code>大小为<code>size</code> bytes，数量为<code>_nobjs</code>。将所申请的这一整个池子的首地址返回给上一级–_S_refill。在_S_refill中，负责将该池子中的每个chunk块建立起链表关系，并挂载到相应free-list成员下。并且_S_refill负责把一个size大小的chunk返回给上一级allocate。（用户调用请求函数）。</li>
<li>而在_S_chunk_alloc中，对于内存池子是从备用内存池请求，还是再从操统中开辟，又分以下情况讨论<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">    <span class="keyword">if</span>(_bytes_left &gt;= total_bytes)&#123; </span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> result;  <span class="comment">//  total大小内存块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(__bytes_left &gt;= __size)&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> result;  <span class="comment">//  尽量return大点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 后半+的这个是为了malloc越来越大</span></span><br><span class="line">      <span class="comment">// 计算要malloc多少内存s</span></span><br><span class="line">      bytes_to_get = <span class="number">2</span>*__total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// malloc内存</span></span><br><span class="line">      _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">            <span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">            <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                          </span><br><span class="line">              <span class="comment">//  头插法</span></span><br><span class="line">              <span class="comment">//  start_free头插接入_S_free_list + _S_freelist_index(__bytes_left)</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      _S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">      _S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">      <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>*</span><br><span class="line">__default_alloc_template&lt;__threads, __inst&gt;::_S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;            <span class="comment">//  本次总共需要请求的内存大小</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;  <span class="comment">//  __default_alloc_template&lt;__threads, __inst&gt; 从开始到现在，请求的剩余空闲的的内存大小。不包括回收的。只是开辟的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;                <span class="comment">//  剩余的备用内存够支付本次请求的内存大小。</span></span><br><span class="line">        __result = _S_start_free;                       <span class="comment">//  __result 作为返回内存首地址</span></span><br><span class="line">        _S_start_free += __total_bytes;                 <span class="comment">//  移动_S_start_free</span></span><br><span class="line">        <span class="keyword">return</span>(__result);                               <span class="comment">//  [result , _S_start_free)  作为请求结果返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;                <span class="comment">//  剩余的不够支付total，但起码能支付一个内存块。（因为要返回的至少是一个内存块大小）</span></span><br><span class="line">        __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);</span><br><span class="line">        __total_bytes = __size * __nobjs;</span><br><span class="line">        __result = _S_start_free;</span><br><span class="line">        _S_start_free += __total_bytes;</span><br><span class="line">        <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">//  剩余的free内存连一个内存块也不够支付</span></span><br><span class="line">        <span class="keyword">size_t</span> __bytes_to_get =                         <span class="comment">//  当剩余的空闲内存不够时，需要向操统malloc内存。这是计算出需要malloc内存的大小（至少malloc出来要求内存的(__total_bytes)两倍）</span></span><br><span class="line">	  <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="comment">// 剩余的备用内存bytes_left,又不够本次请求的一个chunk块大小，就把这块内存挂载到他能所属的freelist成员下。（头插法）</span></span><br><span class="line">        <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;                         <span class="comment">//  </span></span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list =</span><br><span class="line">                        _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line"></span><br><span class="line">            ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">            *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);  <span class="comment">//  向操统malloc内存</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;                       <span class="comment">//  malloc失败</span></span><br><span class="line">            <span class="keyword">size_t</span> __i;</span><br><span class="line">            _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">	    _Obj* __p;</span><br><span class="line">            <span class="comment">// Try to make do with what we have.  That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt.  We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="comment">//  从别的freelist成员管理的原始备用内存池中借用至少size大小的chunk块</span></span><br><span class="line">            <span class="keyword">for</span> (__i = __size;</span><br><span class="line">                 __i &lt;= (<span class="keyword">size_t</span>) _MAX_BYTES;</span><br><span class="line">                 __i += (<span class="keyword">size_t</span>) _ALIGN) &#123;</span><br><span class="line">                __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">                __p = *__my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</span><br><span class="line">                    *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">                    _S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">                    _S_end_free = _S_start_free + __i;</span><br><span class="line">                    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  都没有时，尝试下allcoate来补救</span></span><br><span class="line">	    _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">            _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an</span></span><br><span class="line">            <span class="comment">// exception or remedy the situation.  Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        _S_heap_size += __bytes_to_get;               <span class="comment">//  _S_heap_size：迄今为止总共malloc了多少内存?</span></span><br><span class="line">        _S_end_free = _S_start_free + __bytes_to_get; <span class="comment">//  移动_S_end_free指针。指向空闲内存块末尾</span></span><br><span class="line">        <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));      <span class="comment">//  递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










<h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><ul>
<li><p>什么时候调用chunk_alloc?当某个freelist成员的内存池为空时。（没分配过内存池或者内存池耗尽）</p>
</li>
<li><p><strong>调用上下文</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">allocate中：<span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">_Obj* __RESTRICT __result </span>= *__my_free_list;</span><br><span class="line"><span class="comment">//  当某个freelist成员的内存池为空时。（没分配过内存池或者内存池耗尽） 调用__S_chunk_alloc</span></span><br><span class="line"><span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">  __ret = _S_refill(_S_round_up(__n));</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//  消耗内存池</span></span><br><span class="line">  *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">  __ret = __result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __ret;</span><br><span class="line"></span><br><span class="line">S_refill中</span><br><span class="line"><span class="number">1.</span> <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);</span><br><span class="line"><span class="number">2.</span> 连接得到的chunk块</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<ul>
<li>整体<blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-01-21-13-13.png"></p>
</blockquote>
</li>
<li>我将图中形成链表的自由（空闲）内存节点们称为内存池。</li>
<li>将没有建立链表连接的称为原始内存（或者叫备用内存池）。</li>
</ul>
<hr>
<ul>
<li>大体：<code>start-free==0</code>时，就是一点 <strong>备用的 空闲的</strong> 内存也没有了<ul>
<li>备用内存：<ul>
<li>优先是只进行了malloc的空闲原始内存，也就是没有被形成freelist某成员内存池的</li>
<li>如果没有，其次是已经参与形成内存链表池的空闲chunk块。</li>
</ul>
</li>
</ul>
</li>
<li>当没有备用内存(<code>bytes_left==0</code>)时，正常从操统中malloc内存<ul>
<li>一小块返回给用户使用，</li>
<li>一部分返回给上一级加工成内存池（把chunk块之间连起来）</li>
<li>一部分在 <code>[_start_free</code> 和 <code>_end_free)</code>之间，用作备用内存（备用内存池/原始内存）。</li>
</ul>
</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-09-38.png"></li>
</ul>
<hr>
<ul>
<li>当有备用内存时<ul>
<li>start和free之间malloc的原始内存，还没参与形成内存池</li>
<li> [start，free) &gt; size (nobjs&gt;1)，则将这块内存挂给相应freelist成员</li>
<li>图中为空闲内存有160bytes，而上层申请16*20bytes内存<br><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-05-28-12-10-52.png"></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>条件同上<ul>
<li>start和free之间malloc的原始内存，还没参与形成内存池</li>
<li>nobjs = [start，free) / size = 1，则将这内存块返回。（因为只有一个，所以不必挂载形成内存池） </li>
<li>图中空闲内存为160bytes，而上层申请16*128bytes内存。<ul>
<li>返回1个128bytes内存块</li>
</ul>
</li>
<li>用户又接着申请32bytes</li>
<li>用户接着申请128bytes</li>
</ul>
</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-08-16.png"></li>
<li><blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-08-39-50.png"></p>
</blockquote>
</li>
<li>第三张红圈的例子：解释如下。<ul>
<li>只返回一个<code>128bytes</code>块时，<code>freelist</code>的<code>128bytes</code>成员仍是空，因为返回的这一个直接就用作请求结果了，并没空闲内存块。</li>
<li>当上层(allocate)再次请求128Bytes时，_S_refill调用<code>chunk = _S_chunk_alloc(size_t __size = 128, int&amp; __nobjs = 20)</code>。由于剩下<code>__bytes_left = 32bytes &lt; size = 128bytes</code>。故进入<code>else</code>。</li>
<li>剩余的<code>32bytes</code>被<code>freelist</code>的<code>32bytes</code>成员管理（因为这个<code>32bytes</code>对于128bytes的chunk块来说无用）。再开辟<code>bytes_to_get</code>的内存。移动<code>free_start</code>。接下来的操作同一开始malloc内存。（再循环调用<code>chunk_alloc...</code></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>malloc失败<ul>
<li>从别的freelist成员已经形成链表的内存池中，拿出一块chunk，给本次请求用<blockquote>
<p><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-22-10-58-25.png"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h2><ul>
<li>功能概述：归还p指向的、大小为n的内存块，还给内存池链表。（n用于计算归还的该块内存应该在哪个freelist成员管理的内存之中）<ul>
<li>将p头插入法插入内存池链表中。</li>
<li><img src="/2022/04/16/sgi_stl%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/2022-04-21-23-32-12.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)  <span class="comment">//  n&gt;128 同一级空间配置器</span></span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);  <span class="comment">//  找到相应freelist成员</span></span><br><span class="line">      _Obj* __q = (_Obj*)__p;       <span class="comment">//  </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="malloc-alloc-template"><a href="#malloc-alloc-template" class="headerlink" title="__malloc_alloc_template"></a>__malloc_alloc_template</h2><ul>
<li><p>辅助__malloc_alloc_template的类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  申请nbytes。如果空间不足，则释放nbytes</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  释放p</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>malloc_alloc:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="malloc-alloc-allocate"><a href="#malloc-alloc-allocate" class="headerlink" title="malloc_alloc::allocate"></a>malloc_alloc::allocate</h3><ul>
<li>功能概述<ul>
<li>分配nbytes成功 返回result</li>
<li>分配失败，那么就调用预制好的_S_oom_malloc，释放nbytes空间，给result<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>调用上下文<ul>
<li>在没有空间（不能malloc）的情况下，又必须进行malloc。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_S_chunk_alloc()&#123;</span><br><span class="line">  malloc = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 没有空间 却又只能allcoate</span></span><br><span class="line">  _S_end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">  _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="malloc-alloc-S-oom-malloc"><a href="#malloc-alloc-S-oom-malloc" class="headerlink" title="malloc_alloc::_S_oom_malloc"></a>malloc_alloc::_S_oom_malloc</h3><ul>
<li>功能概述：循环调用用户预制的回调函数，以期解决内存不够的问题，好拿出nbyte内存。</li>
<li>oom：out of memory 内存耗尽</li>
<li>用户先前设置好回调函数<code>__malloc_alloc_oom_handler</code><ul>
<li>设置：那么这个回调函数必须实现 释放其他内存，使得可以给当前请求分配内存的功能。否则会陷入死循环，直到可以malloc内存。<code>return</code>malloc的内存。</li>
<li>没设置：直接抛异常 throw bad_alloc<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __my_malloc_handler)();   <span class="comment">//  用于接收回调函数</span></span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;   <span class="comment">//  设置回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;<span class="comment">//  如果用户之前没设置回调函数，那么直接抛异常</span></span><br><span class="line">        (*__my_malloc_handler)();                           <span class="comment">//  调用回调函数</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);                       <span class="comment">//  </span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="reallocate"><a href="#reallocate" class="headerlink" title="reallocate"></a>reallocate</h2><ul>
<li>功能概述<ul>
<li>为指针p重新分配指向的空间，大小为new_sz。并返回这块新内存的地址。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>*</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::<span class="built_in">reallocate</span>(<span class="keyword">void</span>* __p,size_t__old_sz,<span class="keyword">size_t</span> __new_sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line">    <span class="keyword">size_t</span> __copy_sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  old new都&gt;128byets，那么用的就应当是和一级空间配置器一样的方法malloc</span></span><br><span class="line">    <span class="keyword">if</span> (__old_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES &amp;&amp; __new_sz &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="built_in">realloc</span>(__p, __new_sz));   <span class="comment">//  重新分配内存。释放p地址内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果即将分配的chunk块大小一致，那么不必，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (_S_round_up(__old_sz) == _S_round_up(__new_sz)) <span class="keyword">return</span>(__p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  重新从内存池中申请new_size大小内存，并拷贝数据到新申请来的内存里</span></span><br><span class="line">    __result = <span class="built_in">allocate</span>(__new_sz);</span><br><span class="line">    __copy_sz = __new_sz &gt; __old_sz? __old_sz : __new_sz;</span><br><span class="line">    <span class="built_in">memcpy</span>(__result, __p, __copy_sz); <span class="comment">//  拷贝数据</span></span><br><span class="line">    <span class="built_in">deallocate</span>(__p, __old_sz);  <span class="comment">//  将p指向的内存还给内存池链表</span></span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="经典内存池优点"><a href="#经典内存池优点" class="headerlink" title="经典内存池优点"></a>经典内存池优点</h2><ul>
<li><p>C/C++下内存管理是让几乎每一个程序员头疼的问题，分配足够的内存、追踪内存的分配、在不需要的时候释放内存——这个任务相当复杂。而直接使用系统调用malloc/free、new/delete进行内存分配和释放，有以下弊端：<br>利用默认的内存管理函数new/delete或malloc/free在堆上分配和释放内存会有一些额外的开销。</p>
</li>
<li><p>系统在接收到分配一定大小内存的请求时，首先查找内部维护的内存空闲块表，并且需要根据一定的算法（例如分配最先找到的不小于申请大小的内存块给请求者，或者分配最适于申请大小的内存块，或者分配最大空闲的内存块等）找到合适大小的空闲内存块。如果该空闲内存块过大，还需要切割成已分配的部分和较小的空闲块。然后系统更新内存空闲块表，完成一次内存分配。类似地，在释放内存时，系统把释放的内存块重新加入到空闲内存块表中。如果有可能的话，可以把相邻的空闲块合并成较大的空闲块。</p>
</li>
<li><p>默认的内存管理函数还考虑到多线程的应用，需要在每次分配和释放内存时加锁，同样增加了开销。 </p>
</li>
<li><p>可见，如果应用程序频繁地在堆上分配和释放内存，则会导致性能的损失。并且会使系统中出现大量的内存碎片，降低程序性能，降低内存的利用率。</p>
</li>
<li><p>默认的分配和释放内存算法自然也考虑了性能，然而这些内存管理算法的通用版本为了应付更复杂、更广泛的情况，需要做更多的额外工作。而对于某一个具体的应用程序来说，适合自身特定的内存分配释放模式的自定义内存池则可以获得更好的性能。</p>
</li>
<li><p>内存池（memory pool)是代替直接调用malloc/free、new/delete进行内存管理的常用方法，当我们申请内存空间时，首先到我们的内存池中查找合适的内存块，而不是直接向操作系统申请，优势在于：</p>
<ul>
<li>比malloc/free进行内存申请/释放的方式快;</li>
<li>不会产生或很少产生堆碎片;</li>
<li>可避免内存泄漏;</li>
</ul>
</li>
<li><p>普通内存池</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象。</span><br><span class="line"></span><br><span class="line">（2）每个对象连同一个指向下一个对象的指针一起构成一个内存节点（Memory Node）。各个空闲的内存节点通过指针来形成一个链表，链表的每一个内存节点都是一块可供分配的内存空间。</span><br><span class="line"></span><br><span class="line">（3）某个内存节点一旦分配出去，就将从链表中去除。</span><br><span class="line"></span><br><span class="line">（4）一旦释放了某个内存节点的空间，又将该节点重新加入自由内存节点链表。</span><br><span class="line"></span><br><span class="line">（5）如果一个内存块的所有内存节点分配完毕，若程序继续申请新的对象空间，则会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。</span><br><span class="line"></span><br><span class="line">经典内存池的实现过程大致如上面所述，其形象化的过程如下图所示： </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="SGI-STL-二级空间配置器优点"><a href="#SGI-STL-二级空间配置器优点" class="headerlink" title="SGI STL 二级空间配置器优点"></a>SGI STL 二级空间配置器优点</h2><ul>
<li>对于每一个字节数的chunk块分配，都是返回给用户一个使用的内存块，并给freelist一个内存池，，并留有另一部分作为备用内存池。这个备用可以给当前的字节数freelist成员使用，也可以给其他字节数的freelist成员使用。</li>
<li>对于备用内存池划分chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的内存块再次分配出去，备用内存池使用的一滴不剩。</li>
<li>当指定bytes字节数内存分配失败以后，有一个异常处理的过程，bytes -&gt; 128字节所有的chunk块进行查看，如果哪个freelist成员下的内存链表池中有chunk块，借一个出去。<ul>
<li>如果操作失败，会调用<code>_S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get)</code>来malloc内存；<ul>
<li><code>allocate</code>里面通过调用<code>oom_malloc</code>，来调用预先设置好的回调函数<code>__malloc_alloc_oom_handler</code>。用于处理<code>malloc</code>失败的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缺点-我认为"><a href="#缺点-我认为" class="headerlink" title="缺点 我认为"></a>缺点 我认为</h2><ul>
<li>STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些缺点：<ul>
<li>1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它 会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造 成很多内部碎片；</li>
<li>二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过 程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全 是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有： <ul>
<li>1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失 败；</li>
<li>2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请 不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">灼夭. 10:11:37</span><br><span class="line">xdm 请问大家个问题。二级空间配置器真的解决了内存碎片的问题吗。我觉得虽然解决了外部碎片的问题，但好像又会导致产生很多内部碎片呀？还是说虽然会产生内部碎片，但是无所谓？对程序性能、内存利用率也没啥太大影响？</span><br><span class="line"></span><br><span class="line">灼夭. 10:11:51</span><br><span class="line">Alex💡 10:23:52</span><br><span class="line">灼夭.  </span><br><span class="line">xdm 请问大家个问题。二级空间配置器真的解决了内存碎片的问题吗。我觉得虽然解决了外部碎片的问题，但好像又会导致产生很多内部碎片呀？还是说虽然会产生内部碎片，但是无所谓？对程序性能、内存利用率也没啥太大影响？</span><br><span class="line">@灼夭. 我之前看侯捷讲的说法是，二级配置器可以很好的解决频繁调用malloc带来的时间消耗以及额外内存消耗，但是与此同时，内存池分配的小块内存都是8的倍数，也会存在一定的内部碎片，但相对于malloc而言，其性能还是好的。</span><br><span class="line"></span><br><span class="line">灼夭. 10:27:53</span><br><span class="line">Alex💡  </span><br><span class="line">@灼夭. 我之前看侯捷讲的说法是，二级配置器可以很好的解决频繁调用malloc带来的时间消耗以及额外内存消耗，但是与此同时，内存池分配的小块内存都是8的倍数，也会存在一定的内部碎片，但相对于malloc而言，其性能还是好的。</span><br><span class="line">@Alex💡 哦哦哦 多谢xd</span><br><span class="line"></span><br><span class="line">Alex💡 10:28:17</span><br><span class="line">没事儿。</span><br></pre></td></tr></table></figure>


<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fdk_lcl/article/details/89482835">https://blog.csdn.net/fdk_lcl/article/details/89482835</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">round - 必应词典</span><br><span class="line">美[raʊnd]英[raʊnd]</span><br><span class="line">n.旋转；巡视；一连串；绕圈</span><br><span class="line">adv.环绕；附近；各处；向四面</span><br><span class="line">prep.环绕；在…周围；始终</span><br><span class="line">v.绕过；拐过；使成圆形；把…四舍五入</span><br><span class="line">adj.圆的；球形的；肥胖的；弧形的</span><br><span class="line">网络回合；轮；圆形的</span><br><span class="line"></span><br><span class="line">round up 向上取整</span><br></pre></td></tr></table></figure>








<ul>
<li>计组<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>计算机里的数都是补码形式，因为CPU只会做加法，数的补码形式就可以用加法实现减法运算，进而以加法完成所有的运算。至于数以什么码的形式输入和输出，编程人员是可以控制的。</span><br><span class="line"><span class="number">2.</span>计算机里数码的位数是<span class="number">2</span>的正整数次方，比如<span class="number">4</span>位、<span class="number">8</span>位、<span class="number">16</span>位，因为CPU及周边电路一旦制成，一次处理数据位数、总线位数、各种寄存器位数就都固定下来，都是<span class="number">2</span>的正整数次方位，这样选择的理由很多，可参照有关资料了解。</span><br><span class="line"><span class="number">3.</span>一个<span class="number">8</span>位的补码数，它表示数的范围是<span class="number">-128</span>~+<span class="number">127</span>，原码表示数的范围是<span class="number">-127</span>~+<span class="number">127</span>，反码表示数的范围是<span class="number">-127</span>~+<span class="number">127</span>，就是因为最高位是符号位，实际数位只有<span class="number">7</span> 位。</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内存碎片是问题吗？"><a href="#内存碎片是问题吗？" class="headerlink" title="内存碎片是问题吗？"></a>内存碎片是问题吗？</h2><ul>
<li>截</li>
</ul>
<hr>
<h2 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Default node allocator.</span></span><br><span class="line"><span class="comment">// With a reasonable compiler, this should be roughly as fast as the</span></span><br><span class="line"><span class="comment">// original STL class-specific allocators, but with less fragmentation.</span></span><br><span class="line"><span class="comment">// Default_alloc_template parameters are experimental and MAY</span></span><br><span class="line"><span class="comment">// DISAPPEAR in the future.  Clients should just use alloc for now.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Important implementation properties:</span></span><br><span class="line"><span class="comment">// 1. If the client request an object of size &gt; _MAX_BYTES, the resulting</span></span><br><span class="line"><span class="comment">//    object will be obtained directly from malloc.</span></span><br><span class="line"><span class="comment">// 2. In all other cases, we allocate an object of size exactly</span></span><br><span class="line"><span class="comment">//    _S_round_up(requested_size).  Thus the client has enough size</span></span><br><span class="line"><span class="comment">//    information that we can return the object to the proper free list</span></span><br><span class="line"><span class="comment">//    without permanently losing part of the object.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The first template parameter specifies whether more than one thread</span></span><br><span class="line"><span class="comment">// may use this allocator.  It is safe to allocate an object from</span></span><br><span class="line"><span class="comment">// one instance of a default_alloc and deallocate it with another</span></span><br><span class="line"><span class="comment">// one.  This effectively transfers its ownership to the second one.</span></span><br><span class="line"><span class="comment">// This may have undesirable effects on reference locality.</span></span><br><span class="line"><span class="comment">// The second parameter is unreferenced and serves only to allow the</span></span><br><span class="line"><span class="comment">// creation of multiple default_alloc instances.</span></span><br><span class="line"><span class="comment">// Node that containers built on different allocator instances have</span></span><br><span class="line"><span class="comment">// different types, limiting the utility of this approach.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size __n, and optionally adds to size __n free list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_THREADS</span></span><br><span class="line">    <span class="keyword">static</span> _STL_mutex_lock _S_node_allocator_lock;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It would be nice to use _STL_auto_lock here.  But we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need the NULL check.  And we do need a test whether</span></span><br><span class="line">    <span class="comment">// threads have actually been started.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125;</span><br><span class="line">            ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Really we should use static const int x = N</span></span><br><span class="line">  <span class="comment">// instead of enum &#123; x = N &#125;, but few compilers accept the former.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ! (defined(__SUNPRO_CC) || defined(__GNUC__))</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;; <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">  _S_round_up(<span class="keyword">size_t</span> __bytes) </span><br><span class="line">    &#123; <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line">__PRIVATE:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">        <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC)</span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[]; </span><br><span class="line">        <span class="comment">// Specifying a size results in duplicate def for 4.1</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; </span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an object of size __n, and optionally adds to size __n free list.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// Allocates a chunk for nobjs of size size.  nobjs may be reduced</span></span><br><span class="line">  <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_THREADS</span></span><br><span class="line">    <span class="keyword">static</span> _STL_mutex_lock _S_node_allocator_lock;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// It would be nice to use _STL_auto_lock here.  But we</span></span><br><span class="line">    <span class="comment">// don&#x27;t need the NULL check.  And we do need a test whether</span></span><br><span class="line">    <span class="comment">// threads have actually been started.</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> _<span class="title">Lock</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            _Lock() &#123; __NODE_ALLOCATOR_LOCK; &#125;</span><br><span class="line">            ~_Lock() &#123; __NODE_ALLOCATOR_UNLOCK; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __n must be &gt; 0      */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;</span><br><span class="line">      __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      <span class="comment">// Acquire the lock here with a constructor call.</span></span><br><span class="line">      <span class="comment">// This ensures that it is released in exit or during stack</span></span><br><span class="line">      <span class="comment">// unwinding.</span></span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span></span></span><br><span class="line">      _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (__result == <span class="number">0</span>)</span><br><span class="line">        __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">        __ret = __result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __ret;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* __p may not be 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES)</span><br><span class="line">      malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      _Obj* __STL_VOLATILE*  __my_free_list</span><br><span class="line">          = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">      _Obj* __q = (_Obj*)__p;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// acquire lock</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifndef</span> _NOTHREADS</span></span><br><span class="line">      <span class="comment">/*REFERENCED*/</span></span><br><span class="line">      _Lock __lock_instance;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* _NOTHREADS */</span></span></span><br><span class="line">      __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = __q;</span><br><span class="line">      <span class="comment">// lock is released here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//  申请nbytes。如果空间不足，则释放nbytes</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//  释放p</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
              <a href="/tags/SGI-STL/" rel="tag"># SGI_STL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/10/HTTP/" rel="prev" title="HTTP(预习)">
      <i class="fa fa-chevron-left"></i> HTTP(预习)
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/22/nginx%E5%86%85%E5%AD%98%E6%B1%A0/" rel="next" title="nginx内存池">
      nginx内存池 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E6%B2%A1%E6%9C%89%E5%86%85%E5%AD%98%E6%B1%A0%E3%80%82%E5%8F%AA%E6%98%AF%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%86%85%E5%AD%98%E7%9A%84%E5%BC%80%E8%BE%9F%E5%88%86%E7%A6%BB%E5%BC%80%E8%80%8C%E5%B7%B2%E3%80%82"><span class="nav-number">1.</span> <span class="nav-text">一级空间配置器没有内存池。只是将对象的构造和内存的开辟分离开而已。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E5%B0%B1%E6%98%AF-%E4%B8%80%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8-%E5%9F%BA%E4%BA%8Efreelist%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E7%BB%93%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">二级空间配置器就是 一级空间配置器 + 基于freelist实现的内存池的结合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SGI-STL-%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8-%E5%8E%9F%E7%90%86"><span class="nav-number"></span> <span class="nav-text">SGI STL 二级空间配置器 原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%A4%BA"><span class="nav-number">1.</span> <span class="nav-text">图示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">相关定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E6%88%90%E5%91%98"><span class="nav-number">3.</span> <span class="nav-text">主要成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">重要辅助函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#allocate"><span class="nav-number">5.</span> <span class="nav-text">allocate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#S-refill"><span class="nav-number">6.</span> <span class="nav-text">_S_refill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#S-chunk-alloc"><span class="nav-number">7.</span> <span class="nav-text">_S_chunk_alloc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">7.2.</span> <span class="nav-text">代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%A4%BA-1"><span class="nav-number">7.3.</span> <span class="nav-text">图示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deallocate"><span class="nav-number">8.</span> <span class="nav-text">deallocate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-alloc-template"><span class="nav-number">9.</span> <span class="nav-text">__malloc_alloc_template</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-alloc-allocate"><span class="nav-number">9.1.</span> <span class="nav-text">malloc_alloc::allocate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-alloc-S-oom-malloc"><span class="nav-number">9.2.</span> <span class="nav-text">malloc_alloc::_S_oom_malloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reallocate"><span class="nav-number">10.</span> <span class="nav-text">reallocate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%86%85%E5%AD%98%E6%B1%A0%E4%BC%98%E7%82%B9"><span class="nav-number">11.</span> <span class="nav-text">经典内存池优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGI-STL-%E4%BA%8C%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%E4%BC%98%E7%82%B9"><span class="nav-number">12.</span> <span class="nav-text">SGI STL 二级空间配置器优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-%E6%88%91%E8%AE%A4%E4%B8%BA"><span class="nav-number">13.</span> <span class="nav-text">缺点 我认为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E9%87%8A"><span class="nav-number">14.</span> <span class="nav-text">问题解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">15.</span> <span class="nav-text">内存碎片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E6%98%AF%E9%97%AE%E9%A2%98%E5%90%97%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">内存碎片是问题吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="nav-number">17.</span> <span class="nav-text">整体代码</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cstardust</p>
  <div class="site-description" itemprop="description">小窝</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cstardust</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
