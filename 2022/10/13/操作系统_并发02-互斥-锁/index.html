<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="互斥困难的根本原因:load 和 store不原子  纯软件层面的互斥算法实现太复杂了，下面借助硬件提供的原子指令 实现比peterson简单的互斥协议。  硬件提供的原子指令如 : x86-64提供的lock ,xchg ; riscv提供的LR&#x2F;SC(实现CAS)    自旋锁spinlock : 基于xchg实现的spinlock 正确实现临界区互斥。  spinlock 缺陷。 除了进入">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-并发-互斥">
<meta property="og:url" content="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/index.html">
<meta property="og:site_name" content="不落辰">
<meta property="og:description" content="互斥困难的根本原因:load 和 store不原子  纯软件层面的互斥算法实现太复杂了，下面借助硬件提供的原子指令 实现比peterson简单的互斥协议。  硬件提供的原子指令如 : x86-64提供的lock ,xchg ; riscv提供的LR&#x2F;SC(实现CAS)    自旋锁spinlock : 基于xchg实现的spinlock 正确实现临界区互斥。  spinlock 缺陷。 除了进入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-07-53-21.png">
<meta property="og:image" content="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-08-55-51.png">
<meta property="og:image" content="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-08-56-29.png">
<meta property="og:image" content="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-09-41-43.png">
<meta property="og:image" content="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-13-32-27.png">
<meta property="article:published_time" content="2022-10-13T11:22:39.000Z">
<meta property="article:modified_time" content="2023-02-27T15:21:31.420Z">
<meta property="article:author" content="Cstardust">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-07-53-21.png">

<link rel="canonical" href="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统-并发-互斥 | 不落辰</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不落辰" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不落辰</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知不可乎骤得,托遗响于悲风</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="知不可乎骤得,托遗响于悲风">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统-并发-互斥
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-13 19:22:39" itemprop="dateCreated datePublished" datetime="2022-10-13T19:22:39+08:00">2022-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-27 23:21:31" itemprop="dateModified" datetime="2023-02-27T23:21:31+08:00">2023-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li><p>互斥困难的根本原因:load 和 store不原子</p>
</li>
<li><p>纯软件层面的互斥算法实现太复杂了，下面借助硬件提供的原子指令 实现比peterson简单的互斥协议。</p>
</li>
<li><p>硬件提供的原子指令如 : x86-64提供的lock ,xchg ; riscv提供的LR/SC(实现CAS)  </p>
</li>
<li><p>自旋锁spinlock : 基于xchg实现的spinlock 正确实现临界区互斥。</p>
<ul>
<li>spinlock 缺陷。<ul>
<li>除了进入临界区的线程，其他处理器上的线程都在空转</li>
<li>获得自旋锁的线程可能被操作系统切换出去</li>
</ul>
</li>
<li>spinlock 使用场景<ul>
<li>内核的并发数据结构</li>
</ul>
</li>
</ul>
</li>
<li><p>互斥锁mutex : 在spinlock的基础上实现mutex</p>
<ul>
<li>目的 : thread在没拿到锁时不自旋空转占用cpu，而是切换到内核并阻塞，然后内核切换到其他thread执行. 避免浪费cpu</li>
<li>由于其目的，故只能是一种syscall</li>
</ul>
</li>
<li><p>xv6 : when to lock :</p>
<ul>
<li>if (2 processes access a shared data structure &amp;&amp; at least on is writiter) , then lock the shared data structure</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h2><p>如何解决问题 -&gt; 问题的假设 -&gt; 假设的难点 -&gt; 改变假设</p>
<ul>
<li>找到你依赖的假设，并大胆的打破它</li>
<li>如何在多处理器系统上实现互斥?<ul>
<li>一开始 软件层面的 <strong>peterson算法</strong>。太难了。</li>
<li>那么 软件不够 硬件来凑（<strong>自旋锁</strong>）(利用硬件提供的原子指令实现)</li>
<li>用户不够 内核来凑（<strong>互斥锁</strong>）(为了让别的thread执行)</li>
<li>fast / slow path ：性能优化的重要途径 : futex</li>
</ul>
</li>
</ul>
<h2 id="互斥困难-根本原因"><a href="#互斥困难-根本原因" class="headerlink" title="互斥困难 根本原因"></a>互斥困难 根本原因</h2><ul>
<li><p>在共享内存上实现<strong>互斥的根本困难</strong>：<strong>不能同时读/写共享内存</strong></p>
<ul>
<li>我们看到的东西马上就过时了。不禁让人想起verilog。读的永远是上一时钟周期的值。</li>
<li><strong>load</strong> (环顾四周) 的时候<strong>不能写</strong>，只能 “看一眼就把眼睛闭上”<ul>
<li><strong>看到的东西马上就过时了</strong></li>
</ul>
</li>
<li><strong>store</strong> (改变物理世界状态) 的时候<strong>不能读</strong>，只能 “闭着眼睛动手”<ul>
<li><strong>也不知道把什么改成了什么</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>实现一个巧妙地互斥算法是很困难的。</p>
</li>
<li><p>我们在这里尽量用简单、粗暴 (稳定)、有效的方法实现互斥。</p>
</li>
<li><p>基于以上事实作为假设，我们之前实现一段临界区互斥的方法：软件层面的，如Peterson算法、deckker算法等。很困难</p>
</li>
<li><p>那么我们让硬件帮忙，更改一些假设呢？</p>
</li>
</ul>
<h2 id="硬件提供的原子操作"><a href="#硬件提供的原子操作" class="headerlink" title="硬件提供的原子操作"></a>硬件提供的原子操作</h2><ul>
<li><p>汇编中的几条指令可以使得硬件进行原子操作</p>
</li>
<li><p><strong>lock</strong></p>
<ul>
<li>原子的实现 load 和 store</li>
<li>汇编的lock前缀,是使用了在硬件层面实现的锁</li>
<li>lock是个指令前缀。处理器读到lock 先去上锁。也即，先去获得总线的锁 等到得到总线的锁之后 在执行后面的指令，执行完之后 释放总线上的锁。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lock add $1 , %0 &quot;</span>: <span class="string">&quot;+m&quot;</span>(sum))</span></span>;</span><br><span class="line">        <span class="comment">//  ++sum 需要先把sum从内存load到寄存器。然后++寄存器。然后将寄存器store到mem</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  sum = 200000000</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>汇编中的xchg</strong></p>
<ul>
<li>最小的 原子的 [load 和 store]：也就是 原子的可以先看一眼 然后改变。</li>
<li>于是，利用汇编中的xchg，实现另一个原子的将两个数值原子的交换的函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  原子的交换</span></span><br><span class="line">  <span class="comment">//  将addr地址存储的值 和 newval的值 进行原子的交换</span></span><br><span class="line">  <span class="comment">//  并返回addr原本的值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *addr,<span class="keyword">int</span> newval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;xchg %0 , %1&quot;</span> : <span class="string">&quot;+m&quot;</span>(*addr),<span class="string">&quot;=a&quot;</span>(res) : <span class="string">&quot;1&quot;</span>(newval))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>原子指令的模型</strong></p>
<ul>
<li>保证之前的store都写入内存（处理器还保证，在一个lock之前发生的所有事情，都可以在后面的lock时被看见）<ul>
<li>保证了内存的可见性。 </li>
</ul>
</li>
<li>保证load/store不与原子指令乱序（处理器保证，所有带lock的指令 都可以排出一个先后的顺序。）<ul>
<li>也因此，就是消灭了并行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用原子操作-实现-锁-基于xchg-实现-spinlock自旋锁"><a href="#使用原子操作-实现-锁-基于xchg-实现-spinlock自旋锁" class="headerlink" title="使用原子操作 实现 锁 : 基于xchg 实现 spinlock自旋锁"></a>使用原子操作 实现 锁 : <strong>基于xchg 实现 spinlock自旋锁</strong></h3><ul>
<li>如何用xchg这样的原子指令实现互斥 ? </li>
</ul>
<h4 id="实现协议"><a href="#实现协议" class="headerlink" title="实现协议"></a>实现协议</h4><ul>
<li><p>人作为thread，物理世界作为 资源： local变量、共享变量、需要互斥进入的临界区。  </p>
<h5 id="人话版"><a href="#人话版" class="headerlink" title="人话版"></a>人话版</h5></li>
<li><p>还是举例上厕所，多个同学上WC，WC上有锁，钥匙放在桌子上，每个同学手里有一个厕所正在使用的牌子。</p>
</li>
<li><p>厕所门口上放一个桌子（共享变量）</p>
<ul>
<li>初始时 ，桌子上是钥匙</li>
</ul>
</li>
<li><p><strong>在原子操作xchg的基础上，去实现一个互斥的协议</strong>。（这就比之前毫无原子操作的假设上实现的Peterson算法简单很多很多）</p>
<ul>
<li>如果同学A想上厕所。那么lock()，lock如下<ul>
<li>A闭眼睛</li>
<li>那么 将手中的 NOPE牌子 和 table上的东西（钥匙或者NOPE） 进行交换。<ul>
<li>这个交换是基于xchg的原子操作。<ul>
<li>拿走table上的东西</li>
<li>将NOPE放在桌子上</li>
</ul>
</li>
</ul>
</li>
<li>A睁眼睛<ul>
<li>如果手中拿到的是钥匙，那么可以进入厕所。</li>
<li>如果不是钥匙，那么循环上述过程</li>
</ul>
</li>
</ul>
</li>
<li>A同学出厕所。那么unlock，unlock如下。<ul>
<li>那么 将手中的 钥匙 和 table上的NOPE 进行交换。</li>
</ul>
</li>
</ul>
</li>
<li><p>人 ：thread , NOPE ： local var , 桌子 ：共享变量table , 厕所 ：临界区</p>
</li>
</ul>
<h4 id="实现code"><a href="#实现code" class="headerlink" title="实现code"></a>实现code</h4><ul>
<li>如果xchg不是原子的话，那么就可以有多个同学同时拿到table上的YES，一起进入临界区</li>
</ul>
<ul>
<li>code版<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">xchg</span>(&amp;locked,<span class="number">1</span>));    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">xchg</span>(&amp;locked,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>人话版<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于 int xchg(volatile int *addr,int newval);  //  实现见上</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOPE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YES 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> table = YES;</span><br><span class="line">由流程易知</span><br><span class="line">table 和 同学 手里 有且只有一个YES 多个NOPE</span><br><span class="line">  如果有&gt;<span class="number">1</span>个YES的话，那么就会有多个同学同时进入临界区</span><br><span class="line">  如果有<span class="number">0</span>个YES的话，那么不会有同学进入临界区</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">//  将table上的标志和我们手中的进行原子的交换(如果我们想要上厕所的话，那么手中最开始一定是个NOPE[禁] , 然后我们要去获得table上的(YES)[钥匙]，去获得进入临界区的机会[打开厕所的门])</span></span><br><span class="line"><span class="comment">//  如果此时table上是 YES [钥匙]    </span></span><br><span class="line">    <span class="comment">//  那么 xchg之后 我们拿到的就是钥匙 (因为交换的动作是原子的，所以有且只会有一个人拿到了钥匙 不存在重复拿到的情况)</span></span><br><span class="line">    <span class="comment">//  成功拿到 钥匙 ，可以打开WC。于是我们继续向下走（即进入临界区）</span></span><br><span class="line"><span class="comment">//  如果此时table上是 NOPE [禁止入内]</span></span><br><span class="line">    <span class="comment">//  那么 xchg之后 我们拿到的就是NOPE </span></span><br><span class="line">    <span class="comment">//  循环等待</span></span><br><span class="line">    <span class="keyword">int</span> got_old_table = <span class="built_in">xchg</span>(&amp;table,NOPE);</span><br><span class="line">    <span class="keyword">if</span>(got_old_table == NOPE)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(got_old_table == YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果有一个没有上锁的人 调用了unlock 那么就会导致这个临界区中可以同时出现两个user</span></span><br><span class="line"><span class="comment">//  因为table可以同时存在两个yes</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">xchg</span>(&amp;table,YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>testSpinLock<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> N = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">lock</span>();</span><br><span class="line">        ++sum;</span><br><span class="line">        <span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(testFunc)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(testFunc)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout&lt;&lt;sum&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./spinlock</span><br><span class="line"><span class="number">200000</span></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.018</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.032</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="原子操作在cpu上怎么实现"><a href="#原子操作在cpu上怎么实现" class="headerlink" title="原子操作在cpu上怎么实现"></a>原子操作在cpu上怎么实现</h2><ul>
<li>介绍下前缀lock如何保证硬件的原子操作</li>
</ul>
<h3 id="原子操作的需求"><a href="#原子操作的需求" class="headerlink" title="原子操作的需求"></a><strong>原子操作的需求</strong></h3><ul>
<li><strong>atomic test and set</strong>  原子的比较、赋值<ul>
<li>regVal = load(x) ;                //  取出regsiter x的值 </li>
<li>if(regVal == XX) {store (x,YY)}   //  如果x存的是XX，那么将YY存入x</li>
</ul>
</li>
<li><strong>lock xchg</strong>             原子的交换值<ul>
<li>reg = load(x);</li>
<li>store(x,XX);</li>
</ul>
</li>
<li><strong>lock add</strong>              原子的++<ul>
<li>t = load(x)</li>
<li>++t</li>
<li>store(x,t)</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>其本质都是</strong></p>
<ul>
<li><strong>load</strong> 从内存中加载到reg</li>
<li><strong>exec</strong> 即处理本地reg运算</li>
<li><strong>store</strong> 从reg中存到内存</li>
</ul>
</li>
<li><p>实现原子操作就是要 保证 一个内存的状态 可以由 我知道的一个状态，变成我想要他变成的一个状态。</p>
</li>
</ul>
<h3 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h3><h4 id="前缀lock的早期实现（无cache-只需要锁住主存即可）"><a href="#前缀lock的早期实现（无cache-只需要锁住主存即可）" class="headerlink" title="前缀lock的早期实现（无cache 只需要锁住主存即可）"></a>前缀lock的早期实现（无cache 只需要锁住主存即可）</h4><ul>
<li>执行时发现前缀有lock，那么先锁住内存，然后再执行后面的指令，执行完之后释放对内存的锁。<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-07-53-21.png"></li>
</ul>
<h4 id="前缀lock的现代实现（需要考虑缓存一致性）"><a href="#前缀lock的现代实现（需要考虑缓存一致性）" class="headerlink" title="前缀lock的现代实现（需要考虑缓存一致性）"></a>前缀lock的现代实现（需要考虑缓存一致性）</h4><ul>
<li><p>在 L1 cache 层保持一致性 (ring/mesh bus)</p>
<ul>
<li>相当于每个 cache line 有分别的锁</li>
<li>store(x) 进入 L1 缓存即保证对其他处理器可见<ul>
<li>但要小心 store buffer 和乱序执行</li>
</ul>
</li>
</ul>
</li>
<li><p>L1 cache line 根据状态进行协调</p>
<ul>
<li>M (Modified), 脏值</li>
<li>E ( Exclusive ), 独占访问</li>
<li>S (Shared), 只读共享</li>
<li>I (Invalid), 不拥有 cache line</li>
</ul>
</li>
</ul>
<h4 id="应用lock前缀实现上层的原子操作"><a href="#应用lock前缀实现上层的原子操作" class="headerlink" title="应用lock前缀实现上层的原子操作"></a>应用lock前缀实现上层的原子操作</h4><ul>
<li><strong>应用lock前缀实现原子的load和store</strong></li>
<li>如上的xchg函数 将（exchange操作）load和store作为打包为一个原子的指令。</li>
</ul>
<ul>
<li><strong>插一条小结</strong><ul>
<li>使用 cpu提供的原子指令 的开销就是锁总线的开销以及保持缓存一致性的开销</li>
<li>使用自旋锁的开销 既包括 原子指令的开销，又包括了空转的开销。</li>
<li>使用互斥锁的开销 就是 进入、离开kernel的开销 以及 使用原子指令的开销。</li>
<li>使用futex的开销 ：少量的进入、离开kernel的开销 以及 使用原子指令的开销。（没进入和进入都需要用原子指令）</li>
<li>所以常说的 CAS无锁无锁，这个锁到底说的是什么？<ul>
<li>是汇编层面的那个lock前缀？我之前认为是，不过现在看来显然不是，反汇编之后仍然可以看到lock</li>
<li>我现在认为应当指的是 如果不用atomic_int的话，那么对于int sum的++我们理应会使用POSIX库中的pthread_mutex_lock。这个实际上是futex锁，尽管是少量，不过也会有可能进入离开kernel。造成开销。那么如果我们直接用cpu提供的原子指令的话，就完全不必进入离开kernel，而是一直在用户态就可以。</li>
<li>所以我现在认为，所谓的”无锁无锁,<strong>无锁开销小</strong>“,指的是user无需使用os提供给user的syscall的锁接口.(如pthread_mutex_lock). , 进而<strong>无需进入和离开kernel切换上下文. 故开销小</strong>.<ul>
<li>我是这么认为的. 还没有求证. 不过感觉89不离10</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h3><ul>
<li><strong>基本思想</strong>:本地的local的计算不重要，重要的是我要写入的共享内存的状态(当我想要写入时 是否和我之前看到的一样)。本地的local的计算可以重做</li>
</ul>
<h4 id="CPU-通过-LR-and-SC-实现原子操作"><a href="#CPU-通过-LR-and-SC-实现原子操作" class="headerlink" title="CPU 通过 LR and SC 实现原子操作"></a>CPU 通过 LR and SC 实现原子操作</h4><ul>
<li><p>Load-Reserved(LR): 在内存上标记 reserved (盯上你了)，中断、其他处理器写入都会导致标记消除<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-08-55-51.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lr.w rd, (rs1) </span><br><span class="line">  含义如下</span><br><span class="line">  rd = M[rs1]</span><br><span class="line">  reserve M[rs1]</span><br></pre></td></tr></table></figure></li>
<li><p>Store-Conditional(SC): 如果我对于该内存的”盯上”(标记)未被解除，则写入;如果被解除了，那么放弃写入，丢弃本次local计算的结果，稍后重试。<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-08-56-29.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sc.w rd, rs2, (rs1)   </span><br><span class="line">  含义如下</span><br><span class="line">  <span class="keyword">if</span> still reserved:  如果内存地址rs1上存在加载保留</span><br><span class="line">    M[rs1] = rs2      写入</span><br><span class="line">    rd = <span class="number">0</span>            存入成功 向reg[rd]写入<span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    rd = nonzero      存入失败（即不存在加载保留，写入非<span class="number">0</span>的errno）</span><br></pre></td></tr></table></figure></li>
<li><p>通过LR和SC的搭配使用，可以实现对一块mem的原子的load和store</p>
</li>
</ul>
<h4 id="应用LR-SC实现原子操作-：-原子的Compare-and-Swap的LR-SC实现"><a href="#应用LR-SC实现原子操作-：-原子的Compare-and-Swap的LR-SC实现" class="headerlink" title="应用LR/SC实现原子操作 ： 原子的Compare and Swap的LR/SC实现"></a>应用LR/SC实现原子操作 ： 原子的Compare and Swap的LR/SC实现</h4><ul>
<li><p>可以看到 没有使用锁 就是先了load和store的原子操作</p>
</li>
<li><p>所谓的原子的Compare ans Swap的实现 </p>
<ul>
<li><strong>指的是在我们 [compare(load) , (exec) , swap(store)] ,mem没有被其他指令读取、改变</strong>。（也就是所谓的没被打断，原子性）</li>
</ul>
</li>
<li><p>RISC-V-Reader d的 Compare and Swap<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-09-41-43.png"></p>
</li>
</ul>
<ul>
<li><p>C</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cas</span><span class="params">(<span class="keyword">int</span> *addr, <span class="keyword">int</span> cmp_val, <span class="keyword">int</span> new_val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> old_val = *addr;</span><br><span class="line">  <span class="keyword">if</span> (old_val == cmp_val) &#123;</span><br><span class="line">    *addr = new_val; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对应的RISCV 汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cas:</span><br><span class="line">  lr.w  t0, (a0)       # Load original value.     </span><br><span class="line">    将mema0的内容加载进t0 并打上flag</span><br><span class="line">  bne   t0, a1, fail   # Doesn’t match, so fail.</span><br><span class="line">  sc.w  t0, a2, (a0)   # Try to update.           </span><br><span class="line">    尝试将a2写入mema0,</span><br><span class="line">      如果a0的flag仍存在，那么写入成功，将标志寄存器t0赋值<span class="number">0</span>代表成功   </span><br><span class="line">      如果a1的flag被改变，那么写入失败，将标志寄存器t0赋值nonzero代表写入失败</span><br><span class="line">  bnez  t0, cas        # Retry <span class="keyword">if</span> store-conditional failed.</span><br><span class="line">    t0!=<span class="number">0</span> 代表store失败（失败的根本原因是因为不能和load形成原子的操作 从头load开始重新尝试。）</span><br><span class="line">  li a0, <span class="number">0</span>             # Set <span class="keyword">return</span> to success.</span><br><span class="line">  jr ra                # Return.</span><br><span class="line">fail:</span><br><span class="line">  li a0, <span class="number">1</span>             # Set <span class="keyword">return</span> to failure.</span><br><span class="line">  jr ra                # Return</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="spinlock缺陷-性能问题"><a href="#spinlock缺陷-性能问题" class="headerlink" title="spinlock缺陷 性能问题"></a>spinlock缺陷 性能问题</h2><ul>
<li><p><strong>性能问题 1</strong></p>
<ul>
<li>自旋 (共享变量) 会触发处理器间的<strong>缓存同步</strong>，延迟增加</li>
</ul>
</li>
<li><p><strong>性能问题 2</strong></p>
<ul>
<li>除了进入临界区的线程，其他处理器上的<strong>线程都在空转</strong></li>
<li>争抢锁的处理器<strong>越多</strong>，<strong>cpu利用率越低</strong><ul>
<li>一核处理（进入临界区的thread的核），多核围观。（其他所有没进入临界区的thread）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>性能问题 3</strong> （比 12都严重）</p>
<ul>
<li>获得自旋锁的线程可能被操作系统<strong>切换出去</strong><ul>
<li>那么，这个拿到了spinlock的进入临界区的thread在睡觉，其他没拿到spinlock的thread在空转，并且等待一个 较长时间之后才会释放的锁。（因为拿到锁的thread在睡觉）</li>
<li>那么，0核处理，1核睡觉，多核围观。</li>
<li><strong>实现 100% 的资源浪费</strong></li>
<li>操作系统不 “感知” 线程在做什么</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>由于以上三点，同样的工作，线程数量越多，执行时间越长。对于spinlock尤其明显<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">1</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.135</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.132</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">2</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.825</span>s</span><br><span class="line">user    <span class="number">0</span>m1<span class="number">.641</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">3</span></span><br><span class="line">sum = <span class="number">9999999</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m1<span class="number">.162</span>s</span><br><span class="line">user    <span class="number">0</span>m3<span class="number">.445</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">4</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m1<span class="number">.688</span>s</span><br><span class="line">user    <span class="number">0</span>m6<span class="number">.670</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock$ time ./sum-scalability <span class="number">5</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m2<span class="number">.493</span>s</span><br><span class="line">user    <span class="number">0</span>m12<span class="number">.278</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>对于futex（因为无法获取锁时会阻塞,调度到其他进程而非空转），时间不会随着thread数增大而极度增大<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">1</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.154</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.145</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.000</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">2</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.786</span>s</span><br><span class="line">user    <span class="number">0</span>m0<span class="number">.993</span>s</span><br><span class="line">sys     <span class="number">0</span>m0<span class="number">.564</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">7</span></span><br><span class="line">sum = <span class="number">9999997</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.921</span>s</span><br><span class="line">user    <span class="number">0</span>m1<span class="number">.499</span>s</span><br><span class="line">sys     <span class="number">0</span>m4<span class="number">.003</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">15</span></span><br><span class="line">sum = <span class="number">9999990</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m1<span class="number">.002</span>s</span><br><span class="line">user    <span class="number">0</span>m1<span class="number">.685</span>s</span><br><span class="line">sys     <span class="number">0</span>m9<span class="number">.346</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ time ./sum-scalability2 <span class="number">32</span></span><br><span class="line">sum = <span class="number">10000000</span></span><br><span class="line"></span><br><span class="line">real    <span class="number">0</span>m0<span class="number">.916</span>s</span><br><span class="line">user    <span class="number">0</span>m1<span class="number">.134</span>s</span><br><span class="line">sys     <span class="number">0</span>m9<span class="number">.653</span>s</span><br><span class="line">shc@DESKTOP-TVUERHD:~/Code/<span class="keyword">try</span>/lock/jyy$ </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Scalability-性能的新维度"><a href="#Scalability-性能的新维度" class="headerlink" title="Scalability : 性能的新维度"></a>Scalability : 性能的新维度</h3><ul>
<li>同一份计算任务，时间 (CPU cycles) 和空间 ( mapped memory) 会随处理器数量的增长而变化<br><img src="/2022/10/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9102-%E4%BA%92%E6%96%A5-%E9%94%81/2022-10-14-13-32-27.png"></li>
</ul>
<h2 id="spinlock的使用场景"><a href="#spinlock的使用场景" class="headerlink" title="spinlock的使用场景"></a>spinlock的使用场景</h2><ul>
<li><p><strong>临界区几乎不拥堵</strong></p>
<ul>
<li>几乎不会发生锁的争抢。</li>
<li>比如说 queue作为临界区，threadpool从queue中取任务。取一个任务用100ns，执行一个任务用100ms，不频繁的取队列，锁也就不会争抢，因此可以用spinlock</li>
</ul>
</li>
<li><p><strong>持有自旋锁时禁止执行流切换</strong></p>
<ul>
<li>但是，这对机器很危险。应用程序也不会有这个权限。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>真正使用场景：操作系统内核的并发数据结构（短临界区）</strong></li>
</ul>
<p>操作系统可以关闭中断和抢占</p>
<ul>
<li>spinlock的如何使用好是一个很困难的问题。（以前甚至可以发paper）</li>
</ul>
<h2 id="mutex-互斥锁-os实现的系统调用"><a href="#mutex-互斥锁-os实现的系统调用" class="headerlink" title="mutex 互斥锁(os实现的系统调用)"></a>mutex 互斥锁(os实现的系统调用)</h2><h3 id="为什么要有互斥锁"><a href="#为什么要有互斥锁" class="headerlink" title="为什么要有互斥锁"></a>为什么要有互斥锁</h3><ul>
<li><p>如果希望实现一个很长的临界区，比如要我在写一个文件的时候，不希望别的thread写。</p>
</li>
<li><p>又或者如果我想做一件事情，但是现在做不了，需要等待一个长临界区。我们让另一个任务开始执行。</p>
</li>
<li><p>所以，对于<strong>让</strong>这个动作。<strong>让</strong>别的thread执行。在<strong>用户态</strong>用C语言是<strong>无法实现</strong>的，<strong>因此，操作系统应当实现这个系统调用。</strong></p>
</li>
<li><p>把锁的实现放到操作系统里就好啦！</p>
<ul>
<li>syscall(SYSCALL_lock, &amp;lk);<ul>
<li>syscall 进入kernel，关中断，然后进行xchg锁</li>
<li>试图获得 锁，<ul>
<li>如果<strong>成功上锁</strong>，</li>
<li>但如果<strong>失败，就切换到其他</strong>线程。（切换到其他线程，即让别的thread执行，这个动作只能由os做，user是做不到的）</li>
</ul>
</li>
</ul>
</li>
<li>syscall(SYSCALL_unlock, &amp;lk);<ul>
<li>释放 锁，如果有等待锁的线程就唤醒</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="互斥锁实现思路"><a href="#互斥锁实现思路" class="headerlink" title="互斥锁实现思路"></a>互斥锁实现思路</h3><p>初始lock = unlocked<br>临界区 = 更衣室<br>os = 更衣室管理员<br>thread = 要进去的人</p>
<ul>
<li><p>先到的人 thread</p>
<ul>
<li>成功获得手环，进入更衣室</li>
<li>lock 状态 变为 locked</li>
</ul>
</li>
<li><p>后到的人 thread</p>
<ul>
<li>不能进入更衣室，排队等待</li>
<li>这个后到的thread放入等待队列 执行thread切换（yield）</li>
</ul>
</li>
<li><p>洗完澡出来的人 thread</p>
<ul>
<li>交还手环给管理员；</li>
<li>管理员把手环再交给排队的人<ul>
<li>如果waiting thread queue is not empty，从queue中取出一个thread允许执行</li>
<li>如果waiting thread queue is empty，lock置为 unlocked</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>管理员OS通过使用spin lock来确保 自己处理手环的过程是原子的</strong>。</p>
<ul>
<li>所以，我们站在用户层面看的时候，就可以看到，<strong>锁的获取</strong>（load看一眼有没有，有的话就拿store；）；和<strong>锁的释放</strong>是<strong>原子的</strong>。</li>
<li>到最底层都是用了cpu提供的原子指令如 xchg</li>
<li>我们就是利用的获得释放锁的原子性，来提供临界区互斥（只允许有n个thread）的功能。</li>
</ul>
</li>
</ul>
<h2 id="关于-spinlock-和-睡眠锁-的快慢分析"><a href="#关于-spinlock-和-睡眠锁-的快慢分析" class="headerlink" title="关于 spinlock 和 睡眠锁 的快慢分析"></a>关于 spinlock 和 睡眠锁 的快慢分析</h2><ul>
<li><strong>自旋锁（thread直接共享locked）</strong><ul>
<li>更快的fast path<ul>
<li>xchg成功 -&gt; 立即进入临界区，开销很小</li>
</ul>
</li>
<li>更慢的slow path<ul>
<li>xchg失败 -&gt; 浪费CPU自选等待</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>睡眠锁（就是上文中的互斥锁，mutex）</strong> (通过系统调用访问 locked)<ul>
<li>更慢的 fast path<ul>
<li>即便上锁成功也需要进出内核 (syscall)</li>
</ul>
</li>
<li>更快的 slow path<ul>
<li>上锁失败线程不再占用 CPU</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>今天OS上的锁如何实现</li>
<li>小孩子才做选择。我当然是全都要啦！</li>
</ul>
<h2 id="Futex-Fast-Userspace-Mutexes"><a href="#Futex-Fast-Userspace-Mutexes" class="headerlink" title="Futex: Fast Userspace Mutexes"></a>Futex: Fast Userspace Mutexes</h2><ul>
<li><p><strong>Fast path: 一条原子指令，上锁成功立即返回。无需进入kernel</strong></p>
</li>
<li><p><strong>Slow path: 上锁失败，执行系统调用睡眠。需要进入kenrel（系统调用）</strong></p>
<ul>
<li>性能优化的最常见技巧<ul>
<li>看 average (frequent) case 而不是 worst case</li>
</ul>
</li>
<li>绝大多数的时候 都上锁成功 没进入kernel</li>
</ul>
</li>
<li><p>POSIX 线程库中的互斥锁 (pthread_mutex)</p>
<ul>
<li>futuex调用的数量远远小于lock和unlock的数量</li>
</ul>
</li>
<li><p>线程库中的锁，在绝大多数情况下都不会触发系统调用，直接用原子指令就解决了。只有在少部分情况下，有争抢的情况下，才会触发系统调用。</p>
</li>
<li><p>所以目前我认为 ：futex的好处就是尽量少的触发系统调用？绝大部分情况都不进入内核</p>
</li>
</ul>
<hr>
<h2 id="XV6-6-S801"><a href="#XV6-6-S801" class="headerlink" title="XV6 6.S801"></a>XV6 6.S801</h2><h3 id="When-to-lock"><a href="#When-to-lock" class="headerlink" title="When to lock"></a><strong>When to lock</strong></h3><ul>
<li><strong>Constructive rule:</strong><ul>
<li>if (2 processes access a shared data structure &amp;&amp; at least on is writiter) -&gt;</li>
<li>lock data structure </li>
<li><strong>too strict</strong>,相较于lock free programming。但是用锁来实现共享已经足够难了。</li>
</ul>
</li>
</ul>
<h3 id="Perspective"><a href="#Perspective" class="headerlink" title="Perspective"></a>Perspective</h3><ul>
<li><strong>Lock perspective</strong><ul>
<li>lock help avoid last update<ul>
<li>防止更新的数据/页/节点被覆盖/丢失。</li>
<li>如防止 list = l 被覆盖</li>
</ul>
</li>
<li>lock help amke multi-step to be atomic<ul>
<li>使得多步操作原子。</li>
<li>如 l-&gt; next 和 liast = l原子。 </li>
</ul>
</li>
<li>lock help maintain 不变量<ul>
<li>保持list是指向链表首元素的属性。</li>
<li>不变量是跨操作维护的数据结构的属性。通常，操作的正确行为取决于操作开始时不变量是否为真。操作可能暂时违反不变量，但必须在完成之前重新建立它们。例如，在链表的例子中，不变量是list指向列表中的第一个元素，以及每个元素的next字段指向下一个元素。push的实现暂时违反了这个不变量：在第17行，l-&gt;next指向list（注：则此时list不再指向列表中的第一个元素，即违反了不变量），但是list还没有指向l（在第18行重新建立）。我们上面检查的竞态条件发生了，因为第二个CPU执行了依赖于列表不变量的代码，而这些代码（暂时）被违反了。正确使用锁可以确保每次只有一个CPU可以对临界区域中的数据结构进行操作，因此当数据结构的不变量不成立时，将没有其他CPU对数据结构执行操作。</li>
</ul>
</li>
</ul>
</li>
<li>list例子<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">list</span> =</span> <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lock</span> <span class="title">listlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">l</span>;</span></span><br><span class="line"></span><br><span class="line">    l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">    l-&gt;data = data;</span><br><span class="line">    acquire(&amp;listlock);</span><br><span class="line">    l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span> = l; </span><br><span class="line">    release(&amp;listlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>如何lock并且尽量做到较好的performance性能<ul>
<li>need to split up data structure</li>
<li>best split is a challenge</li>
<li>方法<ul>
<li>start with 粗粒度的lock</li>
<li>measure performance，是否出现争用</li>
<li>重新设计</li>
<li>是否值得更细粒度，因为越细逻辑越复杂。可能不值得</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul>
<li>人们很自然地会想到程序是按照源代码语句出现的顺序执行的。然而，许多编译器和中央处理器为了获得更高的性能而不按顺序执行代码。如果一条指令需要许多周期才能完成，中央处理器可能会提前发出指令，这样它就可以与其他指令重叠，避免中央处理器停顿。例如，中央处理器可能会注意到在顺序指令序列A和B中彼此不存在依赖。CPU也许首先启动指令B，或者是因为它的输入先于A的输入准备就绪，或者是为了重叠执行A和B。编译器可以执行类似的重新排序，方法是在源代码中一条语句的指令发出之前，先发出另一条语句的指令。</li>
<li>编译器和CPU在重新排序时需要遵循一定规则，以确保它们不会改变正确编写的串行代码的结果。然而，规则确实允许重新排序后改变并发代码的结果，并且很容易导致多处理器上的不正确行为。CPU的排序规则称为内存模型（memory model）。</li>
<li>例如，在push的代码中，如果编译器或CPU将对应于第4行的存储指令移动到第6行release后的某个地方，那将是一场灾难：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *l);</span><br><span class="line">l-&gt;data = data;</span><br><span class="line">acquire(&amp;listlock);</span><br><span class="line">l-&gt;next = <span class="built_in">list</span>;</span><br><span class="line"><span class="built_in">list</span> = l;</span><br><span class="line">release(&amp;listlock);</span><br></pre></td></tr></table></figure></li>
<li>如果发生这样的重新排序，将会有一个窗口期，另一个CPU可以获取锁并查看更新后的list，但却看到一个未初始化的list-&gt;next。</li>
<li>为了告诉硬件和编译器不要执行这样的重新排序，xv6在acquire(kernel/spinlock.c:22) 和release(kernel/spinlock.c:47)中都使用了__sync_synchronize()。__sync_synchronize()是一个内存障碍：它告诉编译器和CPU不要跨障碍重新排序load或store指令。因为xv6在访问共享数据时使用了锁，xv6的acquire和release中的障碍在几乎所有重要的情况下都会强制顺序执行。第9章讨论了一些例外。</li>
</ul>
<h3 id="Wrap-Up"><a href="#Wrap-Up" class="headerlink" title="Wrap Up"></a>Wrap Up</h3><ul>
<li>locks good for correctness , can be bad  for perf</li>
<li>locks complicate programming</li>
<li>don’t share data structre if you don’t have to</li>
<li>start with 粗粒度锁 , 在需要时转向细粒度锁</li>
<li>使用工具 检测性能和 race</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_concurrency.html">https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_concurrency.html</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/12/muduo-%E5%85%B3%E4%BA%8EEventLoop%E7%9A%84runInLoop%E4%B8%8EqueueInLoop/" rel="prev" title="muduo-关于EventLoop的runInLoop与queueInLoop">
      <i class="fa fa-chevron-left"></i> muduo-关于EventLoop的runInLoop与queueInLoop
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E5%B9%B6%E5%8F%9103-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6/" rel="next" title="操作系统-并发03-同步控制">
      操作系统-并发03-同步控制 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">如何解决问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E5%9B%B0%E9%9A%BE-%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0"><span class="nav-number">2.</span> <span class="nav-text">互斥困难 根本原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">硬件提供的原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-%E5%AE%9E%E7%8E%B0-%E9%94%81-%E5%9F%BA%E4%BA%8Exchg-%E5%AE%9E%E7%8E%B0-spinlock%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">3.1.</span> <span class="nav-text">使用原子操作 实现 锁 : 基于xchg 实现 spinlock自旋锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.1.</span> <span class="nav-text">实现协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%BA%E8%AF%9D%E7%89%88"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">人话版</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0code"><span class="nav-number">3.1.2.</span> <span class="nav-text">实现code</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%9C%A8cpu%E4%B8%8A%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">原子操作在cpu上怎么实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E9%9C%80%E6%B1%82"><span class="nav-number">4.1.</span> <span class="nav-text">原子操作的需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-64"><span class="nav-number">4.2.</span> <span class="nav-text">x86-64</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80lock%E7%9A%84%E6%97%A9%E6%9C%9F%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%97%A0cache-%E5%8F%AA%E9%9C%80%E8%A6%81%E9%94%81%E4%BD%8F%E4%B8%BB%E5%AD%98%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="nav-number">4.2.1.</span> <span class="nav-text">前缀lock的早期实现（无cache 只需要锁住主存即可）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80lock%E7%9A%84%E7%8E%B0%E4%BB%A3%E5%AE%9E%E7%8E%B0%EF%BC%88%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89"><span class="nav-number">4.2.2.</span> <span class="nav-text">前缀lock的现代实现（需要考虑缓存一致性）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8lock%E5%89%8D%E7%BC%80%E5%AE%9E%E7%8E%B0%E4%B8%8A%E5%B1%82%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">4.2.3.</span> <span class="nav-text">应用lock前缀实现上层的原子操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RISC-V"><span class="nav-number">4.3.</span> <span class="nav-text">RISC-V</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU-%E9%80%9A%E8%BF%87-LR-and-SC-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">4.3.1.</span> <span class="nav-text">CPU 通过 LR and SC 实现原子操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8LR-SC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-%EF%BC%9A-%E5%8E%9F%E5%AD%90%E7%9A%84Compare-and-Swap%E7%9A%84LR-SC%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.3.2.</span> <span class="nav-text">应用LR&#x2F;SC实现原子操作 ： 原子的Compare and Swap的LR&#x2F;SC实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spinlock%E7%BC%BA%E9%99%B7-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">spinlock缺陷 性能问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scalability-%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B0%E7%BB%B4%E5%BA%A6"><span class="nav-number">5.1.</span> <span class="nav-text">Scalability : 性能的新维度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#spinlock%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.</span> <span class="nav-text">spinlock的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mutex-%E4%BA%92%E6%96%A5%E9%94%81-os%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">mutex 互斥锁(os实现的系统调用)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">7.1.</span> <span class="nav-text">为什么要有互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">7.2.</span> <span class="nav-text">互斥锁实现思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-spinlock-%E5%92%8C-%E7%9D%A1%E7%9C%A0%E9%94%81-%E7%9A%84%E5%BF%AB%E6%85%A2%E5%88%86%E6%9E%90"><span class="nav-number">8.</span> <span class="nav-text">关于 spinlock 和 睡眠锁 的快慢分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Futex-Fast-Userspace-Mutexes"><span class="nav-number">9.</span> <span class="nav-text">Futex: Fast Userspace Mutexes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XV6-6-S801"><span class="nav-number">10.</span> <span class="nav-text">XV6 6.S801</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#When-to-lock"><span class="nav-number">10.1.</span> <span class="nav-text">When to lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perspective"><span class="nav-number">10.2.</span> <span class="nav-text">Perspective</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="nav-number">10.3.</span> <span class="nav-text">指令重排</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Wrap-Up"><span class="nav-number">10.4.</span> <span class="nav-text">Wrap Up</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cstardust</p>
  <div class="site-description" itemprop="description">知不可乎骤得,托遗响于悲风</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cstardust</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">656k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:56</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'd683461326668b112a07',
      clientSecret: 'fbd3f91ac2d4f7b501c4b5f88af770661529c238',
      repo        : 'BlogComments',
      owner       : 'Cstardust',
      admin       : ['Cstardust'],
      id          : '95faadd398a2955b76f8c4361a5a8629',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
