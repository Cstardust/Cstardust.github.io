<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);  本实验实现了简易的mmap syscall(阉割版). 实现所谓的将”文件映射到内存”  对比  现代OSmmap : disk -&gt; kernel buf. user va映射到kernel bu 实现的xv6mmap :">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-xv6-lab10-mmap">
<meta property="og:url" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/index.html">
<meta property="og:site_name" content="不落辰">
<meta property="og:description" content="void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);  本实验实现了简易的mmap syscall(阉割版). 实现所谓的将”文件映射到内存”  对比  现代OSmmap : disk -&gt; kernel buf. user va映射到kernel bu 实现的xv6mmap :">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-11-18-58.png">
<meta property="og:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-30-06.png">
<meta property="og:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-16-53-57.png">
<meta property="og:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-05-03.png">
<meta property="og:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-23-48.png">
<meta property="og:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-26-34.png">
<meta property="og:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-19-04-30.png">
<meta property="og:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-19-12-58.png">
<meta property="article:published_time" content="2022-12-13T10:49:08.000Z">
<meta property="article:modified_time" content="2023-02-28T14:39:17.682Z">
<meta property="article:author" content="Cstardust">
<meta property="article:tag" content="xv6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-11-18-58.png">

<link rel="canonical" href="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统-xv6-lab10-mmap | 不落辰</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不落辰" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">不落辰</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">知不可乎骤得,托遗响于悲风</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cstardust">
      <meta itemprop="description" content="知不可乎骤得,托遗响于悲风">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不落辰">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统-xv6-lab10-mmap
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-13 18:49:08" itemprop="dateCreated datePublished" datetime="2022-12-13T18:49:08+08:00">2022-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-28 22:39:17" itemprop="dateModified" datetime="2023-02-28T22:39:17+08:00">2023-02-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xv6/" itemprop="url" rel="index"><span itemprop="name">xv6</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li><p>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</p>
</li>
<li><p>本实验实现了简易的mmap syscall(阉割版). 实现所谓的将”文件映射到内存”</p>
</li>
<li><p>对比</p>
<ul>
<li>现代OSmmap : disk -&gt; kernel buf. user va映射到kernel bu</li>
<li>实现的xv6mmap : disk -&gt; kernel buf -&gt; user physical mem. user va映射到 physical mem<ul>
<li>且没有实现MAP_PRIVATE,MAP_SHARED时的共享mem,也没实现MAP_PRIVATE的cow</li>
</ul>
</li>
</ul>
</li>
<li><p>实现关键 : lazy allocation</p>
<ul>
<li>mmap 先获取一块vma区域 但并不建立映射, 仅仅设定这块va合法 ; 当发生pgfault的时候，再读取文件相应内容 , 为va建立映射 , 然后返回.</li>
<li>munmap 就是解除vma内建立了映射的va</li>
</ul>
</li>
<li><p>mmap优势</p>
<ul>
<li>效率高，高于普通的read file<ul>
<li>比起read少一次拷贝. 映射到kenerl buf</li>
<li>减少陷入内核次数，减少上下文切换开销.(read每次都陷入)</li>
<li>lazy allocation(不必一次全部读入)</li>
</ul>
</li>
<li>更加方便user读写文件<ul>
<li>这也就是mmap所谓的 “映射文件到用户进程”。</li>
<li>user调用mmap之后 , 可以将对内存的读写看成对文件的读写,如何加载数据,如何落入磁盘 等都不需要user管.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>prot : 对内存权限 ; flags : 对file权限。 二者不可冲突</p>
<span id="more"></span>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在xv6中实现 mmap munmap<br>mmap：将用户的虚拟地址(user virtual address)映射到内核占有的物理内存。其中物理内存中保存的是自file中读出的数据。<br>munmap：解除映射。</p>
<ul>
<li><strong>vma</strong> : 约定将 vma 称为 user通过mmap建立映射时，被kernel选择的<strong>用户的虚拟地址</strong>范围的那一块区域的虚拟内存<ul>
<li>vma也即映射到的虚拟内存。也即mapping memory。</li>
</ul>
</li>
<li>将 mmap将vma映射到的真实的物理地址范围的物理内存（其中有file的数据） 称为 <strong>目标物理内存</strong></li>
</ul>
<ul>
<li><p><strong>API含义</strong></p>
</li>
<li><p><code>**void \*mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);***</code></p>
<ul>
<li><strong>addr</strong> : 0<ul>
<li>kernel替user选择，将user的哪部分虚拟地址范围作为映射区域。</li>
</ul>
</li>
<li><strong>length</strong> : vma区域的大小</li>
<li><strong>prot 对于内存权限</strong> : <ul>
<li>user关于vma虚拟内存区域/映射到的物理内存（一样，反正对vma读写就是在对physical mem读写）的权限，不可以和file的打开模式冲突。</li>
<li>The prot argument describes the desired memory protection of the mapping (and must not conflict with the open mode of the file).</li>
<li><strong>PROT_READ</strong><ul>
<li>Pages may be read。vma的每页可以读。</li>
</ul>
</li>
<li><strong>PROT_WRITE</strong> <ul>
<li>Pages may be written。vma的每页可以写。</li>
</ul>
</li>
<li><strong>PROT_EXEC</strong>  <ul>
<li>Pages may be executed。vma的每页可执行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>flags 对于file的权限(写回标志) + process之间是否共享physical mem</strong><ul>
<li><strong>MAP_SHARED</strong><ul>
<li>Share this mapping.  Updates to the mapping are visible to other processes mapping the same region, and (in the case of  file-backed  mappings) are carried through to the underlying file.</li>
<li> 共享mapping。</li>
<li> <strong>1.</strong> 也即，当file相同时，不同process将各自的vma映射到同一块目标physical memory。一个process对vma进行修改（也即对vma映射到的physical memory修改），其他process都可以看到。（因为映射到的是同一physical mempry）</li>
<li> <strong>2.</strong> 且，当munmap解除vma到dram的映射时，会将physical memory的修改（通过dirty bit判断）写回disk上的file。</li>
<li> <strong>lab实现区别</strong>：对于MAP_SHARED , 本lab只实现了2，1的话lab没做要求。（对于MAP_SHARED，正常来讲，第一个process会lazy allocation分配vma映射到的physicalmem，其余process会直接指向该块physicalmem。然而本lab中实现的仅仅是每个process都lazy allocation一块physical mem）也即，本实验只是实现了将vma映射到的physical mem写回disk。</li>
</ul>
</li>
<li><strong>MAP_PRIVATE</strong><ul>
<li>Create a private copy-on-write mapping.  Updates to the mapping are not visible to other processes mapping the same file, and are not carried  through  to the underlying file.  </li>
<li>创建一个写时复制的映射。 </li>
<li>我理解的是：<ul>
<li><ol>
<li>当file相同时，第一个process会为vma进行lazy allocation一块phyiscal mem，其余的process再使用他们自己的vma时，先映射到第一个process lazy alloc的pm，然后当某个process发生写动作时，该process再进行copy on write。</li>
</ol>
</li>
<li><ol start="2">
<li>对于file加载进的physical mem的修改，在munmap解除映射时，不会落入disk。</li>
</ol>
</li>
</ul>
</li>
<li><strong>lab实现区别</strong>：然而本lab实现的，并没有实现copy on write，仅仅实现了对于每个process，当其要使用vma的某一page时，都要进行lazy allocation。也即每个process即使在读vma时，其映射到的physical mem也是各自独享的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>int munmap(void *addr, size_t length);</strong></p>
<ul>
<li>The munmap()  system  call  deletes the mappings for the specified address range, and causes further references to addresses within the range to generate invalid memory references.  The region is also automatically unmapped when the process is terminated.  On the other  hand,  closing  the file descriptor does not unmap the region.</li>
<li>解除从vma到physical mem的映射。后续process的vma变成无效的虚拟地址；</li>
<li>当进程exit时，vma区域会自动解除映射；</li>
<li>user close(fd)不会导致vma映射解除，也不会导致lazy allocation失败。<ul>
<li>After the mmap() call has returned, the file descriptor, fd, can be closed  immediately  without  invalidating the mapping</li>
<li>即当mmap返回后 关闭fd文件 映射依然有效。</li>
<li>因为mmap时会自动将struct file的引用计数++，防止被从ftable中替换走；知道munmap时，才会–struct file</li>
</ul>
</li>
</ul>
</li>
<li><p>例子</p>
<ul>
<li>char *p = mmap(0, PGSIZE*2, PROT_READ, MAP_PRIVATE, fd, 0);<ul>
<li>0: kernel choose the virtual address。内核选择负责映射到的用户虚拟地址</li>
<li>PGSIZE*2 : 映射多少bytes内存</li>
<li>PROT_READ : the mapped memory is read-only。用户对这段用户虚拟地址只能读、不能写</li>
<li>MAP_PRIVATE : <ul>
<li>如果进程修改了这段映射的内存，修改的内容不会被写回文件、也不会与其他映射同一文件的进程共享。</li>
</ul>
</li>
<li>fd :file</li>
<li>0 : offset</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>mmap核心思想：</strong>（我感觉）<br>在user的va中划出一片区域，将文件内容映射其中。让user可以像操作内存数据一样，操作文件数据。也即使得user访问其virtual address就是在访问文件<br>更加方便user读写文件。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我所做的工作如下</p>
<h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><ul>
<li><p>设计：将user process的最上方的可用虚拟地址，作为vma。也即自TRAPFRAME向下，选取虚拟内存区域作为vma。</p>
<ul>
<li><blockquote>
<p><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-11-18-58.png">    </p>
</blockquote>
</li>
</ul>
</li>
<li><p>struct <strong>vma</strong> : process用作映射到physical mem的virtual mem区域。(physical mem中是file的内容)，然后为proc结构体添加vma数组。</p>
<ul>
<li>是否有效、映射文件、映射范围、对mem(物理/虚拟一样，一个效果)的权限PROT、对file的权限(写回标志)、映射file的起始偏移量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NVMA 16</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> valid;      <span class="comment">//  是否有效</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span> <span class="comment">//  映射的文件</span></span><br><span class="line">    uint64 start;   <span class="comment">//  user该段映射的起始虚拟地址  根据上一次映射的最低地址和本次的sz来确定。PGSIZE对齐</span></span><br><span class="line">    uint64 sz;      <span class="comment">//  PGSIZE对齐。[start , end = start + sz - 1]</span></span><br><span class="line">    uint64 left;    <span class="comment">//  vma中剩余的还没被释放的bytes数量</span></span><br><span class="line">    <span class="keyword">int</span> prot;    <span class="comment">//  权限: 对mem的权限。PROT_READ PROT_WRITE</span></span><br><span class="line">    <span class="keyword">int</span> flag;    <span class="comment">//  权限: 对file的权限。MAP_PRIVATE MAP_SHARED 是否写回文件。是否和其他process共享physical mem</span></span><br><span class="line">    uint64 offset;  <span class="comment">//  映射文件的起始偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>实现 系统调用mmap</strong></p>
<ul>
<li><strong>思想</strong>：和之前的lazy allocation lab相同，分为两步<ul>
<li><strong>1. sys_mmap 将vma的这段虚拟地址标记为合法，但未建立映射</strong></li>
<li><strong>2. pgfault handler : lazy allocation。然后当user process使用该段虚拟地址、进而触发pagefault时，对其进行lazy allocation</strong>。<ul>
<li>与lazyalloc lab不同的是<ul>
<li>这里只需要考虑user使用未建立映射的user va</li>
<li>而不需要考虑kenrel使用未建立映射的user va</li>
<li>因为只有user会调用mmap</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>实现sys_mmap</strong></p>
<ul>
<li>取user传参</li>
<li>判定prot、flag 和 file 权限是否矛盾</li>
<li><strong>寻找free的vma槽 并 计算 vma的start，end。</strong></li>
<li><strong>初始化vma</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_mmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//  1. 取user传参</span></span><br><span class="line">    argaddr(<span class="number">0</span>,&amp;addr); argaddr(<span class="number">1</span>,&amp;sz); argint(<span class="number">2</span>,&amp;prot); </span><br><span class="line">    argint(<span class="number">3</span>,&amp;flag); argint(<span class="number">4</span>,&amp;fd); argaddr(<span class="number">5</span>,&amp;offset);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">//  获取fd的file</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 判定prot、flag 和 file 权限是否矛盾</span></span><br><span class="line">        <span class="comment">//  file不可读 user要求可读</span></span><br><span class="line">    <span class="keyword">if</span>( (!f-&gt;readable) &amp;&amp; (prot &amp; PROT_READ) ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file can not read but you want to read\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//  file不可写 user要求写file</span></span><br><span class="line">        <span class="comment">//  f-&gt;writable : file可写</span></span><br><span class="line">        <span class="comment">//  PROT_WRITE : user要求写映射内存</span></span><br><span class="line">        <span class="comment">//  flag : user要求将写的内容落入磁盘</span></span><br><span class="line">    <span class="keyword">if</span>( (!f-&gt;writable) &amp;&amp; ((prot &amp; PROT_WRITE) &amp;&amp; (flag &amp; MAP_SHARED)) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file can not write but you want to write\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. 寻找free的vma槽 并 计算 vma的start，end。</span></span><br><span class="line">    sz = PGROUNDUP(sz);     <span class="comment">//  sz对PGSIZE对齐</span></span><br><span class="line">    uint64 mapuplimit = TRAPFRAME;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NVMA ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;vmas[i].valid == <span class="number">0</span> &amp;&amp; !found)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;vmas[i].valid = <span class="number">1</span>;</span><br><span class="line">            idx = i;</span><br><span class="line">            found = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  找到proc中最低的 可以提供给 mmap的 end虚拟地址</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;vmas[i].valid == <span class="number">1</span> &amp;&amp; mapuplimit &gt; p-&gt;vmas[i].start)</span><br><span class="line">        &#123;</span><br><span class="line">            mapuplimit = p-&gt;vmas[i].start;  <span class="comment">//  一定是对PGSIZE对齐的。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4. 初始化vma</span></span><br><span class="line">    p-&gt;vmas[idx].f = f;</span><br><span class="line">    p-&gt;vmas[idx].sz = sz;</span><br><span class="line">    p-&gt;vmas[idx].left = sz;</span><br><span class="line">    p-&gt;vmas[idx].start = PGROUNDDOWN(mapuplimit - sz);  <span class="comment">//  start一定是PGSIZE对齐的 sz可能不是</span></span><br><span class="line">    p-&gt;vmas[idx].prot = prot;</span><br><span class="line">    p-&gt;vmas[idx].flag = flag;</span><br><span class="line">    p-&gt;vmas[idx].offset = offset;  </span><br><span class="line">    filedup(f);     <span class="comment">//  ++ref</span></span><br><span class="line">    <span class="comment">//  增加struct file 引用计数</span></span><br><span class="line">    <span class="comment">//  这样即使user关闭了文件，struct file也至少有一个引用计数由mmap的vma管理，防止struct file在ftable中被替换掉</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p-&gt;vmas[idx].start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>pagefault handler : lazy allocation</strong></p>
<ul>
<li>trap : 自不必说，判断是否落入vma区域<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">15</span> || r_scause() == <span class="number">13</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pagefault %p cause %d\n&quot;</span>,r_stval(),r_scause());</span><br><span class="line">    uint64 pgault_va = r_stval();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma</span> *<span class="title">vma</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//  判断是否是被映射的地址范围 若是则获取相应vma</span></span><br><span class="line">    <span class="keyword">if</span>(!validMmap(pgault_va,&amp;vma))   </span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        uvmlazyMmap(vma,pgault_va);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>void uvmlazyMmap(struct vma* vma,uint64 pgault_va)</strong></p>
<ul>
<li>一言以蔽之：<ul>
<li><strong>为user process的pgfault_va所在的page进行lazyallocation（也即为va所在的虚拟页建立相应映射、映射到相应的物理页）。并且将file（由vma可知）的相应字节内容读入physical page</strong>。</li>
</ul>
</li>
<li><ol>
<li>分配要vma映射到的physical page</li>
</ol>
</li>
<li><ol start="2">
<li> 从disk读取data到pa 注意计算file读取的起始字节</li>
</ol>
</li>
<li><ol start="3">
<li> prot权限 – pte权限</li>
</ol>
</li>
<li><ol start="4">
<li> 建立映射 : (va所在virtual page)  —&gt; (physical page)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  每次处理一页</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uvmlazyMmap</span><span class="params">(struct vma* vma,uint64 pgault_va)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">//  1. 分配要vma映射到的physical mem</span></span><br><span class="line">    uint64 pa = (uint64)kalloc();</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">void</span>*)pa,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line">    uint64 va = PGROUNDDOWN(pgault_va);     <span class="comment">//  va对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2.  从disk读取data到pa 注意计算file读取的起始字节</span></span><br><span class="line">    begin_op();</span><br><span class="line">    ilock(vma-&gt;f-&gt;ip);</span><br><span class="line">        <span class="comment">//  va - vma-&gt;start  --- 应当从file的第几个bytes开始读</span></span><br><span class="line">        <span class="comment">//  物理上的file应当从(offset开始的第几个bytes开始读) 其 &quot;第几个bytes&quot; 是和 (va相比与vm-&gt;start的差) 同步的。</span></span><br><span class="line">        <span class="comment">//  所以应当是 offset + va - vma-&gt;start</span></span><br><span class="line">        <span class="comment">//  如果不这样的话会读取错误的file内容</span></span><br><span class="line">    readi(vma-&gt;f-&gt;ip,<span class="number">0</span>,pa,vma-&gt;offset + (va - vma-&gt;start),PGSIZE);    <span class="comment">//  readi会处理PGSIZE超出文件剩余大小</span></span><br><span class="line">    iunlock(vma-&gt;f-&gt;ip);</span><br><span class="line">    end_op();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3.  prot权限 -- pte权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="comment">//  建立映射 : 一次映射一页。</span></span><br><span class="line">        <span class="comment">//  权限</span></span><br><span class="line">    <span class="keyword">int</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span>(vma-&gt;prot &amp; PROT_READ)</span><br><span class="line">        perm |= PTE_R;</span><br><span class="line">    <span class="keyword">if</span>(vma-&gt;prot &amp; PROT_WRITE)</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  **4.  建立映射**</span></span><br><span class="line">        <span class="comment">//  (va所在virtual page)  ---&gt; (physical page)</span></span><br><span class="line">    mappages(p-&gt;pagetable,va,PGSIZE,pa,perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p>pgfaulthandler 之后user process再次使用该va即可.</p>
</li>
</ul>
<h3 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h3><p>int munmap(void *addr, size_t length);</p>
<ul>
<li><p><strong>uint64 sys_munmap(void)</strong></p>
<ul>
<li>作用：解除vma管理的va到pa的有效页的映射，并根据需要写回磁盘。（均由vmamunmap实现）</li>
<li><ol>
<li>检查user传入的addr是否合法</li>
</ol>
</li>
<li><ol start="2">
<li>计算释放范围对于释放范围以及对齐情况，本lab中没有corner case，</li>
</ol>
<ul>
<li>对于user传入的地址以及要映射的范围，从maptest中可以看出user传入的起始地址已经对PGSIZE对齐，传入的sz也和PGSIZE对齐。因此不必处理对齐也可过。如果真的处理全部corner case真是得不偿失了。这个实验的重点应该在与理解mmap流程、为什么比read/write file高效。</li>
<li>本lab中只需要实现如下三种地址范围的释放.<ul>
<li>[vma-&gt;start , x)   (x &lt;= vma-&gt;end)  x不必和PGSIZE对齐</li>
<li>[x , vma-&gt;end)     (x &gt;= vma-&gt;start)      x不必和PGSIZE对齐</li>
<li>[vma-&gt;start , vma-&gt;end)             the whole region</li>
<li>只是禁止dig a hole ： addr &gt; vma-&gt;start &amp;&amp; addr + sz &lt; getVmaEnd(vma) is forbiddened</li>
</ul>
</li>
</ul>
</li>
<li><ol start="3">
<li><strong>核心：vmamunmap解除映射   vmamunmap(vma,start,sz,myproc()-&gt;pagetable);</strong></li>
</ol>
</li>
<li><ol start="4">
<li>释放vma槽<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_munmap</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    argaddr(<span class="number">0</span>,&amp;addr); argaddr(<span class="number">1</span>,&amp;sz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1. 检验addr和sz的合法性</span></span><br><span class="line">        <span class="comment">//  是否在vma中</span></span><br><span class="line">    <span class="keyword">if</span>(!validMmap(addr,&amp;vma)) fail</span><br><span class="line">        <span class="comment">//  检验munmap范围合法性 : not to dig a hole</span></span><br><span class="line">    <span class="keyword">if</span>(addr &gt; vma-&gt;start &amp;&amp; addr + sz &lt; getVmaEnd(vma)) fail</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 计算要munmap的范围（核心逻辑如下）</span></span><br><span class="line">    uint64 start = PGROUNDDOWN(addr);   <span class="comment">//  起始地址向下对齐</span></span><br><span class="line">    sz = sz</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3. **解除映射**</span></span><br><span class="line">    <span class="comment">//  真正的核心实现逻辑在这个函数里</span></span><br><span class="line">    vmamunmap(vma,start,sz,myproc()-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4.  释放vma槽  </span></span><br><span class="line">    vma-&gt;left -= sz;</span><br><span class="line">    <span class="comment">//  如果vma的所有bytes都被释放</span></span><br><span class="line">    <span class="keyword">if</span>(vma-&gt;left == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vma-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        vma-&gt;left = <span class="number">0</span>;</span><br><span class="line">        fileclose(vma-&gt;f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>void vmamunmap(struct vma* vma , uint64 start , uint64 sz , pagetable_t pagetable)</strong></p>
<ul>
<li>sys_munmap的核心函数，真正负责解除映射的函数</li>
<li><strong>1. 解除vma管理的 从 [start,start+sz) 到 pa 的 有效页的映射，释放physical mem</strong><ul>
<li>所谓有效页，我的意思是指那些在[start,start+sz)范围之内，已经建立了映射的虚拟页，解除他们的映射。对于无效的地址，也即vma中没有被lazy allocation建立映射的地址，则不必理会。</li>
<li>pte = walk(pgtbl,va,0);</li>
<li>*pte = 0;</li>
<li>kfree(PTE2PA(pte))</li>
</ul>
</li>
<li><strong>2. 并在需要时将physical mem中的内容写入disk</strong> <ul>
<li>如果vma管理的映射区域为MAP_SHARED，且该page之前修改过，则将该page（writei）落入磁盘.   writei(vma-&gt;f-&gt;ip,0,pa,dest_file_byte,PGSIZE);<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">参考<span class="function">uvmunmap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmamunmap</span><span class="params">(struct vma* vma , uint64 start , uint64 sz , <span class="keyword">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(uint64 a = start ; a &lt; start + sz; a +=PGSIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//  如果userva真的建立了到pa的映射</span></span><br><span class="line">        <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">        &#123;</span><br><span class="line">        uint64 pa = PTE2PA(*pte);</span><br><span class="line">        <span class="comment">//  如果map_shared 且 确实写过 则 写入disk file</span></span><br><span class="line">        <span class="keyword">if</span>((*pte &amp; PTE_D) &amp;&amp; (vma-&gt;flag &amp; MAP_SHARED))</span><br><span class="line">        &#123;</span><br><span class="line">            begin_op();</span><br><span class="line">            ilock(vma-&gt;f-&gt;ip);</span><br><span class="line">            uint64 dest_file_byte = vma-&gt;offset+(a-vma-&gt;start);   <span class="comment">//  要写入的file的起始bytes</span></span><br><span class="line">            uint64 bytes_to_write = start + sz - a;               <span class="comment">//  总共还有多少bytes要写</span></span><br><span class="line">            <span class="keyword">if</span>(bytes_to_write &gt;= PGSIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// writei(vma-&gt;f-&gt;ip,1,a,dest_file_byte,PGSIZE);  使用user_va  ok</span></span><br><span class="line">                writei(vma-&gt;f-&gt;ip,<span class="number">0</span>,pa,dest_file_byte,PGSIZE);    <span class="comment">//  使用pa</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>      <span class="comment">//  如果不足1PGSIZEs</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// writei(vma-&gt;f-&gt;ip,1,a,dest_file_byte,bytes_to_write);  使用user_va  ok</span></span><br><span class="line">                writei(vma-&gt;f-&gt;ip,<span class="number">0</span>,pa,dest_file_byte,bytes_to_write);  <span class="comment">//  使用pa</span></span><br><span class="line">            &#125;</span><br><span class="line">            iunlock(vma-&gt;f-&gt;ip);</span><br><span class="line">            end_op();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  清空PTE</span></span><br><span class="line">        *pte = <span class="number">0</span>;     </span><br><span class="line">        <span class="comment">//  释放mem</span></span><br><span class="line">        kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><ul>
<li>下面考虑并发。修改fork</li>
<li><strong>fork</strong><ul>
<li><strong>child拷贝parent的有效vma信息</strong></li>
<li>但是child只copy了parent vma区域信息，并没有为child分配物理内存建立映射。</li>
<li>也即只是说child和parent<strong>使用一样的虚拟地址</strong>范围用作vma区域，但是并<strong>没有映射到同样的物理内存</strong>，child的vma也并没有立刻建立到物理内存的映射。</li>
<li>child要等到自己陷入pagefault后，再做如上pgfaulthandler处理，分配物理内存、建立映射。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">acquire(&amp;np-&gt;lock);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NVMA;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;vmas[i].valid)</span><br><span class="line">    &#123;</span><br><span class="line">        np-&gt;vmas[i] = p-&gt;vmas[i];     </span><br><span class="line">        filedup(p-&gt;vmas[i].f);      <span class="comment">//  增加struct file 引用计数 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">np-&gt;state = RUNNABLE;</span><br><span class="line">release(&amp;np-&gt;lock);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>exit时自动解除映射  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  清空vma，关闭文件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NVMA;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;vmas[i].valid)</span><br><span class="line">        &#123;</span><br><span class="line">            vmamunmap(&amp;p-&gt;vmas[i],p-&gt;vmas[i].start,p-&gt;vmas[i].sz,p-&gt;pagetable);</span><br><span class="line">            fileclose(p-&gt;vmas[i].f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;p-&gt;vmas[i],<span class="number">0</span>,<span class="keyword">sizeof</span>(p-&gt;vmas[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>拿下<br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-30-06.png"></p>
<h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><ul>
<li><p>写mmap的时候的疑问</p>
</li>
<li><p>易知vma管理了映射区域数据，其中就有struct file*。那么在user读写mmap映射到的vma虚拟内存时，kenrel需要去改变file的偏移量吗？</p>
<ul>
<li>我觉得不应该会。因为和read fd write fd不同，read write时，user知道自己是在对文件进行操作；而mmap时user知道他只是在对一块内存中选取地址进行操作，只是其中有文件内容罢了。故不应该改变file偏移量。</li>
</ul>
</li>
<li><p>关于MAP_SHARED ,在子进程对vma区域进行操作时，可以直接向父进程一样，为子进程的vma区域进行lazy allocation；更好的解决方式是 使得子进程的vma指向(父进程的vma指向的dram)，也即父子进程共享同一块dram区域（该块dram中装的是file的data）。</p>
<ul>
<li>我这里实现的是前者，感觉后者有点复杂。父进程munmap时还有看其有几个子进程，是否已经全部munmap，或许还要考虑其他的，目前还没想好.如果两个进程之间没有父子关系，该如何做，又是另一种情况。</li>
</ul>
</li>
<li><p>当mmap之后，还没munmap之前，如果user关闭了文件会怎么样？也即close(fd)</p>
<ul>
<li>On the other hand, closing the file descriptor does not unmap the region.</li>
<li>即close(fd)，对mapped memory无影响，user仍可以正常都写。</li>
<li>filedup作用：<ul>
<li>所谓打开一个文件，其实也就是拿到它的inode，拿到inode才可以读写相应数据。而我们又将inode*存储在struct file里，因此打开文件就是拿到相应的struct file。</li>
<li>filedup就是增加file的引用计数，防止其被从ftable中踢掉。当struct file的引用计数降为0的时候，则会被其他inode的struct file替换。而user是通过自己的fd-file表引用struct file的，（其表中存储的是file*）那么user就会通过fd引用到错误的struct file。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关于效率（拷贝次数）"><a href="#关于效率（拷贝次数）" class="headerlink" title="关于效率（拷贝次数）"></a>关于效率（拷贝次数）</h2><ul>
<li><strong>mmap 加载file到physical mem，然后user映射读取 和 user自己读取file有什么区别？为什么高效？</strong></li>
</ul>
<h3 id="XV6中mmap"><a href="#XV6中mmap" class="headerlink" title="XV6中mmap"></a>XV6中mmap</h3><ul>
<li><strong>结论：在xv6中，两者效率似乎并无高低之分，因为拷贝的次数都是相同的。</strong><ul>
<li><strong>都是需要2次拷贝</strong><ul>
<li><ol>
<li><strong>从 disk 读进 kernel buffer cache</strong>，</li>
</ol>
</li>
<li><ol start="2">
<li><strong>然后从kernel buffer cache 拷贝到 user va 映射到的 physical mem</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>首先，对于mmap</strong></p>
<ul>
<li><strong>user使用mmap读取文件数据流程：</strong><ul>
<li>mmap : return mapped memory address</li>
<li>read / write mapped memory</li>
<li>munmap : 解除映射。vma管理的虚拟地址范围 全部解除映射后，mapped memory 就不可再被引用。</li>
</ul>
</li>
<li>映射关系如图<ul>
<li><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-16-53-57.png"></li>
</ul>
</li>
<li>data拷贝逻辑如图<ul>
<li>disk -&gt; kernel buffer cache -&gt; user process  </li>
<li><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-05-03.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mmap</span></span><br><span class="line">    <span class="comment">//  open for get fd</span></span><br><span class="line">    fd = open(f, O_RDWR)</span><br><span class="line">    <span class="comment">//  mmap</span></span><br><span class="line">    p = mmap(<span class="number">0</span>, PGSIZE*<span class="number">3</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//  it&#x27;s ok to close</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  read / write mapped memory</span></span><br><span class="line">    <span class="comment">// check that the mapping still works after close(fd). (read)</span></span><br><span class="line">    _v1(p);       </span><br><span class="line">    <span class="comment">// write the mapped memory.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PGSIZE*<span class="number">2</span>; i++)</span><br><span class="line">        p[i] = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  munmap mapped memory</span></span><br><span class="line">    <span class="comment">// unmap just the first two of three pages of mapped memory.</span></span><br><span class="line">    munmap(p, PGSIZE*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// unmap the rest of the mapped memory.</span></span><br><span class="line">    munmap(p+PGSIZE*<span class="number">2</span>, PGSIZE);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>然后，对于read/write，拷贝逻辑并无不同。</p>
<ul>
<li>disk -&gt; kernel buffer cache -&gt; user process phyiscal mem<br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-23-48.png"><br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-17-26-34.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(path, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">read(fd, &amp;de, <span class="keyword">sizeof</span>(de));</span><br><span class="line">读写 de.<span class="function">member</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(fd,&amp;de,<span class="keyword">sizeof</span>(de))</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li><p>和xv6不同，拷贝次数少一次。没有从kernel buffer到user physical mem的拷贝。</p>
</li>
<li><p><strong>至于所说的linux中的mmap比read高效，其中一点原因应当是指就拷贝次数而言，mmap比read少一次</strong></p>
<ul>
<li><strong>mmap直接将user va映射到了kernel buffer cache。而非新alloc一个physical page。这个实现应该是xv6得option challenge。</strong></li>
<li><strong>Your solution probably allocates a new physical page for each page read from the mmap-ed file, even though the data is also in kernel memory in the buffer cache</strong>. <strong>Modify your implementation to use that physical memory, instead of allocating a new page</strong>. This requires that file blocks be the same size as pages (set BSIZE to 4096). You will need to pin mmap-ed blocks into the buffer cache. You will need worry about reference counts.</li>
</ul>
</li>
<li><p>没有做optional challenge，不过实现完之后应当是这样。</p>
<ul>
<li><strong>当user第一次使用vma管理的虚拟地址时，file data 从disk —&gt; 读到 kernel buffer。然后将user pagetable上建立从user va 到 kernel buffer的映射</strong></li>
<li><strong>可以看到，并没有未该vma新alloc一个physical page去映射，而是直接将user的va映射到buffer cache上，减少了一次从kernel buffer cache到user phyical mem的拷贝，效率比read更高。（read还要拷贝一次）</strong><br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-19-04-30.png"><br><img src="/2022/12/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab9-mmap/2022-12-15-19-12-58.png"></li>
</ul>
</li>
<li><p><strong>lazy allocation</strong> : </p>
<ul>
<li>虽然没有为user va新alloc一块physical page，不过也可以称得上是lazy allocation</li>
<li>因为lazy allocation的思想就是要推迟va建立映射的时间，尽可能的推迟为va分配映射到的physical page。而这里确实是将va的映射推迟到了其被使用时才建立，只不过是没新alloc罢了，新建立的映射是从va到buffer cache的映射。</li>
</ul>
</li>
<li><p><strong>Optional Challenge</strong></p>
<ul>
<li>感觉把下面的都实现了的话，才能算是一个现代os中的mmap<blockquote>
<p>If two processes have the same file mmap-ed (as in fork_test), share their physical pages. You will need reference counts on physical pages.<br>Your solution probably allocates a new physical page for each page read from the mmap-ed file, even though the data is also in kernel memory in the buffer cache. Modify your implementation to use that physical memory, instead of allocating a new page. This requires that file blocks be the same size as pages (set BSIZE to 4096). You will need to pin mmap-ed blocks into the buffer cache. You will need worry about reference counts.<br>Remove redundancy between your implementation for lazy allocation and your implementation of mmap-ed files. (Hint: create a VMA for the lazy allocation area.)<br>Modify exec to use a VMA for different sections of the binary so that you get on-demand-paged executables. This will make starting programs faster, because exec will not have to read any data from the file system.<br>Implement page-out and page-in: have the kernel move some parts of processes to disk when physical memory is low. Then, page in the paged-out memory when the process references it.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="小结-mmap优势"><a href="#小结-mmap优势" class="headerlink" title="小结 mmap优势"></a>小结 mmap优势</h2><ul>
<li><p><strong>mmap优势</strong></p>
</li>
<li><p><strong>优势1：在于效率高，高于普通的read file</strong></p>
<ul>
<li><p>效率高原因如下</p>
</li>
<li><p><strong>1. 减少拷贝次数</strong>，如上讨论。</p>
<ul>
<li><strong>mmap</strong> 在读取va对应保存的内容时，<strong>内核只需要一次拷贝数据</strong>。<ul>
<li>optional Challenge中实现</li>
<li>以下为第一次使用va时触发的pgfault ，陷入内核，进入handler所做的工作<ul>
<li>disk —-&gt; kernel buffer cache</li>
<li>建立va 到 kernel buffer cache的映射</li>
</ul>
</li>
<li>然后回到user态，user再度读写va即可。 </li>
</ul>
</li>
<li>而<strong>read</strong> 读取va对应保存的内容时，<strong>内核需要拷贝两次数据</strong>。<ul>
<li>read时也需要进入一次内核。<ul>
<li>disk —&gt; kernel buffer cache 一次拷贝</li>
<li>kernel buffer cache —&gt; user process physical mem 两次拷贝</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>2. 减少陷入内核次数，减少上下文切换开销</strong></p>
<ul>
<li>通过mmap映射文件 : 对于一个page中的va，第一次使用该va，会触发pgfault，陷入内核，pgfault handler会进行lazy alloc处理（如1和上节linux所述）。而后，再次使用该page中的va，则不会触发pgfault，也就不会进入内核，直接在user态读写va即可。因为整个page都已经建立了映射。</li>
<li>而read，每次read都需要陷入内核。</li>
<li>如下，通过mmap减少大量陷入内核的次数.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  read: 每次read都要进入一次内核</span></span><br><span class="line">    <span class="keyword">char</span> de;</span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;</span><br><span class="line">        read/write de</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  mmap : 每个page进入一次内核即可(使用到哪个page就为哪个page进入内核建立映射)</span></span><br><span class="line">    <span class="keyword">char</span> *p = mmap(<span class="number">0</span>, PGSIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PGSIZE; i++) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (p[i] != <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mismatch at %d, wanted &#x27;A&#x27;, got 0x%x\n&quot;</span>, i, p[i]);</span><br><span class="line">        err(<span class="string">&quot;v1 mismatch (1)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>3. 共享物理内存</strong></p>
<ul>
<li>当多个进程将同一页面映射到内存时，数据可以在这些进程之间共享。<ul>
<li>对于 只读 PROT_READ 的PAGE可以完全共享。</li>
<li>对于PROT_WRITE &amp;&amp; MAP_PRIVATE 的PAGE，可以通过COW节省开销。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优势2 ： 更加方便user读写文件</strong> ：</p>
<ul>
<li>在user的va中划出一片区域，将文件内容映射其中。让user可以像操作内存数据一样，操作文件数据。</li>
<li>也即**使得user读写va就是在读写file的内容(在物理内存中读写而非磁盘上)**。</li>
<li>也因此，对于随机访问，不用频繁 lseek。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>优势3：lazy allocation</strong><ul>
<li>mmap的另一个特点：<strong>lazy allocation</strong></li>
<li>某种程度上说也提高了效率<ul>
<li>user使用mmap之后，kernel不会立刻将file全部内容读取physical mem，然后为user va建立映射。而是等待usr使用到相应的va，才会触发pagefault，进入kenerl，handler处理，读取内容，建立映射。</li>
</ul>
</li>
<li>并且感觉也为user提供了方便<ul>
<li>user调用mmap之后，不必管file的内容如何加载到mem，也不用管如何建立映射，也不用管数据如何落回磁盘。user只需要简单地认为，这块内存里就存有file的数据即可，user只需要负责对其进行读写罢了,以及最后munmap，并且知道可以根据我们的需要落入磁盘。其余的都不必管。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>解释：mmap所谓的 “映射文件到用户进程” ：</strong><ul>
<li><strong>读取文件内容，建立user va到dram的映射</strong></li>
<li>所谓的映射：实际上就是将disk上file的内容读到一块physical mem，然后将user的pagetabl上，建立va到physical mem的映射</li>
<li>之所以叫映射，应当是和mmap的实现无关，只是因为从user的角度看起来，很像是将file的内容映射到user的一段va中<ul>
<li>mmap之后，user读写相应va就是在读写file的内容(在物理内存中读写而非磁盘上)</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/xv6/" rel="tag"># xv6</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="prev" title="操作系统-xv6-lab9-文件系统">
      <i class="fa fa-chevron-left"></i> 操作系统-xv6-lab9-文件系统
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/12/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-xv6-lab8-lock/" rel="next" title="操作系统-xv6-lab8-lock">
      操作系统-xv6-lab8-lock <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap"><span class="nav-number">2.1.</span> <span class="nav-text">mmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#munmap"><span class="nav-number">2.2.</span> <span class="nav-text">munmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B6%E5%B0%BE"><span class="nav-number">2.3.</span> <span class="nav-text">收尾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%82%E8%AE%B0"><span class="nav-number">3.</span> <span class="nav-text">杂记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%95%88%E7%8E%87%EF%BC%88%E6%8B%B7%E8%B4%9D%E6%AC%A1%E6%95%B0%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">关于效率（拷贝次数）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XV6%E4%B8%ADmmap"><span class="nav-number">4.1.</span> <span class="nav-text">XV6中mmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux"><span class="nav-number">4.2.</span> <span class="nav-text">Linux</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-mmap%E4%BC%98%E5%8A%BF"><span class="nav-number">5.</span> <span class="nav-text">小结 mmap优势</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cstardust</p>
  <div class="site-description" itemprop="description">知不可乎骤得,托遗响于悲风</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cstardust</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">639k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">9:41</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'd683461326668b112a07',
      clientSecret: 'fbd3f91ac2d4f7b501c4b5f88af770661529c238',
      repo        : 'BlogComments',
      owner       : 'Cstardust',
      admin       : ['Cstardust'],
      id          : '4f47e4dbe20b2d3b0b16a20518429e90',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
